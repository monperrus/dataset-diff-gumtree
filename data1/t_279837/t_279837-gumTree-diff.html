<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Diff result</title>
<style type="text/css">
body { width: 100%; font-size: 10pt; }
h1 { font-size: 125%; }
div.content { font-family: Verdana, "DejaVu Sans Condensed", "Liberation Sans","Nimbus Sans L", Helvetica, sans-serif; margin : 1em auto; width: 100%; }
div.left { float: left; width: 48%; padding: 1em; }
div.right { float: right; width: 48%; padding: 1em; }
div.code { font-family: "Liberation Mono", "Courrier New", monospace; border:1px solid black;}
div.clear { clear: both; }
span.del { background-color : red; font-weight: normal; font-style: normal;}
span.add { background-color : lightgreen; font-weight: bold; font-style: normal;}
span.upd { background-color : orange; font-weight: bold; font-style: italic;}
span.id { background-color : white; font-weight: normal; font-style: normal;}
span.mv { background-color : yellow; font-weight: normal; font-style: normal;}
</style></head><body><div class="content"><div class="left">
<h1>left_Ajp12_1.17.java</h1>
<div class="code">
<div class="id">
/*<br/>
 *<br/>
 * ====================================================================<br/>
 *<br/>
 * The Apache Software License, Version 1.1<br/>
 *<br/>
 * Copyright (c) 1999 The Apache Software Foundation.  All rights<br/>
 * reserved.<br/>
 *<br/>
 * Redistribution and use in source and binary forms, with or without<br/>
 * modification, are permitted provided that the following conditions<br/>
 * are met:<br/>
 *<br/>
 * 1. Redistributions of source code must retain the above copyright<br/>
 *    notice, this list of conditions and the following disclaimer.<br/>
 *<br/>
 * 2. Redistributions in binary form must reproduce the above copyright<br/>
 *    notice, this list of conditions and the following disclaimer in<br/>
 *    the documentation and/or other materials provided with the<br/>
 *    distribution.<br/>
 *<br/>
 * 3. The end-user documentation included with the redistribution, if<br/>
 *    any, must include the following acknowlegement:<br/>
 *       "This product includes software developed by the<br/>
 *        Apache Software Foundation (http://www.apache.org/)."<br/>
 *    Alternately, this acknowlegement may appear in the software itself,<br/>
 *    if and wherever such third-party acknowlegements normally appear.<br/>
 *<br/>
 * 4. The names "The Jakarta Project", "Tomcat", and "Apache Software<br/>
 *    Foundation" must not be used to endorse or promote products derived<br/>
 *    from this software without prior written permission. For written<br/>
 *    permission, please contact apache@apache.org.<br/>
 *<br/>
 * 5. Products derived from this software may not be called "Apache"<br/>
 *    nor may "Apache" appear in their names without prior written<br/>
 *    permission of the Apache Group.<br/>
 *<br/>
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED<br/>
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES<br/>
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE<br/>
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR<br/>
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,<br/>
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT<br/>
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF<br/>
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<br/>
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,<br/>
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT<br/>
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF<br/>
 * SUCH DAMAGE.<br/>
 * ====================================================================<br/>
 *<br/>
 * This software consists of voluntary contributions made by many<br/>
 * individuals on behalf of the Apache Software Foundation.  For more<br/>
 * information on the Apache Software Foundation, please see<br/>
 * &lt;http://www.apache.org/&gt;.<br/>
 *<br/>
 * [Additional notices, if required by prior licensing conditions]<br/>
 *<br/>
 */<br/>
<br/>
<br/>
/*<br/>
  Based on Ajp11ConnectionHandler and Ajp12 implementation of JServ<br/>
*/<br/>
package org.apache.tomcat.modules.server;<br/>
<br/>
import java.io.*;<br/>
import java.net.*;<br/>
import java.util.*;<br/>
import org.apache.tomcat.core.*;<br/>
import org.apache.tomcat.util.net.*;<br/>
import org.apache.tomcat.util.*;<br/>
<br/>
class Ajp12 {<br/>
    Socket socket;<br/>
    InputStream sin;<br/>
    BufferedInputStream ajpin;<br/>
    private boolean tomcatAuthentication=true;<br/>
    boolean shutdown=false;<br/>
    boolean isPing=false;<br/>
    boolean doLog;<br/>
    String secret=null;<br/>
<br/>
    public Ajp12() {<br/>
    }<br/>
<br/>
    // Debug only - use only to debug this component<br/>
    void d( String s ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.print("Ajp12: ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println( s );<br/>
    }<br/>
    <br/>
    public int doRead() throws IOException {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return ajpin.read();<br/>
    }<br/>
<br/>
    public  int doRead( byte b[], int off, int len ) throws IOException {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return ajpin.read( b,off,len);<br/>
    }<br/>
<br/>
    public void setSocket( Socket s ) throws IOException {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this.socket = s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sin = s.getInputStream();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ajpin = new BufferedInputStream(sin);<br/>
    }<br/>
<br/>
    public void setSecret( String s ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;secret=s;<br/>
    }<br/>
    <br/>
    public void readNextRequest(Request req) throws IOException {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String dummy,token1,token2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int marker;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int signal;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    boolean more=true;<br/>
            while (more) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;marker = ajpin.read();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (marker) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0:       //NOP marker useful for testing if stream is OK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: //beginning of request<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.method().setString(  readString(ajpin, null));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //Zone<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    String contextPath = readString(ajpin, null);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // GS, the following commented line causes the Apache +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Jserv + Tomcat combination to hang with a 404!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // if("ROOT".equals( contextPath ) ) contextPath="";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if("ROOT".equalsIgnoreCase( contextPath ) ) contextPath=null;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // XXX Do not set the context - we need extra info.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // this have to be rewritten !!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if( contextPath!= null )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //&nbsp;&nbsp;&nbsp;&nbsp;req.setContext( contextM.getContext( contextPath ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //Servlet - not used<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy=readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //Server hostname<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.serverName().setString(readString(ajpin, null) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //System.out.println("XXX hostname: " + req.serverName());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //Apache document root<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, null);               <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.pathInfo().setString( readString(ajpin, null));               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //Apache parsed path-translated XXX Bug in mod_jserv !!!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.queryString().setString( readString(ajpin, null));  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.remoteAddr().setString(readString(ajpin, ""));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.remoteHost().setString( readString(ajpin, ""));<br/>
                    if (isTomcatAuthentication())<br/>
                        dummy=readString(ajpin, null);<br/>
                    else req.setRemoteUser( readString(ajpin, null));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.setAuthType(readString(ajpin, null));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //remote port<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    System.out.println("XXX rport " + dummy );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.method().setString( readString(ajpin, null));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.requestURI().setString( readString(ajpin, ""));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // XXX don't set lookup path - problems with URL rewriting.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // need to be fixed.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //if(contextPath!=null &amp;&amp; contextPath.length() &gt;0 )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //lookupPath=requestURI.substring( contextPath.length()+1 );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //script filename<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //script name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, null);                   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.serverName().setString( readString(ajpin, ""));       <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int serverPort=80;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String p=readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//System.out.println("XXX p " + p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(p==null ) p="80";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverPort= Integer.parseInt(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } catch (Exception any) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any.printStackTrace();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.setServerPort( serverPort );<br/>
<br/>
                    /* Quick and dirty patch to set https scheme in ajp12<br/>
                     * but I recommand using ajp13 instead <br/>
                     */<br/>
                    if (serverPort == 443)<br/>
                       req.scheme().setString("https");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // System.out.println("XXX port: " + req.getServerPort());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //server protocol<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    String proto=readString(ajpin,null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if( proto==null ) proto="HTTP/1.0";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.protocol().setString (proto);  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //server signature<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, "");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //server software<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, "");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.setJvmRoute( readString(ajpin, null));                   <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, "");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, "");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
<br/>
<br/>
                    /**<br/>
                     * Marker = 5 will be used by mod_jserv to send environment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * vars as key+value (dynamically configurable).<br/>
                     * can be considered as "reserved", and safely ignored by<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * other connectors.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * env_vars is (above in this  code) commented out for<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * performance issues. so theses env vars are simply<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * ignored. (just here for compatibility)<br/>
                     * but it is where mod_jserv would place SSL_* env vars<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (by exemple)<br/>
                     * See the new parameter for mod_jserv (version &gt; 1.1):<br/>
                     * ApJServEnvVar localname remotename<br/>
                     *                                            - jluc<br/>
                     */<br/>
                case 5: // Environment vars<br/>
                    token1 = readString(ajpin, null);<br/>
                    token2 = readString(ajpin, "");<br/>
                    /*<br/>
                     * Env variables should go into the request attributes<br/>
                     * table. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Also, if one of the request attributes is HTTPS=on<br/>
                     * assume that there is an SSL connection.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */<br/>
                    req.setAttribute(token1, token2);<br/>
                    if(token1.equals("HTTPS") &amp;&amp; token2.equals("on")) {<br/>
                        req.scheme().setString("https");<br/>
                    }<br/>
                    break;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: // Header<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    token1 = readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    token2 = readString(ajpin, "");<br/>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if( "Host".equalsIgnoreCase( token1 )) {<br/>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("XXX Host: " + token2);<br/>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.getMimeHeaders().addValue(token1).setString(token2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 254: // Signal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    signal = ajpin.read();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if (signal == 0) { // PING implemented as signal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // close the socket connection after we send reply<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    socket.getOutputStream().write(0); // PING reply<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    sin.close();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (IOException ignored) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.getContextManager().log("Exception closing, ignored",  ignored);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                        isPing = true;<br/>
                        return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // close the socket connection before handling any<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // signal but get the addresses first so they are<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // not corrupted<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    InetAddress serverAddr = socket.getLocalAddress();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    InetAddress clientAddr = socket.getInetAddress();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( (signal== 15) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSameAddress(serverAddr, clientAddr) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( secret!=null ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    String stopMsg=readString(ajpin, "");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if( ! secret.equals( stopMsg ) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;req.getContextManager().log("Attempt to stop with the wrong secret");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                                ContextManager cm=req.getContextManager();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cm.shutdown();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cm.log("Exiting" );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="del"><span class="del"><span class="del"><span class="del">cm</span>.<span class="del">getLog</span>()</span>.<span class="del">flush</span>()</span>;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// same behavior as in past, because it seems<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// that stopping everything doesn't work -<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// need to figure<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// out what happens with the threads ( XXX )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shutdown=true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    sin.close();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception ignored) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.getContextManager().log("Ignored exception " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      "processing signal " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      signal, ignored);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 255:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    more=false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case -1:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    throw new java.io.IOException("Stream closed prematurely");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    throw new java.io.IOException("Stream broken");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // switch<br/>
            } // while<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} catch (IOException ioe) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    throw ioe;<br/>
        } catch (Exception e) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    req.getContextManager().log("Uncaught exception handling request", e);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// REQUEST_URI may includes query string<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String requestURI=req.requestURI().toString();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int indexQ=requestURI.indexOf("?");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int rLen=requestURI.length();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( (indexQ &gt;-1) &amp;&amp; ( indexQ  &lt; rLen) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    req.queryString().<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setString( requestURI.substring(indexQ + 1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestURI.length()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    req.requestURI().setString( requestURI.substring(0, indexQ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <br/>
    }<br/>
<br/>
    /**<br/>
     * Return &lt;code&gt;true&lt;/code&gt; if the specified client and server addresses<br/>
     * are the same.  This method works around a bug in the IBM 1.1.8 JVM on<br/>
     * Linux, where the address bytes are returned reversed in some<br/>
     * circumstances.<br/>
     *<br/>
     * @param server The server's InetAddress<br/>
     * @param client The client's InetAddress<br/>
     */<br/>
    public static boolean isSameAddress(InetAddress server, InetAddress client) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Compare the byte array versions of the two addresses<br/>
&nbsp;&nbsp;&nbsp;&nbsp;byte serverAddr[] = server.getAddress();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;byte clientAddr[] = client.getAddress();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (serverAddr.length != clientAddr.length)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean match = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; serverAddr.length; i++) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (serverAddr[i] != clientAddr[i]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (match)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (true);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Compare the reversed form of the two addresses<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; serverAddr.length; i++) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (serverAddr[i] != clientAddr[(serverAddr.length-1)-i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return (true);<br/>
    }<br/>
<br/>
    <br/>
    public static int readWord(InputStream in ) throws java.io.IOException {<br/>
        int b1 = in.read();<br/>
        if( b1 == -1)<br/>
            return -1;<br/>
<br/>
        int b2 = in.read();<br/>
        if ( b2==-1)<br/>
            return -1;<br/>
<br/>
        return ((int)((b1 &lt;&lt; 8) | b2)) &amp; 0xffff;<br/>
    }<br/>
<br/>
    // UTF8 is a strict superset of ASCII.<br/>
    final static String CHARSET = "UTF8";<br/>
<br/>
    public static String readString(InputStream in, String def)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throws java.io.IOException {<br/>
        int len = readWord(in);<br/>
<br/>
        if( len == 0xffff)<br/>
            return def;<br/>
<br/>
        if( len == -1)<br/>
            throw new java.io.IOException("Stream broken");<br/>
<br/>
        byte[] b = new byte[len];<br/>
        int p = 0;<br/>
        int r;<br/>
        while(p&lt;len) {<br/>
            r = in.read(b,p, len - p);<br/>
            if( r&lt; 0) {<br/>
                throw new IOException("Stream broken, couldn't " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      "demarshal string :"+len+":"+p);<br/>
            }<br/>
            p = p+r;<br/>
        }<br/>
        return new String(b, CHARSET);<br/>
    }<br/>
<br/>
    public boolean isTomcatAuthentication() {<br/>
        return tomcatAuthentication;<br/>
    }<br/>
<br/>
    public void setTomcatAuthentication(boolean newTomcatAuthentication) {<br/>
        tomcatAuthentication = newTomcatAuthentication;<br/>
    }<br/>
<br/>
    <br/>
}<br/>
<br/>
</div>
</div>
</div>
<div class="right">
<h1>right_Ajp12_1.18.java</h1>
<div class="code">
<div class="id">
/*<br/>
 *<br/>
 * ====================================================================<br/>
 *<br/>
 * The Apache Software License, Version 1.1<br/>
 *<br/>
 * Copyright (c) 1999 The Apache Software Foundation.  All rights<br/>
 * reserved.<br/>
 *<br/>
 * Redistribution and use in source and binary forms, with or without<br/>
 * modification, are permitted provided that the following conditions<br/>
 * are met:<br/>
 *<br/>
 * 1. Redistributions of source code must retain the above copyright<br/>
 *    notice, this list of conditions and the following disclaimer.<br/>
 *<br/>
 * 2. Redistributions in binary form must reproduce the above copyright<br/>
 *    notice, this list of conditions and the following disclaimer in<br/>
 *    the documentation and/or other materials provided with the<br/>
 *    distribution.<br/>
 *<br/>
 * 3. The end-user documentation included with the redistribution, if<br/>
 *    any, must include the following acknowlegement:<br/>
 *       "This product includes software developed by the<br/>
 *        Apache Software Foundation (http://www.apache.org/)."<br/>
 *    Alternately, this acknowlegement may appear in the software itself,<br/>
 *    if and wherever such third-party acknowlegements normally appear.<br/>
 *<br/>
 * 4. The names "The Jakarta Project", "Tomcat", and "Apache Software<br/>
 *    Foundation" must not be used to endorse or promote products derived<br/>
 *    from this software without prior written permission. For written<br/>
 *    permission, please contact apache@apache.org.<br/>
 *<br/>
 * 5. Products derived from this software may not be called "Apache"<br/>
 *    nor may "Apache" appear in their names without prior written<br/>
 *    permission of the Apache Group.<br/>
 *<br/>
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED<br/>
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES<br/>
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE<br/>
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR<br/>
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,<br/>
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT<br/>
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF<br/>
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<br/>
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,<br/>
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT<br/>
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF<br/>
 * SUCH DAMAGE.<br/>
 * ====================================================================<br/>
 *<br/>
 * This software consists of voluntary contributions made by many<br/>
 * individuals on behalf of the Apache Software Foundation.  For more<br/>
 * information on the Apache Software Foundation, please see<br/>
 * &lt;http://www.apache.org/&gt;.<br/>
 *<br/>
 * [Additional notices, if required by prior licensing conditions]<br/>
 *<br/>
 */<br/>
<br/>
<br/>
/*<br/>
  Based on Ajp11ConnectionHandler and Ajp12 implementation of JServ<br/>
*/<br/>
package org.apache.tomcat.modules.server;<br/>
<br/>
import java.io.*;<br/>
import java.net.*;<br/>
import java.util.*;<br/>
import org.apache.tomcat.core.*;<br/>
import org.apache.tomcat.util.net.*;<br/>
import org.apache.tomcat.util.*;<br/>
<br/>
class Ajp12 {<br/>
    Socket socket;<br/>
    InputStream sin;<br/>
    BufferedInputStream ajpin;<br/>
    private boolean tomcatAuthentication=true;<br/>
    boolean shutdown=false;<br/>
    boolean isPing=false;<br/>
    boolean doLog;<br/>
    String secret=null;<br/>
<br/>
    public Ajp12() {<br/>
    }<br/>
<br/>
    // Debug only - use only to debug this component<br/>
    void d( String s ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.print("Ajp12: ");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println( s );<br/>
    }<br/>
    <br/>
    public int doRead() throws IOException {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return ajpin.read();<br/>
    }<br/>
<br/>
    public  int doRead( byte b[], int off, int len ) throws IOException {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return ajpin.read( b,off,len);<br/>
    }<br/>
<br/>
    public void setSocket( Socket s ) throws IOException {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;this.socket = s;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;sin = s.getInputStream();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;ajpin = new BufferedInputStream(sin);<br/>
    }<br/>
<br/>
    public void setSecret( String s ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;secret=s;<br/>
    }<br/>
    <br/>
    public void readNextRequest(Request req) throws IOException {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String dummy,token1,token2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int marker;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int signal;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    boolean more=true;<br/>
            while (more) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;marker = ajpin.read();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (marker) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0:       //NOP marker useful for testing if stream is OK<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: //beginning of request<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.method().setString(  readString(ajpin, null));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //Zone<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    String contextPath = readString(ajpin, null);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // GS, the following commented line causes the Apache +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // Jserv + Tomcat combination to hang with a 404!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // if("ROOT".equals( contextPath ) ) contextPath="";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if("ROOT".equalsIgnoreCase( contextPath ) ) contextPath=null;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // XXX Do not set the context - we need extra info.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // this have to be rewritten !!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if( contextPath!= null )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //&nbsp;&nbsp;&nbsp;&nbsp;req.setContext( contextM.getContext( contextPath ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //Servlet - not used<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy=readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //Server hostname<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.serverName().setString(readString(ajpin, null) );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //System.out.println("XXX hostname: " + req.serverName());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //Apache document root<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, null);               <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.pathInfo().setString( readString(ajpin, null));               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //Apache parsed path-translated XXX Bug in mod_jserv !!!!!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.queryString().setString( readString(ajpin, null));  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.remoteAddr().setString(readString(ajpin, ""));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.remoteHost().setString( readString(ajpin, ""));<br/>
                    if (isTomcatAuthentication())<br/>
                        dummy=readString(ajpin, null);<br/>
                    else req.setRemoteUser( readString(ajpin, null));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.setAuthType(readString(ajpin, null));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //remote port<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    System.out.println("XXX rport " + dummy );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.method().setString( readString(ajpin, null));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.requestURI().setString( readString(ajpin, ""));<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // XXX don't set lookup path - problems with URL rewriting.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // need to be fixed.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //if(contextPath!=null &amp;&amp; contextPath.length() &gt;0 )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //lookupPath=requestURI.substring( contextPath.length()+1 );<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //script filename<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //script name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, null);                   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.serverName().setString( readString(ajpin, ""));       <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    int serverPort=80;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String p=readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//System.out.println("XXX p " + p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(p==null ) p="80";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverPort= Integer.parseInt(p);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } catch (Exception any) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any.printStackTrace();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.setServerPort( serverPort );<br/>
<br/>
                    /* Quick and dirty patch to set https scheme in ajp12<br/>
                     * but I recommand using ajp13 instead <br/>
                     */<br/>
                    if (serverPort == 443)<br/>
                       req.scheme().setString("https");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // System.out.println("XXX port: " + req.getServerPort());<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //server protocol<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    String proto=readString(ajpin,null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if( proto==null ) proto="HTTP/1.0";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.protocol().setString (proto);  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //server signature<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, "");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    //server software<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, "");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.setJvmRoute( readString(ajpin, null));                   <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, "");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    dummy = readString(ajpin, "");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
<br/>
<br/>
                    /**<br/>
                     * Marker = 5 will be used by mod_jserv to send environment<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * vars as key+value (dynamically configurable).<br/>
                     * can be considered as "reserved", and safely ignored by<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * other connectors.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * env_vars is (above in this  code) commented out for<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * performance issues. so theses env vars are simply<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * ignored. (just here for compatibility)<br/>
                     * but it is where mod_jserv would place SSL_* env vars<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * (by exemple)<br/>
                     * See the new parameter for mod_jserv (version &gt; 1.1):<br/>
                     * ApJServEnvVar localname remotename<br/>
                     *                                            - jluc<br/>
                     */<br/>
                case 5: // Environment vars<br/>
                    token1 = readString(ajpin, null);<br/>
                    token2 = readString(ajpin, "");<br/>
                    /*<br/>
                     * Env variables should go into the request attributes<br/>
                     * table. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     * Also, if one of the request attributes is HTTPS=on<br/>
                     * assume that there is an SSL connection.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     */<br/>
                    req.setAttribute(token1, token2);<br/>
                    if(token1.equals("HTTPS") &amp;&amp; token2.equals("on")) {<br/>
                        req.scheme().setString("https");<br/>
                    }<br/>
                    break;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 3: // Header<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    token1 = readString(ajpin, null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    token2 = readString(ajpin, "");<br/>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if( "Host".equalsIgnoreCase( token1 )) {<br/>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("XXX Host: " + token2);<br/>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.getMimeHeaders().addValue(token1).setString(token2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 254: // Signal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    signal = ajpin.read();<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if (signal == 0) { // PING implemented as signal<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // close the socket connection after we send reply<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    socket.getOutputStream().write(0); // PING reply<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    sin.close();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (IOException ignored) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.getContextManager().log("Exception closing, ignored",  ignored);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                        isPing = true;<br/>
                        return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    } else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // close the socket connection before handling any<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // signal but get the addresses first so they are<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    // not corrupted<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    InetAddress serverAddr = socket.getLocalAddress();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    InetAddress clientAddr = socket.getInetAddress();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if ( (signal== 15) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isSameAddress(serverAddr, clientAddr) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( secret!=null ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    String stopMsg=readString(ajpin, "");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if( ! secret.equals( stopMsg ) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;req.getContextManager().log("Attempt to stop with the wrong secret");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                                ContextManager cm=req.getContextManager();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cm.shutdown();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cm.log("Exiting" );<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// same behavior as in past, because it seems<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// that stopping everything doesn't work -<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// need to figure<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// out what happens with the threads ( XXX )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shutdown=true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    sin.close();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception ignored) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    req.getContextManager().log("Ignored exception " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      "processing signal " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      signal, ignored);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 4:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 255:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    more=false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case -1:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    throw new java.io.IOException("Stream closed prematurely");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    throw new java.io.IOException("Stream broken");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} // switch<br/>
            } // while<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} catch (IOException ioe) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    throw ioe;<br/>
        } catch (Exception e) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    req.getContextManager().log("Uncaught exception handling request", e);<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// REQUEST_URI may includes query string<br/>
&nbsp;&nbsp;&nbsp;&nbsp;String requestURI=req.requestURI().toString();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int indexQ=requestURI.indexOf("?");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int rLen=requestURI.length();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if ( (indexQ &gt;-1) &amp;&amp; ( indexQ  &lt; rLen) ) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    req.queryString().<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setString( requestURI.substring(indexQ + 1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestURI.length()));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    req.requestURI().setString( requestURI.substring(0, indexQ));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;} <br/>
    }<br/>
<br/>
    /**<br/>
     * Return &lt;code&gt;true&lt;/code&gt; if the specified client and server addresses<br/>
     * are the same.  This method works around a bug in the IBM 1.1.8 JVM on<br/>
     * Linux, where the address bytes are returned reversed in some<br/>
     * circumstances.<br/>
     *<br/>
     * @param server The server's InetAddress<br/>
     * @param client The client's InetAddress<br/>
     */<br/>
    public static boolean isSameAddress(InetAddress server, InetAddress client) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Compare the byte array versions of the two addresses<br/>
&nbsp;&nbsp;&nbsp;&nbsp;byte serverAddr[] = server.getAddress();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;byte clientAddr[] = client.getAddress();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (serverAddr.length != clientAddr.length)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolean match = true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; serverAddr.length; i++) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (serverAddr[i] != clientAddr[i]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match = false;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (match)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (true);<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// Compare the reversed form of the two addresses<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; serverAddr.length; i++) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (serverAddr[i] != clientAddr[(serverAddr.length-1)-i])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (false);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return (true);<br/>
    }<br/>
<br/>
    <br/>
    public static int readWord(InputStream in ) throws java.io.IOException {<br/>
        int b1 = in.read();<br/>
        if( b1 == -1)<br/>
            return -1;<br/>
<br/>
        int b2 = in.read();<br/>
        if ( b2==-1)<br/>
            return -1;<br/>
<br/>
        return ((int)((b1 &lt;&lt; 8) | b2)) &amp; 0xffff;<br/>
    }<br/>
<br/>
    // UTF8 is a strict superset of ASCII.<br/>
    final static String CHARSET = "UTF8";<br/>
<br/>
    public static String readString(InputStream in, String def)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throws java.io.IOException {<br/>
        int len = readWord(in);<br/>
<br/>
        if( len == 0xffff)<br/>
            return def;<br/>
<br/>
        if( len == -1)<br/>
            throw new java.io.IOException("Stream broken");<br/>
<br/>
        byte[] b = new byte[len];<br/>
        int p = 0;<br/>
        int r;<br/>
        while(p&lt;len) {<br/>
            r = in.read(b,p, len - p);<br/>
            if( r&lt; 0) {<br/>
                throw new IOException("Stream broken, couldn't " +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      "demarshal string :"+len+":"+p);<br/>
            }<br/>
            p = p+r;<br/>
        }<br/>
        return new String(b, CHARSET);<br/>
    }<br/>
<br/>
    public boolean isTomcatAuthentication() {<br/>
        return tomcatAuthentication;<br/>
    }<br/>
<br/>
    public void setTomcatAuthentication(boolean newTomcatAuthentication) {<br/>
        tomcatAuthentication = newTomcatAuthentication;<br/>
    }<br/>
<br/>
    <br/>
}<br/>
<br/>
</div>
</div>
</div>
<div class="clear"></div>
</div>
</body>
</html>