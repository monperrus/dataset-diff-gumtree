<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Diff result</title>
<style type="text/css">
body { width: 100%; font-size: 10pt; }
h1 { font-size: 125%; }
div.content { font-family: Verdana, "DejaVu Sans Condensed", "Liberation Sans","Nimbus Sans L", Helvetica, sans-serif; margin : 1em auto; width: 100%; }
div.left { float: left; width: 48%; padding: 1em; }
div.right { float: right; width: 48%; padding: 1em; }
div.code { font-family: "Liberation Mono", "Courrier New", monospace; border:1px solid black;}
div.clear { clear: both; }
span.del { background-color : red; font-weight: normal; font-style: normal;}
span.add { background-color : lightgreen; font-weight: bold; font-style: normal;}
span.upd { background-color : orange; font-weight: bold; font-style: italic;}
span.id { background-color : white; font-weight: normal; font-style: normal;}
span.mv { background-color : yellow; font-weight: normal; font-style: normal;}
</style></head><body><div class="content"><div class="left">
<h1>left_CoreHelperImpl_1.29.java</h1>
<div class="code">
<div class="id">
// $Id: CoreHelperImpl.java,v 1.29 2005-10-05 17:03:51 bobtarling Exp $<br/>
// Copyright (c) 1996-2005 The Regents of the University of California. All<br/>
// Rights Reserved. Permission to use, copy, modify, and distribute this<br/>
// software and its documentation without fee, and without a written<br/>
// agreement is hereby granted, provided that the above copyright notice<br/>
// and this paragraph appear in all copies.  This software program and<br/>
// documentation are copyrighted by The Regents of the University of<br/>
// California. The software program and documentation are supplied "AS<br/>
// IS", without any accompanying services from The Regents. The Regents<br/>
// does not warrant that the operation of the program will be<br/>
// uninterrupted or error-free. The end-user understands that the program<br/>
// was developed for research purposes and is advised not to rely<br/>
// exclusively on the program for any reason.  IN NO EVENT SHALL THE<br/>
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,<br/>
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,<br/>
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF<br/>
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF<br/>
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY<br/>
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF<br/>
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE<br/>
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF<br/>
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,<br/>
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.<br/>
<br/>
package org.argouml.model.uml;<br/>
<br/>
import java.util.ArrayList;<br/>
import java.util.Collection;<br/>
import java.util.HashSet;<br/>
import java.util.Iterator;<br/>
import java.util.List;<br/>
import java.util.Set;<br/>
import java.util.Vector;<br/>
<br/>
import org.apache.log4j.Logger;<br/>
import org.argouml.model.CoreHelper;<br/>
import org.argouml.model.Model;<br/>
import org.argouml.model.ModelMemento;<br/>
import org.argouml.model.UmlException;<br/>
import org.argouml.util.CollectionUtil;<br/>
<br/>
import ru.novosoft.uml.MBase;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MActivityGraph;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MClassifierInState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MObjectFlowState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MPartition;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationEndRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MClassifierRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MCollaboration;<br/>
import ru.novosoft.uml.behavior.collaborations.MInteraction;<br/>
import ru.novosoft.uml.behavior.collaborations.MMessage;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAttributeLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MComponentInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLinkEnd;<br/>
import ru.novosoft.uml.behavior.common_behavior.MNodeInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MReception;<br/>
import ru.novosoft.uml.behavior.common_behavior.MSignal;<br/>
import ru.novosoft.uml.behavior.state_machines.MCompositeState;<br/>
import ru.novosoft.uml.behavior.state_machines.MEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MGuard;<br/>
import ru.novosoft.uml.behavior.state_machines.MPseudostate;<br/>
import ru.novosoft.uml.behavior.state_machines.MState;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateMachine;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateVertex;<br/>
import ru.novosoft.uml.behavior.state_machines.MTransition;<br/>
import ru.novosoft.uml.behavior.use_cases.MActor;<br/>
import ru.novosoft.uml.behavior.use_cases.MExtend;<br/>
import ru.novosoft.uml.behavior.use_cases.MInclude;<br/>
import ru.novosoft.uml.behavior.use_cases.MUseCase;<br/>
import ru.novosoft.uml.foundation.core.MAbstraction;<br/>
import ru.novosoft.uml.foundation.core.MAssociation;<br/>
import ru.novosoft.uml.foundation.core.MAssociationEnd;<br/>
import ru.novosoft.uml.foundation.core.MAttribute;<br/>
import ru.novosoft.uml.foundation.core.MBehavioralFeature;<br/>
import ru.novosoft.uml.foundation.core.MClass;<br/>
import ru.novosoft.uml.foundation.core.MClassifier;<br/>
import ru.novosoft.uml.foundation.core.MComment;<br/>
import ru.novosoft.uml.foundation.core.MComponent;<br/>
import ru.novosoft.uml.foundation.core.MConstraint;<br/>
import ru.novosoft.uml.foundation.core.MDataType;<br/>
import ru.novosoft.uml.foundation.core.MDependency;<br/>
import ru.novosoft.uml.foundation.core.MElementResidence;<br/>
import ru.novosoft.uml.foundation.core.MFeature;<br/>
import ru.novosoft.uml.foundation.core.MFlow;<br/>
import ru.novosoft.uml.foundation.core.MGeneralizableElement;<br/>
import ru.novosoft.uml.foundation.core.MGeneralization;<br/>
import ru.novosoft.uml.foundation.core.MInterface;<br/>
import ru.novosoft.uml.foundation.core.MMethod;<br/>
import ru.novosoft.uml.foundation.core.MModelElement;<br/>
import ru.novosoft.uml.foundation.core.MNamespace;<br/>
import ru.novosoft.uml.foundation.core.MNode;<br/>
import ru.novosoft.uml.foundation.core.MOperation;<br/>
import ru.novosoft.uml.foundation.core.MParameter;<br/>
import ru.novosoft.uml.foundation.core.MRelationship;<br/>
import ru.novosoft.uml.foundation.core.MStructuralFeature;<br/>
import ru.novosoft.uml.foundation.data_types.MAggregationKind;<br/>
import ru.novosoft.uml.foundation.data_types.MBooleanExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MCallConcurrencyKind;<br/>
import ru.novosoft.uml.foundation.data_types.MChangeableKind;<br/>
import ru.novosoft.uml.foundation.data_types.MExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MMultiplicity;<br/>
import ru.novosoft.uml.foundation.data_types.MOrderingKind;<br/>
import ru.novosoft.uml.foundation.data_types.MParameterDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MProcedureExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MPseudostateKind;<br/>
import ru.novosoft.uml.foundation.data_types.MScopeKind;<br/>
import ru.novosoft.uml.foundation.data_types.MVisibilityKind;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MStereotype;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MTaggedValue;<br/>
import ru.novosoft.uml.model_management.MElementImport;<br/>
import ru.novosoft.uml.model_management.MPackage;<br/>
<br/>
/**<br/>
 * Helper class for UML Foundation::Core Package.&lt;p&gt;<br/>
 *<br/>
 * @since ARGO0.11.2<br/>
 * @author Thierry Lach<br/>
 * @author Jaap Branderhorst<br/>
 */<br/>
class CoreHelperImpl implements CoreHelper {<br/>
    /**<br/>
     * Logger.<br/>
     */<br/>
    private static final Logger LOG = Logger.getLogger(CoreHelperImpl.class);<br/>
<br/>
    /**<br/>
     * The model implementation.<br/>
     */<br/>
    private NSUMLModelImplementation nsmodel;<br/>
<br/>
    /**<br/>
     * Don't allow instantiation.<br/>
     *<br/>
     * @param implementation To get other helpers and factories.<br/>
     */<br/>
    CoreHelperImpl(NSUMLModelImplementation implementation) {<br/>
        nsmodel = implementation;<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine if a meta type is a subtype of another.<br/>
     * @param type The parent metatype.<br/>
     * @param subType The metatype to test for being a subtype.<br/>
     * @return true is subType is a sub-type of type.<br/>
     */<br/>
    public boolean isSubType(Object type, Object subType) {<br/>
        if (!(type instanceof Class) || !(subType instanceof Class)) {<br/>
            throw new IllegalArgumentException("Metatypes are expected");<br/>
        }<br/>
           return ((Class) type).isAssignableFrom((Class) subType);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all Classifiers of which this class is a<br/>
     * direct or indirect subtype.<br/>
     *<br/>
     * @param cls1  the class you want to have the parents for<br/>
     * @return a collection of the parents, each of which is a<br/>
     *         {@link MGeneralizableElement MGeneralizableElement}<br/>
     */<br/>
    public Collection getAllSupertypes(Object cls1) {<br/>
<br/>
        if (!(cls1 instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        MClassifier cls = (MClassifier) cls1;<br/>
<br/>
        Collection result = new HashSet();<br/>
        Collection add = getSupertypes(cls);<br/>
        do {<br/>
            Collection newAdd = new HashSet();<br/>
            Iterator addIter = add.iterator();<br/>
            while (addIter.hasNext()) {<br/>
                MGeneralizableElement next =<br/>
                    (MGeneralizableElement) addIter.next();<br/>
                if (next instanceof MClassifier) {<br/>
                    newAdd.addAll(getSupertypes(next));<br/>
                }<br/>
            }<br/>
            result.addAll(add);<br/>
            add = newAdd;<br/>
            add.removeAll(result);<br/>
        }<br/>
        while (!add.isEmpty());<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all Classifiers of which this class is a<br/>
     * direct subtype.&lt;p&gt;<br/>
     *<br/>
     * @param ogeneralizableelement the class you want to have the parents for<br/>
     * @return a collection of the parents, each of which is a<br/>
     *         {@link MGeneralizableElement MGeneralizableElement}<br/>
     */<br/>
    public Collection getSupertypes(Object ogeneralizableelement) {<br/>
        Collection result = new HashSet();<br/>
        if (ogeneralizableelement instanceof MGeneralizableElement) {<br/>
            MGeneralizableElement cls =<br/>
                (MGeneralizableElement) ogeneralizableelement;<br/>
            Collection gens = cls.getGeneralizations();<br/>
            Iterator genIterator = gens.iterator();<br/>
            while (genIterator.hasNext()) {<br/>
                MGeneralization next = (MGeneralization) genIterator.next();<br/>
                result.add(next.getParent());<br/>
            }<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all opposite AssociationEnds of a given<br/>
     * Classifier.<br/>
     *<br/>
     * @param classifier the classifier you want to have the opposite<br/>
     * association ends for<br/>
     * @return a collection of the opposite associationends<br/>
     */<br/>
    public Collection getAssociateEnds(Object classifier) {<br/>
        if (!(classifier instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Collection result = new ArrayList();<br/>
        Iterator ascends =<br/>
            ((MClassifier) classifier).getAssociationEnds().iterator();<br/>
        while (ascends.hasNext()) {<br/>
            MAssociationEnd ascend = (MAssociationEnd) ascends.next();<br/>
            if ((ascend.getOppositeEnd() != null)) {<br/>
                result.add(ascend.getOppositeEnd());<br/>
            }<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all opposite AssociationEnds of a given<br/>
     * Classifier, including inherited.<br/>
     *<br/>
     * @param classifier1 the classifier you want to have the opposite<br/>
     * association ends for<br/>
     * @return a collection of the opposite associationends<br/>
     */<br/>
    public Collection getAssociateEndsInh(Object classifier1) {<br/>
<br/>
        if (!(classifier1 instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        MClassifier classifier = (MClassifier) classifier1;<br/>
<br/>
        Collection result = new ArrayList();<br/>
        result.addAll(getAssociateEnds(classifier));<br/>
        Iterator parents = classifier.getParents().iterator();<br/>
        while (parents.hasNext()) {<br/>
            result.addAll(getAssociateEndsInh(parents.next()));<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a feature from a classifier.<br/>
     *<br/>
     * @param cls the classifier<br/>
     * @param feature the feature to be removed<br/>
     */<br/>
    public void removeFeature(Object cls, Object feature) {<br/>
        if (cls instanceof MClassifier &amp;&amp; feature instanceof MFeature) {<br/>
            if (LOG.isInfoEnabled()) {<br/>
                LOG.info("Removing the feature " + feature);<br/>
            }<br/>
            ((MClassifier) cls).removeFeature((MFeature) feature);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns the name of a feature.<br/>
     *<br/>
     * @param o is the feature<br/>
     * @return name<br/>
     */<br/>
    public String getFeatureName(Object o) {<br/>
        if (o != null &amp;&amp; o instanceof MFeature) {<br/>
            return ((MFeature) o).getName();<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns if the object is a method.<br/>
     *<br/>
     * @param o object<br/>
     * @return true if it's a method, false if not<br/>
     */<br/>
    public boolean isMethod(Object o) {<br/>
        return (o instanceof MMethod);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns if the object is an operation.<br/>
     *<br/>
     * @param o object<br/>
     * @return true if it's an operation, false if not<br/>
     */<br/>
    public boolean isOperation(Object o) {<br/>
        return (o instanceof MOperation);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all operations of a given Classifier.<br/>
     *<br/>
     * @param classifier the classifier you want to have the operations for<br/>
     * @return a collection of the operations<br/>
     */<br/>
    public Collection getOperations(Object classifier) {<br/>
        Collection result = new ArrayList();<br/>
        if (classifier instanceof MClassifier) {<br/>
            MClassifier mclassifier = (MClassifier) classifier;<br/>
            Iterator features = mclassifier.getFeatures().iterator();<br/>
            while (features.hasNext()) {<br/>
                MFeature feature = (MFeature) features.next();<br/>
                if (feature instanceof MOperation) {<br/>
                    result.add(feature);<br/>
                }<br/>
            }<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method replaces all operations of the given classifier<br/>
     * by the given collection of operations.<br/>
     *<br/>
     * @param classifier the given classifier<br/>
     * @param operations the new operations<br/>
     */<br/>
    public void setOperations(Object classifier, Collection operations) {<br/>
        if (classifier instanceof MClassifier) {<br/>
            MClassifier mclassifier = (MClassifier) classifier;<br/>
            List result = new ArrayList(mclassifier.getFeatures());<br/>
            Iterator features = mclassifier.getFeatures().iterator();<br/>
            while (features.hasNext()) {<br/>
                MFeature feature = (MFeature) features.next();<br/>
                if (feature instanceof MOperation) {<br/>
                    result.remove(feature);<br/>
                }<br/>
            }<br/>
            result.addAll(operations);<br/>
            mclassifier.setFeatures(result);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all attributes of a given Classifier.<br/>
     *<br/>
     * @param classifier the classifier you want to have the attributes for<br/>
     * @return a collection of the attributes<br/>
     */<br/>
    public Collection getAttributes(Object classifier) {<br/>
        if (!(classifier instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Collection result = new ArrayList();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Iterator features = ((MClassifier) classifier).getFeatures().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (features.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MFeature feature = (MFeature) features.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (feature instanceof MAttribute) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        result.add(feature);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method replaces all attributes of the given classifier<br/>
     * by the given collection of attributes.<br/>
     * @param classifier the classifier<br/>
     * @param attributes the new attributes<br/>
     */<br/>
    public void setAttributes(Object classifier, Collection attributes) {<br/>
        if (classifier instanceof MClassifier) {<br/>
            MClassifier mclassifier = (MClassifier) classifier;<br/>
            List result = new ArrayList(mclassifier.getFeatures());<br/>
            Iterator features = mclassifier.getFeatures().iterator();<br/>
            while (features.hasNext()) {<br/>
                MFeature feature = (MFeature) features.next();<br/>
                if (feature instanceof MAttribute) {<br/>
                    result.remove(feature);<br/>
                }<br/>
            }<br/>
            result.addAll(attributes);<br/>
            mclassifier.setFeatures(result);<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * This method returns all attributes of a given Classifier,<br/>
     * including inherited.<br/>
     *<br/>
     * @param classifier the classifier you want to have the attributes for<br/>
     * @return a collection of the attributes<br/>
     */<br/>
    public Collection getAttributesInh(Object classifier) {<br/>
<br/>
        if (!(classifier instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Collection result = new ArrayList();<br/>
        result.addAll(nsmodel.getFacade().getStructuralFeatures(classifier));<br/>
        Iterator parents = ((MClassifier) classifier).getParents().iterator();<br/>
        while (parents.hasNext()) {<br/>
            MClassifier parent = (MClassifier) parents.next();<br/>
            if (LOG.isDebugEnabled()) {<br/>
                LOG.debug("Adding attributes for: " + parent);<br/>
            }<br/>
            result.addAll(getAttributesInh(parent));<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all operations of a given Classifier,<br/>
     * including inherited.<br/>
     *<br/>
     * @param classifier the classifier you want to have the operations for<br/>
     * @return a collection of the operations<br/>
     */<br/>
    public Collection getOperationsInh(Object classifier) {<br/>
        if (!(classifier instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Collection result = new ArrayList();<br/>
        result.addAll(nsmodel.getFacade().getOperations(classifier));<br/>
        Iterator parents = ((MClassifier) classifier).getParents().iterator();<br/>
        while (parents.hasNext()) {<br/>
            result.addAll(getOperationsInh(parents.next()));<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method finds all paramters of the given operation which<br/>
     * have the MParamterDirectionType RETURN. If it is only one, it<br/>
     * is returned.  In case there are no return parameters, null is<br/>
     * returned. If there is more than one return paramter, first of<br/>
     * them is returned, but a message is logged.&lt;p&gt;<br/>
     *<br/>
     * @param operation1 the operation you want to find the return<br/>
     * parameter for.<br/>
     * @return If this operation has only one paramter with Kind: RETURN,<br/>
     *         this is it, otherwise null<br/>
     */<br/>
    public Object getReturnParameter(Object operation1) {<br/>
<br/>
        if (!(operation1 instanceof MOperation)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        MOperation operation = (MOperation) operation1;<br/>
<br/>
        Vector returnParams = new Vector();<br/>
        Iterator params = operation.getParameters().iterator();<br/>
        while (params.hasNext()) {<br/>
            MParameter parameter = (MParameter) params.next();<br/>
            if ((parameter.getKind()).equals(MParameterDirectionKind.RETURN)) {<br/>
                returnParams.add(parameter);<br/>
            }<br/>
        }<br/>
        switch (returnParams.size()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1 :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (MParameter) returnParams.elementAt(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0 :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    //Next line gives too many strings while debugging<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // obscuring other errors.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    //cat.debug("No ReturnParameter found!");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    LOG.debug(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      "More than one ReturnParameter found, returning first!");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (MParameter) returnParams.elementAt(0);<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Returns all return parameters for an operation.<br/>
     *<br/>
     * @param operation is the operation.<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getReturnParameters(Object operation) {<br/>
        Vector returnParams = new Vector();<br/>
        Iterator params = ((MOperation) operation).getParameters().iterator();<br/>
        while (params.hasNext()) {<br/>
            MParameter parameter = (MParameter) params.next();<br/>
            if ((parameter.getKind()).equals(MParameterDirectionKind.RETURN)) {<br/>
                returnParams.add(parameter);<br/>
            }<br/>
        }<br/>
        return returnParams;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the operation that some method realized. Returns null if<br/>
     * object isn't a method or, possibly, if the method isn't properly<br/>
     * defined.<br/>
     *<br/>
     * @param object  the method you want the realized operation of.<br/>
     * @return an operation, or null.<br/>
     */<br/>
    public Object getSpecification(Object object) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!(object instanceof MMethod)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return ((MMethod) object).getSpecification();<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all Interfaces of which this class is a realization.&lt;p&gt;<br/>
     *<br/>
     * @param classifier  the class you want to have the interfaces for<br/>
     * @return a collection of the Interfaces<br/>
     */<br/>
    public Collection getSpecifications(Object classifier) {<br/>
        Collection result = new Vector();<br/>
        Collection deps = ((MClassifier) classifier).getClientDependencies();<br/>
        Iterator depIterator = deps.iterator();<br/>
        while (depIterator.hasNext()) {<br/>
            Object dep = depIterator.next();<br/>
            Object stereo = CollectionUtil.getFirstItemOrNull(<br/>
                    Model.getFacade().getStereotypes(dep));<br/>
            if ((dep instanceof MAbstraction)<br/>
                &amp;&amp; stereo != null<br/>
                &amp;&amp; nsmodel.getFacade().getName(stereo) != null<br/>
                &amp;&amp; nsmodel.getFacade().getName(stereo).equals("realize")) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object i = nsmodel.getFacade().getSuppliers(dep).toArray()[0];<br/>
                result.add(i);<br/>
            }<br/>
        }<br/>
        return result;<br/>
    }<br/>
    /**<br/>
     * This method returns all Classifiers of which this class is a<br/>
     * direct supertype.<br/>
     *<br/>
     * @param cls  the class you want to have the children for<br/>
     * @return a collection of the children, each of which is a<br/>
     *         {@link MGeneralizableElement MGeneralizableElement}<br/>
     */<br/>
    public Collection getSubtypes(Object cls) {<br/>
        if (!(cls instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Collection result = new Vector();<br/>
        Collection gens = ((MClassifier) cls).getSpecializations();<br/>
        Iterator genIterator = gens.iterator();<br/>
        while (genIterator.hasNext()) {<br/>
            MGeneralization next = (MGeneralization) genIterator.next();<br/>
            result.add(next.getChild());<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all behavioralfeatures found in this element and its<br/>
     * children.&lt;p&gt;<br/>
     *<br/>
     * @param element is the element<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllBehavioralFeatures(Object element) {<br/>
        if (!(element instanceof MModelElement)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it =<br/>
            ((MModelElement) element).getModelElementContents().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MClassifier) {<br/>
                MClassifier clazz = (MClassifier) o;<br/>
                if (!(clazz instanceof MDataType)) {<br/>
                    Iterator it1 = clazz.getFeatures().iterator();<br/>
                    while (it1.hasNext()) {<br/>
                        Object o1 = it1.next();<br/>
                        if (o1 instanceof MBehavioralFeature) {<br/>
                            list.add(o1);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            } else {<br/>
                list.addAll(getAllBehavioralFeatures(it.next()));<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all behavioral features of some classifier.<br/>
     * @param clazz The classifier<br/>
     * @return the collection with all behavioral features of some classifier<br/>
     */<br/>
    public Collection getBehavioralFeatures(Object clazz) {<br/>
        if (clazz instanceof MClassifier) {<br/>
            List ret = new ArrayList();<br/>
            Iterator it = nsmodel.getFacade().getFeatures(clazz).iterator();<br/>
            while (it.hasNext()) {<br/>
                Object o = it.next();<br/>
                if (o instanceof MBehavioralFeature) {<br/>
                    ret.add(o);<br/>
                }<br/>
            }<br/>
            return ret;<br/>
        }<br/>
        throw new IllegalArgumentException("Argument is not a classifier");<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all interfaces found in this namespace and in its children.<br/>
     *<br/>
     * @param ns the given namespace<br/>
     * @return Collection with all interfaces found<br/>
     */<br/>
    public Collection getAllInterfaces(Object ns) {<br/>
        if (ns == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(ns instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MNamespace) ns).getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllInterfaces(o));<br/>
            }<br/>
            if (o instanceof MInterface) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all classes found in this namespace and in its children.&lt;p&gt;<br/>
     *<br/>
     * @param ns is the namespace.<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllClasses(Object ns) {<br/>
        if (ns == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(ns instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MNamespace) ns).getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllClasses(o));<br/>
            }<br/>
            if (o instanceof MClass) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Return all interfaces the given class realizes.&lt;p&gt;<br/>
     *<br/>
     * @param cls the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getRealizedInterfaces(Object cls) {<br/>
        MClassifier classifier = (MClassifier) cls;<br/>
        if (classifier == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        Iterator it = classifier.getClientDependencies().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object clientDependency = it.next();<br/>
            if (clientDependency instanceof MAbstraction) {<br/>
                Object stereo = CollectionUtil.getFirstItemOrNull(<br/>
                        Model.getFacade().getStereotypes(clientDependency));<br/>
                if (stereo != null<br/>
                        &amp;&amp; nsmodel.getFacade().getBaseClass(stereo) != null<br/>
                        &amp;&amp; nsmodel.getFacade().getName(stereo) != null<br/>
                        &amp;&amp; nsmodel.getFacade().getBaseClass(stereo)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                .equals("Abstraction")<br/>
                        &amp;&amp; nsmodel.getFacade().getName(stereo)<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;.equals("realize")) {<br/>
                    Iterator it2 =<br/>
                        nsmodel.getFacade().getSuppliers(clientDependency)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.iterator();<br/>
                    while (it2.hasNext()) {<br/>
                        Object supplier = it2.next();<br/>
                        if (supplier instanceof MInterface) {<br/>
                            list.add(supplier);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all classes some generalizable element extends.<br/>
     *<br/>
     * @param clazz is the generalizable element<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getExtendedClassifiers(Object clazz) {<br/>
        if (clazz == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        Iterator it = nsmodel.getFacade().getGeneralizations(clazz).iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            MGeneralization gen = (MGeneralization) it.next();<br/>
            MGeneralizableElement parent = gen.getParent();<br/>
            if (parent != null) {<br/>
                list.add(parent);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the generalization between two generalizable elements.<br/>
     * Returns null if there is none.&lt;p&gt;<br/>
     *<br/>
     * @param achild is the child generalizable element.<br/>
     * @param aparent is the parent generalizable element.<br/>
     * @return MGeneralization<br/>
     */<br/>
    public Object getGeneralization(Object achild,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     Object aparent) {<br/>
        MGeneralizableElement child = (MGeneralizableElement) achild;<br/>
        MGeneralizableElement parent = (MGeneralizableElement) aparent;<br/>
        if (child == null || parent == null) {<br/>
            return null;<br/>
        }<br/>
        Iterator it = child.getGeneralizations().iterator();<br/>
        while (it.hasNext()) {<br/>
            MGeneralization gen = (MGeneralization) it.next();<br/>
            if (gen.getParent() == parent) {<br/>
                return gen;<br/>
            }<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * @see org.argouml.model.CoreHelper#getBody(java.lang.Object)<br/>
     */<br/>
    public String getBody(Object comment) {<br/>
        if (comment instanceof MComment) {<br/>
            /* In UML 1.3, get it from the name.<br/>
             * From UML 1.4, get it from the body.<br/>
             */<br/>
            return ((MComment) comment).getName();<br/>
        }<br/>
        throw new IllegalArgumentException();<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all flows from some source modelelement to a target<br/>
     * modelelement.&lt;p&gt;<br/>
     *<br/>
     * @param source is the source model element.<br/>
     * @param target is the target model element.<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getFlows(Object source, Object target) {<br/>
        if (source == null || target == null) {<br/>
            return null;<br/>
        }<br/>
        if (!(source instanceof MModelElement)) {<br/>
            throw new IllegalArgumentException("source");<br/>
        }<br/>
        if (!(target instanceof MModelElement)) {<br/>
            throw new IllegalArgumentException("target");<br/>
        }<br/>
<br/>
        List ret = new ArrayList();<br/>
        Collection targetFlows = ((MModelElement) target).getTargetFlows();<br/>
        Iterator it = ((MModelElement) source).getSourceFlows().iterator();<br/>
        while (it.hasNext()) {<br/>
            MFlow flow = (MFlow) it.next();<br/>
            if (targetFlows.contains(flow)) {<br/>
                ret.add(flow);<br/>
            }<br/>
        }<br/>
        return ret;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all elements that extend some class.<br/>
     *<br/>
     * @param clazz is the class (a generalizable element)<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getExtendingElements(Object clazz) {<br/>
        if (clazz == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        Iterator it = nsmodel.getFacade().getSpecializations(clazz).iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            MGeneralization gen = (MGeneralization) it.next();<br/>
            MGeneralizableElement client =<br/>
                (MGeneralizableElement) nsmodel.getFacade().getChild(gen);<br/>
            if (client != null) {<br/>
                list.add(client);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all classifiers that extend some classifier.<br/>
     *<br/>
     * @param clazz is the classifier.<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getExtendingClassifiers(Object clazz) {<br/>
        if (clazz == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(clazz instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it =<br/>
            ((MGeneralizableElement) clazz).getSpecializations().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            MGeneralization gen = (MGeneralization) it.next();<br/>
            MGeneralizableElement client = gen.getChild();<br/>
            if (client instanceof MClassifier) {<br/>
                list.add(client);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all components found in this namespace and in its children.<br/>
     *<br/>
     * @param ns is the namespace.<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllComponents(Object ns) {<br/>
        if (ns == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(ns instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MNamespace) ns).getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllComponents(o));<br/>
            }<br/>
            if (o instanceof MComponent) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all components found in this namespace and in its children.<br/>
     *<br/>
     * @param ns is the namespace<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllDataTypes(Object ns) {<br/>
        if (ns == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(ns instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MNamespace) ns).getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllDataTypes(o));<br/>
            }<br/>
            if (o instanceof MDataType) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all components found in this namespace and in its children.&lt;p&gt;<br/>
     *<br/>
     * @param ns is the namespace<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllNodes(Object ns) {<br/>
        if (ns == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(ns instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MNamespace) ns).getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllNodes(o));<br/>
            }<br/>
            if (o instanceof MNode) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
    /**<br/>
     * Gets all classifiers that are associated to the given<br/>
     * classifier (have an association relationship with the<br/>
     * classifier).&lt;p&gt;<br/>
     *<br/>
     * @param aclassifier an MClassifier<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAssociatedClassifiers(Object aclassifier) {<br/>
        MClassifier classifier = (MClassifier) aclassifier;<br/>
        if (classifier == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        List list = new ArrayList();<br/>
        Iterator it = classifier.getAssociationEnds().iterator();<br/>
        while (it.hasNext()) {<br/>
            MAssociationEnd end = (MAssociationEnd) it.next();<br/>
            MAssociation assoc = end.getAssociation();<br/>
            Iterator it2 = assoc.getConnections().iterator();<br/>
            while (it2.hasNext()) {<br/>
                MAssociationEnd end2 = (MAssociationEnd) it2.next();<br/>
                if (end2 != end) {<br/>
                    list.add(end2.getType());<br/>
                }<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the associations between the classifiers from and to. Returns null<br/>
     * if from or to is null or if there is no association between them.<br/>
     *<br/>
     * @param from a classifier<br/>
     * @param to a classifier<br/>
     * @return MAssociation<br/>
     */<br/>
    public Collection getAssociations(Object/*MClassifier*/ from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Object/*MClassifier*/ to) {<br/>
        Set ret = new HashSet();<br/>
        if (from == null || to == null) {<br/>
            return ret;<br/>
        }<br/>
        Iterator it = nsmodel.getFacade().getAssociationEnds(from).iterator();<br/>
        while (it.hasNext()) {<br/>
            MAssociationEnd end = (MAssociationEnd) it.next();<br/>
            MAssociation assoc = end.getAssociation();<br/>
            Iterator it2 = assoc.getConnections().iterator();<br/>
            while (it2.hasNext()) {<br/>
                MAssociationEnd end2 = (MAssociationEnd) it2.next();<br/>
                if (end2.getType() == to) {<br/>
                    ret.add(assoc);<br/>
                }<br/>
            }<br/>
        }<br/>
        return ret;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all classifiers found in this namespace and in its children.<br/>
     *<br/>
     * @param namespace the given namespace<br/>
     * @return Collection the collection of all classifiers<br/>
     *                    found in the namespace<br/>
     */<br/>
    public Collection getAllClassifiers(Object namespace) {<br/>
        if (namespace == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        MNamespace ns = (MNamespace) namespace;<br/>
        Iterator it = ns.getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllClassifiers(o));<br/>
            }<br/>
            if (o instanceof MClassifier) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all associations for some classifier.&lt;p&gt;<br/>
     *<br/>
     * @param oclassifier the given classifier<br/>
     * @return Collection all associations for the given classifier<br/>
     */<br/>
    public Collection getAssociations(Object oclassifier) {<br/>
        Collection col = new ArrayList();<br/>
        if (oclassifier instanceof MClassifier) {<br/>
            MClassifier classifier = (MClassifier) oclassifier;<br/>
            Iterator it = classifier.getAssociationEnds().iterator();<br/>
            while (it.hasNext()) {<br/>
                col.add(((MAssociationEnd) it.next()).getAssociation());<br/>
            }<br/>
        }<br/>
        return col;<br/>
    }<br/>
    /**<br/>
     * Returns the associationend between a classifier and<br/>
     * an associaton.&lt;p&gt;<br/>
     *<br/>
     * @param type is the classifier<br/>
     * @param assoc is the association<br/>
     * @return MAssociationEnd<br/>
     */<br/>
    public Object getAssociationEnd(Object type,<br/>
            Object assoc) {<br/>
        if (type == null || assoc == null) {<br/>
            return null;<br/>
        }<br/>
        if (!(type instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
        if (!(assoc instanceof MAssociation)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MClassifier) type).getAssociationEnds().iterator();<br/>
        while (it.hasNext()) {<br/>
            MAssociationEnd end = (MAssociationEnd) it.next();<br/>
            if (((MAssociation) assoc).getConnections().contains(end)) {<br/>
                return end;<br/>
            }<br/>
        }<br/>
        return null;<br/>
    }<br/>
    /**<br/>
     * Returns the contents (owned elements) of this classifier and<br/>
     * all its parents as specified in section 2.5.3.8 of the UML 1.3<br/>
     * spec.&lt;p&gt;<br/>
     *<br/>
     * @param clazz is the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllContents(Object clazz) {<br/>
        if (clazz == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(clazz instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        List list = new ArrayList();<br/>
        Iterator it = ((MNamespace) clazz).getOwnedElements().iterator();<br/>
        while (it.hasNext()) {<br/>
            MModelElement element = (MModelElement) it.next();<br/>
            if (element.getVisibility().equals(MVisibilityKind.PUBLIC)<br/>
                || element.getVisibility().equals(MVisibilityKind.PROTECTED)) {<br/>
                list.add(element);<br/>
            }<br/>
        }<br/>
        it = ((MGeneralizableElement) clazz).getGeneralizations().iterator();<br/>
        while (it.hasNext()) {<br/>
            list.addAll(getAllContents(it.next()));<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all attributes of some classifier and of its parents.<br/>
     *<br/>
     * @param clazz is the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllAttributes(Object clazz) {<br/>
        if (clazz == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(clazz instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        List list = new ArrayList();<br/>
        Iterator it = ((MClassifier) clazz).getFeatures().iterator();<br/>
        while (it.hasNext()) {<br/>
            MFeature element = (MFeature) it.next();<br/>
            if (element instanceof MAttribute) {<br/>
                list.add(element);<br/>
            }<br/>
        }<br/>
        it = ((MClassifier) clazz).getGeneralizations().iterator();<br/>
        while (it.hasNext()) {<br/>
            list.addAll(getAllAttributes(it.next()));<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the source of a relation. The source of a relation is<br/>
     * defined as the modelelement that propagates this relation. If<br/>
     * there are more then 1 sources, only the first is returned. If<br/>
     * there is no source, null is returned. Examples of sources<br/>
     * include classifiers that are types to associationends, usecases<br/>
     * that are bases to extend and include relations and so on. A<br/>
     * source is allways the start from the arrow in the fig, the<br/>
     * destination the end.&lt;p&gt;<br/>
     *<br/>
     * This method also works to get the source of a Link.&lt;p&gt;<br/>
     *<br/>
     * TODO: move this method to a generic ModelHelper<br/>
     *<br/>
     * @param relationship is the relation<br/>
     * @return Object<br/>
     */<br/>
    public Object getSource(Object relationship) {<br/>
        if (!(relationship instanceof MRelationship)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; !(relationship instanceof MLink)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; !(relationship instanceof MAssociationEnd)) {<br/>
<br/>
<br/>
            throw new IllegalArgumentException("Argument "<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       + relationship.toString()<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       + " is not "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       + "a relationship");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if (relationship instanceof MLink) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        nsmodel.getFacade().getConnections(relationship).iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nsmodel.getFacade().getInstance(it.next());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    } <br/>
            return null;<br/>
        }<br/>
        if (relationship instanceof MAssociation) {<br/>
            MAssociation assoc = (MAssociation) relationship;<br/>
            List conns = assoc.getConnections();<br/>
            if (conns == null || conns.isEmpty()) {<br/>
                return null;<br/>
            }<br/>
            return ((MAssociationEnd) conns.get(0)).getType();<br/>
        }<br/>
        if (relationship instanceof MGeneralization) {<br/>
            MGeneralization gen = (MGeneralization) relationship;<br/>
            return gen.getChild();<br/>
        }<br/>
        if (relationship instanceof MDependency) {<br/>
            MDependency dep = (MDependency) relationship;<br/>
            Collection col = dep.getClients();<br/>
            if (col.isEmpty()) {<br/>
                return null;<br/>
            }<br/>
            return (MModelElement) (col.toArray())[0];<br/>
        }<br/>
        if (relationship instanceof MFlow) {<br/>
            MFlow flow = (MFlow) relationship;<br/>
            Collection col = flow.getSources();<br/>
            if (col.isEmpty()) {<br/>
                return null;<br/>
            }<br/>
            return (MModelElement) (col.toArray())[0];<br/>
        }<br/>
        if (relationship instanceof MExtend) {<br/>
            MExtend extend = (MExtend) relationship;<br/>
            return extend.getExtension(); // we have to follow the arrows..<br/>
        }<br/>
        if (relationship instanceof MInclude) {<br/>
            MInclude include = (MInclude) relationship;<br/>
            // we use modelfacade here to cover up for a messup in NSUML<br/>
            return nsmodel.getFacade().getBase(include);<br/>
        }<br/>
        if (relationship instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) relationship).getAssociation();<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the destination of a relation. The destination of a<br/>
     * relation is defined as the modelelement that receives this<br/>
     * relation.  If there are more then 1 destinations, only the<br/>
     * first is returned.  If there is no destination, null is<br/>
     * returned.  Examples of sources include classifiers that are<br/>
     * types to associationends, usecases that are bases to extend and<br/>
     * include relations and so on.  In the case of an association,<br/>
     * the destination is defined as the type of the second element in<br/>
     * the connections list.&lt;p&gt;<br/>
     *<br/>
     * This method also works for links.&lt;p&gt;<br/>
     *<br/>
     * TODO: move this method to a generic ModelHelper<br/>
     *<br/>
     * @param relationship is the relation<br/>
     * @return object<br/>
     */<br/>
    public Object getDestination(Object relationship) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!(relationship instanceof MRelationship)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; !(relationship instanceof MLink)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; !(relationship instanceof MAssociationEnd)) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    throw new IllegalArgumentException("Argument is not "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       + "a relationship");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (relationship instanceof MLink) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        nsmodel.getFacade().getConnections(relationship).iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return nsmodel.getFacade().getInstance(it.next());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<br/>
        if (relationship instanceof MAssociation) {<br/>
            MAssociation assoc = (MAssociation) relationship;<br/>
            List conns = assoc.getConnections();<br/>
            if (conns.size() &lt;= 1) {<br/>
                return null;<br/>
            }<br/>
            return ((MAssociationEnd) conns.get(1)).getType();<br/>
        }<br/>
        if (relationship instanceof MGeneralization) {<br/>
            MGeneralization gen = (MGeneralization) relationship;<br/>
            return gen.getParent();<br/>
        }<br/>
        if (relationship instanceof MDependency) {<br/>
            MDependency dep = (MDependency) relationship;<br/>
            Collection col = dep.getSuppliers();<br/>
            if (col.isEmpty()) {<br/>
                return null;<br/>
            }<br/>
            return (MModelElement) (col.toArray())[0];<br/>
        }<br/>
        if (relationship instanceof MFlow) {<br/>
            MFlow flow = (MFlow) relationship;<br/>
            Collection col = flow.getTargets();<br/>
            if (col.isEmpty()) {<br/>
                return null;<br/>
            }<br/>
            return (MModelElement) (col.toArray())[0];<br/>
        }<br/>
        if (relationship instanceof MExtend) {<br/>
            MExtend extend = (MExtend) relationship;<br/>
            return extend.getBase();<br/>
        }<br/>
        if (relationship instanceof MInclude) {<br/>
            MInclude include = (MInclude) relationship;<br/>
            return nsmodel.getFacade().getAddition(include);<br/>
        }<br/>
        if (relationship instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) relationship).getType();<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the dependencies between some supplier modelelement and<br/>
     * some client modelelement.  Does not return the vica versa<br/>
     * relationship (dependency 'from client to supplier').&lt;p&gt;<br/>
     *<br/>
     * @param supplierObj a MModelElement<br/>
     * @param clientObj a MModelElement<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getDependencies(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Object supplierObj,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Object clientObj) {<br/>
<br/>
        if (!(supplierObj instanceof MModelElement)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    || !(clientObj instanceof MModelElement)) {<br/>
<br/>
            return null;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
        MModelElement supplier = (MModelElement) supplierObj;<br/>
        MModelElement client = (MModelElement) clientObj;<br/>
<br/>
        List ret = new ArrayList();<br/>
        Collection clientDependencies = client.getClientDependencies();<br/>
        Iterator it = supplier.getSupplierDependencies().iterator();<br/>
        while (it.hasNext()) {<br/>
            MDependency dep = (MDependency) it.next();<br/>
            if (clientDependencies.contains(dep)) {<br/>
                ret.add(dep);<br/>
            }<br/>
        }<br/>
        return ret;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all relationships between the source and dest<br/>
     * modelelement and vica versa.&lt;p&gt;<br/>
     *<br/>
     * @param source is the source model element<br/>
     * @param dest is the destination model element<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getRelationships(Object source,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       Object dest) {<br/>
        Set ret = new HashSet();<br/>
        if (source == null || dest == null) {<br/>
            return ret;<br/>
        }<br/>
        if (!(source instanceof MModelElement)) {<br/>
            throw new IllegalArgumentException("source");<br/>
        }<br/>
        if (!(dest instanceof MModelElement)) {<br/>
            throw new IllegalArgumentException("dest");<br/>
        }<br/>
<br/>
        ret.addAll(getFlows(source, dest));<br/>
        ret.addAll(getFlows(dest, source));<br/>
        ret.addAll(getDependencies(source, dest));<br/>
        ret.addAll(getDependencies(dest, source));<br/>
        if (source instanceof MGeneralizableElement<br/>
            &amp;&amp; dest instanceof MGeneralizableElement) {<br/>
            ret.add(getGeneralization(source, dest));<br/>
            ret.add(getGeneralization(dest, source));<br/>
            if (source instanceof MClassifier &amp;&amp; dest instanceof MClassifier) {<br/>
                ret.addAll(getAssociations(source, dest));<br/>
            }<br/>
        }<br/>
        return ret;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if some modelelement may be owned by the given<br/>
     * namespace.&lt;p&gt;<br/>
     *<br/>
     * @param mObj a MModelElement<br/>
     * @param nsObj a MNamespace<br/>
     * @return boolean<br/>
     */<br/>
    public boolean isValidNamespace(Object mObj, Object nsObj) {<br/>
<br/>
        if (!(mObj instanceof MModelElement)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    || !(nsObj instanceof MNamespace)) {<br/>
<br/>
            return false;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
        MModelElement modelElement = (MModelElement) mObj;<br/>
        MNamespace ns = (MNamespace) nsObj;<br/>
<br/>
        if (modelElement == null || ns == null) {<br/>
            return false;<br/>
        }<br/>
        if (ns.getModel() != modelElement.getModel()) {<br/>
            return false;<br/>
        }<br/>
        if (modelElement == ns) {<br/>
            return false;<br/>
        }<br/>
        if (modelElement instanceof MNamespace<br/>
                &amp;&amp; modelElement == getFirstSharedNamespace(modelElement, ns)) {<br/>
            return false;<br/>
        }<br/>
        if (ns instanceof MInterface<br/>
            || ns instanceof MActor<br/>
            || ns instanceof MUseCase) {<br/>
            return false;<br/>
        } else if (ns instanceof MComponent) {<br/>
            return (modelElement instanceof MComponent &amp;&amp; modelElement != ns);<br/>
        } else if (ns instanceof MCollaboration) {<br/>
            if (!(modelElement instanceof MClassifierRole<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MAssociationRole<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MGeneralization<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MConstraint)) {<br/>
                return false;<br/>
            }<br/>
        } else if (ns instanceof MPackage) {<br/>
            if (!(modelElement instanceof MPackage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MClassifier<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MAssociation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MGeneralization<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MDependency<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MConstraint<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MCollaboration<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MStateMachine<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MStereotype)) {<br/>
                return false;<br/>
            }<br/>
        } else if (ns instanceof MClass) {<br/>
            if (!(modelElement instanceof MClass<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MAssociation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MGeneralization<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MUseCase<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MConstraint<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MDependency<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MCollaboration<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MDataType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MInterface)) {<br/>
                return false;<br/>
            }<br/>
        } else if (ns instanceof MClassifierRole) {<br/>
            MClassifierRole cr = (MClassifierRole) ns;<br/>
            if (!(cr.getAvailableContentses().contains(modelElement)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || cr.getAvailableFeatures().contains(modelElement))) {<br/>
                return false;<br/>
            }<br/>
        }<br/>
        if (modelElement instanceof MStructuralFeature) {<br/>
            if (!isValidNamespace((MStructuralFeature) modelElement, ns)) {<br/>
                return false;<br/>
            }<br/>
        } else if (modelElement instanceof MGeneralizableElement) {<br/>
            if (!isValidNamespace((MGeneralizableElement) modelElement, ns)) {<br/>
                return false;<br/>
            }<br/>
        } else if (modelElement instanceof MGeneralization) {<br/>
            if (!isValidNamespace((MGeneralization) modelElement, ns)) {<br/>
                return false;<br/>
            }<br/>
        }<br/>
        if (modelElement instanceof MAssociation) {<br/>
            if (!isValidNamespace((MAssociation) modelElement, ns)) {<br/>
                return false;<br/>
            }<br/>
        } else if (modelElement instanceof MCollaboration) {<br/>
            if (!isValidNamespace((MCollaboration) modelElement, ns)) {<br/>
                return false;<br/>
            }<br/>
        }<br/>
        return true;<br/>
    }<br/>
    private boolean isValidNamespace(MCollaboration collab, MNamespace ns) {<br/>
        Iterator it = collab.getOwnedElements().iterator();<br/>
        while (it.hasNext()) {<br/>
            MModelElement m = (MModelElement) it.next();<br/>
            if (m instanceof MClassifierRole) {<br/>
                MClassifierRole role = (MClassifierRole) m;<br/>
                Iterator it2 = role.getBases().iterator();<br/>
                while (it2.hasNext()) {<br/>
                    if (!ns.getOwnedElements().contains(it2.next())) {<br/>
                        return false;<br/>
                    }<br/>
                }<br/>
            } else if (m instanceof MAssociationRole) {<br/>
                if (!ns.getOwnedElements()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    .contains(((MAssociationRole) m).getBase())) {<br/>
                    return false;<br/>
                }<br/>
            }<br/>
        }<br/>
        return true;<br/>
    }<br/>
<br/>
    private boolean isValidNamespace(MGeneralization gen, MNamespace ns) {<br/>
        if (gen.getParent() == null || gen.getChild() == null) {<br/>
            return true;<br/>
        }<br/>
        MNamespace ns1 = gen.getParent().getNamespace();<br/>
        MNamespace ns2 = gen.getChild().getNamespace();<br/>
        if (ns == getFirstSharedNamespace(ns1, ns2)) {<br/>
            return true;<br/>
        }<br/>
        return false;<br/>
    }<br/>
<br/>
    private boolean isValidNamespace(MStructuralFeature struc, MNamespace ns) {<br/>
        if (struc.getType() == null || struc.getOwner() == null) {<br/>
            return true;<br/>
        }<br/>
        return struc.getOwner().getNamespace()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    .getOwnedElements().contains(struc.getType());<br/>
    }<br/>
<br/>
    private boolean isValidNamespace(MAssociation assoc, MNamespace ns) {<br/>
        Iterator it = assoc.getConnections().iterator();<br/>
        List namespaces = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            MAssociationEnd end = (MAssociationEnd) it.next();<br/>
            namespaces.add(end.getType().getNamespace());<br/>
        }<br/>
        it = namespaces.iterator();<br/>
        while (it.hasNext()) {<br/>
            MNamespace ns1 = (MNamespace) it.next();<br/>
            if (it.hasNext()) {<br/>
                MNamespace ns2 = (MNamespace) it.next();<br/>
                // TODO: this contains a small error (ns can be part<br/>
                // of hierarchy of namespaces, that's not taken into<br/>
                // account)<br/>
                if (ns == getFirstSharedNamespace(ns1, ns2)) {<br/>
                    return true;<br/>
                }<br/>
            }<br/>
        }<br/>
        return false;<br/>
    }<br/>
<br/>
    private boolean isValidNamespace(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     MGeneralizableElement gen,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     MNamespace ns) {<br/>
        Iterator it = gen.getParents().iterator();<br/>
        while (it.hasNext()) {<br/>
            MGeneralizableElement gen2 = (MGeneralizableElement) it.next();<br/>
            if (!ns.getOwnedElements().contains(gen2)) {<br/>
                return false;<br/>
            }<br/>
        }<br/>
        return true;<br/>
    }<br/>
    /**<br/>
     * Gets the first namespace two namespaces share. That is: it<br/>
     * returns the first namespace that owns the given namespaces<br/>
     * itself or some owner of the given namespaces.&lt;p&gt;<br/>
     *<br/>
     * @param ns1 is the first name space<br/>
     * @param ns2 is the second name space<br/>
     * @return MNamespace<br/>
     */<br/>
    public Object getFirstSharedNamespace(Object ns1, Object ns2) {<br/>
        if (ns1 == null || ns2 == null) {<br/>
            return null;<br/>
        }<br/>
        if (ns1 == ns2) {<br/>
            return ns1;<br/>
        }<br/>
        if (!(ns1 instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
        if (!(ns2 instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        boolean ns1Owner =<br/>
            nsmodel.getModelManagementHelper()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        .getAllNamespaces(ns1).contains(ns2);<br/>
        boolean ns2Owner =<br/>
            nsmodel.getModelManagementHelper()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        .getAllNamespaces(ns2).contains(ns1);<br/>
        if (ns1Owner) {<br/>
            return ns1;<br/>
        }<br/>
        if (ns2Owner) {<br/>
            return ns2;<br/>
        }<br/>
        return getFirstSharedNamespace(<br/>
                ((MModelElement) ns1).getNamespace(),<br/>
                ((MModelElement) ns2).getNamespace());<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all possible namespaces that may be selected by some given<br/>
     * modelelement. Which namespaces are allowed, is decided in the method<br/>
     * isValidNamespace.&lt;p&gt;<br/>
     *<br/>
     * @param modelElement is the model element<br/>
     * @param model the model to search<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllPossibleNamespaces(Object modelElement,<br/>
            Object model) {<br/>
        MModelElement m = (MModelElement) modelElement;<br/>
        List ret = new ArrayList();<br/>
        if (m == null) {<br/>
            return ret;<br/>
        }<br/>
        if (isValidNamespace(m, model)) {<br/>
            ret.add(model);<br/>
        }<br/>
        Iterator it =<br/>
            nsmodel.getModelManagementHelper()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        .getAllModelElementsOfKind(model, MNamespace.class)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;            .iterator();<br/>
        while (it.hasNext()) {<br/>
            MNamespace ns = (MNamespace) it.next();<br/>
            if (isValidNamespace(m, ns)) {<br/>
                ret.add(ns);<br/>
            }<br/>
        }<br/>
        return ret;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all children from some given generalizableelement on<br/>
     * all levels (the complete tree excluding the generalizable<br/>
     * element itself).&lt;p&gt;<br/>
     *<br/>
     * @param o is the generalizable element<br/>
     * @return Collection<br/>
     * @throws IllegalStateException if there is a circular reference.<br/>
     */<br/>
    // TODO: Argument shall be typed to catch a lot of problems at<br/>
    //       compile time.<br/>
    // TODO: The exception shall be declared explicitly.<br/>
    // TODO: Use an exception that needs to be caugh so users of<br/>
    //       getChildren won't forget that they need to catch it.<br/>
    public Collection getChildren(Object o) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Collection col = new ArrayList();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collection generalizations = new ArrayList();<br/>
        if (o instanceof MGeneralizableElement) {<br/>
            Iterator it =<br/>
                ((MGeneralizableElement) o).getSpecializations().iterator();<br/>
            while (it.hasNext()) {<br/>
                getChildren(col, (MGeneralization) it.next(), generalizations);<br/>
            }<br/>
        }<br/>
        return col;<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds all children recursively to the Collection in the first argument.<br/>
     * The algorithm assumes that there is a cycle when a node has been visited twice<br/>
     * using already known generalizations.<br/>
     *<br/>
     * @param currentChildren collection to collect them in.<br/>
     * @param gen element whose children are added.<br/>
     * @param generalizations the list of already traversed generalizations.<br/>
     * @throws IllegalStateException if there is a circular reference.<br/>
     */<br/>
    private void getChildren(Collection currentChildren, MGeneralization gen, Collection generalizations) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MGeneralizableElement child = gen.getChild();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (currentChildren.contains(child) &amp;&amp; generalizations.contains(gen)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalStateException("Circular inheritance occured.");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentChildren.add(child);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generalizations.add(gen);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Iterator it = child.getSpecializations().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    getChildren(currentChildren, (MGeneralization) it.next(), generalizations);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
    /**<br/>
     * Returns all interfaces that are realized by the given class or<br/>
     * by its superclasses. It's possible that interfaces occur twice<br/>
     * in the collection returned. In that case there is a double<br/>
     * reference to that interface.<br/>
     *<br/>
     * @param o is the given class<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllRealizedInterfaces(Object o) {<br/>
        return internalGetAllRealizedInterfaces(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new ArrayList(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new HashSet());<br/>
    }<br/>
<br/>
    /**<br/>
     * Helper method for getAllRealizedInterfaces.<br/>
     * @param o<br/>
     * @param col<br/>
     * @param visited<br/>
     * @return Collection<br/>
     */<br/>
    private Collection internalGetAllRealizedInterfaces(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object o, Collection col, Set visited) {<br/>
        visited.add(o);<br/>
        if (o != null) {<br/>
            if (o instanceof MClass) {<br/>
                MClass clazz = (MClass) o;<br/>
                Collection supDependencies = clazz.getClientDependencies();<br/>
                Iterator it = supDependencies.iterator();<br/>
                while (it.hasNext()) {<br/>
                    MDependency dependency = (MDependency) it.next();<br/>
                    MStereotype stereo = dependency.getStereotype();<br/>
                    if (dependency instanceof MAbstraction<br/>
                        &amp;&amp; stereo != null<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "realize".equals(stereo.getName())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "Abstraction".equals(stereo.getBaseClass())) {<br/>
<br/>
                        col.addAll(dependency.getSuppliers());<br/>
<br/>
                    }<br/>
                }<br/>
                Collection superTypes = getSupertypes(o);<br/>
                it = superTypes.iterator();<br/>
                while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Object obj = it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if (!visited.contains(obj)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internalGetAllRealizedInterfaces(obj, col, visited);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
                }<br/>
            }<br/>
        }<br/>
        return col;<br/>
    }<br/>
<br/>
    /**<br/>
     * @param  association the association to be investigated<br/>
     * @return true if one of the association ends of the given association<br/>
     *         is of the composite kind<br/>
     */<br/>
    public final boolean hasCompositeEnd(Object association) {<br/>
        if (!(association instanceof MAssociation)) {<br/>
            throw new IllegalArgumentException();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
        MAssociation association1 = (MAssociation) association;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;List ends = association1.getConnections();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (Iterator iter = ends.iterator(); iter.hasNext();) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MAssociationEnd end = (MAssociationEnd) iter.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (end.getAggregation() == MAggregationKind.COMPOSITE) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * @param associationEnd is the association end<br/>
     * @param kindType the MAggregationKind as a string in lower case letter,<br/>
     *                 eg: composite.<br/>
     * @return true if the aggregation kinds are the same.<br/>
     */<br/>
    public final boolean equalsAggregationKind(Object associationEnd,<br/>
                                               String kindType) {<br/>
        if (!(associationEnd instanceof MAssociationEnd)) {<br/>
            throw new IllegalArgumentException();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
        MAssociationEnd associationEnd1 = (MAssociationEnd) associationEnd;<br/>
<br/>
        if (kindType.equals("composite")) {<br/>
            return MAggregationKind.COMPOSITE.equals(<br/>
                            associationEnd1.getAggregation());<br/>
        } <br/>
        throw new IllegalArgumentException("kindType: " + kindType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       + " not supported");<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove the given modelelement from a given comment.<br/>
     *<br/>
     * @param handle MComment<br/>
     * @param me MModelElement<br/>
     */<br/>
    public void removeAnnotatedElement(Object handle, Object me) {<br/>
        if (handle instanceof MComment &amp;&amp; me instanceof MModelElement) {<br/>
            ((MComment) handle).removeAnnotatedElement((MModelElement) me);<br/>
            return;<br/>
        }<br/>
        LOG.error("Failed to remove comment from model element");<br/>
        throw new IllegalArgumentException();<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a dependency from a model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param dep is the dependency<br/>
     */<br/>
    public void removeClientDependency(Object handle, Object dep) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; dep instanceof MDependency) {<br/>
            ((MModelElement) handle).removeClientDependency((MDependency) dep);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException();<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove the given constraint from a given ModelElement.<br/>
     *<br/>
     * @param handle ModelElement<br/>
     * @param cons Constraint<br/>
     */<br/>
    public void removeConstraint(Object handle, Object cons) {<br/>
        if (handle instanceof MModelElement &amp;&amp; cons instanceof MConstraint) {<br/>
            ((MModelElement) handle).removeConstraint((MConstraint) cons);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or cons: " + cons);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes a owned model element from a namespace.<br/>
     *<br/>
     * @param handle is the name space<br/>
     * @param value is the model element<br/>
     */<br/>
    public void removeOwnedElement(Object handle, Object value) {<br/>
        if (handle instanceof MNamespace<br/>
                &amp;&amp; value instanceof MModelElement) {<br/>
            ((MNamespace) handle).removeOwnedElement((MModelElement) value);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or value: " + value);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a parameter from an operation.<br/>
     *<br/>
     * @param handle The operation.<br/>
     * @param parameter The parameter.<br/>
     */<br/>
    public void removeParameter(Object handle, Object parameter) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (handle instanceof MObjectFlowState) {<br/>
                ((MObjectFlowState) handle).removeParameter(<br/>
                        (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MEvent) {<br/>
                ((MEvent) handle).removeParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) handle).removeParameter(<br/>
                    (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MClassifier) {<br/>
                ((MClassifier) handle).removeParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or parameter: " + parameter);<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove a source flow from a model element.<br/>
     *<br/>
     * @param handle The model element.<br/>
     * @param flow The flow.<br/>
     */<br/>
    public void removeSourceFlow(Object handle, Object flow) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; flow instanceof MFlow) {<br/>
            ((MModelElement) handle).removeSourceFlow((MFlow) flow);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or flow: " + flow);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a supplier dependency to some modelelement.<br/>
     *<br/>
     * @param supplier the supplier<br/>
     * @param dependency the dependency<br/>
     */<br/>
    public void removeSupplierDependency(<br/>
            Object supplier,<br/>
            Object dependency) {<br/>
        if (supplier instanceof MModelElement<br/>
                &amp;&amp; dependency instanceof MDependency) {<br/>
            MModelElement me = (MModelElement) supplier;<br/>
            me.removeSupplierDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("supplier: " + supplier<br/>
                + " or dependency: " + dependency);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes a named tagged value from a model element, ie subsequent calls<br/>
     * to getTaggedValue will return null for name, at least until a tagged<br/>
     * value with that name has been added again.<br/>
     *<br/>
     * @param handle the model element to remove the tagged value from<br/>
     * @param name the name of the tagged value<br/>
     * @throws IllegalArgumentException if handle isn't a model element<br/>
     */<br/>
    public void removeTaggedValue(Object handle, String name) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement me = (MModelElement) handle;<br/>
            me.removeTaggedValue(name);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a target flow to a model element.<br/>
     *<br/>
     * @param handle The model element.<br/>
     * @param flow The flow to add.<br/>
     */<br/>
    public void removeTargetFlow(Object handle, Object flow) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; flow instanceof MFlow) {<br/>
            ((MModelElement) handle).removeTargetFlow((MFlow) flow);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or flow: " + flow);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds an annotated element to a comment.<br/>
     *<br/>
     * @param comment The comment to which the element is annotated<br/>
     * @param annotatedElement The element to annotate<br/>
     */<br/>
    public void addAnnotatedElement(Object comment,<br/>
            Object annotatedElement) {<br/>
        if (comment instanceof MComment<br/>
                &amp;&amp; annotatedElement instanceof MModelElement) {<br/>
            ((MComment) comment)<br/>
                .addAnnotatedElement(((MModelElement) annotatedElement));<br/>
            return;<br/>
        }<br/>
        LOG.error("Failed to link a comment to a model element");<br/>
        throw new IllegalArgumentException("comment: " + comment<br/>
                + " or annotatedElement: " + annotatedElement);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a client model element to some dependency.<br/>
     *<br/>
     * @param handle dependency.<br/>
     * @param element The model element.<br/>
     * @throws IllegalArgumentException if the handle is not a dependency<br/>
     * or the element is not a model element.<br/>
     */<br/>
    public void addClient(Object handle, Object element) {<br/>
        if (handle instanceof MDependency<br/>
                &amp;&amp; element instanceof MModelElement) {<br/>
            ((MDependency) handle).addClient((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or element: " + element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a client dependency to some modelelement.<br/>
     *<br/>
     * @param handle the modelelement<br/>
     * @param dependency the dependency<br/>
     */<br/>
    public void addClientDependency(Object handle, Object dependency) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; dependency instanceof MDependency) {<br/>
            MModelElement me = (MModelElement) handle;<br/>
            me.addClientDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or dependency: " + dependency);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a new comment to a model element.<br/>
     *<br/>
     * @param element the element to which the comment is to be added<br/>
     * @param comment the comment for the model element<br/>
     */<br/>
    public void addComment(Object element, Object comment) {<br/>
        if (element instanceof MModelElement &amp;&amp; comment instanceof MComment) {<br/>
            ((MModelElement) element).addComment((MComment) comment);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("element: " + element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add an End to a connection.<br/>
     *<br/>
     * @param handle Association or Link<br/>
     * @param connection AssociationEnd or LinkEnd<br/>
     */<br/>
    public void addConnection(Object handle, Object connection) {<br/>
        if (handle instanceof MAssociation<br/>
            &amp;&amp; connection instanceof MAssociationEnd) {<br/>
            ((MAssociation) handle).addConnection((MAssociationEnd) connection);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MLink<br/>
            &amp;&amp; connection instanceof MLinkEnd) {<br/>
            ((MLink) handle).addConnection((MLinkEnd) connection);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or connection: " + connection);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a constraint to some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param mc constraint<br/>
     */<br/>
    public void addConstraint(Object handle, Object mc) {<br/>
        if (handle instanceof MModelElement &amp;&amp; mc instanceof MConstraint) {<br/>
            ((MModelElement) handle).addConstraint((MConstraint) mc);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle + " or mc: " + mc);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Component<br/>
     * @param node Node<br/>
     */<br/>
    public void addDeploymentLocation(Object handle, Object node) {<br/>
        if (handle instanceof MComponent &amp;&amp; node instanceof MNode) {<br/>
            ((MComponent) handle).addDeploymentLocation((MNode) node);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or node: " + node);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a feature to some classifier.<br/>
     *<br/>
     * @param handle classifier<br/>
     * @param index position<br/>
     * @param f feature<br/>
     */<br/>
    public void addFeature(Object handle, int index, Object f) {<br/>
        if (handle instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            if (LOG.isInfoEnabled()) {<br/>
                LOG.info("Adding the feature " + f + " at " + index);<br/>
            }<br/>
            ((MClassifier) handle).addFeature(index, (MFeature) f);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or f: " + f);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a feature to some classifier.<br/>
     *<br/>
     * @param handle classifier<br/>
     * @param f feature<br/>
     */<br/>
    public void addFeature(Object handle, Object f) {<br/>
        if (handle instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            if (LOG.isInfoEnabled()) {<br/>
                LOG.info("Adding the feature " + f);<br/>
            }<br/>
            ((MClassifier) handle).addFeature((MFeature) f);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add the given Link to the given Link or Association.<br/>
     *<br/>
     * @param handle the Link or Association<br/>
     * @param link Link<br/>
     */<br/>
    public void addLink(Object handle, Object link) {<br/>
        if (handle instanceof MAssociation &amp;&amp; link instanceof MLink) {<br/>
            ((MAssociation) handle).addLink((MLink) link);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or link: " + link);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a method to some operation and copies the op's attributes<br/>
     * to the method.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param m is the method<br/>
     */<br/>
    public void addMethod(Object handle, Object m) {<br/>
        if (handle instanceof MOperation<br/>
            &amp;&amp; m instanceof MMethod) {<br/>
            ((MMethod) m).setVisibility(((MOperation) handle).getVisibility());<br/>
            ((MMethod) m).setOwnerScope(((MOperation) handle).getOwnerScope());<br/>
            ((MOperation) handle).addMethod((MMethod) m);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle + " or m: " + m);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a model element to some namespace.<br/>
     *<br/>
     * @param handle namespace<br/>
     * @param me model element<br/>
     */<br/>
    public void addOwnedElement(Object handle, Object me) {<br/>
        if (handle instanceof MNamespace &amp;&amp; me instanceof MModelElement) {<br/>
            ((MNamespace) handle).addOwnedElement((MModelElement) me);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or me: " + me);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a Parameter to the given object at given location.<br/>
     *<br/>
     * @param handle The object that will get the Parameter:<br/>
     *               MEvent, MBehavioralFeature.<br/>
     * @param index the location<br/>
     * @param parameter Object that will be added<br/>
     */<br/>
    public void addParameter(<br/>
        Object handle,<br/>
        int index,<br/>
        Object parameter) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (handle instanceof MEvent) {<br/>
                ((MEvent) handle).addParameter(index, (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) handle).addParameter(<br/>
                        index,<br/>
                        (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or parameter: " + parameter);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a Parameter to the given object.<br/>
     *<br/>
     * @param handle The object that will get the Parameter:<br/>
     *               MObjectFlowState, MEvent, MBehavioralFeature, MClassifier.<br/>
     * @param parameter Object that will be added<br/>
     */<br/>
    public void addParameter(Object handle, Object parameter) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (handle instanceof MObjectFlowState) {<br/>
                ((MObjectFlowState) handle).addParameter(<br/>
                        (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MEvent) {<br/>
                ((MEvent) handle).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) handle).addParameter(<br/>
                    (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MClassifier) {<br/>
                ((MClassifier) handle).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or parameter: " + parameter);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a raised Signal to a Message or Operation.<br/>
     *<br/>
     * @param handle the Message or Operation<br/>
     * @param sig the Signal that is raised<br/>
     */<br/>
    public void addRaisedSignal(Object handle, Object sig) {<br/>
        if (sig instanceof MSignal) {<br/>
            if (handle instanceof MMessage) {<br/>
                ((MBehavioralFeature) handle).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MOperation) {<br/>
                ((MOperation) handle).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or sig: " + sig);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a source flow to a model element.<br/>
     *<br/>
     * @param handle The model element.<br/>
     * @param flow The flow.<br/>
     */<br/>
    public void addSourceFlow(Object handle, Object flow) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; flow instanceof MFlow) {<br/>
            ((MModelElement) handle).addSourceFlow((MFlow) flow);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or flow: " + flow);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a supplier classifier to some abstraction.<br/>
     *<br/>
     * @param handle abstraction<br/>
     * @param element supplier model element<br/>
     */<br/>
    public void addSupplier(Object handle, Object element) {<br/>
        if (handle instanceof MDependency &amp;&amp; element instanceof MModelElement) {<br/>
            ((MDependency) handle).addSupplier((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or element: " + element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a supplier dependency to some modelelement.<br/>
     *<br/>
     * @param supplier the supplier<br/>
     * @param dependency the dependency<br/>
     */<br/>
    public void addSupplierDependency(<br/>
            Object supplier,<br/>
            Object dependency) {<br/>
        if (supplier instanceof MModelElement<br/>
                &amp;&amp; dependency instanceof MDependency) {<br/>
            MModelElement me = (MModelElement) supplier;<br/>
            me.addSupplierDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("supplier: " + supplier<br/>
                + " or dependency: " + dependency);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a TaggedValue to a ModelElement.<br/>
     *<br/>
     * @param handle ModelElement<br/>
     * @param taggedValue TaggedValue<br/>
     */<br/>
    public void addTaggedValue(Object handle, Object taggedValue) {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsmodel.getExtensionMechanismsHelper().addTaggedValue(handle,taggedValue);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a target flow to a model element.<br/>
     *<br/>
     * @param handle The model element.<br/>
     * @param flow The flow to add.<br/>
     */<br/>
    public void addTargetFlow(Object handle, Object flow) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; flow instanceof MFlow) {<br/>
            ((MModelElement) handle).addTargetFlow((MFlow) flow);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or flow: " + flow);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if some model element is abstract.<br/>
     *<br/>
     * @see org.argouml.model.CoreHelper#setAbstract(Object, boolean)<br/>
     * @param handle is the classifier<br/>
     * @param flag is true if it should be abstract<br/>
     */<br/>
    public void setAbstract(Object handle, boolean flag) {<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) handle).setAbstract(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            ((MOperation) handle).setAbstract(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setAbstarct(flag);<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes a Class active.<br/>
     *<br/>
     * @param handle Class<br/>
     * @param active boolean<br/>
     */<br/>
    public void setActive(Object handle, boolean active) {<br/>
        if (handle instanceof MClass) {<br/>
            ((MClass) handle).setActive(active);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the aggregation of some model element.<br/>
     *<br/>
     * @param handle the model element to set aggregation<br/>
     * @param aggregationKind the aggregation kind<br/>
     */<br/>
    public void setAggregation(Object handle, Object aggregationKind) {<br/>
        if (handle instanceof MAssociationEnd<br/>
            &amp;&amp; aggregationKind instanceof MAggregationKind) {<br/>
            ((MAssociationEnd) handle).setAggregation(<br/>
                (MAggregationKind) aggregationKind);<br/>
                return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or aggregationKind: " + aggregationKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the list of annotated elements of the given comment.<br/>
     *<br/>
     * @param handle the given comment<br/>
     * @param elems the list of annotated modelelements<br/>
     */<br/>
    public void setAnnotatedElements(Object handle, Collection elems) {<br/>
        if (handle instanceof MComment<br/>
            &amp;&amp; elems instanceof List) {<br/>
            ((MComment) handle).setAnnotatedElements(elems);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the association of some model element.<br/>
     *<br/>
     * @param handle the model element to set association<br/>
     * @param association is the association<br/>
     */<br/>
    public void setAssociation(Object handle, Object association) {<br/>
        if (association instanceof MAssociation) {<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setAssociation(<br/>
                    (MAssociation) association);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MLink) {<br/>
                ((MLink) handle).setAssociation((MAssociation) association);<br/>
                return;<br/>
            }<br/>
        } else if (association instanceof MAssociationRole) {<br/>
            if (handle instanceof MAssociationEndRole) {<br/>
                ((MAssociationEndRole) handle).setAssociation(<br/>
                        (MAssociationRole) association);<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or association: " + association);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if some model element is a leaf.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a leaf.<br/>
     */<br/>
    public void setLeaf(Object handle, boolean flag) {<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            ((MOperation) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the raised signals of some behavioural feature.<br/>
     *<br/>
     * @param handle the behavioural feature<br/>
     * @param raisedSignals the raised signals<br/>
     */<br/>
    public void setRaisedSignals(<br/>
        Object handle,<br/>
        Collection raisedSignals) {<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) handle).setRaisedSignals(raisedSignals);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @see org.argouml.model.CoreHelper#setBody(<br/>
     *         java.lang.Object, java.lang.Object)<br/>
     */<br/>
    public void setBody(Object handle, Object expr) {<br/>
        if (handle instanceof MMethod<br/>
            &amp;&amp; (expr == null || expr instanceof MProcedureExpression)) {<br/>
            ((MMethod) handle).setBody((MProcedureExpression) expr);<br/>
            return;<br/>
        }<br/>
<br/>
        if (handle instanceof MConstraint<br/>
            &amp;&amp; (expr == null || expr instanceof MBooleanExpression)) {<br/>
            ((MConstraint) handle).setBody((MBooleanExpression) expr);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or expr: " + expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Changeability of a StructuralFeature or AssociationEnd.<br/>
     *<br/>
     * @param handle StructuralFeature or AssociationEnd<br/>
     * @param ck ChangeableKind<br/>
     */<br/>
    public void setChangeability(Object handle, Object ck) {<br/>
        if (ck == null || ck instanceof MChangeableKind) {<br/>
            MChangeableKind changeableKind = (MChangeableKind) ck;<br/>
<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or ck: " + ck);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the changeability of some feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @param flag is the changeability flag<br/>
     */<br/>
    public void setChangeable(Object handle, boolean flag) {<br/>
        // TODO: the implementation is ugly, because I have no spec<br/>
        // at hand...<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            if (flag) {<br/>
                ((MStructuralFeature) handle).setChangeability(<br/>
                    MChangeableKind.CHANGEABLE);<br/>
                    return;<br/>
            } <br/>
            ((MStructuralFeature) handle).setChangeability(<br/>
                    MChangeableKind.FROZEN);<br/>
            return;<br/>
        } else if (handle instanceof MAssociationEnd) {<br/>
            MAssociationEnd ae = (MAssociationEnd) handle;<br/>
            if (flag) {<br/>
                ae.setChangeability(MChangeableKind.CHANGEABLE);<br/>
            } else {<br/>
                ae.setChangeability(MChangeableKind.FROZEN);<br/>
            }<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the child for a generalization.<br/>
     *<br/>
     * @param handle Generalization<br/>
     * @param child GeneralizableElement<br/>
     */<br/>
    public void setChild(Object handle, Object child) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            ((MGeneralization) handle).setChild((MGeneralizableElement) child);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or child: " + child);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the concurrency of some operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param concurrencyKind is the concurrency<br/>
     */<br/>
    public void setConcurrency(<br/>
        Object handle,<br/>
        Object concurrencyKind) {<br/>
        if (handle instanceof MOperation<br/>
            &amp;&amp; concurrencyKind instanceof MCallConcurrencyKind) {<br/>
            ((MOperation) handle).setConcurrency(<br/>
                (MCallConcurrencyKind) concurrencyKind);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or concurrencyKind: " + concurrencyKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the list of connections of the given association or link.<br/>
     *<br/>
     * @param handle the given association or link<br/>
     * @param elems the list of association-ends or link-ends<br/>
     */<br/>
    public void setConnections(Object handle, Collection elems) {<br/>
        if (handle instanceof MAssociation &amp;&amp; elems instanceof List) {<br/>
            ((MAssociation) handle).setConnections((List) elems);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MLink &amp;&amp; elems instanceof List) {<br/>
            ((MLink) handle).setConnections(elems);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a default value of some parameter.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param expr is the expression<br/>
     */<br/>
    public void setDefaultValue(Object handle, Object expr) {<br/>
        if (handle instanceof MParameter &amp;&amp; expr instanceof MExpression) {<br/>
            ((MParameter) handle).setDefaultValue((MExpression) expr);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or expr: " + expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle a generalization<br/>
     * @param discriminator the discriminator to set<br/>
     */<br/>
    public void setDiscriminator(Object handle, String discriminator) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            ((MGeneralization) handle).setDiscriminator(discriminator);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the feature at the given position.<br/>
     *<br/>
     * @param elem The classifier to set.<br/>
     * @param i The position. Start with 0.<br/>
     * @param impl The feature to set.<br/>
     */<br/>
    public void setFeature(Object elem, int i, Object impl) {<br/>
        if (elem instanceof MClassifier &amp;&amp; impl instanceof MFeature) {<br/>
            if (LOG.isInfoEnabled()) {<br/>
                LOG.info("Setting the feature " + impl + " at " + i);<br/>
            }<br/>
            ((MClassifier) elem).setFeature(i, (MFeature) impl);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("elem: " + elem<br/>
                + " or impl: " + impl);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the features of some model element.<br/>
     *<br/>
     * @param handle the model element to set features to<br/>
     * @param features the features<br/>
     */<br/>
    public void setFeatures(Object handle, Collection features) {<br/>
        if (handle instanceof MClassifier) {<br/>
            LOG.info("Setting the features collection");<br/>
            List featuresList = null;<br/>
            if (features instanceof List) {<br/>
                featuresList = (List) features;<br/>
            } else {<br/>
                featuresList = new ArrayList(features);<br/>
            }<br/>
            ((MClassifier) handle).setFeatures(featuresList);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the ImplementationLocation of the given ElementResidence<br/>
     * to the given Component.<br/>
     *<br/>
     * @param handle the ElementResidence<br/>
     * @param component the Component<br/>
     * @deprecated UML 1.3 only see setContainer<br/>
     */<br/>
    public void setImplementationLocation(Object handle, Object component) {<br/>
        setContainer(handle, component);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Container of the given ElementResidence to the given Component.<br/>
     *<br/>
     * @param handle<br/>
     *            the ElementResidence<br/>
     * @param component<br/>
     *            the Component<br/>
     */<br/>
    public void setContainer(<br/>
        Object handle,<br/>
        Object component) {<br/>
        if (handle instanceof MElementResidence<br/>
                &amp;&amp; (component == null || component instanceof MComponent)) {<br/>
            ((MElementResidence) handle).setImplementationLocation(<br/>
                (MComponent) component);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or component: " + component);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets an initial value.<br/>
     *<br/>
     * @param at attribute that we set the initial value of<br/>
     * @param expr that is the value to set. Can be &lt;code&gt;null&lt;/code&gt;.<br/>
     */<br/>
    public void setInitialValue(Object at, Object expr) {<br/>
        if (at instanceof MAttribute<br/>
                &amp;&amp; (expr == null || expr instanceof MExpression)) {<br/>
            ((MAttribute) at).setInitialValue((MExpression) expr);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("at: " + at + " or expr: " + expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param kind is the directionkind<br/>
     */<br/>
    public void setKind(Object handle, Object kind) {<br/>
        if (handle instanceof MParameter<br/>
            &amp;&amp; kind instanceof MParameterDirectionKind) {<br/>
            ((MParameter) handle).setKind((MParameterDirectionKind) kind);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MPseudostate<br/>
            &amp;&amp; kind instanceof MPseudostateKind) {<br/>
            ((MPseudostate) handle).setKind((MPseudostateKind) kind);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or kind: " + kind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'in'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public void setKindToIn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            ((MParameter) handle).setKind(MParameterDirectionKind.IN);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'in/out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public void setKindToInOut(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            ((MParameter) handle).setKind(MParameterDirectionKind.INOUT);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public void setKindToOut(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            ((MParameter) handle).setKind(MParameterDirectionKind.OUT);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'return'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public void setKindToReturn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            ((MParameter) handle).setKind(MParameterDirectionKind.RETURN);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the container that owns the handle. This must be set<br/>
     * correctly so every modelelement except the root model does have<br/>
     * an owner. Otherwise the saving/loading will fail.&lt;p&gt;<br/>
     *<br/>
     * &lt;em&gt;Warning: when changing the implementation of this method<br/>
     * be warned that the sequence of the if then else tree DOES<br/>
     * matter.&lt;/em&gt; Most notabely, do not move the setNamespace method<br/>
     * any level up in the tree.&lt;p&gt;<br/>
     *<br/>
     * &lt;em&gt;Warning: the implementation does not support setting the<br/>
     * owner of actions.&lt;/em&gt; Use setState1 etc. on action for that<br/>
     * goal&lt;p&gt;<br/>
     *<br/>
     * @param handle The modelelement that must be added to the container<br/>
     * @param container The owning modelelement<br/>
     * @exception IllegalArgumentException when the handle or<br/>
     * container is null or if the handle cannot be added to the<br/>
     * container.<br/>
     */<br/>
    public void setModelElementContainer(<br/>
        Object handle,<br/>
        Object container) {<br/>
        if (handle instanceof MPartition<br/>
            &amp;&amp; container instanceof MActivityGraph) {<br/>
            ((MPartition) handle).setActivityGraph((MActivityGraph) container);<br/>
        } else if (handle instanceof MModelElement<br/>
                &amp;&amp; container instanceof MPartition) {<br/>
            ((MPartition) container).addContents((MModelElement) handle);<br/>
        } else if (<br/>
            handle instanceof MConstraint<br/>
                &amp;&amp; container instanceof MStereotype) {<br/>
            MConstraint c = (MConstraint) handle;<br/>
            c.setConstrainedElement2((MStereotype) container);<br/>
        } else if (<br/>
            handle instanceof MInteraction<br/>
                &amp;&amp; container instanceof MCollaboration) {<br/>
            ((MInteraction) handle).setContext((MCollaboration) container);<br/>
        } else if (<br/>
            handle instanceof MElementResidence<br/>
                &amp;&amp; container instanceof MComponent) {<br/>
            MElementResidence er = (MElementResidence) handle;<br/>
            er.setImplementationLocation((MComponent) container);<br/>
        } else if (<br/>
            handle instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MInstance) {<br/>
            ((MAttributeLink) handle).setInstance((MInstance) container);<br/>
        } else if (<br/>
            handle instanceof MMessage &amp;&amp; container instanceof MInteraction) {<br/>
            ((MMessage) handle).setInteraction((MInteraction) container);<br/>
        } else if (handle instanceof MLinkEnd &amp;&amp; container instanceof MLink) {<br/>
            ((MLinkEnd) handle).setLink((MLink) container);<br/>
        } else if (<br/>
            handle instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MLinkEnd) {<br/>
            ((MAttributeLink) handle).setLinkEnd((MLinkEnd) container);<br/>
        } else if (<br/>
            handle instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MStereotype) {<br/>
            ((MTaggedValue) handle).setStereotype((MStereotype) container);<br/>
        } else if (<br/>
            handle instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MModelElement) {<br/>
            ((MTaggedValue) handle).setModelElement((MModelElement) container);<br/>
        } else if (<br/>
            handle instanceof MStateVertex<br/>
                &amp;&amp; container instanceof MCompositeState) {<br/>
            ((MStateVertex) handle).setContainer((MCompositeState) container);<br/>
        } else if (<br/>
            handle instanceof MElementImport<br/>
                &amp;&amp; container instanceof MPackage) {<br/>
            ((MElementImport) handle).setPackage((MPackage) container);<br/>
        } else if (<br/>
            handle instanceof MTransition &amp;&amp; container instanceof MState) {<br/>
            ((MTransition) handle).setState((MState) container);<br/>
        } else if (<br/>
            handle instanceof MState &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MState) handle).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            handle instanceof MTransition<br/>
                &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MTransition) handle).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            handle instanceof MAction &amp;&amp; container instanceof MTransition) {<br/>
            ((MAction) handle).setTransition((MTransition) container);<br/>
        } else if (<br/>
            handle instanceof MGuard &amp;&amp; container instanceof MTransition) {<br/>
            ((MGuard) handle).setTransition((MTransition) container);<br/>
        } else if (<br/>
            handle instanceof MModelElement<br/>
                &amp;&amp; container instanceof MNamespace) {<br/>
            ((MModelElement) handle).setNamespace((MNamespace) container);<br/>
        } else {<br/>
            throw new IllegalArgumentException("handle: " + handle<br/>
                    + " or container: " + container);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a multiplicity of some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param arg multiplicity as string OR multiplicity object<br/>
     */<br/>
    public void setMultiplicity(Object handle, Object arg) {<br/>
        if (arg instanceof String) {<br/>
            arg =<br/>
                ("1_N".equals(arg)) ? MMultiplicity.M1_N : MMultiplicity.M1_1;<br/>
        }<br/>
<br/>
        if (arg instanceof MMultiplicity) {<br/>
            MMultiplicity mult = (MMultiplicity) arg;<br/>
<br/>
            if (handle instanceof MAssociationRole) {<br/>
                ((MAssociationRole) handle).setMultiplicity(mult);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MClassifierRole) {<br/>
                ((MClassifierRole) handle).setMultiplicity(mult);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setMultiplicity(mult);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setMultiplicity(mult);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or arg: " + arg);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a name of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param name to set<br/>
     */<br/>
    public void setName(Object handle, String name) {<br/>
        if ((handle instanceof MModelElement) &amp;&amp; (name != null)) {<br/>
            // The following code is a workaround for issue<br/>
            // http://argouml.tigris.org/issues/show_bug.cgi?id=2847.<br/>
            // The cause is<br/>
            // not known and the best fix available for the moment is to remove<br/>
            // the corruptions as they are found.<br/>
<br/>
            int pos = 0;<br/>
            while ((pos = name.indexOf(0xffff)) &gt;= 0) {<br/>
                name =<br/>
                    name.substring(0, pos)<br/>
                    + name.substring(pos + 1, name.length());<br/>
                try {<br/>
                    throw new UmlException(<br/>
                            "Illegal character stripped out of element name");<br/>
                } catch (UmlException e) {<br/>
                    LOG.warn("0xFFFF detected in element name", e);<br/>
                }<br/>
            }<br/>
            final String safeName = name;<br/>
            <br/>
            final MModelElement modelElement = (MModelElement) handle;<br/>
<br/>
            Model.notifyMementoCreationObserver(<br/>
                new ModelMemento() {<br/>
                    String oldName = modelElement.getName();<br/>
                    public void undo() {<br/>
                        modelElement.setName(oldName);<br/>
                    }<br/>
                    public void redo() {<br/>
                        modelElement.setName(safeName);<br/>
                    }<br/>
                }<br/>
            );<br/>
            modelElement.setName(safeName);<br/>
<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or name: " + name);<br/>
    }<br/>
<br/>
    /**<br/>
     * @see org.argouml.model.CoreHelper#setBody(<br/>
     *         java.lang.Object, java.lang.String)<br/>
     */<br/>
    public void setBody(Object handle, String body) {<br/>
        if ((handle instanceof MComment) &amp;&amp; (body != null)) {<br/>
            //in UML 1.3 we store it in the name:<br/>
            ((MComment) handle).setName(body);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a namespace of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param ns is the namespace. Can be &lt;code&gt;null&lt;/code&gt;.<br/>
     */<br/>
    public void setNamespace(Object handle, Object ns) {<br/>
        if (handle instanceof MModelElement<br/>
            &amp;&amp; (ns == null || ns instanceof MNamespace)) {<br/>
            ((MModelElement) handle).setNamespace((MNamespace) ns);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or ns: " + ns);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the navigability of some association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @param flag is the navigability flag<br/>
     */<br/>
    public void setNavigable(Object handle, boolean flag) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) handle).setNavigable(flag);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the OrderingKind of a given AssociationEnd.<br/>
     *<br/>
     * @param handle AssociationEnd<br/>
     * @param ok OrderingKind<br/>
     */<br/>
    public void setOrdering(Object handle, Object ok) {<br/>
        if (handle instanceof MAssociationEnd &amp;&amp; ok instanceof MOrderingKind) {<br/>
            ((MAssociationEnd) handle).setOrdering((MOrderingKind) ok);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or ok: " + ok);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the owner of a Feature.<br/>
     *<br/>
     * @param handle Feature<br/>
     * @param owner Classifier or null<br/>
     */<br/>
    public void setOwner(Object handle, Object owner) {<br/>
        if (handle instanceof MFeature<br/>
            &amp;&amp; (owner == null || owner instanceof MClassifier)) {<br/>
            ((MFeature) handle).setOwner((MClassifier) owner);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or owner: " + owner);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Feature<br/>
     * @param os ScopeKind<br/>
     */<br/>
    public void setOwnerScope(Object handle, Object os) {<br/>
        if (handle instanceof MFeature<br/>
            &amp;&amp; (os == null || os instanceof MScopeKind)) {<br/>
            ((MFeature) handle).setOwnerScope((MScopeKind) os);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or os: " + os);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the parameters of a classifier, event, objectflowstate or<br/>
     * behavioralfeature.<br/>
     *<br/>
     * @param handle the classifier, event, objectflowstate or<br/>
     * behavioralfeature<br/>
     * @param parameters is a Collection of parameters<br/>
     */<br/>
    public void setParameters(Object handle, Collection parameters) {<br/>
        if (handle instanceof MObjectFlowState) {<br/>
            ((MObjectFlowState) handle).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            ((MClassifier) handle).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MEvent &amp;&amp; parameters instanceof List) {<br/>
            ((MEvent) handle).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MBehavioralFeature<br/>
            &amp;&amp; parameters instanceof List) {<br/>
            ((MBehavioralFeature) handle).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or parameters: " + parameters);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the parent of a generalization.<br/>
     *<br/>
     * @param handle generalization<br/>
     * @param parent generalizable element (parent)<br/>
     */<br/>
    public void setParent(Object handle, Object parent) {<br/>
        if (handle instanceof MGeneralization<br/>
            &amp;&amp; parent instanceof MGeneralizableElement) {<br/>
            ((MGeneralization) handle).setParent(<br/>
                (MGeneralizableElement) parent);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or parent: " + parent);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the PowerType of a Generalization.<br/>
     * @param handle Generalization<br/>
     * @param pt Classifier<br/>
     */<br/>
    public void setPowertype(Object handle, Object pt) {<br/>
        if (handle instanceof MGeneralization<br/>
                &amp;&amp; (pt == null<br/>
                        || pt instanceof MClassifier)) {<br/>
            ((MGeneralization) handle).setPowertype((MClassifier) pt);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or pt: " + pt);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the qualified attributes of an association end.<br/>
     *<br/>
     * @param handle the association end<br/>
     * @param elems is a Collection of qualifiers<br/>
     */<br/>
    public void setQualifiers(Object handle, Collection elems) {<br/>
        if (handle instanceof MAssociationEnd &amp;&amp; elems instanceof List) {<br/>
            ((MAssociationEnd) handle).setQualifiers((List) elems);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the query flag of a behavioral feature.<br/>
     *<br/>
     * @param handle is the behavioral feature<br/>
     * @param flag is the query flag<br/>
     */<br/>
    public void setQuery(Object handle, boolean flag) {<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) handle).setQuery(flag);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle ElementResidence<br/>
     * @param resident ModelElement or null<br/>
     */<br/>
    public void setResident(Object handle, Object resident) {<br/>
        if (handle instanceof MElementResidence<br/>
            &amp;&amp; (resident == null || resident instanceof MModelElement)) {<br/>
            ((MElementResidence) handle).setResident((MModelElement) resident);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or resident: " + resident);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the residents of some model element.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param residents collection<br/>
     */<br/>
    public void setResidents(Object handle, Collection residents) {<br/>
        if (handle instanceof MNodeInstance) {<br/>
            ((MNodeInstance) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MComponentInstance) {<br/>
            ((MComponentInstance) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MNode) {<br/>
            ((MNode) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if some model element is a root.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a root<br/>
     */<br/>
    public void setRoot(Object handle, boolean flag) {<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            ((MOperation) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Flow<br/>
     * @param specifications the collection of ModelEvents (sourceFlow)<br/>
     */<br/>
    public void setSources(Object handle, Collection specifications) {<br/>
        if (handle instanceof MFlow) {<br/>
            ((MFlow) handle).setSources(specifications);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Specification flag for a ModelElement.<br/>
     *<br/>
     * @param handle ModelElement<br/>
     * @param specification boolean<br/>
     */<br/>
    public void setSpecification(Object handle, boolean specification) {<br/>
        if (handle instanceof MModelElement) {<br/>
            ((MModelElement) handle).setSpecification(specification);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the specifications of some association end.<br/>
     *<br/>
     * @param handle the association end<br/>
     * @param specifications collection<br/>
     */<br/>
    public void setSpecifications(<br/>
        Object handle,<br/>
        Collection specifications) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) handle).setSpecifications(specifications);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the stereotype of some modelelement. The method also<br/>
     * copies a stereotype that is not a part of the current model to<br/>
     * the current model.&lt;p&gt;<br/>
     *<br/>
     * TODO: Currently does not copy the stereotype, but changes the<br/>
     * namespace to the new model (kidnapping it). That might possibly be<br/>
     * dangerous, especially if more complex profile models are developed.<br/>
     * This documentation should say what is supposed to be done. I think<br/>
     * it would have been better if the caller had been responsible for the<br/>
     * stereotype being in the right model and been adviced of<br/>
     * eg ModelManagementHelper.getCorrespondingElement(...). Or if that had<br/>
     * been used here. This function could possibly assert that the caller had<br/>
     * got it right.<br/>
     *<br/>
     * TODO: For moving towards future version of UML we should instead<br/>
     * have addStereotype and removeStereotype.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param stereo stereotype<br/>
     */<br/>
    public void setStereotype(Object handle, Object stereo) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; (stereo instanceof MStereotype || stereo == null)) {<br/>
<br/>
            MModelElement me = (MModelElement) handle;<br/>
            MStereotype stereotype = (MStereotype) stereo;<br/>
<br/>
            MStereotype existingStereotype = me.getStereotype();<br/>
<br/>
            if (LOG.isInfoEnabled()) {<br/>
                if (existingStereotype == null) {<br/>
                    LOG.info("About to give a stereotype to " + handle);<br/>
                } else {<br/>
                    LOG.info("About to change stereotype on " + handle<br/>
                            + " to &lt;&lt;" + existingStereotype.getName() + "&gt;&gt;");<br/>
                }<br/>
            }<br/>
<br/>
            if (existingStereotype == stereotype) {<br/>
                LOG.info("Stereotype is already set. Do nothing.");<br/>
                return;<br/>
            }<br/>
<br/>
            if (LOG.isInfoEnabled()) {<br/>
                if (stereotype == null) {<br/>
                    LOG.info("Removing any stereotype on " + handle);<br/>
                } else {<br/>
                    LOG.info("Setting the stereotype on " + handle<br/>
                            + " to &lt;&lt;" + stereotype.getName() + "&gt;&gt;");<br/>
                }<br/>
            }<br/>
<br/>
            // With this block in place save fails with an error<br/>
            // With this block removed save appears to work but<br/>
            // the save file does not record the stereotype<br/>
            if (stereotype != null &amp;&amp; me.getModel() != stereotype.getModel()) {<br/>
                if (LOG.isInfoEnabled()) {<br/>
                    LOG.info("Changing the stereotype namespace from "<br/>
                            + stereotype.getModel() + " to " + me.getModel());<br/>
                }<br/>
                stereotype.setNamespace(me.getModel());<br/>
            }<br/>
<br/>
            me.setStereotype(stereotype);<br/>
<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or stereo: " + stereo);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a tagged value of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param tag is the tag name (a string)<br/>
     * @param value is the value<br/>
     */<br/>
    public void setTaggedValue(<br/>
        Object handle,<br/>
        String tag,<br/>
        String value) {<br/>
        if (handle instanceof MModelElement) {<br/>
            ((MModelElement) handle).setTaggedValue(tag, value);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the TaggedValues of a ModelElement.<br/>
     *<br/>
     * @param handle ModelElement<br/>
     * @param taggedValues Collection of TaggedValues<br/>
     */<br/>
    public void setTaggedValues(<br/>
        Object handle,<br/>
        Collection taggedValues) {<br/>
        if (handle instanceof MModelElement) {<br/>
            ((MModelElement) handle).setTaggedValues(taggedValues);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the target scope of some association end or structural feature.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param scopeKind the target scope<br/>
     */<br/>
    public void setTargetScope(Object handle, Object scopeKind) {<br/>
        if (scopeKind instanceof MScopeKind) {<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setTargetScope(<br/>
                    (MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle)<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;.setTargetScope((MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or scopeKind: " + scopeKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the type of some parameter.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param type is the type (a classifier)<br/>
     */<br/>
    public void setType(Object handle, Object type) {<br/>
        if (type == null || type instanceof MClassifier) {<br/>
            if (handle instanceof MObjectFlowState) {<br/>
                ((MObjectFlowState) handle).setType((MClassifier) type);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MClassifierInState) {<br/>
                ((MClassifierInState) handle).setType((MClassifier) type);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MParameter) {<br/>
                ((MParameter) handle).setType((MClassifier) type);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setType((MClassifier) type);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setType((MClassifier) type);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or type: " + type);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the UUID of this element.<br/>
     *<br/>
     * @param handle base element (MBase type)<br/>
     * @param uuid is the UUID<br/>
     */<br/>
    public void setUUID(Object handle, String uuid) {<br/>
        if (handle instanceof MBase) {<br/>
            ((MBase) handle).setUUID(uuid);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the visibility of some modelelement.<br/>
     *<br/>
     * @param handle element<br/>
     * @param visibility is the visibility<br/>
     */<br/>
    public void setVisibility(Object handle, Object visibility) {<br/>
        if (visibility instanceof MVisibilityKind) {<br/>
            if (handle instanceof MModelElement) {<br/>
                ((MModelElement) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MElementResidence) {<br/>
                ((MElementResidence) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
            if (handle instanceof MElementImport) {<br/>
                ((MElementImport) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or visibility: " + visibility);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Component<br/>
     * @param node Node<br/>
     */<br/>
    public void removeDeploymentLocation(Object handle, Object node) {<br/>
        if (handle instanceof MComponent &amp;&amp; node instanceof MNode) {<br/>
            ((MComponent) handle).removeDeploymentLocation((MNode) node);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or node: " + node);<br/>
    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/* (non-Javadoc)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * @see org.argouml.model.CoreHelper#addElementResidence(java.lang.Object, java.lang.Object)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; */<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public void addElementResidence(Object handle, Object residence) {<br/>
        if (handle instanceof MModelElement &amp;&amp; residence instanceof MElementResidence) {<br/>
            ((MModelElement) handle).addElementResidence((MElementResidence) residence);<br/>
            return;<br/>
        }&nbsp;&nbsp;&nbsp;&nbsp;<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or residence: " + residence);        <br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/* (non-Javadoc)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * @see org.argouml.model.CoreHelper#removeConnection(java.lang.Object, java.lang.Object)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; */<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public void removeConnection(Object handle, Object connection) {<br/>
        if (handle instanceof MAssociationRole &amp;&amp; connection instanceof MAssociationEnd) {<br/>
            ((MAssociationRole) handle).removeConnection((MAssociationEnd) connection);<br/>
            return;<br/>
        }&nbsp;&nbsp;&nbsp;&nbsp;<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or connection: " + connection);        <br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/* (non-Javadoc)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * @see org.argouml.model.CoreHelper#removeElementResidence(java.lang.Object, java.lang.Object)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; */<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public void removeElementResidence(Object handle, Object residence) {<br/>
        if (handle instanceof MModelElement &amp;&amp; residence instanceof MElementResidence) {<br/>
            ((MModelElement) handle).removeElementResidence((MElementResidence) residence);<br/>
            return;<br/>
        }&nbsp;&nbsp;&nbsp;&nbsp;<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or residence: " + residence);        <br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
    /**<br/>
     * @see org.argouml.model.CoreHelper#addStereotype(java.lang.Object, java.lang.Object)<br/>
     */<br/>
    public void addStereotype(Object modelElement, Object stereo) {<br/>
        // This will never be implemented in NSUML<br/>
    }<br/>
<br/>
    /**<br/>
     * @see org.argouml.model.CoreHelper#removeStereotype(java.lang.Object, java.lang.Object)<br/>
     */<br/>
    public void removeStereotype(Object handle, Object stereo) {<br/>
        // This will never be implemented in NSUML<br/>
    }<br/>
}<br/>
</div>
</div>
</div>
<div class="right">
<h1>right_CoreHelperImpl_1.30.java</h1>
<div class="code">
<div class="id">
// $Id: CoreHelperImpl.java,v 1.30 2005-10-16 08:33:12 rastaman Exp $<br/>
// Copyright (c) 1996-2005 The Regents of the University of California. All<br/>
// Rights Reserved. Permission to use, copy, modify, and distribute this<br/>
// software and its documentation without fee, and without a written<br/>
// agreement is hereby granted, provided that the above copyright notice<br/>
// and this paragraph appear in all copies.  This software program and<br/>
// documentation are copyrighted by The Regents of the University of<br/>
// California. The software program and documentation are supplied "AS<br/>
// IS", without any accompanying services from The Regents. The Regents<br/>
// does not warrant that the operation of the program will be<br/>
// uninterrupted or error-free. The end-user understands that the program<br/>
// was developed for research purposes and is advised not to rely<br/>
// exclusively on the program for any reason.  IN NO EVENT SHALL THE<br/>
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,<br/>
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,<br/>
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF<br/>
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF<br/>
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY<br/>
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF<br/>
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE<br/>
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF<br/>
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,<br/>
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.<br/>
<br/>
package org.argouml.model.uml;<br/>
<br/>
import java.util.ArrayList;<br/>
import java.util.Collection;<br/>
import java.util.HashSet;<br/>
import java.util.Iterator;<br/>
import java.util.List;<br/>
import java.util.Set;<br/>
import java.util.Vector;<br/>
<br/>
import org.apache.log4j.Logger;<br/>
import org.argouml.model.CoreHelper;<br/>
import org.argouml.model.Model;<br/>
import org.argouml.model.ModelMemento;<br/>
import org.argouml.model.UmlException;<br/>
import org.argouml.util.CollectionUtil;<br/>
<br/>
import ru.novosoft.uml.MBase;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MActivityGraph;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MClassifierInState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MObjectFlowState;<br/>
import ru.novosoft.uml.behavior.activity_graphs.MPartition;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationEndRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MAssociationRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MClassifierRole;<br/>
import ru.novosoft.uml.behavior.collaborations.MCollaboration;<br/>
import ru.novosoft.uml.behavior.collaborations.MInteraction;<br/>
import ru.novosoft.uml.behavior.collaborations.MMessage;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAction;<br/>
import ru.novosoft.uml.behavior.common_behavior.MAttributeLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MComponentInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLink;<br/>
import ru.novosoft.uml.behavior.common_behavior.MLinkEnd;<br/>
import ru.novosoft.uml.behavior.common_behavior.MNodeInstance;<br/>
import ru.novosoft.uml.behavior.common_behavior.MReception;<br/>
import ru.novosoft.uml.behavior.common_behavior.MSignal;<br/>
import ru.novosoft.uml.behavior.state_machines.MCompositeState;<br/>
import ru.novosoft.uml.behavior.state_machines.MEvent;<br/>
import ru.novosoft.uml.behavior.state_machines.MGuard;<br/>
import ru.novosoft.uml.behavior.state_machines.MPseudostate;<br/>
import ru.novosoft.uml.behavior.state_machines.MState;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateMachine;<br/>
import ru.novosoft.uml.behavior.state_machines.MStateVertex;<br/>
import ru.novosoft.uml.behavior.state_machines.MTransition;<br/>
import ru.novosoft.uml.behavior.use_cases.MActor;<br/>
import ru.novosoft.uml.behavior.use_cases.MExtend;<br/>
import ru.novosoft.uml.behavior.use_cases.MInclude;<br/>
import ru.novosoft.uml.behavior.use_cases.MUseCase;<br/>
import ru.novosoft.uml.foundation.core.MAbstraction;<br/>
import ru.novosoft.uml.foundation.core.MAssociation;<br/>
import ru.novosoft.uml.foundation.core.MAssociationEnd;<br/>
import ru.novosoft.uml.foundation.core.MAttribute;<br/>
import ru.novosoft.uml.foundation.core.MBehavioralFeature;<br/>
import ru.novosoft.uml.foundation.core.MClass;<br/>
import ru.novosoft.uml.foundation.core.MClassifier;<br/>
import ru.novosoft.uml.foundation.core.MComment;<br/>
import ru.novosoft.uml.foundation.core.MComponent;<br/>
import ru.novosoft.uml.foundation.core.MConstraint;<br/>
import ru.novosoft.uml.foundation.core.MDataType;<br/>
import ru.novosoft.uml.foundation.core.MDependency;<br/>
import ru.novosoft.uml.foundation.core.MElementResidence;<br/>
import ru.novosoft.uml.foundation.core.MFeature;<br/>
import ru.novosoft.uml.foundation.core.MFlow;<br/>
import ru.novosoft.uml.foundation.core.MGeneralizableElement;<br/>
import ru.novosoft.uml.foundation.core.MGeneralization;<br/>
import ru.novosoft.uml.foundation.core.MInterface;<br/>
import ru.novosoft.uml.foundation.core.MMethod;<br/>
import ru.novosoft.uml.foundation.core.MModelElement;<br/>
import ru.novosoft.uml.foundation.core.MNamespace;<br/>
import ru.novosoft.uml.foundation.core.MNode;<br/>
import ru.novosoft.uml.foundation.core.MOperation;<br/>
import ru.novosoft.uml.foundation.core.MParameter;<br/>
import ru.novosoft.uml.foundation.core.MRelationship;<br/>
import ru.novosoft.uml.foundation.core.MStructuralFeature;<br/>
import ru.novosoft.uml.foundation.data_types.MAggregationKind;<br/>
import ru.novosoft.uml.foundation.data_types.MBooleanExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MCallConcurrencyKind;<br/>
import ru.novosoft.uml.foundation.data_types.MChangeableKind;<br/>
import ru.novosoft.uml.foundation.data_types.MExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MMultiplicity;<br/>
import ru.novosoft.uml.foundation.data_types.MOrderingKind;<br/>
import ru.novosoft.uml.foundation.data_types.MParameterDirectionKind;<br/>
import ru.novosoft.uml.foundation.data_types.MProcedureExpression;<br/>
import ru.novosoft.uml.foundation.data_types.MPseudostateKind;<br/>
import ru.novosoft.uml.foundation.data_types.MScopeKind;<br/>
import ru.novosoft.uml.foundation.data_types.MVisibilityKind;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MStereotype;<br/>
import ru.novosoft.uml.foundation.extension_mechanisms.MTaggedValue;<br/>
import ru.novosoft.uml.model_management.MElementImport;<br/>
import ru.novosoft.uml.model_management.MPackage;<br/>
<br/>
/**<br/>
 * Helper class for UML Foundation::Core Package.&lt;p&gt;<br/>
 *<br/>
 * @since ARGO0.11.2<br/>
 * @author Thierry Lach<br/>
 * @author Jaap Branderhorst<br/>
 */<br/>
class CoreHelperImpl implements CoreHelper {<br/>
    /**<br/>
     * Logger.<br/>
     */<br/>
    private static final Logger LOG = Logger.getLogger(CoreHelperImpl.class);<br/>
<br/>
    /**<br/>
     * The model implementation.<br/>
     */<br/>
    private NSUMLModelImplementation nsmodel;<br/>
<br/>
    /**<br/>
     * Don't allow instantiation.<br/>
     *<br/>
     * @param implementation To get other helpers and factories.<br/>
     */<br/>
    CoreHelperImpl(NSUMLModelImplementation implementation) {<br/>
        nsmodel = implementation;<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine if a meta type is a subtype of another.<br/>
     * @param type The parent metatype.<br/>
     * @param subType The metatype to test for being a subtype.<br/>
     * @return true is subType is a sub-type of type.<br/>
     */<br/>
    public boolean isSubType(Object type, Object subType) {<br/>
        if (!(type instanceof Class) || !(subType instanceof Class)) {<br/>
            throw new IllegalArgumentException("Metatypes are expected");<br/>
        }<br/>
           return ((Class) type).isAssignableFrom((Class) subType);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all Classifiers of which this class is a<br/>
     * direct or indirect subtype.<br/>
     *<br/>
     * @param cls1  the class you want to have the parents for<br/>
     * @return a collection of the parents, each of which is a<br/>
     *         {@link MGeneralizableElement MGeneralizableElement}<br/>
     */<br/>
    public Collection getAllSupertypes(Object cls1) {<br/>
<br/>
        if (!(cls1 instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        MClassifier cls = (MClassifier) cls1;<br/>
<br/>
        Collection result = new HashSet();<br/>
        Collection add = getSupertypes(cls);<br/>
        do {<br/>
            Collection newAdd = new HashSet();<br/>
            Iterator addIter = add.iterator();<br/>
            while (addIter.hasNext()) {<br/>
                MGeneralizableElement next =<br/>
                    (MGeneralizableElement) addIter.next();<br/>
                if (next instanceof MClassifier) {<br/>
                    newAdd.addAll(getSupertypes(next));<br/>
                }<br/>
            }<br/>
            result.addAll(add);<br/>
            add = newAdd;<br/>
            add.removeAll(result);<br/>
        }<br/>
        while (!add.isEmpty());<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all Classifiers of which this class is a<br/>
     * direct subtype.&lt;p&gt;<br/>
     *<br/>
     * @param ogeneralizableelement the class you want to have the parents for<br/>
     * @return a collection of the parents, each of which is a<br/>
     *         {@link MGeneralizableElement MGeneralizableElement}<br/>
     */<br/>
    public Collection getSupertypes(Object ogeneralizableelement) {<br/>
        Collection result = new HashSet();<br/>
        if (ogeneralizableelement instanceof MGeneralizableElement) {<br/>
            MGeneralizableElement cls =<br/>
                (MGeneralizableElement) ogeneralizableelement;<br/>
            Collection gens = cls.getGeneralizations();<br/>
            Iterator genIterator = gens.iterator();<br/>
            while (genIterator.hasNext()) {<br/>
                MGeneralization next = (MGeneralization) genIterator.next();<br/>
                result.add(next.getParent());<br/>
            }<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all opposite AssociationEnds of a given<br/>
     * Classifier.<br/>
     *<br/>
     * @param classifier the classifier you want to have the opposite<br/>
     * association ends for<br/>
     * @return a collection of the opposite associationends<br/>
     */<br/>
    public Collection getAssociateEnds(Object classifier) {<br/>
        if (!(classifier instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Collection result = new ArrayList();<br/>
        Iterator ascends =<br/>
            ((MClassifier) classifier).getAssociationEnds().iterator();<br/>
        while (ascends.hasNext()) {<br/>
            MAssociationEnd ascend = (MAssociationEnd) ascends.next();<br/>
            if ((ascend.getOppositeEnd() != null)) {<br/>
                result.add(ascend.getOppositeEnd());<br/>
            }<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all opposite AssociationEnds of a given<br/>
     * Classifier, including inherited.<br/>
     *<br/>
     * @param classifier1 the classifier you want to have the opposite<br/>
     * association ends for<br/>
     * @return a collection of the opposite associationends<br/>
     */<br/>
    public Collection getAssociateEndsInh(Object classifier1) {<br/>
<br/>
        if (!(classifier1 instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        MClassifier classifier = (MClassifier) classifier1;<br/>
<br/>
        Collection result = new ArrayList();<br/>
        result.addAll(getAssociateEnds(classifier));<br/>
        Iterator parents = classifier.getParents().iterator();<br/>
        while (parents.hasNext()) {<br/>
            result.addAll(getAssociateEndsInh(parents.next()));<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a feature from a classifier.<br/>
     *<br/>
     * @param cls the classifier<br/>
     * @param feature the feature to be removed<br/>
     */<br/>
    public void removeFeature(Object cls, Object feature) {<br/>
        if (cls instanceof MClassifier &amp;&amp; feature instanceof MFeature) {<br/>
            if (LOG.isInfoEnabled()) {<br/>
                LOG.info("Removing the feature " + feature);<br/>
            }<br/>
            ((MClassifier) cls).removeFeature((MFeature) feature);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns the name of a feature.<br/>
     *<br/>
     * @param o is the feature<br/>
     * @return name<br/>
     */<br/>
    public String getFeatureName(Object o) {<br/>
        if (o != null &amp;&amp; o instanceof MFeature) {<br/>
            return ((MFeature) o).getName();<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns if the object is a method.<br/>
     *<br/>
     * @param o object<br/>
     * @return true if it's a method, false if not<br/>
     */<br/>
    public boolean isMethod(Object o) {<br/>
        return (o instanceof MMethod);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns if the object is an operation.<br/>
     *<br/>
     * @param o object<br/>
     * @return true if it's an operation, false if not<br/>
     */<br/>
    public boolean isOperation(Object o) {<br/>
        return (o instanceof MOperation);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all operations of a given Classifier.<br/>
     *<br/>
     * @param classifier the classifier you want to have the operations for<br/>
     * @return a collection of the operations<br/>
     */<br/>
    public Collection getOperations(Object classifier) {<br/>
        Collection result = new ArrayList();<br/>
        if (classifier instanceof MClassifier) {<br/>
            MClassifier mclassifier = (MClassifier) classifier;<br/>
            Iterator features = mclassifier.getFeatures().iterator();<br/>
            while (features.hasNext()) {<br/>
                MFeature feature = (MFeature) features.next();<br/>
                if (feature instanceof MOperation) {<br/>
                    result.add(feature);<br/>
                }<br/>
            }<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method replaces all operations of the given classifier<br/>
     * by the given collection of operations.<br/>
     *<br/>
     * @param classifier the given classifier<br/>
     * @param operations the new operations<br/>
     */<br/>
    public void setOperations(Object classifier, Collection operations) {<br/>
        if (classifier instanceof MClassifier) {<br/>
            MClassifier mclassifier = (MClassifier) classifier;<br/>
            List result = new ArrayList(mclassifier.getFeatures());<br/>
            Iterator features = mclassifier.getFeatures().iterator();<br/>
            while (features.hasNext()) {<br/>
                MFeature feature = (MFeature) features.next();<br/>
                if (feature instanceof MOperation) {<br/>
                    result.remove(feature);<br/>
                }<br/>
            }<br/>
            result.addAll(operations);<br/>
            mclassifier.setFeatures(result);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all attributes of a given Classifier.<br/>
     *<br/>
     * @param classifier the classifier you want to have the attributes for<br/>
     * @return a collection of the attributes<br/>
     */<br/>
    public Collection getAttributes(Object classifier) {<br/>
        if (!(classifier instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Collection result = new ArrayList();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Iterator features = ((MClassifier) classifier).getFeatures().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (features.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MFeature feature = (MFeature) features.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (feature instanceof MAttribute) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        result.add(feature);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method replaces all attributes of the given classifier<br/>
     * by the given collection of attributes.<br/>
     * @param classifier the classifier<br/>
     * @param attributes the new attributes<br/>
     */<br/>
    public void setAttributes(Object classifier, Collection attributes) {<br/>
        if (classifier instanceof MClassifier) {<br/>
            MClassifier mclassifier = (MClassifier) classifier;<br/>
            List result = new ArrayList(mclassifier.getFeatures());<br/>
            Iterator features = mclassifier.getFeatures().iterator();<br/>
            while (features.hasNext()) {<br/>
                MFeature feature = (MFeature) features.next();<br/>
                if (feature instanceof MAttribute) {<br/>
                    result.remove(feature);<br/>
                }<br/>
            }<br/>
            result.addAll(attributes);<br/>
            mclassifier.setFeatures(result);<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * This method returns all attributes of a given Classifier,<br/>
     * including inherited.<br/>
     *<br/>
     * @param classifier the classifier you want to have the attributes for<br/>
     * @return a collection of the attributes<br/>
     */<br/>
    public Collection getAttributesInh(Object classifier) {<br/>
<br/>
        if (!(classifier instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Collection result = new ArrayList();<br/>
        result.addAll(nsmodel.getFacade().getStructuralFeatures(classifier));<br/>
        Iterator parents = ((MClassifier) classifier).getParents().iterator();<br/>
        while (parents.hasNext()) {<br/>
            MClassifier parent = (MClassifier) parents.next();<br/>
            if (LOG.isDebugEnabled()) {<br/>
                LOG.debug("Adding attributes for: " + parent);<br/>
            }<br/>
            result.addAll(getAttributesInh(parent));<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method returns all operations of a given Classifier,<br/>
     * including inherited.<br/>
     *<br/>
     * @param classifier the classifier you want to have the operations for<br/>
     * @return a collection of the operations<br/>
     */<br/>
    public Collection getOperationsInh(Object classifier) {<br/>
        if (!(classifier instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Collection result = new ArrayList();<br/>
        result.addAll(nsmodel.getFacade().getOperations(classifier));<br/>
        Iterator parents = ((MClassifier) classifier).getParents().iterator();<br/>
        while (parents.hasNext()) {<br/>
            result.addAll(getOperationsInh(parents.next()));<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * This method finds all paramters of the given operation which<br/>
     * have the MParamterDirectionType RETURN. If it is only one, it<br/>
     * is returned.  In case there are no return parameters, null is<br/>
     * returned. If there is more than one return paramter, first of<br/>
     * them is returned, but a message is logged.&lt;p&gt;<br/>
     *<br/>
     * @param operation1 the operation you want to find the return<br/>
     * parameter for.<br/>
     * @return If this operation has only one paramter with Kind: RETURN,<br/>
     *         this is it, otherwise null<br/>
     */<br/>
    public Object getReturnParameter(Object operation1) {<br/>
<br/>
        if (!(operation1 instanceof MOperation)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        MOperation operation = (MOperation) operation1;<br/>
<br/>
        Vector returnParams = new Vector();<br/>
        Iterator params = operation.getParameters().iterator();<br/>
        while (params.hasNext()) {<br/>
            MParameter parameter = (MParameter) params.next();<br/>
            if ((parameter.getKind()).equals(MParameterDirectionKind.RETURN)) {<br/>
                returnParams.add(parameter);<br/>
            }<br/>
        }<br/>
        switch (returnParams.size()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 1 :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (MParameter) returnParams.elementAt(0);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;case 0 :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    //Next line gives too many strings while debugging<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    // obscuring other errors.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    //cat.debug("No ReturnParameter found!");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;default :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    LOG.debug(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      "More than one ReturnParameter found, returning first!");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return (MParameter) returnParams.elementAt(0);<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Returns all return parameters for an operation.<br/>
     *<br/>
     * @param operation is the operation.<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getReturnParameters(Object operation) {<br/>
        Vector returnParams = new Vector();<br/>
        Iterator params = ((MOperation) operation).getParameters().iterator();<br/>
        while (params.hasNext()) {<br/>
            MParameter parameter = (MParameter) params.next();<br/>
            if ((parameter.getKind()).equals(MParameterDirectionKind.RETURN)) {<br/>
                returnParams.add(parameter);<br/>
            }<br/>
        }<br/>
        return returnParams;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the operation that some method realized. Returns null if<br/>
     * object isn't a method or, possibly, if the method isn't properly<br/>
     * defined.<br/>
     *<br/>
     * @param object  the method you want the realized operation of.<br/>
     * @return an operation, or null.<br/>
     */<br/>
    public Object getSpecification(Object object) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!(object instanceof MMethod)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return ((MMethod) object).getSpecification();<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all Interfaces of which this class is a realization.&lt;p&gt;<br/>
     *<br/>
     * @param classifier  the class you want to have the interfaces for<br/>
     * @return a collection of the Interfaces<br/>
     */<br/>
    public Collection getSpecifications(Object classifier) {<br/>
        Collection result = new Vector();<br/>
        Collection deps = ((MClassifier) classifier).getClientDependencies();<br/>
        Iterator depIterator = deps.iterator();<br/>
        while (depIterator.hasNext()) {<br/>
            Object dep = depIterator.next();<br/>
            Object stereo = CollectionUtil.getFirstItemOrNull(<br/>
                    Model.getFacade().getStereotypes(dep));<br/>
            if ((dep instanceof MAbstraction)<br/>
                &amp;&amp; stereo != null<br/>
                &amp;&amp; nsmodel.getFacade().getName(stereo) != null<br/>
                &amp;&amp; nsmodel.getFacade().getName(stereo).equals("realize")) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object i = nsmodel.getFacade().getSuppliers(dep).toArray()[0];<br/>
                result.add(i);<br/>
            }<br/>
        }<br/>
        return result;<br/>
    }<br/>
    /**<br/>
     * This method returns all Classifiers of which this class is a<br/>
     * direct supertype.<br/>
     *<br/>
     * @param cls  the class you want to have the children for<br/>
     * @return a collection of the children, each of which is a<br/>
     *         {@link MGeneralizableElement MGeneralizableElement}<br/>
     */<br/>
    public Collection getSubtypes(Object cls) {<br/>
        if (!(cls instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Collection result = new Vector();<br/>
        Collection gens = ((MClassifier) cls).getSpecializations();<br/>
        Iterator genIterator = gens.iterator();<br/>
        while (genIterator.hasNext()) {<br/>
            MGeneralization next = (MGeneralization) genIterator.next();<br/>
            result.add(next.getChild());<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all behavioralfeatures found in this element and its<br/>
     * children.&lt;p&gt;<br/>
     *<br/>
     * @param element is the element<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllBehavioralFeatures(Object element) {<br/>
        if (!(element instanceof MModelElement)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it =<br/>
            ((MModelElement) element).getModelElementContents().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MClassifier) {<br/>
                MClassifier clazz = (MClassifier) o;<br/>
                if (!(clazz instanceof MDataType)) {<br/>
                    Iterator it1 = clazz.getFeatures().iterator();<br/>
                    while (it1.hasNext()) {<br/>
                        Object o1 = it1.next();<br/>
                        if (o1 instanceof MBehavioralFeature) {<br/>
                            list.add(o1);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            } else {<br/>
                list.addAll(getAllBehavioralFeatures(it.next()));<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all behavioral features of some classifier.<br/>
     * @param clazz The classifier<br/>
     * @return the collection with all behavioral features of some classifier<br/>
     */<br/>
    public Collection getBehavioralFeatures(Object clazz) {<br/>
        if (clazz instanceof MClassifier) {<br/>
            List ret = new ArrayList();<br/>
            Iterator it = nsmodel.getFacade().getFeatures(clazz).iterator();<br/>
            while (it.hasNext()) {<br/>
                Object o = it.next();<br/>
                if (o instanceof MBehavioralFeature) {<br/>
                    ret.add(o);<br/>
                }<br/>
            }<br/>
            return ret;<br/>
        }<br/>
        throw new IllegalArgumentException("Argument is not a classifier");<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all interfaces found in this namespace and in its children.<br/>
     *<br/>
     * @param ns the given namespace<br/>
     * @return Collection with all interfaces found<br/>
     */<br/>
    public Collection getAllInterfaces(Object ns) {<br/>
        if (ns == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(ns instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MNamespace) ns).getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllInterfaces(o));<br/>
            }<br/>
            if (o instanceof MInterface) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all classes found in this namespace and in its children.&lt;p&gt;<br/>
     *<br/>
     * @param ns is the namespace.<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllClasses(Object ns) {<br/>
        if (ns == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(ns instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MNamespace) ns).getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllClasses(o));<br/>
            }<br/>
            if (o instanceof MClass) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Return all interfaces the given class realizes.&lt;p&gt;<br/>
     *<br/>
     * @param cls the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getRealizedInterfaces(Object cls) {<br/>
        MClassifier classifier = (MClassifier) cls;<br/>
        if (classifier == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        Iterator it = classifier.getClientDependencies().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object clientDependency = it.next();<br/>
            if (clientDependency instanceof MAbstraction) {<br/>
                Object stereo = CollectionUtil.getFirstItemOrNull(<br/>
                        Model.getFacade().getStereotypes(clientDependency));<br/>
                if (stereo != null<br/>
                        &amp;&amp; nsmodel.getFacade().getBaseClass(stereo) != null<br/>
                        &amp;&amp; nsmodel.getFacade().getName(stereo) != null<br/>
                        &amp;&amp; nsmodel.getFacade().getBaseClass(stereo)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                .equals("Abstraction")<br/>
                        &amp;&amp; nsmodel.getFacade().getName(stereo)<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;.equals("realize")) {<br/>
                    Iterator it2 =<br/>
                        nsmodel.getFacade().getSuppliers(clientDependency)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.iterator();<br/>
                    while (it2.hasNext()) {<br/>
                        Object supplier = it2.next();<br/>
                        if (supplier instanceof MInterface) {<br/>
                            list.add(supplier);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all classes some generalizable element extends.<br/>
     *<br/>
     * @param clazz is the generalizable element<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getExtendedClassifiers(Object clazz) {<br/>
        if (clazz == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        Iterator it = nsmodel.getFacade().getGeneralizations(clazz).iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            MGeneralization gen = (MGeneralization) it.next();<br/>
            MGeneralizableElement parent = gen.getParent();<br/>
            if (parent != null) {<br/>
                list.add(parent);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the generalization between two generalizable elements.<br/>
     * Returns null if there is none.&lt;p&gt;<br/>
     *<br/>
     * @param achild is the child generalizable element.<br/>
     * @param aparent is the parent generalizable element.<br/>
     * @return MGeneralization<br/>
     */<br/>
    public Object getGeneralization(Object achild,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     Object aparent) {<br/>
        MGeneralizableElement child = (MGeneralizableElement) achild;<br/>
        MGeneralizableElement parent = (MGeneralizableElement) aparent;<br/>
        if (child == null || parent == null) {<br/>
            return null;<br/>
        }<br/>
        Iterator it = child.getGeneralizations().iterator();<br/>
        while (it.hasNext()) {<br/>
            MGeneralization gen = (MGeneralization) it.next();<br/>
            if (gen.getParent() == parent) {<br/>
                return gen;<br/>
            }<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * @see org.argouml.model.CoreHelper#getBody(java.lang.Object)<br/>
     */<br/>
    public String getBody(Object comment) {<br/>
        if (comment instanceof MComment) {<br/>
            /* In UML 1.3, get it from the name.<br/>
             * From UML 1.4, get it from the body.<br/>
             */<br/>
            return ((MComment) comment).getName();<br/>
        }<br/>
        throw new IllegalArgumentException();<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all flows from some source modelelement to a target<br/>
     * modelelement.&lt;p&gt;<br/>
     *<br/>
     * @param source is the source model element.<br/>
     * @param target is the target model element.<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getFlows(Object source, Object target) {<br/>
        if (source == null || target == null) {<br/>
            return null;<br/>
        }<br/>
        if (!(source instanceof MModelElement)) {<br/>
            throw new IllegalArgumentException("source");<br/>
        }<br/>
        if (!(target instanceof MModelElement)) {<br/>
            throw new IllegalArgumentException("target");<br/>
        }<br/>
<br/>
        List ret = new ArrayList();<br/>
        Collection targetFlows = ((MModelElement) target).getTargetFlows();<br/>
        Iterator it = ((MModelElement) source).getSourceFlows().iterator();<br/>
        while (it.hasNext()) {<br/>
            MFlow flow = (MFlow) it.next();<br/>
            if (targetFlows.contains(flow)) {<br/>
                ret.add(flow);<br/>
            }<br/>
        }<br/>
        return ret;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all elements that extend some class.<br/>
     *<br/>
     * @param clazz is the class (a generalizable element)<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getExtendingElements(Object clazz) {<br/>
        if (clazz == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        Iterator it = nsmodel.getFacade().getSpecializations(clazz).iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            MGeneralization gen = (MGeneralization) it.next();<br/>
            MGeneralizableElement client =<br/>
                (MGeneralizableElement) nsmodel.getFacade().getChild(gen);<br/>
            if (client != null) {<br/>
                list.add(client);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all classifiers that extend some classifier.<br/>
     *<br/>
     * @param clazz is the classifier.<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getExtendingClassifiers(Object clazz) {<br/>
        if (clazz == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(clazz instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it =<br/>
            ((MGeneralizableElement) clazz).getSpecializations().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            MGeneralization gen = (MGeneralization) it.next();<br/>
            MGeneralizableElement client = gen.getChild();<br/>
            if (client instanceof MClassifier) {<br/>
                list.add(client);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all components found in this namespace and in its children.<br/>
     *<br/>
     * @param ns is the namespace.<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllComponents(Object ns) {<br/>
        if (ns == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(ns instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MNamespace) ns).getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllComponents(o));<br/>
            }<br/>
            if (o instanceof MComponent) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all components found in this namespace and in its children.<br/>
     *<br/>
     * @param ns is the namespace<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllDataTypes(Object ns) {<br/>
        if (ns == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(ns instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MNamespace) ns).getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllDataTypes(o));<br/>
            }<br/>
            if (o instanceof MDataType) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all components found in this namespace and in its children.&lt;p&gt;<br/>
     *<br/>
     * @param ns is the namespace<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllNodes(Object ns) {<br/>
        if (ns == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(ns instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MNamespace) ns).getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllNodes(o));<br/>
            }<br/>
            if (o instanceof MNode) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
    /**<br/>
     * Gets all classifiers that are associated to the given<br/>
     * classifier (have an association relationship with the<br/>
     * classifier).&lt;p&gt;<br/>
     *<br/>
     * @param aclassifier an MClassifier<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAssociatedClassifiers(Object aclassifier) {<br/>
        MClassifier classifier = (MClassifier) aclassifier;<br/>
        if (classifier == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        List list = new ArrayList();<br/>
        Iterator it = classifier.getAssociationEnds().iterator();<br/>
        while (it.hasNext()) {<br/>
            MAssociationEnd end = (MAssociationEnd) it.next();<br/>
            MAssociation assoc = end.getAssociation();<br/>
            Iterator it2 = assoc.getConnections().iterator();<br/>
            while (it2.hasNext()) {<br/>
                MAssociationEnd end2 = (MAssociationEnd) it2.next();<br/>
                if (end2 != end) {<br/>
                    list.add(end2.getType());<br/>
                }<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Gets the associations between the classifiers from and to. Returns null<br/>
     * if from or to is null or if there is no association between them.<br/>
     *<br/>
     * @param from a classifier<br/>
     * @param to a classifier<br/>
     * @return MAssociation<br/>
     */<br/>
    public Collection getAssociations(Object/*MClassifier*/ from,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Object/*MClassifier*/ to) {<br/>
        Set ret = new HashSet();<br/>
        if (from == null || to == null) {<br/>
            return ret;<br/>
        }<br/>
        Iterator it = nsmodel.getFacade().getAssociationEnds(from).iterator();<br/>
        while (it.hasNext()) {<br/>
            MAssociationEnd end = (MAssociationEnd) it.next();<br/>
            MAssociation assoc = end.getAssociation();<br/>
            Iterator it2 = assoc.getConnections().iterator();<br/>
            while (it2.hasNext()) {<br/>
                MAssociationEnd end2 = (MAssociationEnd) it2.next();<br/>
                if (end2.getType() == to) {<br/>
                    ret.add(assoc);<br/>
                }<br/>
            }<br/>
        }<br/>
        return ret;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all classifiers found in this namespace and in its children.<br/>
     *<br/>
     * @param namespace the given namespace<br/>
     * @return Collection the collection of all classifiers<br/>
     *                    found in the namespace<br/>
     */<br/>
    public Collection getAllClassifiers(Object namespace) {<br/>
        if (namespace == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        MNamespace ns = (MNamespace) namespace;<br/>
        Iterator it = ns.getOwnedElements().iterator();<br/>
        List list = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            Object o = it.next();<br/>
            if (o instanceof MNamespace) {<br/>
                list.addAll(getAllClassifiers(o));<br/>
            }<br/>
            if (o instanceof MClassifier) {<br/>
                list.add(o);<br/>
            }<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all associations for some classifier.&lt;p&gt;<br/>
     *<br/>
     * @param oclassifier the given classifier<br/>
     * @return Collection all associations for the given classifier<br/>
     */<br/>
    public Collection getAssociations(Object oclassifier) {<br/>
        Collection col = new ArrayList();<br/>
        if (oclassifier instanceof MClassifier) {<br/>
            MClassifier classifier = (MClassifier) oclassifier;<br/>
            Iterator it = classifier.getAssociationEnds().iterator();<br/>
            while (it.hasNext()) {<br/>
                col.add(((MAssociationEnd) it.next()).getAssociation());<br/>
            }<br/>
        }<br/>
        return col;<br/>
    }<br/>
    /**<br/>
     * Returns the associationend between a classifier and<br/>
     * an associaton.&lt;p&gt;<br/>
     *<br/>
     * @param type is the classifier<br/>
     * @param assoc is the association<br/>
     * @return MAssociationEnd<br/>
     */<br/>
    public Object getAssociationEnd(Object type,<br/>
            Object assoc) {<br/>
        if (type == null || assoc == null) {<br/>
            return null;<br/>
        }<br/>
        if (!(type instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
        if (!(assoc instanceof MAssociation)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        Iterator it = ((MClassifier) type).getAssociationEnds().iterator();<br/>
        while (it.hasNext()) {<br/>
            MAssociationEnd end = (MAssociationEnd) it.next();<br/>
            if (((MAssociation) assoc).getConnections().contains(end)) {<br/>
                return end;<br/>
            }<br/>
        }<br/>
        return null;<br/>
    }<br/>
    /**<br/>
     * Returns the contents (owned elements) of this classifier and<br/>
     * all its parents as specified in section 2.5.3.8 of the UML 1.3<br/>
     * spec.&lt;p&gt;<br/>
     *<br/>
     * @param clazz is the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllContents(Object clazz) {<br/>
        if (clazz == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(clazz instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        List list = new ArrayList();<br/>
        Iterator it = ((MNamespace) clazz).getOwnedElements().iterator();<br/>
        while (it.hasNext()) {<br/>
            MModelElement element = (MModelElement) it.next();<br/>
            if (element.getVisibility().equals(MVisibilityKind.PUBLIC)<br/>
                || element.getVisibility().equals(MVisibilityKind.PROTECTED)) {<br/>
                list.add(element);<br/>
            }<br/>
        }<br/>
        it = ((MGeneralizableElement) clazz).getGeneralizations().iterator();<br/>
        while (it.hasNext()) {<br/>
            list.addAll(getAllContents(it.next()));<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all attributes of some classifier and of its parents.<br/>
     *<br/>
     * @param clazz is the classifier<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllAttributes(Object clazz) {<br/>
        if (clazz == null) {<br/>
            return new ArrayList();<br/>
        }<br/>
        if (!(clazz instanceof MClassifier)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        List list = new ArrayList();<br/>
        Iterator it = ((MClassifier) clazz).getFeatures().iterator();<br/>
        while (it.hasNext()) {<br/>
            MFeature element = (MFeature) it.next();<br/>
            if (element instanceof MAttribute) {<br/>
                list.add(element);<br/>
            }<br/>
        }<br/>
        it = ((MClassifier) clazz).getGeneralizations().iterator();<br/>
        while (it.hasNext()) {<br/>
            list.addAll(getAllAttributes(it.next()));<br/>
        }<br/>
        return list;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the source of a relation. The source of a relation is<br/>
     * defined as the modelelement that propagates this relation. If<br/>
     * there are more then 1 sources, only the first is returned. If<br/>
     * there is no source, null is returned. Examples of sources<br/>
     * include classifiers that are types to associationends, usecases<br/>
     * that are bases to extend and include relations and so on. A<br/>
     * source is allways the start from the arrow in the fig, the<br/>
     * destination the end.&lt;p&gt;<br/>
     *<br/>
     * This method also works to get the source of a Link.&lt;p&gt;<br/>
     *<br/>
     * TODO: move this method to a generic ModelHelper<br/>
     *<br/>
     * @param relationship is the relation<br/>
     * @return Object<br/>
     */<br/>
    public Object getSource(Object relationship) {<br/>
        if (!(relationship instanceof MRelationship)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; !(relationship instanceof MLink)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; !(relationship instanceof MAssociationEnd)) {<br/>
<br/>
<br/>
            throw new IllegalArgumentException("Argument "<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       + relationship.toString()<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       + " is not "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       + "a relationship");<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
        if (relationship instanceof MLink) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        nsmodel.getFacade().getConnections(relationship).iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nsmodel.getFacade().getInstance(it.next());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    } <br/>
            return null;<br/>
        }<br/>
        if (relationship instanceof MAssociation) {<br/>
            MAssociation assoc = (MAssociation) relationship;<br/>
            List conns = assoc.getConnections();<br/>
            if (conns == null || conns.isEmpty()) {<br/>
                return null;<br/>
            }<br/>
            return ((MAssociationEnd) conns.get(0)).getType();<br/>
        }<br/>
        if (relationship instanceof MGeneralization) {<br/>
            MGeneralization gen = (MGeneralization) relationship;<br/>
            return gen.getChild();<br/>
        }<br/>
        if (relationship instanceof MDependency) {<br/>
            MDependency dep = (MDependency) relationship;<br/>
            Collection col = dep.getClients();<br/>
            if (col.isEmpty()) {<br/>
                return null;<br/>
            }<br/>
            return (MModelElement) (col.toArray())[0];<br/>
        }<br/>
        if (relationship instanceof MFlow) {<br/>
            MFlow flow = (MFlow) relationship;<br/>
            Collection col = flow.getSources();<br/>
            if (col.isEmpty()) {<br/>
                return null;<br/>
            }<br/>
            return (MModelElement) (col.toArray())[0];<br/>
        }<br/>
        if (relationship instanceof MExtend) {<br/>
            MExtend extend = (MExtend) relationship;<br/>
            return extend.getExtension(); // we have to follow the arrows..<br/>
        }<br/>
        if (relationship instanceof MInclude) {<br/>
            MInclude include = (MInclude) relationship;<br/>
            // we use modelfacade here to cover up for a messup in NSUML<br/>
            return nsmodel.getFacade().getBase(include);<br/>
        }<br/>
        if (relationship instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) relationship).getAssociation();<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the destination of a relation. The destination of a<br/>
     * relation is defined as the modelelement that receives this<br/>
     * relation.  If there are more then 1 destinations, only the<br/>
     * first is returned.  If there is no destination, null is<br/>
     * returned.  Examples of sources include classifiers that are<br/>
     * types to associationends, usecases that are bases to extend and<br/>
     * include relations and so on.  In the case of an association,<br/>
     * the destination is defined as the type of the second element in<br/>
     * the connections list.&lt;p&gt;<br/>
     *<br/>
     * This method also works for links.&lt;p&gt;<br/>
     *<br/>
     * TODO: move this method to a generic ModelHelper<br/>
     *<br/>
     * @param relationship is the relation<br/>
     * @return object<br/>
     */<br/>
    public Object getDestination(Object relationship) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (!(relationship instanceof MRelationship)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; !(relationship instanceof MLink)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    &amp;&amp; !(relationship instanceof MAssociationEnd)) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    throw new IllegalArgumentException("Argument is not "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       + "a relationship");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (relationship instanceof MLink) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Iterator it =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        nsmodel.getFacade().getConnections(relationship).iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    return nsmodel.getFacade().getInstance(it.next());<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
            return null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<br/>
        if (relationship instanceof MAssociation) {<br/>
            MAssociation assoc = (MAssociation) relationship;<br/>
            List conns = assoc.getConnections();<br/>
            if (conns.size() &lt;= 1) {<br/>
                return null;<br/>
            }<br/>
            return ((MAssociationEnd) conns.get(1)).getType();<br/>
        }<br/>
        if (relationship instanceof MGeneralization) {<br/>
            MGeneralization gen = (MGeneralization) relationship;<br/>
            return gen.getParent();<br/>
        }<br/>
        if (relationship instanceof MDependency) {<br/>
            MDependency dep = (MDependency) relationship;<br/>
            Collection col = dep.getSuppliers();<br/>
            if (col.isEmpty()) {<br/>
                return null;<br/>
            }<br/>
            return (MModelElement) (col.toArray())[0];<br/>
        }<br/>
        if (relationship instanceof MFlow) {<br/>
            MFlow flow = (MFlow) relationship;<br/>
            Collection col = flow.getTargets();<br/>
            if (col.isEmpty()) {<br/>
                return null;<br/>
            }<br/>
            return (MModelElement) (col.toArray())[0];<br/>
        }<br/>
        if (relationship instanceof MExtend) {<br/>
            MExtend extend = (MExtend) relationship;<br/>
            return extend.getBase();<br/>
        }<br/>
        if (relationship instanceof MInclude) {<br/>
            MInclude include = (MInclude) relationship;<br/>
            return nsmodel.getFacade().getAddition(include);<br/>
        }<br/>
        if (relationship instanceof MAssociationEnd) {<br/>
            return ((MAssociationEnd) relationship).getType();<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the dependencies between some supplier modelelement and<br/>
     * some client modelelement.  Does not return the vica versa<br/>
     * relationship (dependency 'from client to supplier').&lt;p&gt;<br/>
     *<br/>
     * @param supplierObj a MModelElement<br/>
     * @param clientObj a MModelElement<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getDependencies(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Object supplierObj,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      Object clientObj) {<br/>
<br/>
        if (!(supplierObj instanceof MModelElement)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    || !(clientObj instanceof MModelElement)) {<br/>
<br/>
            return null;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
        MModelElement supplier = (MModelElement) supplierObj;<br/>
        MModelElement client = (MModelElement) clientObj;<br/>
<br/>
        List ret = new ArrayList();<br/>
        Collection clientDependencies = client.getClientDependencies();<br/>
        Iterator it = supplier.getSupplierDependencies().iterator();<br/>
        while (it.hasNext()) {<br/>
            MDependency dep = (MDependency) it.next();<br/>
            if (clientDependencies.contains(dep)) {<br/>
                ret.add(dep);<br/>
            }<br/>
        }<br/>
        return ret;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all relationships between the source and dest<br/>
     * modelelement and vica versa.&lt;p&gt;<br/>
     *<br/>
     * @param source is the source model element<br/>
     * @param dest is the destination model element<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getRelationships(Object source,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       Object dest) {<br/>
        Set ret = new HashSet();<br/>
        if (source == null || dest == null) {<br/>
            return ret;<br/>
        }<br/>
        if (!(source instanceof MModelElement)) {<br/>
            throw new IllegalArgumentException("source");<br/>
        }<br/>
        if (!(dest instanceof MModelElement)) {<br/>
            throw new IllegalArgumentException("dest");<br/>
        }<br/>
<br/>
        ret.addAll(getFlows(source, dest));<br/>
        ret.addAll(getFlows(dest, source));<br/>
        ret.addAll(getDependencies(source, dest));<br/>
        ret.addAll(getDependencies(dest, source));<br/>
        if (source instanceof MGeneralizableElement<br/>
            &amp;&amp; dest instanceof MGeneralizableElement) {<br/>
            ret.add(getGeneralization(source, dest));<br/>
            ret.add(getGeneralization(dest, source));<br/>
            if (source instanceof MClassifier &amp;&amp; dest instanceof MClassifier) {<br/>
                ret.addAll(getAssociations(source, dest));<br/>
            }<br/>
        }<br/>
        return ret;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if some modelelement may be owned by the given<br/>
     * namespace.&lt;p&gt;<br/>
     *<br/>
     * @param mObj a MModelElement<br/>
     * @param nsObj a MNamespace<br/>
     * @return boolean<br/>
     */<br/>
    public boolean isValidNamespace(Object mObj, Object nsObj) {<br/>
<br/>
        if (!(mObj instanceof MModelElement)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    || !(nsObj instanceof MNamespace)) {<br/>
<br/>
            return false;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
        MModelElement modelElement = (MModelElement) mObj;<br/>
        MNamespace ns = (MNamespace) nsObj;<br/>
<br/>
        if (modelElement == null || ns == null) {<br/>
            return false;<br/>
        }<br/>
        if (ns.getModel() != modelElement.getModel()) {<br/>
            return false;<br/>
        }<br/>
        if (modelElement == ns) {<br/>
            return false;<br/>
        }<br/>
        if (modelElement instanceof MNamespace<br/>
                &amp;&amp; modelElement == getFirstSharedNamespace(modelElement, ns)) {<br/>
            return false;<br/>
        }<br/>
        if (ns instanceof MInterface<br/>
            || ns instanceof MActor<br/>
            || ns instanceof MUseCase) {<br/>
            return false;<br/>
        } else if (ns instanceof MComponent) {<br/>
            return (modelElement instanceof MComponent &amp;&amp; modelElement != ns);<br/>
        } else if (ns instanceof MCollaboration) {<br/>
            if (!(modelElement instanceof MClassifierRole<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MAssociationRole<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MGeneralization<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MConstraint)) {<br/>
                return false;<br/>
            }<br/>
        } else if (ns instanceof MPackage) {<br/>
            if (!(modelElement instanceof MPackage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MClassifier<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MAssociation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MGeneralization<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MDependency<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MConstraint<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MCollaboration<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MStateMachine<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MStereotype)) {<br/>
                return false;<br/>
            }<br/>
        } else if (ns instanceof MClass) {<br/>
            if (!(modelElement instanceof MClass<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MAssociation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MGeneralization<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MUseCase<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MConstraint<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MDependency<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MCollaboration<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MDataType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || modelElement instanceof MInterface)) {<br/>
                return false;<br/>
            }<br/>
        } else if (ns instanceof MClassifierRole) {<br/>
            MClassifierRole cr = (MClassifierRole) ns;<br/>
            if (!(cr.getAvailableContentses().contains(modelElement)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  || cr.getAvailableFeatures().contains(modelElement))) {<br/>
                return false;<br/>
            }<br/>
        }<br/>
        if (modelElement instanceof MStructuralFeature) {<br/>
            if (!isValidNamespace((MStructuralFeature) modelElement, ns)) {<br/>
                return false;<br/>
            }<br/>
        } else if (modelElement instanceof MGeneralizableElement) {<br/>
            if (!isValidNamespace((MGeneralizableElement) modelElement, ns)) {<br/>
                return false;<br/>
            }<br/>
        } else if (modelElement instanceof MGeneralization) {<br/>
            if (!isValidNamespace((MGeneralization) modelElement, ns)) {<br/>
                return false;<br/>
            }<br/>
        }<br/>
        if (modelElement instanceof MAssociation) {<br/>
            if (!isValidNamespace((MAssociation) modelElement, ns)) {<br/>
                return false;<br/>
            }<br/>
        } else if (modelElement instanceof MCollaboration) {<br/>
            if (!isValidNamespace((MCollaboration) modelElement, ns)) {<br/>
                return false;<br/>
            }<br/>
        }<br/>
        return true;<br/>
    }<br/>
    private boolean isValidNamespace(MCollaboration collab, MNamespace ns) {<br/>
        Iterator it = collab.getOwnedElements().iterator();<br/>
        while (it.hasNext()) {<br/>
            MModelElement m = (MModelElement) it.next();<br/>
            if (m instanceof MClassifierRole) {<br/>
                MClassifierRole role = (MClassifierRole) m;<br/>
                Iterator it2 = role.getBases().iterator();<br/>
                while (it2.hasNext()) {<br/>
                    if (!ns.getOwnedElements().contains(it2.next())) {<br/>
                        return false;<br/>
                    }<br/>
                }<br/>
            } else if (m instanceof MAssociationRole) {<br/>
                if (!ns.getOwnedElements()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    .contains(((MAssociationRole) m).getBase())) {<br/>
                    return false;<br/>
                }<br/>
            }<br/>
        }<br/>
        return true;<br/>
    }<br/>
<br/>
    private boolean isValidNamespace(MGeneralization gen, MNamespace ns) {<br/>
        if (gen.getParent() == null || gen.getChild() == null) {<br/>
            return true;<br/>
        }<br/>
        MNamespace ns1 = gen.getParent().getNamespace();<br/>
        MNamespace ns2 = gen.getChild().getNamespace();<br/>
        if (ns == getFirstSharedNamespace(ns1, ns2)) {<br/>
            return true;<br/>
        }<br/>
        return false;<br/>
    }<br/>
<br/>
    private boolean isValidNamespace(MStructuralFeature struc, MNamespace ns) {<br/>
        if (struc.getType() == null || struc.getOwner() == null) {<br/>
            return true;<br/>
        }<br/>
        return struc.getOwner().getNamespace()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    .getOwnedElements().contains(struc.getType());<br/>
    }<br/>
<br/>
    private boolean isValidNamespace(MAssociation assoc, MNamespace ns) {<br/>
        Iterator it = assoc.getConnections().iterator();<br/>
        List namespaces = new ArrayList();<br/>
        while (it.hasNext()) {<br/>
            MAssociationEnd end = (MAssociationEnd) it.next();<br/>
            namespaces.add(end.getType().getNamespace());<br/>
        }<br/>
        it = namespaces.iterator();<br/>
        while (it.hasNext()) {<br/>
            MNamespace ns1 = (MNamespace) it.next();<br/>
            if (it.hasNext()) {<br/>
                MNamespace ns2 = (MNamespace) it.next();<br/>
                // TODO: this contains a small error (ns can be part<br/>
                // of hierarchy of namespaces, that's not taken into<br/>
                // account)<br/>
                if (ns == getFirstSharedNamespace(ns1, ns2)) {<br/>
                    return true;<br/>
                }<br/>
            }<br/>
        }<br/>
        return false;<br/>
    }<br/>
<br/>
    private boolean isValidNamespace(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     MGeneralizableElement gen,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     MNamespace ns) {<br/>
        Iterator it = gen.getParents().iterator();<br/>
        while (it.hasNext()) {<br/>
            MGeneralizableElement gen2 = (MGeneralizableElement) it.next();<br/>
            if (!ns.getOwnedElements().contains(gen2)) {<br/>
                return false;<br/>
            }<br/>
        }<br/>
        return true;<br/>
    }<br/>
    /**<br/>
     * Gets the first namespace two namespaces share. That is: it<br/>
     * returns the first namespace that owns the given namespaces<br/>
     * itself or some owner of the given namespaces.&lt;p&gt;<br/>
     *<br/>
     * @param ns1 is the first name space<br/>
     * @param ns2 is the second name space<br/>
     * @return MNamespace<br/>
     */<br/>
    public Object getFirstSharedNamespace(Object ns1, Object ns2) {<br/>
        if (ns1 == null || ns2 == null) {<br/>
            return null;<br/>
        }<br/>
        if (ns1 == ns2) {<br/>
            return ns1;<br/>
        }<br/>
        if (!(ns1 instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
        if (!(ns2 instanceof MNamespace)) {<br/>
            throw new IllegalArgumentException();<br/>
        }<br/>
<br/>
        boolean ns1Owner =<br/>
            nsmodel.getModelManagementHelper()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        .getAllNamespaces(ns1).contains(ns2);<br/>
        boolean ns2Owner =<br/>
            nsmodel.getModelManagementHelper()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        .getAllNamespaces(ns2).contains(ns1);<br/>
        if (ns1Owner) {<br/>
            return ns1;<br/>
        }<br/>
        if (ns2Owner) {<br/>
            return ns2;<br/>
        }<br/>
        return getFirstSharedNamespace(<br/>
                ((MModelElement) ns1).getNamespace(),<br/>
                ((MModelElement) ns2).getNamespace());<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all possible namespaces that may be selected by some given<br/>
     * modelelement. Which namespaces are allowed, is decided in the method<br/>
     * isValidNamespace.&lt;p&gt;<br/>
     *<br/>
     * @param modelElement is the model element<br/>
     * @param model the model to search<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllPossibleNamespaces(Object modelElement,<br/>
            Object model) {<br/>
        MModelElement m = (MModelElement) modelElement;<br/>
        List ret = new ArrayList();<br/>
        if (m == null) {<br/>
            return ret;<br/>
        }<br/>
        if (isValidNamespace(m, model)) {<br/>
            ret.add(model);<br/>
        }<br/>
        Iterator it =<br/>
            nsmodel.getModelManagementHelper()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        .getAllModelElementsOfKind(model, MNamespace.class)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;            .iterator();<br/>
        while (it.hasNext()) {<br/>
            MNamespace ns = (MNamespace) it.next();<br/>
            if (isValidNamespace(m, ns)) {<br/>
                ret.add(ns);<br/>
            }<br/>
        }<br/>
        return ret;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns all children from some given generalizableelement on<br/>
     * all levels (the complete tree excluding the generalizable<br/>
     * element itself).&lt;p&gt;<br/>
     *<br/>
     * @param o is the generalizable element<br/>
     * @return Collection<br/>
     * @throws IllegalStateException if there is a circular reference.<br/>
     */<br/>
    // TODO: Argument shall be typed to catch a lot of problems at<br/>
    //       compile time.<br/>
    // TODO: The exception shall be declared explicitly.<br/>
    // TODO: Use an exception that needs to be caugh so users of<br/>
    //       getChildren won't forget that they need to catch it.<br/>
    public Collection getChildren(Object o) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    Collection col = new ArrayList();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collection generalizations = new ArrayList();<br/>
        if (o instanceof MGeneralizableElement) {<br/>
            Iterator it =<br/>
                ((MGeneralizableElement) o).getSpecializations().iterator();<br/>
            while (it.hasNext()) {<br/>
                getChildren(col, (MGeneralization) it.next(), generalizations);<br/>
            }<br/>
        }<br/>
        return col;<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds all children recursively to the Collection in the first argument.<br/>
     * The algorithm assumes that there is a cycle when a node has been visited twice<br/>
     * using already known generalizations.<br/>
     *<br/>
     * @param currentChildren collection to collect them in.<br/>
     * @param gen element whose children are added.<br/>
     * @param generalizations the list of already traversed generalizations.<br/>
     * @throws IllegalStateException if there is a circular reference.<br/>
     */<br/>
    private void getChildren(Collection currentChildren, MGeneralization gen, Collection generalizations) {<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MGeneralizableElement child = gen.getChild();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (currentChildren.contains(child) &amp;&amp; generalizations.contains(gen)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalStateException("Circular inheritance occured.");<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentChildren.add(child);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generalizations.add(gen);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Iterator it = child.getSpecializations().iterator();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    getChildren(currentChildren, (MGeneralization) it.next(), generalizations);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
    /**<br/>
     * Returns all interfaces that are realized by the given class or<br/>
     * by its superclasses. It's possible that interfaces occur twice<br/>
     * in the collection returned. In that case there is a double<br/>
     * reference to that interface.<br/>
     *<br/>
     * @param o is the given class<br/>
     * @return Collection<br/>
     */<br/>
    public Collection getAllRealizedInterfaces(Object o) {<br/>
        return internalGetAllRealizedInterfaces(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new ArrayList(),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new HashSet());<br/>
    }<br/>
<br/>
    /**<br/>
     * Helper method for getAllRealizedInterfaces.<br/>
     * @param o<br/>
     * @param col<br/>
     * @param visited<br/>
     * @return Collection<br/>
     */<br/>
    private Collection internalGetAllRealizedInterfaces(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object o, Collection col, Set visited) {<br/>
        visited.add(o);<br/>
        if (o != null) {<br/>
            if (o instanceof MClass) {<br/>
                MClass clazz = (MClass) o;<br/>
                Collection supDependencies = clazz.getClientDependencies();<br/>
                Iterator it = supDependencies.iterator();<br/>
                while (it.hasNext()) {<br/>
                    MDependency dependency = (MDependency) it.next();<br/>
                    MStereotype stereo = dependency.getStereotype();<br/>
                    if (dependency instanceof MAbstraction<br/>
                        &amp;&amp; stereo != null<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "realize".equals(stereo.getName())<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; "Abstraction".equals(stereo.getBaseClass())) {<br/>
<br/>
                        col.addAll(dependency.getSuppliers());<br/>
<br/>
                    }<br/>
                }<br/>
                Collection superTypes = getSupertypes(o);<br/>
                it = superTypes.iterator();<br/>
                while (it.hasNext()) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    Object obj = it.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    if (!visited.contains(obj)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;internalGetAllRealizedInterfaces(obj, col, visited);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
                }<br/>
            }<br/>
        }<br/>
        return col;<br/>
    }<br/>
<br/>
    /**<br/>
     * @param  association the association to be investigated<br/>
     * @return true if one of the association ends of the given association<br/>
     *         is of the composite kind<br/>
     */<br/>
    public final boolean hasCompositeEnd(Object association) {<br/>
        if (!(association instanceof MAssociation)) {<br/>
            throw new IllegalArgumentException();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
        MAssociation association1 = (MAssociation) association;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;List ends = association1.getConnections();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (Iterator iter = ends.iterator(); iter.hasNext();) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    MAssociationEnd end = (MAssociationEnd) iter.next();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    if (end.getAggregation() == MAggregationKind.COMPOSITE) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;        return true;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;    }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * @param associationEnd is the association end<br/>
     * @param kindType the MAggregationKind as a string in lower case letter,<br/>
     *                 eg: composite.<br/>
     * @return true if the aggregation kinds are the same.<br/>
     */<br/>
    public final boolean equalsAggregationKind(Object associationEnd,<br/>
                                               String kindType) {<br/>
        if (!(associationEnd instanceof MAssociationEnd)) {<br/>
            throw new IllegalArgumentException();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
        MAssociationEnd associationEnd1 = (MAssociationEnd) associationEnd;<br/>
<br/>
        if (kindType.equals("composite")) {<br/>
            return MAggregationKind.COMPOSITE.equals(<br/>
                            associationEnd1.getAggregation());<br/>
        } <br/>
        throw new IllegalArgumentException("kindType: " + kindType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       + " not supported");<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove the given modelelement from a given comment.<br/>
     *<br/>
     * @param handle MComment<br/>
     * @param me MModelElement<br/>
     */<br/>
    public void removeAnnotatedElement(Object handle, Object me) {<br/>
        if (handle instanceof MComment &amp;&amp; me instanceof MModelElement) {<br/>
            ((MComment) handle).removeAnnotatedElement((MModelElement) me);<br/>
            return;<br/>
        }<br/>
        LOG.error("Failed to remove comment from model element");<br/>
        throw new IllegalArgumentException();<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a dependency from a model element.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param dep is the dependency<br/>
     */<br/>
    public void removeClientDependency(Object handle, Object dep) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; dep instanceof MDependency) {<br/>
            ((MModelElement) handle).removeClientDependency((MDependency) dep);<br/>
            return;<br/>
        }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException();<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove the given constraint from a given ModelElement.<br/>
     *<br/>
     * @param handle ModelElement<br/>
     * @param cons Constraint<br/>
     */<br/>
    public void removeConstraint(Object handle, Object cons) {<br/>
        if (handle instanceof MModelElement &amp;&amp; cons instanceof MConstraint) {<br/>
            ((MModelElement) handle).removeConstraint((MConstraint) cons);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or cons: " + cons);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes a owned model element from a namespace.<br/>
     *<br/>
     * @param handle is the name space<br/>
     * @param value is the model element<br/>
     */<br/>
    public void removeOwnedElement(Object handle, Object value) {<br/>
        if (handle instanceof MNamespace<br/>
                &amp;&amp; value instanceof MModelElement) {<br/>
            ((MNamespace) handle).removeOwnedElement((MModelElement) value);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or value: " + value);<br/>
    }<br/>
<br/>
    /**<br/>
     * This method removes a parameter from an operation.<br/>
     *<br/>
     * @param handle The operation.<br/>
     * @param parameter The parameter.<br/>
     */<br/>
    public void removeParameter(Object handle, Object parameter) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (handle instanceof MObjectFlowState) {<br/>
                ((MObjectFlowState) handle).removeParameter(<br/>
                        (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MEvent) {<br/>
                ((MEvent) handle).removeParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) handle).removeParameter(<br/>
                    (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MClassifier) {<br/>
                ((MClassifier) handle).removeParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or parameter: " + parameter);<br/>
    }<br/>
<br/>
    /**<br/>
     * Remove a source flow from a model element.<br/>
     *<br/>
     * @param handle The model element.<br/>
     * @param flow The flow.<br/>
     */<br/>
    public void removeSourceFlow(Object handle, Object flow) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; flow instanceof MFlow) {<br/>
            ((MModelElement) handle).removeSourceFlow((MFlow) flow);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or flow: " + flow);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a supplier dependency to some modelelement.<br/>
     *<br/>
     * @param supplier the supplier<br/>
     * @param dependency the dependency<br/>
     */<br/>
    public void removeSupplierDependency(<br/>
            Object supplier,<br/>
            Object dependency) {<br/>
        if (supplier instanceof MModelElement<br/>
                &amp;&amp; dependency instanceof MDependency) {<br/>
            MModelElement me = (MModelElement) supplier;<br/>
            me.removeSupplierDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("supplier: " + supplier<br/>
                + " or dependency: " + dependency);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes a named tagged value from a model element, ie subsequent calls<br/>
     * to getTaggedValue will return null for name, at least until a tagged<br/>
     * value with that name has been added again.<br/>
     *<br/>
     * @param handle the model element to remove the tagged value from<br/>
     * @param name the name of the tagged value<br/>
     * @throws IllegalArgumentException if handle isn't a model element<br/>
     */<br/>
    public void removeTaggedValue(Object handle, String name) {<br/>
        if (handle instanceof MModelElement) {<br/>
            MModelElement me = (MModelElement) handle;<br/>
            me.removeTaggedValue(name);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a target flow to a model element.<br/>
     *<br/>
     * @param handle The model element.<br/>
     * @param flow The flow to add.<br/>
     */<br/>
    public void removeTargetFlow(Object handle, Object flow) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; flow instanceof MFlow) {<br/>
            ((MModelElement) handle).removeTargetFlow((MFlow) flow);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or flow: " + flow);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds an annotated element to a comment.<br/>
     *<br/>
     * @param comment The comment to which the element is annotated<br/>
     * @param annotatedElement The element to annotate<br/>
     */<br/>
    public void addAnnotatedElement(Object comment,<br/>
            Object annotatedElement) {<br/>
        if (comment instanceof MComment<br/>
                &amp;&amp; annotatedElement instanceof MModelElement) {<br/>
            ((MComment) comment)<br/>
                .addAnnotatedElement(((MModelElement) annotatedElement));<br/>
            return;<br/>
        }<br/>
        LOG.error("Failed to link a comment to a model element");<br/>
        throw new IllegalArgumentException("comment: " + comment<br/>
                + " or annotatedElement: " + annotatedElement);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a client model element to some dependency.<br/>
     *<br/>
     * @param handle dependency.<br/>
     * @param element The model element.<br/>
     * @throws IllegalArgumentException if the handle is not a dependency<br/>
     * or the element is not a model element.<br/>
     */<br/>
    public void addClient(Object handle, Object element) {<br/>
        if (handle instanceof MDependency<br/>
                &amp;&amp; element instanceof MModelElement) {<br/>
            ((MDependency) handle).addClient((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or element: " + element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a client dependency to some modelelement.<br/>
     *<br/>
     * @param handle the modelelement<br/>
     * @param dependency the dependency<br/>
     */<br/>
    public void addClientDependency(Object handle, Object dependency) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; dependency instanceof MDependency) {<br/>
            MModelElement me = (MModelElement) handle;<br/>
            me.addClientDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or dependency: " + dependency);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a new comment to a model element.<br/>
     *<br/>
     * @param element the element to which the comment is to be added<br/>
     * @param comment the comment for the model element<br/>
     */<br/>
    public void addComment(Object element, Object comment) {<br/>
        if (element instanceof MModelElement &amp;&amp; comment instanceof MComment) {<br/>
            ((MModelElement) element).addComment((MComment) comment);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("element: " + element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add an End to a connection.<br/>
     *<br/>
     * @param handle Association or Link<br/>
     * @param connection AssociationEnd or LinkEnd<br/>
     */<br/>
    public void addConnection(Object handle, Object connection) {<br/>
        if (handle instanceof MAssociation<br/>
            &amp;&amp; connection instanceof MAssociationEnd) {<br/>
            ((MAssociation) handle).addConnection((MAssociationEnd) connection);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MLink<br/>
            &amp;&amp; connection instanceof MLinkEnd) {<br/>
            ((MLink) handle).addConnection((MLinkEnd) connection);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or connection: " + connection);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a constraint to some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param mc constraint<br/>
     */<br/>
    public void addConstraint(Object handle, Object mc) {<br/>
        if (handle instanceof MModelElement &amp;&amp; mc instanceof MConstraint) {<br/>
            ((MModelElement) handle).addConstraint((MConstraint) mc);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle + " or mc: " + mc);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Component<br/>
     * @param node Node<br/>
     */<br/>
    public void addDeploymentLocation(Object handle, Object node) {<br/>
        if (handle instanceof MComponent &amp;&amp; node instanceof MNode) {<br/>
            ((MComponent) handle).addDeploymentLocation((MNode) node);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or node: " + node);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a feature to some classifier.<br/>
     *<br/>
     * @param handle classifier<br/>
     * @param index position<br/>
     * @param f feature<br/>
     */<br/>
    public void addFeature(Object handle, int index, Object f) {<br/>
        if (handle instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            if (LOG.isInfoEnabled()) {<br/>
                LOG.info("Adding the feature " + f + " at " + index);<br/>
            }<br/>
            ((MClassifier) handle).addFeature(index, (MFeature) f);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or f: " + f);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a feature to some classifier.<br/>
     *<br/>
     * @param handle classifier<br/>
     * @param f feature<br/>
     */<br/>
    public void addFeature(Object handle, Object f) {<br/>
        if (handle instanceof MClassifier &amp;&amp; f instanceof MFeature) {<br/>
            if (LOG.isInfoEnabled()) {<br/>
                LOG.info("Adding the feature " + f);<br/>
            }<br/>
            ((MClassifier) handle).addFeature((MFeature) f);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add the given Link to the given Link or Association.<br/>
     *<br/>
     * @param handle the Link or Association<br/>
     * @param link Link<br/>
     */<br/>
    public void addLink(Object handle, Object link) {<br/>
        if (handle instanceof MAssociation &amp;&amp; link instanceof MLink) {<br/>
            ((MAssociation) handle).addLink((MLink) link);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or link: " + link);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a method to some operation and copies the op's attributes<br/>
     * to the method.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param m is the method<br/>
     */<br/>
    public void addMethod(Object handle, Object m) {<br/>
        if (handle instanceof MOperation<br/>
            &amp;&amp; m instanceof MMethod) {<br/>
            ((MMethod) m).setVisibility(((MOperation) handle).getVisibility());<br/>
            ((MMethod) m).setOwnerScope(((MOperation) handle).getOwnerScope());<br/>
            ((MOperation) handle).addMethod((MMethod) m);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle + " or m: " + m);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a model element to some namespace.<br/>
     *<br/>
     * @param handle namespace<br/>
     * @param me model element<br/>
     */<br/>
    public void addOwnedElement(Object handle, Object me) {<br/>
        if (handle instanceof MNamespace &amp;&amp; me instanceof MModelElement) {<br/>
            ((MNamespace) handle).addOwnedElement((MModelElement) me);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or me: " + me);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a Parameter to the given object at given location.<br/>
     *<br/>
     * @param handle The object that will get the Parameter:<br/>
     *               MEvent, MBehavioralFeature.<br/>
     * @param index the location<br/>
     * @param parameter Object that will be added<br/>
     */<br/>
    public void addParameter(<br/>
        Object handle,<br/>
        int index,<br/>
        Object parameter) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (handle instanceof MEvent) {<br/>
                ((MEvent) handle).addParameter(index, (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) handle).addParameter(<br/>
                        index,<br/>
                        (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or parameter: " + parameter);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a Parameter to the given object.<br/>
     *<br/>
     * @param handle The object that will get the Parameter:<br/>
     *               MObjectFlowState, MEvent, MBehavioralFeature, MClassifier.<br/>
     * @param parameter Object that will be added<br/>
     */<br/>
    public void addParameter(Object handle, Object parameter) {<br/>
        if (parameter instanceof MParameter) {<br/>
            if (handle instanceof MObjectFlowState) {<br/>
                ((MObjectFlowState) handle).addParameter(<br/>
                        (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MEvent) {<br/>
                ((MEvent) handle).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MBehavioralFeature) {<br/>
                ((MBehavioralFeature) handle).addParameter(<br/>
                    (MParameter) parameter);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MClassifier) {<br/>
                ((MClassifier) handle).addParameter((MParameter) parameter);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or parameter: " + parameter);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a raised Signal to a Message or Operation.<br/>
     *<br/>
     * @param handle the Message or Operation<br/>
     * @param sig the Signal that is raised<br/>
     */<br/>
    public void addRaisedSignal(Object handle, Object sig) {<br/>
        if (sig instanceof MSignal) {<br/>
            if (handle instanceof MMessage) {<br/>
                ((MBehavioralFeature) handle).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MOperation) {<br/>
                ((MOperation) handle).addRaisedSignal((MSignal) sig);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or sig: " + sig);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a source flow to a model element.<br/>
     *<br/>
     * @param handle The model element.<br/>
     * @param flow The flow.<br/>
     */<br/>
    public void addSourceFlow(Object handle, Object flow) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; flow instanceof MFlow) {<br/>
            ((MModelElement) handle).addSourceFlow((MFlow) flow);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or flow: " + flow);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a supplier classifier to some abstraction.<br/>
     *<br/>
     * @param handle abstraction<br/>
     * @param element supplier model element<br/>
     */<br/>
    public void addSupplier(Object handle, Object element) {<br/>
        if (handle instanceof MDependency &amp;&amp; element instanceof MModelElement) {<br/>
            ((MDependency) handle).addSupplier((MModelElement) element);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or element: " + element);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a supplier dependency to some modelelement.<br/>
     *<br/>
     * @param supplier the supplier<br/>
     * @param dependency the dependency<br/>
     */<br/>
    public void addSupplierDependency(<br/>
            Object supplier,<br/>
            Object dependency) {<br/>
        if (supplier instanceof MModelElement<br/>
                &amp;&amp; dependency instanceof MDependency) {<br/>
            MModelElement me = (MModelElement) supplier;<br/>
            me.addSupplierDependency((MDependency) dependency);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("supplier: " + supplier<br/>
                + " or dependency: " + dependency);<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a TaggedValue to a ModelElement.<br/>
     *<br/>
     * @param handle ModelElement<br/>
     * @param taggedValue TaggedValue<br/>
     */<br/>
    public void addTaggedValue(Object handle, Object taggedValue) {<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nsmodel.getExtensionMechanismsHelper().addTaggedValue(handle,taggedValue);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add a target flow to a model element.<br/>
     *<br/>
     * @param handle The model element.<br/>
     * @param flow The flow to add.<br/>
     */<br/>
    public void addTargetFlow(Object handle, Object flow) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; flow instanceof MFlow) {<br/>
            ((MModelElement) handle).addTargetFlow((MFlow) flow);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or flow: " + flow);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if some model element is abstract.<br/>
     *<br/>
     * @see org.argouml.model.CoreHelper#setAbstract(Object, boolean)<br/>
     * @param handle is the classifier<br/>
     * @param flag is true if it should be abstract<br/>
     */<br/>
    public void setAbstract(Object handle, boolean flag) {<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) handle).setAbstract(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            ((MOperation) handle).setAbstract(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setAbstarct(flag);<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes a Class active.<br/>
     *<br/>
     * @param handle Class<br/>
     * @param active boolean<br/>
     */<br/>
    public void setActive(Object handle, boolean active) {<br/>
        if (handle instanceof MClass) {<br/>
            ((MClass) handle).setActive(active);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the aggregation of some model element.<br/>
     *<br/>
     * @param handle the model element to set aggregation<br/>
     * @param aggregationKind the aggregation kind<br/>
     */<br/>
    public void setAggregation(Object handle, Object aggregationKind) {<br/>
        if (handle instanceof MAssociationEnd<br/>
            &amp;&amp; aggregationKind instanceof MAggregationKind) {<br/>
            ((MAssociationEnd) handle).setAggregation(<br/>
                (MAggregationKind) aggregationKind);<br/>
                return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or aggregationKind: " + aggregationKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the list of annotated elements of the given comment.<br/>
     *<br/>
     * @param handle the given comment<br/>
     * @param elems the list of annotated modelelements<br/>
     */<br/>
    public void setAnnotatedElements(Object handle, Collection elems) {<br/>
        if (handle instanceof MComment<br/>
            &amp;&amp; elems instanceof List) {<br/>
            ((MComment) handle).setAnnotatedElements(elems);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the association of some model element.<br/>
     *<br/>
     * @param handle the model element to set association<br/>
     * @param association is the association<br/>
     */<br/>
    public void setAssociation(Object handle, Object association) {<br/>
        if (association instanceof MAssociation) {<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setAssociation(<br/>
                    (MAssociation) association);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MLink) {<br/>
                ((MLink) handle).setAssociation((MAssociation) association);<br/>
                return;<br/>
            }<br/>
        } else if (association instanceof MAssociationRole) {<br/>
            if (handle instanceof MAssociationEndRole) {<br/>
                ((MAssociationEndRole) handle).setAssociation(<br/>
                        (MAssociationRole) association);<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or association: " + association);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if some model element is a leaf.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a leaf.<br/>
     */<br/>
    public void setLeaf(Object handle, boolean flag) {<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            ((MOperation) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) handle).setLeaf(flag);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the raised signals of some behavioural feature.<br/>
     *<br/>
     * @param handle the behavioural feature<br/>
     * @param raisedSignals the raised signals<br/>
     */<br/>
    public void setRaisedSignals(<br/>
        Object handle,<br/>
        Collection raisedSignals) {<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) handle).setRaisedSignals(raisedSignals);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @see org.argouml.model.CoreHelper#setBody(<br/>
     *         java.lang.Object, java.lang.Object)<br/>
     */<br/>
    public void setBody(Object handle, Object expr) {<br/>
        if (handle instanceof MMethod<br/>
            &amp;&amp; (expr == null || expr instanceof MProcedureExpression)) {<br/>
            ((MMethod) handle).setBody((MProcedureExpression) expr);<br/>
            return;<br/>
        }<br/>
<br/>
        if (handle instanceof MConstraint<br/>
            &amp;&amp; (expr == null || expr instanceof MBooleanExpression)) {<br/>
            ((MConstraint) handle).setBody((MBooleanExpression) expr);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or expr: " + expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Changeability of a StructuralFeature or AssociationEnd.<br/>
     *<br/>
     * @param handle StructuralFeature or AssociationEnd<br/>
     * @param ck ChangeableKind<br/>
     */<br/>
    public void setChangeability(Object handle, Object ck) {<br/>
        if (ck == null || ck instanceof MChangeableKind) {<br/>
            MChangeableKind changeableKind = (MChangeableKind) ck;<br/>
<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setChangeability(changeableKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or ck: " + ck);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the changeability of some feature.<br/>
     *<br/>
     * @param handle is the feature<br/>
     * @param flag is the changeability flag<br/>
     */<br/>
    public void setChangeable(Object handle, boolean flag) {<br/>
        // TODO: the implementation is ugly, because I have no spec<br/>
        // at hand...<br/>
        if (handle instanceof MStructuralFeature) {<br/>
            if (flag) {<br/>
                ((MStructuralFeature) handle).setChangeability(<br/>
                    MChangeableKind.CHANGEABLE);<br/>
                    return;<br/>
            } <br/>
            ((MStructuralFeature) handle).setChangeability(<br/>
                    MChangeableKind.FROZEN);<br/>
            return;<br/>
        } else if (handle instanceof MAssociationEnd) {<br/>
            MAssociationEnd ae = (MAssociationEnd) handle;<br/>
            if (flag) {<br/>
                ae.setChangeability(MChangeableKind.CHANGEABLE);<br/>
            } else {<br/>
                ae.setChangeability(MChangeableKind.FROZEN);<br/>
            }<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the child for a generalization.<br/>
     *<br/>
     * @param handle Generalization<br/>
     * @param child GeneralizableElement<br/>
     */<br/>
    public void setChild(Object handle, Object child) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            ((MGeneralization) handle).setChild((MGeneralizableElement) child);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or child: " + child);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the concurrency of some operation.<br/>
     *<br/>
     * @param handle is the operation<br/>
     * @param concurrencyKind is the concurrency<br/>
     */<br/>
    public void setConcurrency(<br/>
        Object handle,<br/>
        Object concurrencyKind) {<br/>
        if (handle instanceof MOperation<br/>
            &amp;&amp; concurrencyKind instanceof MCallConcurrencyKind) {<br/>
            ((MOperation) handle).setConcurrency(<br/>
                (MCallConcurrencyKind) concurrencyKind);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or concurrencyKind: " + concurrencyKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the list of connections of the given association or link.<br/>
     *<br/>
     * @param handle the given association or link<br/>
     * @param elems the list of association-ends or link-ends<br/>
     */<br/>
    public void setConnections(Object handle, Collection elems) {<br/>
        if (handle instanceof MAssociation &amp;&amp; elems instanceof List) {<br/>
            ((MAssociation) handle).setConnections((List) elems);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MLink &amp;&amp; elems instanceof List) {<br/>
            ((MLink) handle).setConnections(elems);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a default value of some parameter.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param expr is the expression<br/>
     */<br/>
    public void setDefaultValue(Object handle, Object expr) {<br/>
        if (handle instanceof MParameter &amp;&amp; expr instanceof MExpression) {<br/>
            ((MParameter) handle).setDefaultValue((MExpression) expr);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or expr: " + expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle a generalization<br/>
     * @param discriminator the discriminator to set<br/>
     */<br/>
    public void setDiscriminator(Object handle, String discriminator) {<br/>
        if (handle instanceof MGeneralization) {<br/>
            ((MGeneralization) handle).setDiscriminator(discriminator);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the feature at the given position.<br/>
     *<br/>
     * @param elem The classifier to set.<br/>
     * @param i The position. Start with 0.<br/>
     * @param impl The feature to set.<br/>
     */<br/>
    public void setFeature(Object elem, int i, Object impl) {<br/>
        if (elem instanceof MClassifier &amp;&amp; impl instanceof MFeature) {<br/>
            if (LOG.isInfoEnabled()) {<br/>
                LOG.info("Setting the feature " + impl + " at " + i);<br/>
            }<br/>
            ((MClassifier) elem).setFeature(i, (MFeature) impl);<br/>
            return;<br/>
        }<br/>
<br/>
        throw new IllegalArgumentException("elem: " + elem<br/>
                + " or impl: " + impl);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the features of some model element.<br/>
     *<br/>
     * @param handle the model element to set features to<br/>
     * @param features the features<br/>
     */<br/>
    public void setFeatures(Object handle, Collection features) {<br/>
        if (handle instanceof MClassifier) {<br/>
            LOG.info("Setting the features collection");<br/>
            List featuresList = null;<br/>
            if (features instanceof List) {<br/>
                featuresList = (List) features;<br/>
            } else {<br/>
                featuresList = new ArrayList(features);<br/>
            }<br/>
            ((MClassifier) handle).setFeatures(featuresList);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the ImplementationLocation of the given ElementResidence<br/>
     * to the given Component.<br/>
     *<br/>
     * @param handle the ElementResidence<br/>
     * @param component the Component<br/>
     * @deprecated UML 1.3 only see setContainer<br/>
     */<br/>
    public void setImplementationLocation(Object handle, Object component) {<br/>
        setContainer(handle, component);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Container of the given ElementResidence to the given Component.<br/>
     *<br/>
     * @param handle<br/>
     *            the ElementResidence<br/>
     * @param component<br/>
     *            the Component<br/>
     */<br/>
    public void setContainer(<br/>
        Object handle,<br/>
        Object component) {<br/>
        if (handle instanceof MElementResidence<br/>
                &amp;&amp; (component == null || component instanceof MComponent)) {<br/>
            ((MElementResidence) handle).setImplementationLocation(<br/>
                (MComponent) component);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or component: " + component);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets an initial value.<br/>
     *<br/>
     * @param at attribute that we set the initial value of<br/>
     * @param expr that is the value to set. Can be &lt;code&gt;null&lt;/code&gt;.<br/>
     */<br/>
    public void setInitialValue(Object at, Object expr) {<br/>
        if (at instanceof MAttribute<br/>
                &amp;&amp; (expr == null || expr instanceof MExpression)) {<br/>
            ((MAttribute) at).setInitialValue((MExpression) expr);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("at: " + at + " or expr: " + expr);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     * @param kind is the directionkind<br/>
     */<br/>
    public void setKind(Object handle, Object kind) {<br/>
        if (handle instanceof MParameter<br/>
            &amp;&amp; kind instanceof MParameterDirectionKind) {<br/>
            ((MParameter) handle).setKind((MParameterDirectionKind) kind);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MPseudostate<br/>
            &amp;&amp; kind instanceof MPseudostateKind) {<br/>
            ((MPseudostate) handle).setKind((MPseudostateKind) kind);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or kind: " + kind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'in'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public void setKindToIn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            ((MParameter) handle).setKind(MParameterDirectionKind.IN);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'in/out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public void setKindToInOut(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            ((MParameter) handle).setKind(MParameterDirectionKind.INOUT);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'out'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public void setKindToOut(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            ((MParameter) handle).setKind(MParameterDirectionKind.OUT);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set some parameters kind to 'return'.<br/>
     *<br/>
     * @param handle is the parameter<br/>
     */<br/>
    public void setKindToReturn(Object handle) {<br/>
        if (handle instanceof MParameter) {<br/>
            ((MParameter) handle).setKind(MParameterDirectionKind.RETURN);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the container that owns the handle. This must be set<br/>
     * correctly so every modelelement except the root model does have<br/>
     * an owner. Otherwise the saving/loading will fail.&lt;p&gt;<br/>
     *<br/>
     * &lt;em&gt;Warning: when changing the implementation of this method<br/>
     * be warned that the sequence of the if then else tree DOES<br/>
     * matter.&lt;/em&gt; Most notabely, do not move the setNamespace method<br/>
     * any level up in the tree.&lt;p&gt;<br/>
     *<br/>
     * &lt;em&gt;Warning: the implementation does not support setting the<br/>
     * owner of actions.&lt;/em&gt; Use setState1 etc. on action for that<br/>
     * goal&lt;p&gt;<br/>
     *<br/>
     * @param handle The modelelement that must be added to the container<br/>
     * @param container The owning modelelement<br/>
     * @exception IllegalArgumentException when the handle or<br/>
     * container is null or if the handle cannot be added to the<br/>
     * container.<br/>
     */<br/>
    public void setModelElementContainer(<br/>
        Object handle,<br/>
        Object container) {<br/>
        if (handle instanceof MPartition<br/>
            &amp;&amp; container instanceof MActivityGraph) {<br/>
            ((MPartition) handle).setActivityGraph((MActivityGraph) container);<br/>
        } else if (handle instanceof MModelElement<br/>
                &amp;&amp; container instanceof MPartition) {<br/>
            ((MPartition) container).addContents((MModelElement) handle);<br/>
        } else if (<br/>
            handle instanceof MConstraint<br/>
                &amp;&amp; container instanceof MStereotype) {<br/>
            MConstraint c = (MConstraint) handle;<br/>
            c.setConstrainedElement2((MStereotype) container);<br/>
        } else if (<br/>
            handle instanceof MInteraction<br/>
                &amp;&amp; container instanceof MCollaboration) {<br/>
            ((MInteraction) handle).setContext((MCollaboration) container);<br/>
        } else if (<br/>
            handle instanceof MElementResidence<br/>
                &amp;&amp; container instanceof MComponent) {<br/>
            MElementResidence er = (MElementResidence) handle;<br/>
            er.setImplementationLocation((MComponent) container);<br/>
        } else if (<br/>
            handle instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MInstance) {<br/>
            ((MAttributeLink) handle).setInstance((MInstance) container);<br/>
        } else if (<br/>
            handle instanceof MMessage &amp;&amp; container instanceof MInteraction) {<br/>
            ((MMessage) handle).setInteraction((MInteraction) container);<br/>
        } else if (handle instanceof MLinkEnd &amp;&amp; container instanceof MLink) {<br/>
            ((MLinkEnd) handle).setLink((MLink) container);<br/>
        } else if (<br/>
            handle instanceof MAttributeLink<br/>
                &amp;&amp; container instanceof MLinkEnd) {<br/>
            ((MAttributeLink) handle).setLinkEnd((MLinkEnd) container);<br/>
        } else if (<br/>
            handle instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MStereotype) {<br/>
            ((MTaggedValue) handle).setStereotype((MStereotype) container);<br/>
        } else if (<br/>
            handle instanceof MTaggedValue<br/>
                &amp;&amp; container instanceof MModelElement) {<br/>
            ((MTaggedValue) handle).setModelElement((MModelElement) container);<br/>
        } else if (<br/>
            handle instanceof MStateVertex<br/>
                &amp;&amp; container instanceof MCompositeState) {<br/>
            ((MStateVertex) handle).setContainer((MCompositeState) container);<br/>
        } else if (<br/>
            handle instanceof MElementImport<br/>
                &amp;&amp; container instanceof MPackage) {<br/>
            ((MElementImport) handle).setPackage((MPackage) container);<br/>
        } else if (<br/>
            handle instanceof MTransition &amp;&amp; container instanceof MState) {<br/>
            ((MTransition) handle).setState((MState) container);<br/>
        } else if (<br/>
            handle instanceof MState &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MState) handle).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            handle instanceof MTransition<br/>
                &amp;&amp; container instanceof MStateMachine) {<br/>
            ((MTransition) handle).setStateMachine((MStateMachine) container);<br/>
        } else if (<br/>
            handle instanceof MAction &amp;&amp; container instanceof MTransition) {<br/>
            ((MAction) handle).setTransition((MTransition) container);<br/>
        } else if (<br/>
            handle instanceof MGuard &amp;&amp; container instanceof MTransition) {<br/>
            ((MGuard) handle).setTransition((MTransition) container);<br/>
        } else if (<br/>
            handle instanceof MModelElement<br/>
                &amp;&amp; container instanceof MNamespace) {<br/>
            ((MModelElement) handle).setNamespace((MNamespace) container);<br/>
        } else {<br/>
            throw new IllegalArgumentException("handle: " + handle<br/>
                    + " or container: " + container);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a multiplicity of some model element.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param arg multiplicity as string OR multiplicity object<br/>
     */<br/>
    public void setMultiplicity(Object handle, Object arg) {<br/>
        if (arg instanceof String) {<br/>
            arg =<br/>
                ("1_N".equals(arg)) ? MMultiplicity.M1_N : MMultiplicity.M1_1;<br/>
        }<br/>
<br/>
        if (arg instanceof MMultiplicity) {<br/>
            MMultiplicity mult = (MMultiplicity) arg;<br/>
<br/>
            if (handle instanceof MAssociationRole) {<br/>
                ((MAssociationRole) handle).setMultiplicity(mult);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MClassifierRole) {<br/>
                ((MClassifierRole) handle).setMultiplicity(mult);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setMultiplicity(mult);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setMultiplicity(mult);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or arg: " + arg);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a name of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param name to set<br/>
     */<br/>
    public void setName(Object handle, String name) {<br/>
        if ((handle instanceof MModelElement) &amp;&amp; (name != null)) {<br/>
            // The following code is a workaround for issue<br/>
            // http://argouml.tigris.org/issues/show_bug.cgi?id=2847.<br/>
            // The cause is<br/>
            // not known and the best fix available for the moment is to remove<br/>
            // the corruptions as they are found.<br/>
<br/>
            int pos = 0;<br/>
            while ((pos = name.indexOf(0xffff)) &gt;= 0) {<br/>
                name =<br/>
                    name.substring(0, pos)<br/>
                    + name.substring(pos + 1, name.length());<br/>
                try {<br/>
                    throw new UmlException(<br/>
                            "Illegal character stripped out of element name");<br/>
                } catch (UmlException e) {<br/>
                    LOG.warn("0xFFFF detected in element name", e);<br/>
                }<br/>
            }<br/>
            final String safeName = name;<br/>
            <br/>
            final MModelElement modelElement = (MModelElement) handle;<br/>
<br/>
            Model.notifyMementoCreationObserver(<br/>
                new ModelMemento() {<br/>
                    String oldName = modelElement.getName();<br/>
                    public void undo() {<br/>
                        modelElement.setName(oldName);<br/>
                    }<br/>
                    public void redo() {<br/>
                        modelElement.setName(safeName);<br/>
                    }<br/>
                }<br/>
            );<br/>
            modelElement.setName(safeName);<br/>
<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or name: " + name);<br/>
    }<br/>
<br/>
    /**<br/>
     * @see org.argouml.model.CoreHelper#setBody(<br/>
     *         java.lang.Object, java.lang.String)<br/>
     */<br/>
    public void setBody(Object handle, String body) {<br/>
        if ((handle instanceof MComment) &amp;&amp; (body != null)) {<br/>
            //in UML 1.3 we store it in the name:<br/>
            ((MComment) handle).setName(body);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a namespace of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param ns is the namespace. Can be &lt;code&gt;null&lt;/code&gt;.<br/>
     */<br/>
    public void setNamespace(Object handle, Object ns) {<br/>
        if (handle instanceof MModelElement<br/>
            &amp;&amp; (ns == null || ns instanceof MNamespace)) {<br/>
            ((MModelElement) handle).setNamespace((MNamespace) ns);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or ns: " + ns);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the navigability of some association end.<br/>
     *<br/>
     * @param handle is the association end<br/>
     * @param flag is the navigability flag<br/>
     */<br/>
    public void setNavigable(Object handle, boolean flag) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) handle).setNavigable(flag);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the OrderingKind of a given AssociationEnd.<br/>
     *<br/>
     * @param handle AssociationEnd<br/>
     * @param ok OrderingKind<br/>
     */<br/>
    public void setOrdering(Object handle, Object ok) {<br/>
        if (handle instanceof MAssociationEnd &amp;&amp; ok instanceof MOrderingKind) {<br/>
            ((MAssociationEnd) handle).setOrdering((MOrderingKind) ok);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or ok: " + ok);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the owner of a Feature.<br/>
     *<br/>
     * @param handle Feature<br/>
     * @param owner Classifier or null<br/>
     */<br/>
    public void setOwner(Object handle, Object owner) {<br/>
        if (handle instanceof MFeature<br/>
            &amp;&amp; (owner == null || owner instanceof MClassifier)) {<br/>
            ((MFeature) handle).setOwner((MClassifier) owner);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or owner: " + owner);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Feature<br/>
     * @param os ScopeKind<br/>
     */<br/>
    public void setOwnerScope(Object handle, Object os) {<br/>
        if (handle instanceof MFeature<br/>
            &amp;&amp; (os == null || os instanceof MScopeKind)) {<br/>
            ((MFeature) handle).setOwnerScope((MScopeKind) os);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or os: " + os);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the parameters of a classifier, event, objectflowstate or<br/>
     * behavioralfeature.<br/>
     *<br/>
     * @param handle the classifier, event, objectflowstate or<br/>
     * behavioralfeature<br/>
     * @param parameters is a Collection of parameters<br/>
     */<br/>
    public void setParameters(Object handle, Collection parameters) {<br/>
        if (handle instanceof MObjectFlowState) {<br/>
            ((MObjectFlowState) handle).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MClassifier) {<br/>
            ((MClassifier) handle).setParameters(parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MEvent &amp;&amp; parameters instanceof List) {<br/>
            ((MEvent) handle).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MBehavioralFeature<br/>
            &amp;&amp; parameters instanceof List) {<br/>
            ((MBehavioralFeature) handle).setParameters((List) parameters);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or parameters: " + parameters);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the parent of a generalization.<br/>
     *<br/>
     * @param handle generalization<br/>
     * @param parent generalizable element (parent)<br/>
     */<br/>
    public void setParent(Object handle, Object parent) {<br/>
        if (handle instanceof MGeneralization<br/>
            &amp;&amp; parent instanceof MGeneralizableElement) {<br/>
            ((MGeneralization) handle).setParent(<br/>
                (MGeneralizableElement) parent);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or parent: " + parent);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the PowerType of a Generalization.<br/>
     * @param handle Generalization<br/>
     * @param pt Classifier<br/>
     */<br/>
    public void setPowertype(Object handle, Object pt) {<br/>
        if (handle instanceof MGeneralization<br/>
                &amp;&amp; (pt == null<br/>
                        || pt instanceof MClassifier)) {<br/>
            ((MGeneralization) handle).setPowertype((MClassifier) pt);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or pt: " + pt);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the qualified attributes of an association end.<br/>
     *<br/>
     * @param handle the association end<br/>
     * @param elems is a Collection of qualifiers<br/>
     */<br/>
    public void setQualifiers(Object handle, Collection elems) {<br/>
        if (handle instanceof MAssociationEnd &amp;&amp; elems instanceof List) {<br/>
            ((MAssociationEnd) handle).setQualifiers((List) elems);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the query flag of a behavioral feature.<br/>
     *<br/>
     * @param handle is the behavioral feature<br/>
     * @param flag is the query flag<br/>
     */<br/>
    public void setQuery(Object handle, boolean flag) {<br/>
        if (handle instanceof MBehavioralFeature) {<br/>
            ((MBehavioralFeature) handle).setQuery(flag);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle ElementResidence<br/>
     * @param resident ModelElement or null<br/>
     */<br/>
    public void setResident(Object handle, Object resident) {<br/>
        if (handle instanceof MElementResidence<br/>
            &amp;&amp; (resident == null || resident instanceof MModelElement)) {<br/>
            ((MElementResidence) handle).setResident((MModelElement) resident);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or resident: " + resident);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the residents of some model element.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param residents collection<br/>
     */<br/>
    public void setResidents(Object handle, Collection residents) {<br/>
        if (handle instanceof MNodeInstance) {<br/>
            ((MNodeInstance) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MComponentInstance) {<br/>
            ((MComponentInstance) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MNode) {<br/>
            ((MNode) handle).setResidents(residents);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets if some model element is a root.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param flag is true if it is a root<br/>
     */<br/>
    public void setRoot(Object handle, boolean flag) {<br/>
        if (handle instanceof MReception) {<br/>
            ((MReception) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MOperation) {<br/>
            ((MOperation) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
        if (handle instanceof MGeneralizableElement) {<br/>
            ((MGeneralizableElement) handle).setRoot(flag);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Flow<br/>
     * @param specifications the collection of ModelEvents (sourceFlow)<br/>
     */<br/>
    public void setSources(Object handle, Collection specifications) {<br/>
        if (handle instanceof MFlow) {<br/>
            ((MFlow) handle).setSources(specifications);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the Specification flag for a ModelElement.<br/>
     *<br/>
     * @param handle ModelElement<br/>
     * @param specification boolean<br/>
     */<br/>
    public void setSpecification(Object handle, boolean specification) {<br/>
        if (handle instanceof MModelElement) {<br/>
            ((MModelElement) handle).setSpecification(specification);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the specifications of some association end.<br/>
     *<br/>
     * @param handle the association end<br/>
     * @param specifications collection<br/>
     */<br/>
    public void setSpecifications(<br/>
        Object handle,<br/>
        Collection specifications) {<br/>
        if (handle instanceof MAssociationEnd) {<br/>
            ((MAssociationEnd) handle).setSpecifications(specifications);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the stereotype of some modelelement. The method also<br/>
     * copies a stereotype that is not a part of the current model to<br/>
     * the current model.&lt;p&gt;<br/>
     *<br/>
     * TODO: Currently does not copy the stereotype, but changes the<br/>
     * namespace to the new model (kidnapping it). That might possibly be<br/>
     * dangerous, especially if more complex profile models are developed.<br/>
     * This documentation should say what is supposed to be done. I think<br/>
     * it would have been better if the caller had been responsible for the<br/>
     * stereotype being in the right model and been adviced of<br/>
     * eg ModelManagementHelper.getCorrespondingElement(...). Or if that had<br/>
     * been used here. This function could possibly assert that the caller had<br/>
     * got it right.<br/>
     *<br/>
     * TODO: For moving towards future version of UML we should instead<br/>
     * have addStereotype and removeStereotype.<br/>
     *<br/>
     * @param handle model element<br/>
     * @param stereo stereotype<br/>
     */<br/>
    public void setStereotype(Object handle, Object stereo) {<br/>
        if (handle instanceof MModelElement<br/>
                &amp;&amp; (stereo instanceof MStereotype || stereo == null)) {<br/>
<br/>
            MModelElement me = (MModelElement) handle;<br/>
            MStereotype stereotype = (MStereotype) stereo;<br/>
<br/>
            MStereotype existingStereotype = me.getStereotype();<br/>
<br/>
            if (LOG.isInfoEnabled()) {<br/>
                if (existingStereotype == null) {<br/>
                    LOG.info("About to give a stereotype to " + handle);<br/>
                } else {<br/>
                    LOG.info("About to change stereotype on " + handle<br/>
                            + " to &lt;&lt;" + existingStereotype.getName() + "&gt;&gt;");<br/>
                }<br/>
            }<br/>
<br/>
            if (existingStereotype == stereotype) {<br/>
                LOG.info("Stereotype is already set. Do nothing.");<br/>
                return;<br/>
            }<br/>
<br/>
            if (LOG.isInfoEnabled()) {<br/>
                if (stereotype == null) {<br/>
                    LOG.info("Removing any stereotype on " + handle);<br/>
                } else {<br/>
                    LOG.info("Setting the stereotype on " + handle<br/>
                            + " to &lt;&lt;" + stereotype.getName() + "&gt;&gt;");<br/>
                }<br/>
            }<br/>
<br/>
            // With this block in place save fails with an error<br/>
            // With this block removed save appears to work but<br/>
            // the save file does not record the stereotype<br/>
            if (stereotype != null &amp;&amp; me.getModel() != stereotype.getModel()) {<br/>
                if (LOG.isInfoEnabled()) {<br/>
                    LOG.info("Changing the stereotype namespace from "<br/>
                            + stereotype.getModel() + " to " + me.getModel());<br/>
                }<br/>
                stereotype.setNamespace(me.getModel());<br/>
            }<br/>
<br/>
            me.setStereotype(stereotype);<br/>
<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or stereo: " + stereo);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a tagged value of some modelelement.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param tag is the tag name (a string)<br/>
     * @param value is the value<br/>
     */<br/>
    public void setTaggedValue(<br/>
        Object handle,<br/>
        String tag,<br/>
        String value) {<br/>
        if (handle instanceof MModelElement) {<br/>
            ((MModelElement) handle).setTaggedValue(tag, value);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the TaggedValues of a ModelElement.<br/>
     *<br/>
     * @param handle ModelElement<br/>
     * @param taggedValues Collection of TaggedValues<br/>
     */<br/>
    public void setTaggedValues(<br/>
        Object handle,<br/>
        Collection taggedValues) {<br/>
        if (handle instanceof MModelElement) {<br/>
            ((MModelElement) handle).setTaggedValues(taggedValues);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the target scope of some association end or structural feature.<br/>
     *<br/>
     * @param handle the model element<br/>
     * @param scopeKind the target scope<br/>
     */<br/>
    public void setTargetScope(Object handle, Object scopeKind) {<br/>
        if (scopeKind instanceof MScopeKind) {<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setTargetScope(<br/>
                    (MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle)<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;.setTargetScope((MScopeKind) scopeKind);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or scopeKind: " + scopeKind);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the type of some parameter.<br/>
     *<br/>
     * @param handle is the model element<br/>
     * @param type is the type (a classifier)<br/>
     */<br/>
    public void setType(Object handle, Object type) {<br/>
        if (type == null || type instanceof MClassifier) {<br/>
            if (handle instanceof MObjectFlowState) {<br/>
                ((MObjectFlowState) handle).setType((MClassifier) type);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MClassifierInState) {<br/>
                ((MClassifierInState) handle).setType((MClassifier) type);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MParameter) {<br/>
                ((MParameter) handle).setType((MClassifier) type);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MAssociationEnd) {<br/>
                ((MAssociationEnd) handle).setType((MClassifier) type);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MStructuralFeature) {<br/>
                ((MStructuralFeature) handle).setType((MClassifier) type);<br/>
                return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or type: " + type);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the UUID of this element.<br/>
     *<br/>
     * @param handle base element (MBase type)<br/>
     * @param uuid is the UUID<br/>
     */<br/>
    public void setUUID(Object handle, String uuid) {<br/>
        if (handle instanceof MBase) {<br/>
            ((MBase) handle).setUUID(uuid);<br/>
            return;<br/>
        }<br/>
    throw new IllegalArgumentException("handle: " + handle);<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the visibility of some modelelement.<br/>
     *<br/>
     * @param handle element<br/>
     * @param visibility is the visibility<br/>
     */<br/>
    public void setVisibility(Object handle, Object visibility) {<br/>
        if (visibility instanceof MVisibilityKind) {<br/>
            if (handle instanceof MModelElement) {<br/>
                ((MModelElement) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                return;<br/>
            }<br/>
            if (handle instanceof MElementResidence) {<br/>
                ((MElementResidence) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
            if (handle instanceof MElementImport) {<br/>
                ((MElementImport) handle).setVisibility(<br/>
                    (MVisibilityKind) visibility);<br/>
                    return;<br/>
            }<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or visibility: " + visibility);<br/>
    }<br/>
<br/>
    /**<br/>
     * @param handle Component<br/>
     * @param node Node<br/>
     */<br/>
    public void removeDeploymentLocation(Object handle, Object node) {<br/>
        if (handle instanceof MComponent &amp;&amp; node instanceof MNode) {<br/>
            ((MComponent) handle).removeDeploymentLocation((MNode) node);<br/>
            return;<br/>
        }<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or node: " + node);<br/>
    }<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/* (non-Javadoc)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * @see org.argouml.model.CoreHelper#addElementResidence(java.lang.Object, java.lang.Object)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; */<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public void addElementResidence(Object handle, Object residence) {<br/>
        if (handle instanceof MModelElement &amp;&amp; residence instanceof MElementResidence) {<br/>
            ((MModelElement) handle).addElementResidence((MElementResidence) residence);<br/>
            return;<br/>
        }&nbsp;&nbsp;&nbsp;&nbsp;<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or residence: " + residence);        <br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/* (non-Javadoc)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * @see org.argouml.model.CoreHelper#removeConnection(java.lang.Object, java.lang.Object)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; */<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public void removeConnection(Object handle, Object connection) {<br/>
        if (handle instanceof MAssociationRole &amp;&amp; connection instanceof MAssociationEnd) {<br/>
            ((MAssociationRole) handle).removeConnection((MAssociationEnd) connection);<br/>
            return;<br/>
        }&nbsp;&nbsp;&nbsp;&nbsp;<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or connection: " + connection);        <br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/* (non-Javadoc)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * @see org.argouml.model.CoreHelper#removeElementResidence(java.lang.Object, java.lang.Object)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; */<br/>
&nbsp;&nbsp;&nbsp;&nbsp;public void removeElementResidence(Object handle, Object residence) {<br/>
        if (handle instanceof MModelElement &amp;&amp; residence instanceof MElementResidence) {<br/>
            ((MModelElement) handle).removeElementResidence((MElementResidence) residence);<br/>
            return;<br/>
        }&nbsp;&nbsp;&nbsp;&nbsp;<br/>
        throw new IllegalArgumentException("handle: " + handle<br/>
                + " or residence: " + residence);        <br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
    /**<br/>
     * @see org.argouml.model.CoreHelper#addStereotype(java.lang.Object, java.lang.Object)<br/>
     */<br/>
    public void addStereotype(Object modelElement, Object stereo) {<br/>
        // This will never be implemented in NSUML<br/>
    }<br/>
<br/>
    /**<br/>
     * @see org.argouml.model.CoreHelper#removeStereotype(java.lang.Object, java.lang.Object)<br/>
     */<br/>
    public void removeStereotype(Object handle, Object stereo) {<br/>
        // This will never be implemented in NSUML<br/>
    }<br/>
<br/>
    <span class="add"><span class="add">/**<br/>
     * Unimplemented in UML 1.3<br/>
     * @see org.argouml.model.CoreHelper#setEnumerationLiterals(java.lang.Object, java.util.List)<br/>
     */</span><br/>
    <span class="add">public</span> <span class="add">void</span> <span class="add">setEnumerationLiterals</span>(<span class="add"><span class="add"><span class="add">Object</span></span> <span class="add">enumeration</span></span>, <span class="add"><span class="add"><span class="add">List</span></span> <span class="add">literals</span></span>) <span class="add">{<br/>
        // ILB<br/>
    }</span></span><br/>
}<br/>
</div>
</div>
</div>
<div class="clear"></div>
</div>
</body>
</html>