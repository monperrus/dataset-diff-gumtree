<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Diff result</title>
<style type="text/css">
body { width: 100%; font-size: 10pt; }
h1 { font-size: 125%; }
div.content { font-family: Verdana, "DejaVu Sans Condensed", "Liberation Sans","Nimbus Sans L", Helvetica, sans-serif; margin : 1em auto; width: 100%; }
div.left { float: left; width: 48%; padding: 1em; }
div.right { float: right; width: 48%; padding: 1em; }
div.code { font-family: "Liberation Mono", "Courrier New", monospace; border:1px solid black;}
div.clear { clear: both; }
span.del { background-color : red; font-weight: normal; font-style: normal;}
span.add { background-color : lightgreen; font-weight: bold; font-style: normal;}
span.upd { background-color : orange; font-weight: bold; font-style: italic;}
span.id { background-color : white; font-weight: normal; font-style: normal;}
span.mv { background-color : yellow; font-weight: normal; font-style: normal;}
</style></head><body><div class="content"><div class="left">
<h1>left_Server_1.925.java</h1>
<div class="code">
<div class="id">
/*<br/>
 * MegaMek -<br/>
 * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)<br/>
 *<br/>
 *  This program is free software; you can redistribute it and/or modify it<br/>
 *  under the terms of the GNU General Public License as published by the Free<br/>
 *  Software Foundation; either version 2 of the License, or (at your option)<br/>
 *  any later version.<br/>
 *<br/>
 *  This program is distributed in the hope that it will be useful, but<br/>
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<br/>
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License<br/>
 *  for more details.<br/>
 */<br/>
<br/>
package megamek.server;<br/>
<br/>
import java.io.File;<br/>
import java.io.FileInputStream;<br/>
import java.io.FileOutputStream;<br/>
import java.io.IOException;<br/>
import java.io.ObjectInputStream;<br/>
import java.io.ObjectOutputStream;<br/>
import java.net.InetAddress;<br/>
import java.net.ServerSocket;<br/>
import java.net.Socket;<br/>
import java.net.UnknownHostException;<br/>
import java.text.SimpleDateFormat;<br/>
import java.util.ArrayList;<br/>
import java.util.Collections;<br/>
import java.util.Comparator;<br/>
import java.util.Date;<br/>
import java.util.Enumeration;<br/>
import java.util.Hashtable;<br/>
import java.util.Iterator;<br/>
import java.util.StringTokenizer;<br/>
import java.util.Vector;<br/>
<br/>
import megamek.*;<br/>
import megamek.common.*;<br/>
import megamek.common.actions.*;<br/>
import megamek.server.commands.*;<br/>
import megamek.common.net.*;<br/>
import megamek.common.options.*;<br/>
import megamek.common.util.BoardUtilities;<br/>
import megamek.common.util.StringUtil;<br/>
import megamek.common.verifier.EntityVerifier;<br/>
import megamek.common.verifier.TestEntity;<br/>
import megamek.common.verifier.TestMech;<br/>
import megamek.common.verifier.TestTank;<br/>
import megamek.common.TagInfo;<br/>
import megamek.common.preference.PreferenceManager;<br/>
<br/>
/**<br/>
 * @author Ben Mazur<br/>
 */<br/>
public class Server implements Runnable {<br/>
    //    public final static String  LEGAL_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-";<br/>
    public final static String  DEFAULT_BOARD = MapSettings.BOARD_SURPRISE;<br/>
    private final static String VERIFIER_CONFIG_FILENAME =<br/>
        "data/mechfiles/UnitVerifierOptions.xml";<br/>
<br/>
    // server setup<br/>
    private String              password;<br/>
    private ServerSocket        serverSocket;<br/>
    private String              motd;<br/>
<br/>
    // game info<br/>
    private Vector              connections = new Vector(4);<br/>
    private Vector              connectionsPending = new Vector(4);<br/>
    private Hashtable           connectionIds = new Hashtable();<br/>
<br/>
    private int                 connectionCounter = 0;<br/>
    private int                 entityCounter = 0;<br/>
<br/>
    private IGame               game = new Game();<br/>
<br/>
    private Vector              vPhaseReport = new Vector();<br/>
<br/>
    private MapSettings         mapSettings = new MapSettings();<br/>
<br/>
    // commands<br/>
    private Hashtable           commandsHash = new Hashtable();<br/>
<br/>
    // listens for and connects players<br/>
    private Thread              connector;<br/>
<br/>
    // Track buildings that are affected by an entity's movement.<br/>
    private Hashtable           affectedBldgs = new Hashtable();<br/>
<br/>
    // Track Physical Action results, HACK to deal with opposing pushes <br/>
    // canceling each other<br/>
    private Vector              physicalResults = new Vector();<br/>
    <br/>
    private Vector&lt;DynamicTerrainProcessor&gt; terrainProcessors = new Vector();<br/>
    <br/>
    /* Tracks entities which have been destroyed recently.  Allows refactoring of the<br/>
     * damage and kill logic from Server, where it is now, to the Entity subclasses eventually.  <br/>
     * This has not been implemented yet -- I am just starting to build the groundwork into Server.<br/>
     * It isn't in the execution path and shouldn't cause any bugs */<br/>
    //Note from another coder - I have commented out your groundwork<br/>
    //for now because it is using HashSet, which isn't available in<br/>
    //Java 1.1 unless you import the collections classes.  Since the<br/>
    //Server class isn't using any other collecitons classes, there<br/>
    //might be a reason we're avoiding them here...if not, feel free<br/>
    //to add the import.<br/>
    //private HashSet             knownDeadEntities = new HashSet();<br/>
<br/>
    private static EntityVerifier entityVerifier = null;<br/>
<br/>
    private ConnectionListenerAdapter connectionListener = new ConnectionListenerAdapter() {<br/>
<br/>
        /**<br/>
         * Called when it is sensed that a connection has terminated.<br/>
         */<br/>
        public void disconnected(DisconnectedEvent e) {<br/>
            Connection conn = e.getConnection();<br/>
            <br/>
            // write something in the log<br/>
            System.out.println("s: connection " + conn.getId()+ " disconnected");<br/>
<br/>
            connections.removeElement(conn);<br/>
            connectionsPending.removeElement(conn);<br/>
            connectionIds.remove(new Integer(conn.getId()));<br/>
<br/>
            // if there's a player for this connection, remove it too<br/>
            Player player = getPlayer(conn.getId());<br/>
            if (null != player) {<br/>
                Server.this.disconnected( player );<br/>
            }<br/>
            <br/>
        }<br/>
<br/>
        public void packetReceived(PacketReceivedEvent e) {<br/>
            Server.this.handle(e.getConnection().getId(),e.getPacket());<br/>
        }<br/>
<br/>
    };<br/>
    <br/>
    /**<br/>
     * Construct a new GameHost and begin listening for<br/>
     * incoming clients.<br/>
     * @param   password the &lt;code&gt;String&lt;/code&gt; that is set as a password<br/>
     * @param   port the &lt;code&gt;int&lt;/code&gt; value that specifies the port that<br/>
     *          is used<br/>
     */<br/>
    public Server(String password, int port) {<br/>
        this.password = password.length() &gt; 0 ? password : null;<br/>
        // initialize server socket<br/>
        try {<br/>
            serverSocket = new ServerSocket(port);<br/>
        } catch(IOException ex) {<br/>
            System.err.println("could not create server socket on port "+port);<br/>
        }<br/>
<br/>
        motd = createMotd();<br/>
<br/>
        game.getOptions().initialize();<br/>
<br/>
        changePhase(IGame.PHASE_LOUNGE);<br/>
<br/>
        // display server start text<br/>
        System.out.println("s: starting a new server...");<br/>
<br/>
        try {<br/>
            String host = InetAddress.getLocalHost().getHostName();<br/>
            System.out.print("s: hostname = '" );<br/>
            System.out.print( host );<br/>
            System.out.print( "' port = " );<br/>
            System.out.println( serverSocket.getLocalPort() );<br/>
            InetAddress[] addresses = InetAddress.getAllByName(host);<br/>
            for (int i = 0; i &lt; addresses.length; i++) {<br/>
                System.out.println("s: hosting on address = "<br/>
                                   + addresses[i].getHostAddress());<br/>
            }<br/>
        } catch (UnknownHostException  e) {<br/>
            // oh well.<br/>
        }<br/>
<br/>
        System.out.println("s: password = " + this.password);<br/>
<br/>
        connector = new Thread(this, "Connection Listener");<br/>
        connector.start();<br/>
<br/>
        // register commands<br/>
        registerCommand(new DefeatCommand(this));<br/>
        registerCommand(new HelpCommand(this));<br/>
        registerCommand(new KickCommand(this));<br/>
        registerCommand(new ResetCommand(this));<br/>
        registerCommand(new RollCommand(this));<br/>
        registerCommand(new SaveGameCommand(this));<br/>
        registerCommand(new SkipCommand(this));<br/>
        registerCommand(new VictoryCommand(this));<br/>
        registerCommand(new WhoCommand(this));<br/>
        registerCommand(new SeeAllCommand(this));<br/>
        registerCommand(new LocalSaveGameCommand(this));<br/>
        registerCommand(new FixElevationCommand(this));<br/>
        <br/>
        //register terrain processors<br/>
        terrainProcessors.add(new FireProcessor(this));<br/>
        terrainProcessors.add(new GeyserProcessor(this));<br/>
        terrainProcessors.add(new ElevatorProcessor(this));<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the game for this server.  Restores any transient fields, and sets<br/>
     * all players as ghosts.<br/>
     * This should only be called during server initialization before any<br/>
     * players have connected.<br/>
     */<br/>
    public void setGame(IGame g) {<br/>
        this.game = g;<br/>
<br/>
        // reattach the transient fields and ghost the players<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements(); ) {<br/>
            Entity ent = (Entity)e.nextElement();<br/>
            ent.setGame(game);<br/>
        }<br/>
        game.setOutOfGameEntitiesVector(game.getOutOfGameEntitiesVector());<br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements(); ) {<br/>
            Player p = (Player)e.nextElement();<br/>
            p.setGame(game);<br/>
            p.setGhost(true);<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /** Returns the current game object */<br/>
    public IGame getGame() {<br/>
        return game;<br/>
    }<br/>
<br/>
    /**<br/>
     * Make a default message o' the day containing the version string, and<br/>
     * if it was found, the build timestamp<br/>
     */<br/>
    private String createMotd() {<br/>
        StringBuffer buf = new StringBuffer();<br/>
        buf.append("Welcome to MegaMek.  Server is running version ");<br/>
        buf.append(MegaMek.VERSION);<br/>
        buf.append(", build date ");<br/>
        if (MegaMek.TIMESTAMP &gt; 0L) {<br/>
            buf.append(new Date(MegaMek.TIMESTAMP).toString());<br/>
        } else {<br/>
            buf.append("unknown");<br/>
        }<br/>
        buf.append(".");<br/>
<br/>
        return buf.toString();<br/>
    }<br/>
<br/>
    /**<br/>
     * @return true if the server has a password<br/>
     */<br/>
    public boolean isPassworded() {<br/>
        return password != null;<br/>
    }<br/>
<br/>
    /**<br/>
     * @return true if the password matches<br/>
     */<br/>
    public boolean isPassword(Object guess) {<br/>
        return password.equals(guess);<br/>
    }<br/>
<br/>
    /**<br/>
     * Registers a new command in the server command table<br/>
     */<br/>
    private void registerCommand(ServerCommand command) {<br/>
        commandsHash.put(command.getName(), command);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the command associated with the specified name<br/>
     */<br/>
    public ServerCommand getCommand(String name) {<br/>
        return (ServerCommand)commandsHash.get(name);<br/>
    }<br/>
<br/>
    /**<br/>
     * Shuts down the server.<br/>
     */<br/>
    public void die() {<br/>
        // kill thread accepting new connections<br/>
        connector = null;<br/>
<br/>
        // close socket<br/>
        try {<br/>
            serverSocket.close();<br/>
        } catch(IOException ex) {}<br/>
<br/>
        // kill pending connnections<br/>
        for (Enumeration i=connectionsPending.elements();i.hasMoreElements();){<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.close();<br/>
        }<br/>
        connectionsPending.removeAllElements();<br/>
<br/>
        // Send "kill" commands to all connections<br/>
        // N.B. I may be starting a race here.<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            send(conn.getId(), new Packet(Packet.COMMAND_CLOSE_CONNECTION));<br/>
        }<br/>
<br/>
        // kill active connnections<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.close();<br/>
        }<br/>
        connections.removeAllElements();<br/>
        connectionIds.clear();<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns an enumeration of all the command names<br/>
     */<br/>
    public Enumeration getAllCommandNames() {<br/>
        return commandsHash.keys();<br/>
    }<br/>
<br/>
    /**<br/>
     * Sent when a client attempts to connect.<br/>
     */<br/>
    private void greeting(int cn) {<br/>
        // send server greeting -- client should reply with client info.<br/>
        sendToPending(cn, new Packet(Packet.COMMAND_SERVER_GREETING));<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a free connection id.<br/>
     */<br/>
    public int getFreeConnectionId() {<br/>
        while (getPendingConnection(connectionCounter) != null<br/>
        || getConnection(connectionCounter) != null<br/>
        || getPlayer(connectionCounter) != null) {<br/>
            connectionCounter++;<br/>
        }<br/>
        return connectionCounter;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a free entity id.  Perhaps this should be in Game instead.<br/>
     */<br/>
    public int getFreeEntityId() {<br/>
        return game.getNextEntityId();<br/>
    }<br/>
<br/>
    /**<br/>
     * Allow the player to set whatever parameters he is able to<br/>
     */<br/>
    private void receivePlayerInfo(Packet packet, int connId) {<br/>
        Player player = (Player)packet.getObject(0);<br/>
        Player connPlayer = game.getPlayer( connId );<br/>
        if ( null != connPlayer ) {<br/>
            connPlayer.setColorIndex(player.getColorIndex());<br/>
            connPlayer.setStartingPos(player.getStartingPos());<br/>
            connPlayer.setTeam(player.getTeam());<br/>
            connPlayer.setCamoCategory(player.getCamoCategory());<br/>
            connPlayer.setCamoFileName(player.getCamoFileName());<br/>
            connPlayer.setNbrMFConventional(player.getNbrMFConventional());<br/>
            connPlayer.setNbrMFCommand(player.getNbrMFCommand());<br/>
            connPlayer.setNbrMFVibra(player.getNbrMFVibra());<br/>
        }<br/>
    }<br/>
<br/>
    private String correctDupeName(String oldName) {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            Player player = (Player)i.nextElement();<br/>
            if (player.getName().equals(oldName)) {<br/>
                // We need to correct it.<br/>
                String newName = oldName;<br/>
                int dupNum = 2;<br/>
                try {<br/>
                    dupNum = Integer.parseInt(oldName.substring(oldName.lastIndexOf(".")+1));<br/>
                    dupNum++;<br/>
                    newName = oldName.substring(0,oldName.lastIndexOf("."));<br/>
                } catch (Exception e) {<br/>
                    // If this fails, we don't care much.<br/>
                    // Just assume it's the first time for this name.<br/>
                    dupNum = 2;<br/>
                }<br/>
                newName = newName.concat(".").concat(Integer.toString(dupNum));<br/>
                return correctDupeName(newName);<br/>
            }<br/>
        }<br/>
        return oldName;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recieves a player name, sent from a pending connection, and connects<br/>
     * that connection.<br/>
     */<br/>
    private void receivePlayerName(Packet packet, int connId) {<br/>
        final Connection conn = getPendingConnection(connId);<br/>
        String name = (String)packet.getObject(0);<br/>
        boolean returning = false;<br/>
<br/>
        // this had better be from a pending connection<br/>
        if (conn == null) {<br/>
            System.out.println("server: got a client name from a non-pending" +<br/>
                               " connection");<br/>
            return;<br/>
        }<br/>
<br/>
        // check if they're connecting with the same name as a ghost player<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            Player player = (Player)i.nextElement();<br/>
            if (player.getName().equals(name)) {<br/>
                if (player.isGhost()) {<br/>
                    returning = true;<br/>
                    player.setGhost(false);<br/>
                    // switch id<br/>
                    connId = player.getId();<br/>
                    conn.setId(connId);<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        if (!returning) {<br/>
            // Check to avoid duplicate names...<br/>
            name = correctDupeName(name);<br/>
            send(connId, new Packet(Packet.COMMAND_SERVER_CORRECT_NAME, name));<br/>
        }<br/>
<br/>
        // right, switch the connection into the "active" bin<br/>
        connectionsPending.removeElement(conn);<br/>
        connections.addElement(conn);<br/>
        connectionIds.put(new Integer(conn.getId()), conn);<br/>
<br/>
        // add and validate the player info<br/>
        if (!returning) {<br/>
            game.addPlayer(connId, new Player(connId, name));<br/>
            validatePlayerInfo(connId);<br/>
        }<br/>
<br/>
        // if it is not the lounge phase, this player becomes an observer<br/>
        Player player = getPlayer( connId );<br/>
        if ( game.getPhase() != IGame.PHASE_LOUNGE<br/>
             &amp;&amp; null != player<br/>
             &amp;&amp; game.getEntitiesOwnedBy(player) &lt; 1) {<br/>
            player.setObserver(true);<br/>
        }<br/>
<br/>
        // send the player the motd<br/>
        sendServerChat(connId, motd);<br/>
<br/>
        // send info that the player has connected<br/>
        send(createPlayerConnectPacket(connId));<br/>
<br/>
        // tell them their local playerId<br/>
        send(connId, new Packet(Packet.COMMAND_LOCAL_PN, new Integer(connId)));<br/>
<br/>
        // send current game info<br/>
        sendCurrentInfo(connId);<br/>
<br/>
        try {<br/>
            InetAddress[] addresses = InetAddress.getAllByName(InetAddress<br/>
                                                               .getLocalHost()<br/>
                                                               .getHostName());<br/>
            for (int i = 0; i &lt; addresses.length; i++) {<br/>
                sendServerChat(connId, "Machine IP is " +<br/>
                               addresses[i].getHostAddress());<br/>
            }<br/>
        } catch (UnknownHostException  e) {<br/>
            // oh well.<br/>
        }<br/>
<br/>
        // Send the port we're listening on. Only useful for the player<br/>
        // on the server machine to check.<br/>
        sendServerChat(connId, "Listening on port " + serverSocket<br/>
                                                      .getLocalPort());<br/>
<br/>
        // Get the player *again*, because they may have disconnected.<br/>
        player = getPlayer( connId );<br/>
        if ( null != player ) {<br/>
            StringBuffer buff = new StringBuffer();<br/>
            buff.append( player.getName() )<br/>
                .append( " connected from " )<br/>
                .append( getClient(connId).getInetAddress() );<br/>
            String who = buff.toString();<br/>
            System.out.print( "s: player #" );<br/>
            System.out.print( connId );<br/>
            System.out.print( ", " );<br/>
            System.out.println( who );<br/>
<br/>
            sendServerChat( who );<br/>
<br/>
        } // Found the player<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends a player the info they need to look at the current phase.<br/>
     * This is triggered when a player first connects to the server.<br/>
     */<br/>
    private void sendCurrentInfo(int connId) {<br/>
        //why are these two outside the player != null check below?<br/>
        transmitAllPlayerConnects(connId);<br/>
        send(connId, createGameSettingsPacket());<br/>
<br/>
        Player player = game.getPlayer(connId);<br/>
        if ( null != player ) {<br/>
            send(connId, new Packet(Packet.COMMAND_SENDING_MINEFIELDS,<br/>
                                    player.getMinefields()));<br/>
<br/>
            switch (game.getPhase()) {<br/>
            case IGame.PHASE_LOUNGE :<br/>
                send(connId, createMapSettingsPacket());<br/>
                // Send Entities *after* the Lounge Phase Change<br/>
                send(connId, new Packet(Packet.COMMAND_PHASE_CHANGE,<br/>
                                        new Integer(game.getPhase())));<br/>
                if (doBlind()) {<br/>
                    send(connId, createFilteredFullEntitiesPacket(player));<br/>
                }<br/>
                else {<br/>
                    send(connId, createFullEntitiesPacket());<br/>
                }<br/>
                break;<br/>
            default :<br/>
                send(connId, new Packet(Packet.COMMAND_ROUND_UPDATE, new Integer(game.getRoundCount())));<br/>
                //send(connId, createReportPacket(player));<br/>
                send(connId, createAllReportsPacket(player));<br/>
<br/>
                // Send Entites *before* other phase changes.<br/>
                if (doBlind()) {<br/>
                    send(connId, createFilteredFullEntitiesPacket(player));<br/>
                }<br/>
                else {<br/>
                    send(connId, createFullEntitiesPacket());<br/>
                }<br/>
                player.setDone( game.getEntitiesOwnedBy(player) &lt;= 0 );<br/>
                send(connId, createBoardPacket());<br/>
                send(connId, new Packet(Packet.COMMAND_PHASE_CHANGE,<br/>
                                        new Integer(game.getPhase())));<br/>
                break;<br/>
            }<br/>
            if (game.getPhase() == IGame.PHASE_FIRING ||<br/>
                game.getPhase() == IGame.PHASE_TARGETING ||<br/>
                game.getPhase() == IGame.PHASE_OFFBOARD ||<br/>
                game.getPhase() == IGame.PHASE_PHYSICAL) {<br/>
                // can't go above, need board to have been sent<br/>
                send(connId,createAttackPacket(game.getActionsVector(),0));<br/>
                send(connId,createAttackPacket(game.getChargesVector(),1));<br/>
                send(connId,createAttackPacket(game.getLayMinefieldActionsVector(),2));<br/>
            }<br/>
            if (game.phaseHasTurns(game.getPhase())) {<br/>
                send(connId, createTurnVectorPacket());<br/>
                send(connId, createTurnIndexPacket());<br/>
            }<br/>
            <br/>
            send(connId, createArtilleryPacket(player));<br/>
            send(connId, createFlarePacket());<br/>
<br/>
        } // Found the player.<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Validates the player info.<br/>
     */<br/>
    public void validatePlayerInfo(int playerId) {<br/>
        final Player player = getPlayer(playerId);<br/>
<br/>
        //        maybe this isn't actually useful<br/>
        //        // replace characters we don't like with "X"<br/>
        //        StringBuffer nameBuff = new StringBuffer(player.getName());<br/>
        //        for (int i = 0; i &lt; nameBuff.length(); i++) {<br/>
        //            int chr = nameBuff.charAt(i);<br/>
        //            if (LEGAL_CHARS.indexOf(chr) == -1) {<br/>
        //                nameBuff.setCharAt(i, 'X');<br/>
        //            }<br/>
        //        }<br/>
        //        player.setName(nameBuff.toString());<br/>
<br/>
        //TODO: check for duplicate or reserved names<br/>
<br/>
        // make sure colorIndex is unique<br/>
        boolean[] colorUsed = new boolean[Player.colorNames.length];<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player otherPlayer = (Player)i.nextElement();<br/>
            if (otherPlayer.getId() != playerId) {<br/>
                colorUsed[otherPlayer.getColorIndex()] = true;<br/>
            }<br/>
        }<br/>
        if (null != player &amp;&amp; colorUsed[player.getColorIndex()]) {<br/>
            // find a replacement color;<br/>
            for (int i = 0; i &lt; colorUsed.length; i++) {<br/>
                if (!colorUsed[i]) {<br/>
                    player.setColorIndex(i);<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Called when it's been determined that an actual player<br/>
     * disconnected.  Notifies the other players and does the appropriate<br/>
     * housekeeping.<br/>
     */<br/>
    void disconnected(Player player) {<br/>
        int phase = game.getPhase();<br/>
<br/>
        // in the lounge, just remove all entities for that player<br/>
        if (phase == IGame.PHASE_LOUNGE) {<br/>
            removeAllEntitesOwnedBy(player);<br/>
        }<br/>
<br/>
        // if a player has active entities, he becomes a ghost<br/>
        // except the VICTORY_PHASE when the dosconnected <br/>
        // player is most likely the Bot disconnected after receiving<br/>
        // the COMMAND_END_OF_GAME command <br/>
        // see the Bug 1225949.<br/>
        // TODO Perhaps there is a better solution to handle the Bot disconnect<br/>
        if (game.getEntitiesOwnedBy(player) &gt; 0 &amp;&amp; phase != IGame.PHASE_VICTORY) {<br/>
            player.setGhost(true);<br/>
            player.setDone(true);<br/>
            send(createPlayerUpdatePacket(player.getId()));<br/>
        } else {<br/>
            game.removePlayer(player.getId());<br/>
            send(new Packet(Packet.COMMAND_PLAYER_REMOVE,<br/>
                 new Integer(player.getId())));<br/>
        }<br/>
<br/>
        // make sure the game advances<br/>
        if ( game.phaseHasTurns(game.getPhase()) &amp;&amp; null != game.getTurn() ) {<br/>
            if ( game.getTurn().isValid( player.getId(), game ) ) {<br/>
                sendGhostSkipMessage( player );<br/>
            }<br/>
        } else {<br/>
            checkReady();<br/>
        }<br/>
<br/>
        // notify other players<br/>
        sendServerChat(player.getName() + " disconnected.");<br/>
<br/>
        // log it<br/>
        System.out.println("s: removed player " + player.getName());<br/>
<br/>
        // Reset the game after Elvis has left the building.<br/>
        if ( 0 == game.getNoOfPlayers() ) {<br/>
            resetGame();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks each player to see if he has no entities, and if true, sets the<br/>
     * observer flag for that player.  An exception is that there are no<br/>
     * observers during the lounge phase.<br/>
     */<br/>
    public void checkForObservers() {<br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements(); ) {<br/>
            Player p = (Player)e.nextElement();<br/>
            p.setObserver(game.getEntitiesOwnedBy(p) &lt; 1 &amp;&amp;<br/>
                          game.getPhase() != IGame.PHASE_LOUNGE);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Reset the game back to the lounge.<br/>
     *<br/>
     * TODO: couldn't this be a hazard if there are other things executing at<br/>
     *  the same time?<br/>
     */<br/>
    public void resetGame() {<br/>
        // remove all entities<br/>
        game.reset();<br/>
        send(createEntitiesPacket());<br/>
        send(new Packet(Packet.COMMAND_SENDING_MINEFIELDS, new Vector()));<br/>
<br/>
        //TODO: remove ghosts<br/>
<br/>
        // reset all players<br/>
        resetPlayersDone();<br/>
        transmitAllPlayerDones();<br/>
<br/>
        // Write end of game to stdout so controlling scripts can rotate logs.<br/>
        SimpleDateFormat format = new SimpleDateFormat<br/>
            ( "yyyy-MM-dd HH:mm:ss z" );<br/>
        System.out.print( format.format(new Date()) );<br/>
        System.out.println( " END OF GAME" );<br/>
<br/>
        changePhase(IGame.PHASE_LOUNGE);<br/>
    }<br/>
<br/>
    <br/>
    /**<br/>
     * automatically save the game <br/>
     */<br/>
    public void autoSave() {<br/>
        String fileName = "autosave";<br/>
        if (PreferenceManager.getClientPreferences().stampFilenames()) {<br/>
            fileName = StringUtil.addDateTimeStamp(fileName);<br/>
        }<br/>
        saveGame(fileName,game.getOptions().booleanOption("autosave_msg"));<br/>
    }<br/>
<br/>
    /**<br/>
     * save the game and send it to the sepecified connection<br/>
     * @param connId The &lt;code&gt;int&lt;/code&gt; connection id to send to<br/>
     * @param sFile  The &lt;code&gt;String&lt;/code&gt; filename to use<br/>
     */<br/>
    public void sendSaveGame (int connId, String sFile) {<br/>
        saveGame(sFile, false);<br/>
        String sFinalFile = sFile;<br/>
        if (!sFinalFile.endsWith(".sav")) {<br/>
            sFinalFile = sFile + ".sav";<br/>
        }<br/>
        sFinalFile = "savegames" + File.separator + sFinalFile;<br/>
        File f = new File(sFinalFile);<br/>
        try {<br/>
            ObjectInputStream ois = new ObjectInputStream(<br/>
                new FileInputStream(f));<br/>
            send(connId,new Packet(Packet.COMMAND_SEND_SAVEGAME, new Object[] {sFinalFile, ois.readObject()}));<br/>
            sendChat(connId,"***Server","Savegame has been sent to you.");<br/>
            ois.close();<br/>
        } catch (Exception e) {<br/>
            System.err.println("Unable to load file: " + f);<br/>
            e.printStackTrace();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * save the game<br/>
     * @param sFile   The &lt;code&gt;String&lt;/code&gt; filename to use<br/>
     * @param sendChat A &lt;code&gt;boolean&lt;/code&gt; value wether or not to announce<br/>
     *                 the saving to the server chat. <br/>
     */<br/>
    public void saveGame(String sFile, boolean sendChat) {<br/>
        String sFinalFile = sFile;<br/>
        if (!sFinalFile.endsWith(".sav")) {<br/>
            sFinalFile = sFile + ".sav";<br/>
        }<br/>
        try {<br/>
            File sDir = new File("savegames");<br/>
            if (!sDir.exists()) {<br/>
                sDir.mkdir();<br/>
            }<br/>
            sFinalFile = sDir + File.separator + sFinalFile;<br/>
            ObjectOutputStream oos = new ObjectOutputStream(<br/>
                    new FileOutputStream(sFinalFile));<br/>
            oos.writeObject(game);<br/>
            oos.flush();<br/>
            oos.close();<br/>
        } catch (Exception e) {<br/>
            System.err.println("Unable to save file: " + sFinalFile);<br/>
            e.printStackTrace();<br/>
        }<br/>
<br/>
        if (sendChat) sendChat("MegaMek", "Game saved to " + sFinalFile);<br/>
    }<br/>
<br/>
    /**<br/>
     * save the game<br/>
     * @param sFile   The &lt;code&gt;String&lt;/code&gt; filename to use<br/>
     */<br/>
    public void saveGame(String sFile) {<br/>
        saveGame(sFile,true);<br/>
    }<br/>
<br/>
    /**<br/>
     * load the game<br/>
     * @param f The &lt;code&gt;File&lt;/code&gt; to load<br/>
     * @return A &lt;code&gt;boolean&lt;/code&gt; value wether or not the loading was successfull<br/>
     */<br/>
    public boolean loadGame(File f) {<br/>
        System.out.println("s: loading saved game file '"+f+"'");<br/>
        try {<br/>
            ObjectInputStream ois = new ObjectInputStream(<br/>
                    new FileInputStream(f));<br/>
            game = (IGame)ois.readObject();<br/>
            ois.close();<br/>
        } catch (Exception e) {<br/>
            System.err.println("Unable to load file: " + f);<br/>
            e.printStackTrace();<br/>
            return false;<br/>
        }<br/>
<br/>
        // a bit redundant, but there's some initialization code there<br/>
        setGame(game);<br/>
<br/>
        return true;<br/>
    }<br/>
<br/>
    /**<br/>
     * Shortcut to game.getPlayer(id)<br/>
     */<br/>
    public Player getPlayer(int id) {<br/>
        return game.getPlayer(id);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes all entities owned by a player.  Should only be called when it<br/>
     * won't cause trouble (the lounge, for instance, or between phases.)<br/>
     * @param the &lt;code&gt;Player&lt;/code&gt; whose entites are to be removed<br/>
     */<br/>
    private void removeAllEntitesOwnedBy(Player player) {<br/>
        Vector toRemove = new Vector();<br/>
<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            if (entity.getOwner().equals(player)) {<br/>
                toRemove.addElement(entity);<br/>
            }<br/>
        }<br/>
<br/>
        for (Enumeration e = toRemove.elements(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            int id = entity.getId();<br/>
            game.removeEntity(id, IEntityRemovalConditions.REMOVE_NEVER_JOINED);<br/>
            send(createRemoveEntityPacket(id, IEntityRemovalConditions.REMOVE_NEVER_JOINED));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * a shorter name for getConnection()<br/>
     */<br/>
    private Connection getClient(int connId) {<br/>
        return getConnection(connId);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a connection, indexed by id<br/>
     */<br/>
    public Enumeration getConnections() {<br/>
        return connections.elements();<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a connection, indexed by id<br/>
     */<br/>
    public Connection getConnection(int connId) {<br/>
        return (Connection)connectionIds.get(new Integer(connId));<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a pending connection<br/>
     */<br/>
    private Connection getPendingConnection(int connId) {<br/>
        for (Enumeration i=connectionsPending.elements();i.hasMoreElements();){<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
<br/>
            if (conn.getId() == connId) {<br/>
                return conn;<br/>
            }<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of each game round to reset values on this<br/>
     * entity that are reset every round<br/>
     */<br/>
    private void resetEntityRound() {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
<br/>
            entity.newRound(game.getRoundCount());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of each phase.  Sets and resets<br/>
     * any entity parameters that need to be reset.<br/>
     */<br/>
    private void resetEntityPhase(int phase) {<br/>
        // first, mark doomed entities as destroyed and flag them<br/>
        Vector toRemove = new Vector(0, 10);<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            if (entity.crew.isDoomed()) {<br/>
                entity.crew.setDead(true);<br/>
                entity.setDestroyed(true);<br/>
            }<br/>
<br/>
            if (entity.isDoomed()) {<br/>
                entity.setDestroyed(true);<br/>
<br/>
                // Is this unit swarming somebody?  Better let go before<br/>
                //  it's too late.<br/>
                final int swarmedId = entity.getSwarmTargetId();<br/>
                if ( Entity.NONE != swarmedId ) {<br/>
                    final Entity swarmed = game.getEntity( swarmedId );<br/>
                    swarmed.setSwarmAttackerId( Entity.NONE );<br/>
                    entity.setSwarmTargetId( Entity.NONE );<br/>
                    Report r = new Report(5165);<br/>
                    r.subject = swarmedId;<br/>
                    r.addDesc(swarmed);<br/>
                    addReport(r);<br/>
                    this.entityUpdate( swarmedId );<br/>
                }<br/>
            }<br/>
<br/>
            if (entity.isDestroyed() || entity.getCrew().isDead()) {<br/>
                toRemove.addElement(entity);<br/>
            }<br/>
        }<br/>
<br/>
        // actually remove all flagged entities<br/>
        for (Enumeration e = toRemove.elements(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;<br/>
            if ( !entity.isSalvage() ) {<br/>
                condition = IEntityRemovalConditions.REMOVE_DEVASTATED;<br/>
            }<br/>
<br/>
            this.entityUpdate(entity.getId());<br/>
            game.removeEntity(entity.getId(), condition);<br/>
            send( createRemoveEntityPacket(entity.getId(), condition) );<br/>
        }<br/>
<br/>
        // do some housekeeping on all the remaining<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            entity.applyDamage();<br/>
<br/>
            entity.reloadEmptyWeapons();<br/>
<br/>
            // reset damage this phase<br/>
            entity.damageThisPhase = 0;<br/>
            entity.engineHitsThisRound = 0;<br/>
            entity.rolledForEngineExplosion = false;<br/>
            entity.dodging = false;<br/>
<br/>
            // reset done to false<br/>
<br/>
            if ( phase == IGame.PHASE_DEPLOYMENT ) {<br/>
                entity.setDone(!entity.shouldDeploy(game.getRoundCount()));<br/>
            } else {<br/>
                entity.setDone(false);<br/>
            }<br/>
            <br/>
            // reset spotlights<br/>
            entity.setIlluminated(false);<br/>
            entity.setUsedSearchlight(false);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every player not ready.<br/>
     */<br/>
    private void resetPlayersDone() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            player.setDone(false);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every active player not ready.<br/>
     */<br/>
    private void resetActivePlayersDone() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            player.setDone(game.getEntitiesOwnedBy(player) &lt;= 0);<br/>
<br/>
        }<br/>
        transmitAllPlayerDones();<br/>
    }<br/>
<br/>
    /**<br/>
     * Writes the victory report<br/>
     */<br/>
    private void prepareVictoryReport() {<br/>
        Report r;<br/>
<br/>
        addReport(new Report(7000, Report.PUBLIC));<br/>
<br/>
        //Declare the victor<br/>
        r = new Report(1210);<br/>
        r.type = Report.PUBLIC;<br/>
        if (game.getVictoryTeam() == Player.TEAM_NONE) {<br/>
            Player player = getPlayer( game.getVictoryPlayerId() );<br/>
            if ( null == player ) {<br/>
                r.messageId = 7005;<br/>
            } else {<br/>
                r.messageId = 7010;<br/>
                r.add(player.getName());<br/>
            }<br/>
        } else {<br/>
            //Team victory<br/>
            r.messageId = 7015;<br/>
            r.add(game.getVictoryTeam());<br/>
        }<br/>
        addReport(r);<br/>
<br/>
        //List the survivors<br/>
        Enumeration survivors = game.getEntities();<br/>
        if ( survivors.hasMoreElements() ) {<br/>
            addReport(new Report(7020, Report.PUBLIC));<br/>
            while ( survivors.hasMoreElements() ) {<br/>
                Entity entity = (Entity) survivors.nextElement();<br/>
<br/>
                if ( !entity.isDeployed() )<br/>
                  continue;<br/>
<br/>
                addReport( entity.victoryReport());<br/>
            }<br/>
        }<br/>
        //List units that never deployed<br/>
        Enumeration undeployed = game.getEntities();<br/>
        if ( undeployed.hasMoreElements() ) {<br/>
            boolean wroteHeader = false;<br/>
<br/>
            while ( undeployed.hasMoreElements() ) {<br/>
                Entity entity = (Entity) undeployed.nextElement();<br/>
<br/>
                if ( entity.isDeployed() )<br/>
                  continue;<br/>
<br/>
                if ( !wroteHeader ) {<br/>
                  addReport(new Report(7075, Report.PUBLIC));<br/>
                  wroteHeader = true;<br/>
                }<br/>
<br/>
                addReport( entity.victoryReport());<br/>
            }<br/>
        }<br/>
        //List units that retreated<br/>
        Enumeration retreat = game.getRetreatedEntities();<br/>
        if ( retreat.hasMoreElements() ) {<br/>
            addReport(new Report(7080, Report.PUBLIC));<br/>
            while ( retreat.hasMoreElements() ) {<br/>
                Entity entity = (Entity) retreat.nextElement();<br/>
                addReport( entity.victoryReport());<br/>
            }<br/>
        }<br/>
        //List destroyed units<br/>
        Enumeration graveyard = game.getGraveyardEntities();<br/>
        if ( graveyard.hasMoreElements() ) {<br/>
            addReport(new Report(7085, Report.PUBLIC));<br/>
            while ( graveyard.hasMoreElements() ) {<br/>
                Entity entity = (Entity) graveyard.nextElement();<br/>
                addReport( entity.victoryReport());<br/>
            }<br/>
        }<br/>
        //List devastated units (not salvagable)<br/>
        Enumeration devastated = game.getDevastatedEntities();<br/>
        if ( devastated.hasMoreElements() ) {<br/>
            addReport(new Report(7090, Report.PUBLIC));<br/>
<br/>
            while ( devastated.hasMoreElements() ) {<br/>
                Entity entity = (Entity) devastated.nextElement();<br/>
                addReport( entity.victoryReport());<br/>
            }<br/>
        }<br/>
        //Let player know about entitystatus.txt file<br/>
        addReport(new Report(7095, Report.PUBLIC));<br/>
    }<br/>
<br/>
    /**<br/>
     * Generates a detailed report for campaign use<br/>
     */<br/>
    private String getDetailedVictoryReport() {<br/>
        StringBuffer sb = new StringBuffer();<br/>
<br/>
        Vector vAllUnits = new Vector();<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
<br/>
        for ( Enumeration i = game.getRetreatedEntities();<br/>
              i.hasMoreElements(); ) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
<br/>
        for ( Enumeration i = game.getGraveyardEntities();<br/>
              i.hasMoreElements(); ) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
<br/>
            // Record the player.<br/>
            Player p = (Player)i.nextElement();<br/>
            sb.append("++++++++++ " )<br/>
                .append( p.getName() )<br/>
                .append( " ++++++++++");<br/>
            sb.append( CommonConstants.NL );<br/>
<br/>
            // Record the player's alive, retreated, or salvageable units.<br/>
            for (int x = 0; x &lt; vAllUnits.size(); x++) {<br/>
                Entity e = (Entity)vAllUnits.elementAt(x);<br/>
                if (e.getOwner() == p) {<br/>
                    sb.append(UnitStatusFormatter.format(e));<br/>
                }<br/>
            }<br/>
<br/>
            // Record the player's devastated units.<br/>
            Enumeration devastated = game.getDevastatedEntities();<br/>
            if ( devastated.hasMoreElements() ) {<br/>
                sb.append("=============================================================");<br/>
                sb.append( CommonConstants.NL );<br/>
                sb.append("The following utterly destroyed units are not available for salvage:");<br/>
                sb.append( CommonConstants.NL );<br/>
                while ( devastated.hasMoreElements() ) {<br/>
                    Entity e = (Entity) devastated.nextElement();<br/>
                    if (e.getOwner() == p) {<br/>
                        sb.append( e.getShortName() )<br/>
                            .append( ", Pilot: " )<br/>
                            .append( e.getCrew().getName() )<br/>
                            .append( " (" )<br/>
                            .append( e.getCrew().getGunnery() )<br/>
                            .append( "/" )<br/>
                            .append( e.getCrew().getPiloting() )<br/>
                            .append( ")" );<br/>
                        sb.append( CommonConstants.NL );<br/>
                    }<br/>
                } // Handle the next unsalvageable unit for the player<br/>
                sb.append("=============================================================");<br/>
                sb.append( CommonConstants.NL );<br/>
            }<br/>
<br/>
        } // Handle the next player<br/>
<br/>
        return sb.toString();<br/>
    }<br/>
<br/>
    /**<br/>
     * Forces victory for the specified player, or his/her team at the end of<br/>
     * the round.<br/>
     */<br/>
    public void forceVictory(Player victor) {<br/>
        game.setForceVictory(true);<br/>
        if (victor.getTeam() == Player.TEAM_NONE) {<br/>
            game.setVictoryPlayerId(victor.getId());<br/>
            game.setVictoryTeam(Player.TEAM_NONE);<br/>
        } else {<br/>
            game.setVictoryPlayerId(Player.PLAYER_NONE);<br/>
            game.setVictoryTeam(victor.getTeam());<br/>
        }<br/>
<br/>
        Vector players = game.getPlayersVector();<br/>
        for (int i = 0; i &lt; players.size(); i++) {<br/>
            Player player = (Player) players.elementAt(i);<br/>
            player.setAdmitsDefeat(false);<br/>
        }<br/>
    }<br/>
<br/>
    /** Cancels the force victory */<br/>
    public void cancelVictory() {<br/>
        game.setForceVictory(false);<br/>
        game.setVictoryPlayerId(Player.PLAYER_NONE);<br/>
        game.setVictoryTeam(Player.TEAM_NONE);<br/>
    }<br/>
<br/>
    /**<br/>
     * Called when a player declares that he is "done."  Checks to see if all<br/>
     * players are done, and if so, moves on to the next phase.<br/>
     */<br/>
    private void checkReady() {<br/>
        // check if all active players are done<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if (!player.isGhost() &amp;&amp; !player.isObserver() &amp;&amp; !player.isDone()) {<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // Tactical Genius pilot special ability (lvl 3)<br/>
        if (game.getNoOfInitiativeRerollRequests() &gt; 0) {<br/>
            resetActivePlayersDone();<br/>
            game.rollInitAndResolveTies();<br/>
<br/>
            determineTurnOrder(IGame.PHASE_INITIATIVE);<br/>
            clearReports();<br/>
            writeInitiativeReport(true);<br/>
            sendReport(true);<br/>
            return;  // don't end the phase yet, players need to see new report<br/>
        }<br/>
<br/>
        // need at least one entity in the game for the lounge phase to end<br/>
        if (!game.phaseHasTurns(game.getPhase()) &amp;&amp;<br/>
                (game.getPhase() != IGame.PHASE_LOUNGE || game.getNoOfEntities() &gt; 0)) {<br/>
            endCurrentPhase();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called when the current player has done his current turn and the turn<br/>
     * counter needs to be advanced.<br/>
     * Also enforces the "protos_move_multi" and the "protos_move_multi"<br/>
     * option.  If the player has just moved infantry/protos with a "normal"<br/>
     * turn, adds up to Game.INF_AND_PROTOS_MOVE_MULTI - 1 more<br/>
     * infantry/proto-specific turns after the current turn.<br/>
     */<br/>
    private void endCurrentTurn(Entity entityUsed) {<br/>
<br/>
        // Enforce "inf_move_multi" and "protos_move_multi" options.<br/>
        // The "isNormalTurn" flag is checking to see if any non-Infantry<br/>
        // or non-Protomech units can move during the current turn.<br/>
        boolean turnsChanged = false;<br/>
        GameTurn turn = game.getTurn();<br/>
        final int playerId = (null == entityUsed) ?<br/>
            Player.PLAYER_NONE : entityUsed.getOwnerId();<br/>
        boolean infMoved = entityUsed instanceof Infantry;<br/>
        boolean infMoveMulti =<br/>
            game.getOptions().booleanOption("inf_move_multi")<br/>
            &amp;&amp; (game.getPhase() == IGame.PHASE_MOVEMENT<br/>
                || game.getPhase() == IGame.PHASE_INITIATIVE);<br/>
        boolean protosMoved = entityUsed instanceof Protomech;<br/>
        boolean protosMoveMulti =<br/>
            game.getOptions().booleanOption("protos_move_multi");<br/>
<br/>
        // If infantry or protos move multi see if any<br/>
        // other unit types can move in the current turn.<br/>
        int multiMask = 0;<br/>
        if ( infMoveMulti ) {<br/>
            multiMask += GameTurn.CLASS_INFANTRY;<br/>
        }<br/>
        if ( protosMoveMulti ) {<br/>
            multiMask += GameTurn.CLASS_PROTOMECH;<br/>
        }<br/>
<br/>
        // If a proto declared fire and protos don't move<br/>
        // multi, ignore whether infantry move or not.<br/>
        else if ( protosMoved &amp;&amp; game.getPhase() == IGame.PHASE_FIRING ) {<br/>
            multiMask = 0;<br/>
        }<br/>
<br/>
        // Is this a general move turn?<br/>
        boolean isGeneralMoveTurn =<br/>
            ( !(turn instanceof GameTurn.SpecificEntityTurn) &amp;&amp;<br/>
              !(turn instanceof GameTurn.UnitNumberTurn) &amp;&amp;<br/>
              !(turn instanceof GameTurn.UnloadStrandedTurn) &amp;&amp;<br/>
              ( !(turn instanceof GameTurn.EntityClassTurn) ||<br/>
                ( (turn instanceof GameTurn.EntityClassTurn) &amp;&amp;<br/>
                  ( (GameTurn.EntityClassTurn) turn ).isValidClass(~multiMask)<br/>
                  )<br/>
                )<br/>
              );<br/>
<br/>
        // Unless overridden by the "protos_move_multi" option, all Protomechs<br/>
        // in a unit declare fire, and they don't mix with infantry.<br/>
        if ( protosMoved &amp;&amp; !protosMoveMulti &amp;&amp; isGeneralMoveTurn &amp;&amp;<br/>
             game.getPhase() == IGame.PHASE_FIRING ) {<br/>
<br/>
            // What's the unit number and ID of the entity used?<br/>
            final char movingUnit = entityUsed.getUnitNumber();<br/>
            final int movingId = entityUsed.getId();<br/>
<br/>
            // How many other Protomechs are in the unit that can fire?<br/>
            int protoTurns = game.getSelectedEntityCount<br/>
                ( new EntitySelector() {<br/>
                        private final int ownerId = playerId;<br/>
                        private final int entityId = movingId;<br/>
                        private final char unitNum = movingUnit;<br/>
                        public boolean accept( Entity entity ) {<br/>
                            if ( entity instanceof Protomech &amp;&amp;<br/>
                                 entity.isSelectableThisTurn() &amp;&amp;<br/>
                                 ownerId == entity.getOwnerId() &amp;&amp;<br/>
                                 entityId != entity.getId() &amp;&amp;<br/>
                                 unitNum == entity.getUnitNumber() )<br/>
                                return true;<br/>
                            return false;<br/>
                        }<br/>
                    } );<br/>
<br/>
            // Add the correct number of turns for the Protomech unit number.<br/>
            for (int i = 0; i &lt; protoTurns; i++) {<br/>
                GameTurn newTurn = new GameTurn.UnitNumberTurn<br/>
                    ( playerId, movingUnit );<br/>
                game.insertNextTurn(newTurn);<br/>
                turnsChanged = true;<br/>
            }<br/>
        }<br/>
<br/>
        // Otherwise, we may need to add turns for the "*_move_multi" options.<br/>
        else if ( ( (infMoved &amp;&amp; infMoveMulti) ||<br/>
                    (protosMoved &amp;&amp; protosMoveMulti) ) &amp;&amp;<br/>
                  isGeneralMoveTurn ) {<br/>
            int remaining = 0;<br/>
<br/>
            // Calculate the number of EntityClassTurns need to be added.<br/>
            if ( infMoveMulti ) {<br/>
                remaining += game.getInfantryLeft(playerId);<br/>
            }<br/>
            if ( protosMoveMulti ) {<br/>
                remaining += game.getProtomechsLeft(playerId);<br/>
            }<br/>
            int moreInfAndProtoTurns =<br/>
                Math.min(game.getOptions().intOption("inf_proto_move_multi") - 1, remaining);<br/>
<br/>
            // Add the correct number of turns for the right unit classes.<br/>
            for (int i = 0; i &lt; moreInfAndProtoTurns; i++) {<br/>
                GameTurn newTurn =<br/>
                    new GameTurn.EntityClassTurn( playerId, multiMask );<br/>
                game.insertNextTurn(newTurn);<br/>
                turnsChanged = true;<br/>
            }<br/>
        }<br/>
        // brief everybody on the turn update, if they changed<br/>
        if (turnsChanged) {<br/>
            send(createTurnVectorPacket());<br/>
        }<br/>
<br/>
        // move along<br/>
        changeToNextTurn();<br/>
    }<br/>
<br/>
    /**<br/>
     * Changes the current phase, does some bookkeeping and<br/>
     * then tells the players.<br/>
     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase to change to<br/>
     */<br/>
    private void changePhase(int phase) {<br/>
        game.setLastPhase(game.getPhase());<br/>
        game.setPhase(phase);<br/>
<br/>
        // prepare for the phase<br/>
        prepareForPhase(phase);<br/>
<br/>
        if (isPhasePlayable(phase)) {<br/>
            // tell the players about the new phase<br/>
            send(new Packet(Packet.COMMAND_PHASE_CHANGE, new Integer(phase)));<br/>
<br/>
            // post phase change stuff<br/>
            executePhase(phase);<br/>
        } else {<br/>
            endCurrentPhase();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Prepares for, presumably, the next phase.  This typically involves<br/>
     * resetting the states of entities in the game and making sure the client<br/>
     * has the information it needs for the new phase.<br/>
     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase to prepare for<br/>
     */<br/>
    private void prepareForPhase(int phase) {<br/>
        switch (phase) {<br/>
            case IGame.PHASE_LOUNGE :<br/>
                clearReports();<br/>
                mapSettings.setBoardsAvailableVector<br/>
                    ( scanForBoards(mapSettings.getBoardWidth(),<br/>
                                    mapSettings.getBoardHeight()) );<br/>
                mapSettings.setNullBoards(DEFAULT_BOARD);<br/>
                send(createMapSettingsPacket());<br/>
                break;<br/>
            case IGame.PHASE_INITIATIVE :<br/>
                // remove the last traces of last round<br/>
                game.resetActions();<br/>
                game.resetTagInfo();<br/>
                clearReports();<br/>
                resetEntityRound();<br/>
                resetEntityPhase(phase);<br/>
                checkForObservers();<br/>
                // roll 'em<br/>
                resetActivePlayersDone();<br/>
                rollInitiative();<br/>
<br/>
                if ( !game.shouldDeployThisRound() )<br/>
                    incrementAndSendGameRound();<br/>
<br/>
                //setIneligible(phase);<br/>
                determineTurnOrder(phase);<br/>
                writeInitiativeReport(false);<br/>
                System.out.println("Round " + game.getRoundCount() + " memory usage: " + MegaMek.getMemoryUsed());<br/>
                break;<br/>
            case IGame.PHASE_DEPLOY_MINEFIELDS :<br/>
                checkForObservers();<br/>
                resetActivePlayersDone();<br/>
                setIneligible(phase);<br/>
<br/>
                Enumeration e = game.getPlayers();<br/>
                Vector turns = new Vector();<br/>
                while (e.hasMoreElements()) {<br/>
                    Player p = (Player) e.nextElement();<br/>
                    if (p.hasMinefields()) {<br/>
                        GameTurn gt = new GameTurn(p.getId());<br/>
                        turns.addElement(gt);<br/>
                    }<br/>
                }<br/>
                game.setTurnVector(turns);<br/>
                game.resetTurnIndex();<br/>
<br/>
                // send turns to all players<br/>
                send(createTurnVectorPacket());<br/>
                break;<br/>
            case IGame.PHASE_SET_ARTYAUTOHITHEXES :<br/>
                // place off board entities actually off-board<br/>
                Enumeration i = game.getEntities();<br/>
                while (i.hasMoreElements()) {<br/>
                    Entity en = (Entity) i.nextElement();<br/>
                    en.deployOffBoard();<br/>
                }<br/>
                checkForObservers();<br/>
                resetActivePlayersDone();<br/>
                setIneligible(phase);<br/>
<br/>
                i = game.getPlayers();<br/>
                Vector turn = new Vector();<br/>
<br/>
                // Walk through the players of the game, and add<br/>
                // a turn for all players with artillery weapons.<br/>
                while (i.hasMoreElements()) {<br/>
<br/>
                    // Get the next player.<br/>
                    final Player p = (Player) i.nextElement();<br/>
<br/>
                    // Does the player have any artillery-equipped units?<br/>
                    EntitySelector playerArtySelector = new EntitySelector() {<br/>
                            private Player owner = p;<br/>
                            public boolean accept (Entity entity) {<br/>
                                if ( owner.equals( entity.getOwner() ) &amp;&amp;<br/>
                                     entity.isEligibleForTargetingPhase() )<br/>
                                    return true;<br/>
                                return false;<br/>
                            }<br/>
                        };<br/>
                    if ( game.getSelectedEntities( playerArtySelector )<br/>
                         .hasMoreElements() ) {<br/>
<br/>
                        // Yes, the player has arty-equipped units.<br/>
                        GameTurn gt = new GameTurn(p.getId());<br/>
                        turn.addElement(gt);<br/>
                    }<br/>
                }<br/>
                game.setTurnVector(turn);<br/>
                game.resetTurnIndex();<br/>
<br/>
                // send turns to all players<br/>
                send(createTurnVectorPacket());<br/>
                break;<br/>
            case IGame.PHASE_MOVEMENT :<br/>
            case IGame.PHASE_DEPLOYMENT :<br/>
            case IGame.PHASE_FIRING :<br/>
            case IGame.PHASE_PHYSICAL :<br/>
            case IGame.PHASE_TARGETING:<br/>
            case IGame.PHASE_OFFBOARD:<br/>
                resetEntityPhase(phase);<br/>
                checkForObservers();<br/>
                setIneligible(phase);<br/>
                determineTurnOrder(phase);<br/>
                resetActivePlayersDone();<br/>
                //send(createEntitiesPacket());<br/>
                entityAllUpdate();<br/>
                clearReports();<br/>
                doTryUnstuck();<br/>
                break;<br/>
            case IGame.PHASE_END :<br/>
                resetEntityPhase(phase);<br/>
                clearReports();<br/>
                resolveHeat();<br/>
                //write End Phase header<br/>
                addReport(new Report(5005, Report.PUBLIC));<br/>
                checkForSuffocation();<br/>
                if (game.getOptions().booleanOption("vacuum")) {<br/>
                    checkForVacuumDeath();<br/>
                }<br/>
                for(Enumeration&lt;DynamicTerrainProcessor&gt; tps=terrainProcessors.elements();tps.hasMoreElements();) {<br/>
                    DynamicTerrainProcessor tp = tps.nextElement();<br/>
                    tp.DoEndPhaseChanges(vPhaseReport);<br/>
                }<br/>
                addReport( game.ageFlares());<br/>
                send(createFlarePacket());<br/>
                resolveExtremeTempInfantryDeath();<br/>
                resolveAmmoDumps();<br/>
                resolveCrewDamage();<br/>
                resolveCrewWakeUp();<br/>
                resolveMechWarriorPickUp();<br/>
                resolveVeeINarcPodRemoval();<br/>
                checkForObservers();<br/>
                entityAllUpdate();<br/>
                break;<br/>
            case IGame.PHASE_INITIATIVE_REPORT :<br/>
                autoSave();<br/>
            case IGame.PHASE_MOVEMENT_REPORT :<br/>
            case IGame.PHASE_OFFBOARD_REPORT :<br/>
            case IGame.PHASE_FIRING_REPORT :<br/>
            case IGame.PHASE_PHYSICAL_REPORT :<br/>
            case IGame.PHASE_END_REPORT :<br/>
                resetActivePlayersDone();<br/>
                sendReport();<br/>
                if (game.getOptions().booleanOption("paranoid_autosave")) autoSave();<br/>
                break;<br/>
            case IGame.PHASE_VICTORY :<br/>
                resetPlayersDone();<br/>
                clearReports();<br/>
                prepareVictoryReport();<br/>
                game.addReports(vPhaseReport);<br/>
                send(createFullEntitiesPacket());<br/>
                send(createReportPacket(null));<br/>
                send(createEndOfGamePacket());<br/>
                break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Should we play this phase or skip it?<br/>
     */<br/>
    private boolean isPhasePlayable(int phase) {<br/>
        switch (phase) {<br/>
            case IGame.PHASE_INITIATIVE :<br/>
            case IGame.PHASE_END :<br/>
                return false;<br/>
            case IGame.PHASE_SET_ARTYAUTOHITHEXES :<br/>
            case IGame.PHASE_DEPLOY_MINEFIELDS :<br/>
            case IGame.PHASE_DEPLOYMENT :<br/>
            case IGame.PHASE_MOVEMENT :<br/>
            case IGame.PHASE_FIRING :<br/>
            case IGame.PHASE_PHYSICAL :<br/>
            case IGame.PHASE_TARGETING:<br/>
            case IGame.PHASE_OFFBOARD :<br/>
                return game.hasMoreTurns();<br/>
            default :<br/>
                return true;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Do anything we seed to start the new phase, such as give a turn to<br/>
     * the first player to play.<br/>
     */<br/>
    private void executePhase(int phase) {<br/>
        switch (phase) {<br/>
            case IGame.PHASE_EXCHANGE :<br/>
                resetPlayersDone();<br/>
                // Build teams vector<br/>
                game.setupTeams();<br/>
                applyBoardSettings();<br/>
                game.setupRoundDeployment();<br/>
                game.determineWind();<br/>
                // If we add transporters for any Magnetic Clamp<br/>
                // equiped squads, then update the clients' entities.<br/>
                if ( game.checkForMagneticClamp() ) {<br/>
                    entityAllUpdate();<br/>
                }<br/>
                // transmit the board to everybody<br/>
                send(createBoardPacket());<br/>
                break;<br/>
            case IGame.PHASE_MOVEMENT :<br/>
                //write Movement Phase header to report<br/>
                addReport(new Report(2000, Report.PUBLIC));<br/>
            case IGame.PHASE_SET_ARTYAUTOHITHEXES :<br/>
            case IGame.PHASE_DEPLOY_MINEFIELDS :<br/>
            case IGame.PHASE_DEPLOYMENT :<br/>
            case IGame.PHASE_FIRING :<br/>
            case IGame.PHASE_PHYSICAL :<br/>
            case IGame.PHASE_TARGETING :<br/>
            case IGame.PHASE_OFFBOARD :<br/>
                changeToNextTurn();<br/>
                if (game.getOptions().booleanOption("paranoid_autosave")) autoSave();<br/>
                break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Ends this phase and moves on to the next.<br/>
     */<br/>
    private void endCurrentPhase() {<br/>
        switch (game.getPhase()) {<br/>
            case IGame.PHASE_LOUNGE :<br/>
                changePhase(IGame.PHASE_EXCHANGE);<br/>
                break;<br/>
            case IGame.PHASE_EXCHANGE :<br/>
                changePhase(IGame.PHASE_SET_ARTYAUTOHITHEXES);<br/>
                break;<br/>
            case IGame.PHASE_STARTING_SCENARIO :<br/>
                changePhase(IGame.PHASE_SET_ARTYAUTOHITHEXES);<br/>
                break;<br/>
            case IGame.PHASE_SET_ARTYAUTOHITHEXES :<br/>
                Enumeration e = game.getPlayers();<br/>
                boolean mines = false;<br/>
                while (e.hasMoreElements()) {<br/>
                    Player p = (Player) e.nextElement();<br/>
                    if (p.hasMinefields()) {<br/>
                         mines = true;<br/>
                    }<br/>
                }<br/>
                if (mines) {<br/>
                    changePhase(IGame.PHASE_DEPLOY_MINEFIELDS);<br/>
                } else {<br/>
                    changePhase(IGame.PHASE_INITIATIVE);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_DEPLOY_MINEFIELDS :<br/>
                changePhase(IGame.PHASE_INITIATIVE);<br/>
                break;<br/>
            case IGame.PHASE_DEPLOYMENT :<br/>
                game.clearDeploymentThisRound();<br/>
                game.checkForCompleteDeployment();<br/>
                Enumeration pls = game.getPlayers();<br/>
                while (pls.hasMoreElements()) {<br/>
                    Player p = (Player) pls.nextElement();<br/>
                    p.adjustStartingPosForReinforcements();<br/>
                }<br/>
<br/>
                changePhase(IGame.PHASE_INITIATIVE);<br/>
                break;<br/>
            case IGame.PHASE_INITIATIVE :<br/>
                game.addReports(vPhaseReport);<br/>
                changePhase(IGame.PHASE_INITIATIVE_REPORT);<br/>
                break;<br/>
            case IGame.PHASE_INITIATIVE_REPORT :<br/>
                //boolean doDeploy = game.shouldDeployThisRound() &amp;&amp; (game.getLastPhase() != IGame.PHASE_DEPLOYMENT);<br/>
                if ( game.shouldDeployThisRound() ) {<br/>
                    changePhase(IGame.PHASE_DEPLOYMENT);<br/>
                } else {<br/>
                    changePhase(IGame.PHASE_TARGETING);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_MOVEMENT :<br/>
                doAllAssaultDrops();<br/>
                addMovementHeat();<br/>
                applyBuildingDamage();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls(); // Skids cause damage in movement phase<br/>
                resolveCrewDamage(); // again, I guess<br/>
                checkForFlamingDeath();<br/>
                // check phase report<br/>
                if (vPhaseReport.size() &gt; 1) {<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_MOVEMENT_REPORT);<br/>
                } else {<br/>
                    //just the header, so we'll add the &lt;nothing&gt; label<br/>
                    addReport(new Report(1205, Report.PUBLIC));<br/>
                    game.addReports(vPhaseReport);<br/>
                    sendReport();<br/>
                    changePhase(IGame.PHASE_OFFBOARD);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_MOVEMENT_REPORT :<br/>
                changePhase(IGame.PHASE_OFFBOARD);<br/>
                break;<br/>
            case IGame.PHASE_FIRING :<br/>
                resolveAllButWeaponAttacks();<br/>
                assignAMS();<br/>
                resolveOnlyWeaponAttacks();<br/>
                applyBuildingDamage();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls();<br/>
                resolveCrewDamage(); // again, I guess<br/>
                // check phase report<br/>
                if (vPhaseReport.size() &gt; 1) {<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_FIRING_REPORT);<br/>
                } else {<br/>
                    //just the header, so we'll add the &lt;nothing&gt; label<br/>
                    addReport(new Report(1205, Report.PUBLIC));<br/>
                    sendReport();<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_PHYSICAL);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_FIRING_REPORT :<br/>
                changePhase(IGame.PHASE_PHYSICAL);<br/>
                break;<br/>
            case IGame.PHASE_PHYSICAL :<br/>
                resolvePhysicalAttacks();<br/>
                applyBuildingDamage();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls();<br/>
                resolveCrewDamage(); // again, I guess<br/>
                resolveSinkVees();<br/>
                // check phase report<br/>
                if (vPhaseReport.size() &gt; 1) {<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_PHYSICAL_REPORT);<br/>
                } else {<br/>
                    //just the header, so we'll add the &lt;nothing&gt; label<br/>
                    addReport(new Report(1205, Report.PUBLIC));<br/>
                    game.addReports(vPhaseReport);<br/>
                    sendReport();<br/>
                    changePhase(IGame.PHASE_END);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_PHYSICAL_REPORT :<br/>
                changePhase(IGame.PHASE_END);<br/>
                break;<br/>
            case IGame.PHASE_TARGETING :<br/>
                enqueueIndirectArtilleryAttacks();<br/>
                changePhase(IGame.PHASE_MOVEMENT);<br/>
                break;<br/>
            case IGame.PHASE_OFFBOARD :<br/>
                //write Offboard Attack Phase header<br/>
                addReport(new Report(1100, Report.PUBLIC));<br/>
                resolveAllButWeaponAttacks(); //torso twist or flip arms possible<br/>
                resolveOnlyWeaponAttacks(); //should only be TAG at this point<br/>
                resolveIndirectArtilleryAttacks();<br/>
                applyBuildingDamage();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls();<br/>
                resolveCrewDamage(); // again, I guess<br/>
                //check reports<br/>
                if (vPhaseReport.size() &gt; 1) {<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_OFFBOARD_REPORT);<br/>
                } else {<br/>
                    //just the header, so we'll add the &lt;nothing&gt; label<br/>
                    addReport(new Report(1205, Report.PUBLIC));<br/>
                    game.addReports(vPhaseReport);<br/>
                    sendReport();<br/>
                    changePhase(IGame.PHASE_FIRING);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_OFFBOARD_REPORT:<br/>
                changePhase(IGame.PHASE_FIRING);<br/>
                break;<br/>
            case IGame.PHASE_END :<br/>
                // check phase report<br/>
                //HACK: hardcoded message ID check<br/>
                if (vPhaseReport.size() &gt; 3<br/>
                    || ((Report)vPhaseReport.elementAt(1)).messageId != 1205) {<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_END_REPORT);<br/>
                } else {<br/>
                    //just the heat and end headers, so we'll add<br/>
                    // the &lt;nothing&gt; label<br/>
                    addReport(new Report(1205, Report.PUBLIC));<br/>
                    game.addReports(vPhaseReport);<br/>
                    sendReport();<br/>
                    if (victory()) {<br/>
                        changePhase(IGame.PHASE_VICTORY);<br/>
                    } else {<br/>
                        changePhase(IGame.PHASE_INITIATIVE);<br/>
                    }<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_END_REPORT :<br/>
                if (victory()) {<br/>
                    changePhase(IGame.PHASE_VICTORY);<br/>
                } else {<br/>
                    changePhase(IGame.PHASE_INITIATIVE);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_VICTORY :<br/>
                resetGame();<br/>
                break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Increment's the server's game round and send it to all the clients<br/>
     */<br/>
    private void incrementAndSendGameRound() {<br/>
        game.incrementRoundCount();<br/>
        send(new Packet(Packet.COMMAND_ROUND_UPDATE, new Integer(game.getRoundCount())));<br/>
    }<br/>
<br/>
    /**<br/>
     * Tries to change to the next turn.  If there are no more turns, ends the<br/>
     * current phase.  If the player whose turn it is next is not connected,<br/>
     * we allow the other players to skip that player.<br/>
     */<br/>
    private void changeToNextTurn() {<br/>
        // if there aren't any more turns, end the phase<br/>
        if (!game.hasMoreTurns()) {<br/>
            endCurrentPhase();<br/>
            return;<br/>
        }<br/>
<br/>
        // okay, well next turn then!<br/>
        GameTurn nextTurn = game.changeToNextTurn();<br/>
        send(createTurnIndexPacket());<br/>
<br/>
        Player player = getPlayer( nextTurn.getPlayerNum() );<br/>
        if ( null != player &amp;&amp; player.isGhost() ) {<br/>
            sendGhostSkipMessage( player );<br/>
        }<br/>
        else if ( null == game.getFirstEntity()<br/>
                  &amp;&amp; null != player<br/>
                  &amp;&amp; ((game.getPhase() != IGame.PHASE_DEPLOY_MINEFIELDS) &amp;&amp; (game.getPhase() != IGame.PHASE_SET_ARTYAUTOHITHEXES))) {<br/>
            sendTurnErrorSkipMessage( player );<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out a notification message indicating that a ghost player may<br/>
     * be skipped.<br/>
     *<br/>
     * @param   ghost - the &lt;code&gt;Player&lt;/code&gt; who is ghosted.<br/>
     *          This value must not be &lt;code&gt;null&lt;/code&gt;.<br/>
     */<br/>
    private void sendGhostSkipMessage( Player ghost ) {<br/>
        StringBuffer message = new StringBuffer();<br/>
        message.append( "Player '" )<br/>
            .append( ghost.getName() )<br/>
            .append( "' is disconnected.  You may skip his/her current turn with the /skip command." );<br/>
        sendServerChat( message.toString() );<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out a notification message indicating that the current turn is an<br/>
     * error and should be skipped.<br/>
     *<br/>
     * @param   skip - the &lt;code&gt;Player&lt;/code&gt; who is to be skipped.<br/>
     *          This value must not be &lt;code&gt;null&lt;/code&gt;.<br/>
     */<br/>
    private void sendTurnErrorSkipMessage( Player skip ) {<br/>
        StringBuffer message = new StringBuffer();<br/>
        message.append( "Player '" )<br/>
            .append( skip.getName() )<br/>
            .append( "' has no units to move.  You should skip his/her/your current turn with the /skip command. You may want to report this error.  See the MegaMek homepage (http://megamek.sf.net/) for details." );<br/>
        sendServerChat( message.toString() );<br/>
    }<br/>
<br/>
    /**<br/>
     * Skips the current turn.  This only makes sense in phases that have turns.<br/>
     * Operates by finding an entity to move and then doing nothing with it.<br/>
     */<br/>
    public void skipCurrentTurn() {<br/>
        // find an entity to skip...<br/>
        Entity toSkip = game.getFirstEntity();<br/>
<br/>
        switch (game.getPhase()) {<br/>
            case IGame.PHASE_DEPLOYMENT :<br/>
                sendServerChat("Turns cannot be skipped in the deployment phase.");<br/>
                break;<br/>
            case IGame.PHASE_MOVEMENT :<br/>
                if ( toSkip != null ) {<br/>
                    processMovement(toSkip, new MovePath(game, toSkip));<br/>
                }<br/>
                endCurrentTurn(toSkip);<br/>
                break;<br/>
            case IGame.PHASE_FIRING :<br/>
            case IGame.PHASE_PHYSICAL :<br/>
            case IGame.PHASE_TARGETING :<br/>
            case IGame.PHASE_OFFBOARD :<br/>
                if ( toSkip != null ) {<br/>
                    processAttack(toSkip, new Vector(0));<br/>
                }<br/>
                endCurrentTurn(toSkip);<br/>
                break;<br/>
            default :<br/>
<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the current turn may be skipped.  Ghost players' turns<br/>
     * are skippable, and a turn should be skipped if there's nothing to move.<br/>
     */<br/>
    public boolean isTurnSkippable() {<br/>
        GameTurn turn = game.getTurn();<br/>
        if (null == turn) return false;<br/>
        Player player = getPlayer( turn.getPlayerNum() );<br/>
        return ( null == player || player.isGhost()<br/>
                 || game.getFirstEntity() == null );<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if victory conditions have been met.  Victory conditions<br/>
     * are when there is only one player left with mechs or only one team.<br/>
     */<br/>
    public boolean victory() {<br/>
        if (game.isForceVictory()) {<br/>
            int victoryPlayerId = game.getVictoryPlayerId();<br/>
            int victoryTeam = game.getVictoryTeam();<br/>
            Vector players = game.getPlayersVector();<br/>
            boolean forceVictory = true;<br/>
<br/>
            // Individual victory.<br/>
            if (victoryPlayerId != Player.PLAYER_NONE) {<br/>
                for (int i = 0; i &lt; players.size(); i++) {<br/>
                    Player player = (Player) players.elementAt(i);<br/>
<br/>
                    if (player.getId() != victoryPlayerId &amp;&amp; !player.isObserver()) {<br/>
                        if (!player.admitsDefeat()) {<br/>
                            forceVictory = false;<br/>
                            break;<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
            // Team victory.<br/>
            if (victoryTeam != Player.TEAM_NONE) {<br/>
                for (int i = 0; i &lt; players.size(); i++) {<br/>
                    Player player = (Player) players.elementAt(i);<br/>
<br/>
                    if (player.getTeam() != victoryTeam &amp;&amp; !player.isObserver()) {<br/>
                        if (!player.admitsDefeat()) {<br/>
                            forceVictory = false;<br/>
                            break;<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            for (int i = 0; i &lt; players.size(); i++) {<br/>
                Player player = (Player) players.elementAt(i);<br/>
                player.setAdmitsDefeat(false);<br/>
            }<br/>
<br/>
            if (forceVictory) {<br/>
                return true;<br/>
            }<br/>
            cancelVictory();<br/>
        }<br/>
<br/>
        if (!game.getOptions().booleanOption("check_victory")) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // check all players/teams for aliveness<br/>
        int playersAlive = 0;<br/>
        Player lastPlayer = null;<br/>
        boolean oneTeamAlive = false;<br/>
        int lastTeam = Player.TEAM_NONE;<br/>
        boolean unteamedAlive = false;<br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements();) {<br/>
            Player player = (Player)e.nextElement();<br/>
            int team = player.getTeam();<br/>
            if (game.getLiveDeployedEntitiesOwnedBy(player) &lt;= 0) {<br/>
                continue;<br/>
            }<br/>
            // we found a live one!<br/>
            playersAlive++;<br/>
            lastPlayer = player;<br/>
            // check team<br/>
            if (team == Player.TEAM_NONE) {<br/>
                unteamedAlive = true;<br/>
            } else if (lastTeam == Player.TEAM_NONE) {<br/>
                // possibly only one team alive<br/>
                oneTeamAlive = true;<br/>
                lastTeam = team;<br/>
            } else if (team != lastTeam) {<br/>
                // more than one team alive<br/>
                oneTeamAlive = false;<br/>
                lastTeam = team;<br/>
            }<br/>
        }<br/>
<br/>
        // check if there's one player alive<br/>
        if (playersAlive &lt; 1) {<br/>
            game.setVictoryPlayerId( Player.PLAYER_NONE );<br/>
            game.setVictoryTeam( Player.TEAM_NONE );<br/>
            return true;<br/>
        }<br/>
        else if ( playersAlive == 1 ) {<br/>
            if (lastPlayer.getTeam() == Player.TEAM_NONE) {<br/>
                // individual victory<br/>
                game.setVictoryPlayerId(lastPlayer.getId());<br/>
                game.setVictoryTeam(Player.TEAM_NONE);<br/>
                return true;<br/>
            }<br/>
        }<br/>
<br/>
        // did we only find one live team?<br/>
        if (oneTeamAlive &amp;&amp; !unteamedAlive) {<br/>
            // team victory<br/>
            game.setVictoryPlayerId(Player.PLAYER_NONE);<br/>
            game.setVictoryTeam(lastTeam);<br/>
            return true;<br/>
        }<br/>
<br/>
        return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Applies board settings.  This loads and combines all the boards that<br/>
     * were specified into one mega-board and sets that board as current.<br/>
     */<br/>
    public void applyBoardSettings() {<br/>
        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);<br/>
        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth() * mapSettings.getMapHeight()];<br/>
        for (int i = 0; i &lt; mapSettings.getMapWidth() * mapSettings.getMapHeight(); i++) {<br/>
            sheetBoards[i] = new Board();<br/>
            String name = (String)mapSettings.getBoardsSelectedVector().elementAt(i);<br/>
            boolean isRotated = false;<br/>
            if ( name.startsWith( Board.BOARD_REQUEST_ROTATION ) ) {<br/>
                isRotated = true;<br/>
                name = name.substring( Board.BOARD_REQUEST_ROTATION.length() );<br/>
            }<br/>
            if (name.startsWith(MapSettings.BOARD_GENERATED)) {<br/>
                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);<br/>
            } else {<br/>
                sheetBoards[i].load( name + ".board");<br/>
                BoardUtilities.flip(sheetBoards[i], isRotated, isRotated );<br/>
            }<br/>
        }<br/>
        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(),<br/>
                mapSettings.getMapWidth(), mapSettings.getMapHeight(), sheetBoards);<br/>
        game.setBoard(newBoard);<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Rolls initiative for all the players.<br/>
     */<br/>
    private void rollInitiative() {<br/>
        if(game.getOptions().booleanOption("individual_initiative")) {<br/>
            TurnOrdered.rollInitiative(game.getEntitiesVector());<br/>
        } else {<br/>
            // Roll for initative on the teams.<br/>
            TurnOrdered.rollInitiative(game.getTeamsVector());<br/>
        }<br/>
<br/>
        transmitAllPlayerUpdates();<br/>
    }<br/>
<br/>
    /**<br/>
     * Determines the turn oder for a given phase (with individual init)<br/>
     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase<br/>
     */<br/>
    private void determineTurnOrderIUI(int phase) {<br/>
        for (Enumeration loop = game.getEntities(); loop.hasMoreElements();) {<br/>
            final Entity entity = (Entity)loop.nextElement();<br/>
            entity.resetOtherTurns();<br/>
            if (entity.isSelectableThisTurn()) {<br/>
                entity.incrementOtherTurns();<br/>
            }<br/>
        }<br/>
        // Now, generate the global order of all teams' turns.<br/>
        TurnVectors team_order = TurnOrdered.generateTurnOrder<br/>
            ( game.getEntitiesVector(), game );<br/>
<br/>
        // See if there are any loaded units stranded on immobile transports.<br/>
        Enumeration strandedUnits = game.getSelectedEntities<br/>
            ( new EntitySelector() {<br/>
                    public boolean accept( Entity entity ) {<br/>
                        if ( Server.this.game.isEntityStranded(entity) )<br/>
                            return true;<br/>
                        return false;<br/>
                    }<br/>
                } );<br/>
<br/>
        // Now, we collect everything into a single vector.<br/>
        Vector turns;<br/>
<br/>
        if ( strandedUnits.hasMoreElements() &amp;&amp;<br/>
             game.getPhase() == IGame.PHASE_MOVEMENT ) {<br/>
            // Add a game turn to unload stranded units, if this<br/>
            //  is the movement phase.<br/>
            turns = new Vector( team_order.getNormalTurns() +<br/>
                                team_order.getEvenTurns() + 1);<br/>
            turns.addElement( new GameTurn.UnloadStrandedTurn(strandedUnits) );<br/>
        } else {<br/>
            // No stranded units.<br/>
            turns = new Vector( team_order.getNormalTurns() +<br/>
                                team_order.getEvenTurns() );<br/>
        }<br/>
        <br/>
        //add the turns (this is easy)<br/>
        while(team_order.hasMoreElements()) {<br/>
            Entity e = (Entity)team_order.nextElement();<br/>
            if(e.isSelectableThisTurn())<br/>
                turns.addElement(new GameTurn.SpecificEntityTurn(e.getOwnerId(), e.getId()));<br/>
        }<br/>
        <br/>
        // set fields in game<br/>
        game.setTurnVector(turns);<br/>
        game.resetTurnIndex();<br/>
<br/>
        // send turns to all players<br/>
        send(createTurnVectorPacket());<br/>
    }<br/>
    /**<br/>
     * Determines the turn oder for a given phase<br/>
     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase<br/>
     */<br/>
    private void determineTurnOrder(int phase) {<br/>
<br/>
        if(game.getOptions().booleanOption("individual_initiative")) {<br/>
            determineTurnOrderIUI(phase);<br/>
            return;<br/>
        }<br/>
        // and/or deploy even according to game options.<br/>
        boolean infMoveEven =<br/>
            ( game.getOptions().booleanOption("inf_move_even") &amp;&amp;<br/>
              (game.getPhase() == IGame.PHASE_INITIATIVE ||<br/>
               game.getPhase() == IGame.PHASE_MOVEMENT) ) ||<br/>
            ( game.getOptions().booleanOption("inf_deploy_even") &amp;&amp;<br/>
              game.getPhase() == IGame.PHASE_DEPLOYMENT );<br/>
        boolean infMoveMulti =<br/>
            ( game.getOptions().booleanOption("inf_move_multi") &amp;&amp;<br/>
              (game.getPhase() == IGame.PHASE_INITIATIVE ||<br/>
               game.getPhase() == IGame.PHASE_MOVEMENT) );<br/>
        boolean protosMoveEven =<br/>
            ( game.getOptions().booleanOption("protos_move_even") &amp;&amp;<br/>
              (game.getPhase() == IGame.PHASE_INITIATIVE ||<br/>
               game.getPhase() == IGame.PHASE_MOVEMENT) ) ||<br/>
            ( game.getOptions().booleanOption("protos_deploy_even") &amp;&amp;<br/>
              game.getPhase() == IGame.PHASE_DEPLOYMENT );<br/>
        boolean protosMoveMulti =<br/>
            game.getOptions().booleanOption("protos_move_multi");<br/>
        boolean protosFireMulti = !protosMoveMulti &amp;&amp;<br/>
            game.getPhase() == IGame.PHASE_FIRING;<br/>
        int evenMask = 0;<br/>
        if ( infMoveEven ) evenMask += GameTurn.CLASS_INFANTRY;<br/>
        if ( protosMoveEven ) evenMask += GameTurn.CLASS_PROTOMECH;<br/>
<br/>
        // Reset all of the Players' turn category counts<br/>
        for (Enumeration loop = game.getPlayers(); loop.hasMoreElements();) {<br/>
            final Player player = (Player) loop.nextElement();<br/>
            player.resetEvenTurns();<br/>
            player.resetMultiTurns();<br/>
            player.resetOtherTurns();<br/>
<br/>
            // Add turns for protomechs weapons declaration.<br/>
            if ( protosFireMulti ) {<br/>
<br/>
                // How many Protomechs does the player have?<br/>
                int numPlayerProtos = game.getSelectedEntityCount<br/>
                    ( new EntitySelector() {<br/>
                            private final int ownerId = player.getId();<br/>
                            public boolean accept( Entity entity ) {<br/>
                                if ( entity instanceof Protomech &amp;&amp;<br/>
                                     ownerId == entity.getOwnerId() )<br/>
                                    return true;<br/>
                                return false;<br/>
                            }<br/>
                        } );<br/>
                int numProtoUnits =<br/>
                    (int) Math.ceil( (numPlayerProtos) / 5.0 );<br/>
                for ( int unit = 0; unit &lt; numProtoUnits; unit++ ) {<br/>
                    if ( protosMoveEven ) player.incrementEvenTurns();<br/>
                    else player.incrementOtherTurns();<br/>
                }<br/>
<br/>
            } // End handle-proto-firing-turns<br/>
<br/>
        } // Handle the next player<br/>
<br/>
        // Go through all entities, and update the turn categories of the<br/>
        // entity's player.  The teams get their totals from their players.<br/>
        // N.B. protomechs declare weapons fire based on their point.<br/>
        for (Enumeration loop = game.getEntities(); loop.hasMoreElements();) {<br/>
            final Entity entity = (Entity)loop.nextElement();<br/>
            if (entity.isSelectableThisTurn()) {<br/>
                final Player player = entity.getOwner();<br/>
                if ( entity instanceof Infantry ) {<br/>
                    if ( infMoveEven ) player.incrementEvenTurns();<br/>
                    else if ( infMoveMulti ) player.incrementMultiTurns();<br/>
                    else player.incrementOtherTurns();<br/>
                }<br/>
                else if ( entity instanceof Protomech ) {<br/>
                    if ( !protosFireMulti ) {<br/>
                        if ( protosMoveEven ) player.incrementEvenTurns();<br/>
                        else if ( protosMoveMulti ) player.incrementMultiTurns();<br/>
                        else player.incrementOtherTurns();<br/>
                    }<br/>
                }<br/>
                else<br/>
                    player.incrementOtherTurns();<br/>
            }<br/>
        }<br/>
<br/>
        // Generate the turn order for the Players *within*<br/>
        // each Team.  Map the teams to their turn orders.<br/>
        // Count the number of teams moving this turn.<br/>
        int nTeams = game.getNoOfTeams();<br/>
        Hashtable allTeamTurns = new Hashtable( nTeams );<br/>
        Hashtable evenTrackers = new Hashtable( nTeams );<br/>
        int numTeamsMoving = 0;<br/>
        for (Enumeration loop = game.getTeams(); loop.hasMoreElements(); ) {<br/>
            final Team team = (Team) loop.nextElement();<br/>
            allTeamTurns.put( team, team.determineTeamOrder(game) );<br/>
<br/>
            // Track both the number of times we've checked the team for<br/>
            // "leftover" turns, and the number of "leftover" turns placed.<br/>
            int[] evenTracker = new int[2];<br/>
            evenTracker[0] = 0;<br/>
            evenTracker[1] = 0;<br/>
            evenTrackers.put (team, evenTracker);<br/>
<br/>
            // Count this team if it has any "normal" moves.<br/>
            if (team.getNormalTurns(game) &gt; 0)<br/>
                numTeamsMoving++;<br/>
        }<br/>
<br/>
        // Now, generate the global order of all teams' turns.<br/>
        TurnVectors team_order = TurnOrdered.generateTurnOrder<br/>
            ( game.getTeamsVector(), game );<br/>
<br/>
        // See if there are any loaded units stranded on immobile transports.<br/>
        Enumeration strandedUnits = game.getSelectedEntities<br/>
            ( new EntitySelector() {<br/>
                    public boolean accept( Entity entity ) {<br/>
                        if ( Server.this.game.isEntityStranded(entity) )<br/>
                            return true;<br/>
                        return false;<br/>
                    }<br/>
                } );<br/>
<br/>
        // Now, we collect everything into a single vector.<br/>
        Vector turns;<br/>
<br/>
        if ( strandedUnits.hasMoreElements() &amp;&amp;<br/>
             game.getPhase() == IGame.PHASE_MOVEMENT ) {<br/>
            // Add a game turn to unload stranded units, if this<br/>
            //  is the movement phase.<br/>
            turns = new Vector( team_order.getNormalTurns() +<br/>
                                team_order.getEvenTurns() + 1);<br/>
            turns.addElement( new GameTurn.UnloadStrandedTurn(strandedUnits) );<br/>
        } else {<br/>
            // No stranded units.<br/>
            turns = new Vector( team_order.getNormalTurns() +<br/>
                                team_order.getEvenTurns() );<br/>
        }<br/>
<br/>
        // Walk through the global order, assigning turns<br/>
        // for individual players to the single vector.<br/>
        // Keep track of how many turns we've added to the vector.<br/>
        Team prevTeam = null;<br/>
        int min = team_order.getMin();<br/>
        for ( int numTurn = 0; team_order.hasMoreElements(); numTurn++ ) {<br/>
            Team team = (Team) team_order.nextElement();<br/>
            TurnVectors withinTeamTurns = (TurnVectors) allTeamTurns.get(team);<br/>
<br/>
            int[] evenTracker = (int[]) evenTrackers.get (team);<br/>
            float teamEvenTurns = team.getEvenTurns();<br/>
<br/>
            // Calculate the number of "even" turns to add for this team.<br/>
            int numEven = 0;<br/>
            if (1 == numTeamsMoving) {<br/>
                // The only team moving should move all "even" units.<br/>
                numEven += teamEvenTurns;<br/>
            }<br/>
            else if (prevTeam == null) {<br/>
                // Increment the number of times we've checked for "leftovers".<br/>
                evenTracker[0]++;<br/>
<br/>
                // The first team to move just adds the "baseline" turns.<br/>
                numEven += teamEvenTurns / min;<br/>
            }<br/>
            else if (!team.equals(prevTeam)) {<br/>
                // Increment the number of times we've checked for "leftovers".<br/>
                evenTracker[0]++;<br/>
<br/>
                // This wierd equation attempts to spread the "leftover"<br/>
                // turns accross the turn's moves in a "fair" manner.<br/>
                // It's based on the number of times we've checked for<br/>
                // "leftovers" the number of "leftovers" we started with,<br/>
                // the number of times we've added a turn for a "leftover",<br/>
                // and the total number of times we're going to check.<br/>
                numEven += Math.ceil (evenTracker[0] * (teamEvenTurns % min)<br/>
                                       / min - 0.5) - evenTracker[1];<br/>
<br/>
                // Update the number of turns actually added for "leftovers".<br/>
                evenTracker[1] += numEven;<br/>
<br/>
                // Add the "baseline" number of turns.<br/>
                numEven += teamEvenTurns / min;<br/>
            }<br/>
<br/>
            // Record this team for the next move.<br/>
            prevTeam = team;<br/>
<br/>
            // This may be a "placeholder" for a team without "normal" turns.<br/>
            if (withinTeamTurns.hasMoreElements()) {<br/>
<br/>
                // Not a placeholder... get the player who moves next.<br/>
                Player player = (Player) withinTeamTurns.nextElement();<br/>
<br/>
                // If we've added all "normal" turns, allocate turns<br/>
                // for the infantry and/or protomechs moving even.<br/>
                GameTurn turn = null;<br/>
                if ( numTurn &gt;= team_order.getNormalTurns() ) {<br/>
                    turn = new GameTurn.EntityClassTurn<br/>
                        (player.getId(), evenMask);<br/>
                }<br/>
<br/>
                // If either Infantry or Protomechs move even, only allow<br/>
                // the other classes to move during the "normal" turn.<br/>
                else if ( infMoveEven || protosMoveEven ) {<br/>
                    turn = new GameTurn.EntityClassTurn<br/>
                        (player.getId(), ~evenMask);<br/>
                }<br/>
<br/>
                // Otherwise, let *anybody* move.<br/>
                else {<br/>
                    turn = new GameTurn( player.getId() );<br/>
                }<br/>
                turns.addElement(turn);<br/>
<br/>
            } // End team-has-"normal"-turns<br/>
<br/>
            // Add the calculated number of "even" turns.<br/>
            // Allow the player at least one "normal" turn before the<br/>
            // "even" turns to help with loading infantry in deployment.<br/>
            while (numEven &gt; 0 &amp;&amp; withinTeamTurns.hasMoreEvenElements()) {<br/>
                Player evenPlayer = (Player) withinTeamTurns.nextEvenElement();<br/>
                turns.addElement<br/>
                    (new GameTurn.EntityClassTurn (evenPlayer.getId(),<br/>
                                                   evenMask));<br/>
                numEven--;<br/>
            }<br/>
        }<br/>
<br/>
        // set fields in game<br/>
        game.setTurnVector(turns);<br/>
        game.resetTurnIndex();<br/>
<br/>
        // send turns to all players<br/>
        send(createTurnVectorPacket());<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Write the initiative results to the report<br/>
     */<br/>
    private void writeInitiativeReport(boolean abbreviatedReport) {<br/>
        // write to report<br/>
        Report r;<br/>
        boolean deployment = false;<br/>
        if (!abbreviatedReport) {<br/>
            r = new Report(1210);<br/>
            r.type = Report.PUBLIC;<br/>
            if ((game.getLastPhase() == IGame.PHASE_DEPLOYMENT) || game.isDeploymentComplete() || !game.shouldDeployThisRound()) {<br/>
                r.messageId = 1000;<br/>
                r.add(game.getRoundCount());<br/>
            } else {<br/>
                deployment = true;<br/>
                if ( game.getRoundCount() == 0 ) {<br/>
                    r.messageId = 1005;<br/>
                } else {<br/>
                    r.messageId = 1010;<br/>
                    r.add(game.getRoundCount());<br/>
                }<br/>
            }<br/>
            addReport(r);<br/>
<br/>
            //write seperator<br/>
            addReport(new Report(1200, Report.PUBLIC));<br/>
        } else {<br/>
            addReport(new Report(1210, Report.PUBLIC)); //newline<br/>
        }<br/>
<br/>
        if(game.getOptions().booleanOption("individual_initiative")) {<br/>
            r = new Report(1040, Report.PUBLIC);<br/>
            addReport(r);<br/>
            for(Enumeration&lt;GameTurn&gt; e = game.getTurns();e.hasMoreElements();) {<br/>
                GameTurn t = e.nextElement();<br/>
                if(t instanceof GameTurn.SpecificEntityTurn) {<br/>
                    Entity entity = game.getEntity(((GameTurn.SpecificEntityTurn)t).getEntityNum());<br/>
                    r = new Report(1045);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(entity.getInitiative().toString());<br/>
                    addReport(r);<br/>
                } else {<br/>
                    Player player = getPlayer( t.getPlayerNum() );<br/>
                    if ( null != player ) {<br/>
                        r = new Report(1050, Report.PUBLIC);<br/>
                        r.add(player.getName());<br/>
                        addReport(r);<br/>
                    }                    <br/>
                }<br/>
            }<br/>
        } else {<br/>
            for (Enumeration i = game.getTeams(); i.hasMoreElements();) {<br/>
                final Team team = (Team)i.nextElement();<br/>
    <br/>
                // If there is only one player, list them as the 'team', and<br/>
                // use the team iniative<br/>
                if (team.getSize() == 1) {<br/>
                    final Player player = (Player)team.getPlayers().nextElement();<br/>
                    r = new Report(1015, Report.PUBLIC);<br/>
                    r.add(player.getName());<br/>
                    r.add(team.getInitiative().toString());<br/>
                    addReport(r);<br/>
                } else {<br/>
                    // Multiple players.  List the team, then break it down.<br/>
                    r = new Report(1015, Report.PUBLIC);<br/>
                    r.add(Player.teamNames[team.getId()]);<br/>
                    r.add(team.getInitiative().toString());<br/>
                    addReport(r);<br/>
                    for( Enumeration j = team.getPlayers(); j.hasMoreElements();) {<br/>
                        final Player player = (Player)j.nextElement();<br/>
                        r = new Report(1015, Report.PUBLIC);<br/>
                        r.indent();<br/>
                        r.add(player.getName());<br/>
                        r.add(player.getInitiative().toString());<br/>
                        addReport(r);<br/>
                    }<br/>
                }<br/>
            }<br/>
    <br/>
            // The turn order is different in movement phase<br/>
            // if a player has any "even" moving units.<br/>
            r = new Report(1020, Report.PUBLIC);<br/>
    <br/>
            boolean firstTurn = true;<br/>
            boolean hasEven = false;<br/>
            for (Enumeration i = game.getTurns(); i.hasMoreElements();) {<br/>
                GameTurn turn = (GameTurn)i.nextElement();<br/>
                Player player = getPlayer( turn.getPlayerNum() );<br/>
                if ( null != player ) {<br/>
                    r.add(player.getName());<br/>
                    firstTurn = false;<br/>
                    if (player.getEvenTurns() &gt; 0)<br/>
                        hasEven = true;<br/>
                }<br/>
            }<br/>
            r.newlines = 2;<br/>
            addReport(r);<br/>
            if (hasEven) {<br/>
                r = new Report(1021, Report.PUBLIC);<br/>
                if ((game.getOptions().booleanOption("inf_deploy_even")<br/>
                    || game.getOptions().booleanOption("protos_deploy_even")) &amp;&amp;<br/>
                    !(game.getLastPhase() == IGame.PHASE_END_REPORT))<br/>
                    r.choose(true);<br/>
                else r.choose(false);<br/>
                r.indent();<br/>
                r.newlines = 2;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
        if (!abbreviatedReport) {<br/>
            //Wind direction and strength<br/>
            r = new Report(1025, Report.PUBLIC);<br/>
            r.add(game.getStringWindDirection());<br/>
            if (game.getWindStrength() != -1) {<br/>
                Report r2 = new Report(1030, Report.PUBLIC);<br/>
                r2.add(game.getStringWindStrength());<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
                addReport(r2);<br/>
            } else {<br/>
                addReport(r);<br/>
            }<br/>
<br/>
            if (deployment)<br/>
                addNewLines();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks ineligible entities as not ready for this phase<br/>
     */<br/>
    private void setIneligible(int phase) {<br/>
        Vector assistants = new Vector();<br/>
        boolean assistable = false;<br/>
        Entity entity = null;<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            entity = (Entity)e.nextElement();<br/>
            if (!entity.isEligibleFor(phase)) {<br/>
                assistants.addElement(entity);<br/>
            } else {<br/>
                assistable=true;<br/>
            }<br/>
        }<br/>
        for (int i=0;i&lt;assistants.size();i++) {<br/>
            entity = (Entity)assistants.elementAt(i);<br/>
            if(!assistable || !(entity.canAssist(phase))) {<br/>
                entity.setDone(true);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Have the loader load the indicated unit.<br/>
     * The unit being loaded loses its turn.<br/>
     *<br/>
     * @param   loader - the &lt;code&gt;Entity&lt;/code&gt; that is loading the unit.<br/>
     * @param   unit - the &lt;code&gt;Entity&lt;/code&gt; being loaded.<br/>
     */<br/>
    private void loadUnit( Entity loader, Entity unit ) {<br/>
<br/>
        // Remove the *last* friendly turn (removing the *first* penalizes<br/>
        // the opponent too much, and re-calculating moves is too hard).<br/>
        game.removeTurnFor(unit);<br/>
        send(createTurnVectorPacket());<br/>
<br/>
        // Load the unit.<br/>
        loader.load( unit );<br/>
<br/>
        // The loaded unit is being carried by the loader.<br/>
        unit.setTransportId( loader.getId() );<br/>
<br/>
        // Remove the loaded unit from the screen.<br/>
        unit.setPosition( null );<br/>
<br/>
        // Update the loaded unit.<br/>
        this.entityUpdate( unit.getId() );<br/>
    }<br/>
<br/>
    /**<br/>
     * Have the unloader unload the indicated unit.<br/>
     * The unit being unloaded does *not* gain a turn.<br/>
     *<br/>
     * @param   unloader - the &lt;code&gt;Entity&lt;/code&gt; that is unloading the unit.<br/>
     * @param   unloaded - the &lt;code&gt;Targetable&lt;/code&gt; unit being unloaded.<br/>
     * @param   pos - the &lt;code&gt;Coords&lt;/code&gt; for the unloaded unit.<br/>
     * @param   facing - the &lt;code&gt;int&lt;/code&gt; facing for the unloaded unit.<br/>
     * @param   elevation - the &lt;code&gt;int&lt;/code&gt; elevation at which to unload,<br/>
     *                      if both loader and loaded units use VTOL movement.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the unit was successfully unloaded,<br/>
     *          &lt;code&gt;false&lt;/code&gt; if the unit isn't carried in unloader.<br/>
     */<br/>
    private boolean unloadUnit( Entity unloader, Targetable unloaded,<br/>
                             Coords pos, int facing, int elevation ) {<br/>
<br/>
        // We can only unload Entities.<br/>
        Entity unit = null;<br/>
        if ( unloaded instanceof Entity ) {<br/>
            unit = (Entity) unloaded;<br/>
        } else {<br/>
            return false;<br/>
        }<br/>
<br/>
        // Unload the unit.<br/>
        if ( !unloader.unload( unit ) ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // The unloaded unit is no longer being carried.<br/>
        unit.setTransportId( Entity.NONE );<br/>
<br/>
        // Place the unloaded unit onto the screen.<br/>
        unit.setPosition( pos );<br/>
<br/>
        // Units unloaded onto the screen are deployed.<br/>
        if ( pos != null ) {<br/>
            unit.setDeployed( true );<br/>
        }<br/>
<br/>
        // Point the unloaded unit in the given direction.<br/>
        unit.setFacing( facing );<br/>
        unit.setSecondaryFacing( facing );<br/>
        <br/>
        IHex hex = game.getBoard().getHex(pos);<br/>
        boolean isBridge = hex.containsTerrain(Terrains.PAVEMENT);<br/>
<br/>
        if (unloader.getMovementMode() == IEntityMovementMode.VTOL) {<br/>
            if (unit.getMovementMode() == IEntityMovementMode.VTOL) {<br/>
                // Flying units onload to the same elevation as the flying transport<br/>
                unit.setElevation(elevation);<br/>
            } else if (game.getBoard().getBuildingAt(pos) != null) {<br/>
                // non-flying unit onloaded from a flying onto a building<br/>
                // -&gt; sit on the roff<br/>
                unit.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));<br/>
            }<br/>
        } else if (game.getBoard().getBuildingAt(pos) != null) {<br/>
            // non flying unit unloading units into a building<br/>
            // -&gt; sit in the building at the same elevation<br/>
            unit.setElevation(elevation);<br/>
        } else if (hex.terrainLevel(Terrains.WATER)&gt;0) {<br/>
            if (unit.getMovementMode() == IEntityMovementMode.HOVER ||<br/>
                unit.getMovementMode() == IEntityMovementMode.HYDROFOIL ||<br/>
                unit.getMovementMode() == IEntityMovementMode.NAVAL ||<br/>
                unit.getMovementMode() == IEntityMovementMode.SUBMARINE ||<br/>
                hex.containsTerrain(Terrains.ICE) ||<br/>
                isBridge) {<br/>
                // units that can float stay on the surface, or we go on the bridge<br/>
                // this means elevation 0, because elevation is relative to the surface<br/>
                unit.setElevation(0);<br/>
            } <br/>
        } else {<br/>
            // default to the floor of the hex.<br/>
            // unit elevation is relative to the surface <br/>
            unit.setElevation(hex.floor() - hex.surface());<br/>
        }<br/>
        doSetLocationsExposure(unit, hex, false, unit.getElevation());<br/>
<br/>
        // Update the unloaded unit.<br/>
        this.entityUpdate( unit.getId() );<br/>
<br/>
        // Unloaded successfully.<br/>
        return true;<br/>
    }<br/>
<br/>
    /**<br/>
     * Record that the given building has been affected by the current<br/>
     * entity's movement.  At the end of the entity's movement, notify<br/>
     * the clients about the updates.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that has been affected.<br/>
     * @param   collapse - a &lt;code&gt;boolean&lt;/code&gt; value that specifies that<br/>
     *          the building collapsed (when &lt;code&gt;true&lt;/code&gt;).<br/>
     */<br/>
    private void addAffectedBldg( Building bldg, boolean collapse ) {<br/>
<br/>
        // If the building collapsed, then the clients have already<br/>
        // been notified, so remove it from the notification list.<br/>
        if ( collapse ) {<br/>
            System.err.print( "Removing building from a list of " + affectedBldgs.size() + "\n" );//killme<br/>
            this.affectedBldgs.remove( bldg );<br/>
            System.err.print( "... now list of " + affectedBldgs.size() + "\n" );//killme<br/>
        }<br/>
<br/>
        // Otherwise, make sure that this building is tracked.<br/>
        else {<br/>
            this.affectedBldgs.put( bldg, Boolean.FALSE );<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Walk through the building hexes that were affected by the recent<br/>
     * entity's movement.  Notify the clients about the updates to all<br/>
     * affected entities and uncollapsed buildings.  The affected hexes<br/>
     * is then cleared for the next entity's movement.<br/>
     */<br/>
    private void applyAffectedBldgs() {<br/>
<br/>
        // Build a list of Building updates.<br/>
        Vector bldgUpdates = new Vector();<br/>
<br/>
        // Only send a single turn update.<br/>
        boolean bTurnsChanged = false;<br/>
<br/>
        // Walk the set of buildings.<br/>
        Enumeration bldgs = this.affectedBldgs.keys();<br/>
        while ( bldgs.hasMoreElements() ) {<br/>
            final Building bldg = (Building) bldgs.nextElement();<br/>
<br/>
            // Walk through the building's coordinates.<br/>
            Enumeration bldgCoords = bldg.getCoords();<br/>
            while ( bldgCoords.hasMoreElements() ) {<br/>
                final Coords coords = (Coords) bldgCoords.nextElement();<br/>
<br/>
                // Walk through the entities at these coordinates.<br/>
                Enumeration entities = game.getEntities( coords );<br/>
                while( entities.hasMoreElements() ) {<br/>
                    final Entity entity = (Entity) entities.nextElement();<br/>
<br/>
                    // Is the entity infantry?<br/>
                    if ( entity instanceof Infantry ) {<br/>
<br/>
                        // Is the infantry dead?<br/>
                        if ( entity.isDoomed() || entity.isDestroyed() ) {<br/>
<br/>
                            // Has the entity taken a turn?<br/>
                            if ( !entity.isDone() ) {<br/>
<br/>
                                // Dead entities don't take turns.<br/>
                                game.removeTurnFor(entity);<br/>
                                bTurnsChanged = true;<br/>
<br/>
                            } // End entity-still-to-move<br/>
<br/>
                            // Clean out the dead entity.<br/>
                            entity.setDestroyed(true);<br/>
                            game.moveToGraveyard(entity.getId());<br/>
                            send(createRemoveEntityPacket(entity.getId()));<br/>
                        }<br/>
<br/>
                        // Infantry that aren't dead are damaged.<br/>
                        else {<br/>
                            this.entityUpdate( entity.getId() );<br/>
                        }<br/>
<br/>
                    } // End entity-is-infantry<br/>
<br/>
                } // Check the next entity.<br/>
<br/>
            } // Handle the next hex in this building.<br/>
<br/>
            // Add this building to the report.<br/>
            bldgUpdates.addElement( bldg );<br/>
<br/>
        } // Handle the next affected building.<br/>
<br/>
        // Did we update the turns?<br/>
        if ( bTurnsChanged ) {<br/>
            send(createTurnVectorPacket());<br/>
        }<br/>
<br/>
        // Are there any building updates?<br/>
        if ( !bldgUpdates.isEmpty() ) {<br/>
<br/>
            // Send the building updates to the clients.<br/>
            sendChangedCFBuildings( bldgUpdates );<br/>
<br/>
            // Clear the list of affected buildings.<br/>
            this.affectedBldgs.clear();<br/>
        }<br/>
<br/>
        // And we're done.<br/>
        return;<br/>
<br/>
    } // End private void applyAffectedBldgs()<br/>
<br/>
    /**<br/>
     * Receives an entity movement packet, and if valid, executes it and ends<br/>
     * the current turn.<br/>
     *<br/>
     */<br/>
    private void receiveMovement(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        MovePath md = (MovePath)packet.getObject(1);<br/>
<br/>
        // is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_MOVEMENT) {<br/>
            System.err.println("error: server got movement packet in wrong phase");<br/>
            return;<br/>
        }<br/>
<br/>
        // can this player/entity act right now?<br/>
        if (!game.getTurn().isValid(connId, entity, game)) {<br/>
            System.err.println("error: server got invalid movement packet");<br/>
            return;<br/>
        }<br/>
<br/>
        // looks like mostly everything's okay<br/>
        processMovement(entity, md);<br/>
<br/>
        // Notify the clients about any building updates.<br/>
        applyAffectedBldgs();<br/>
<br/>
        // Update visibility indications if using double blind.<br/>
        if (doBlind()) {<br/>
            updateVisibilityIndicator();<br/>
        }<br/>
<br/>
        // This entity's turn is over.<br/>
        // N.B. if the entity fell, a *new* turn has already been added.<br/>
        endCurrentTurn(entity);<br/>
    }<br/>
<br/>
    /**<br/>
     * Steps through an entity movement packet, executing it.<br/>
     */<br/>
    private void processMovement(Entity entity, MovePath md) {<br/>
        Report r;<br/>
        boolean sideslipped = false; // for VTOL sideslipping<br/>
        <br/>
        // check for fleeing<br/>
        if (md.contains(MovePath.STEP_FLEE)) {<br/>
            // Unit has fled the battlefield.<br/>
            r = new Report(2005, Report.PUBLIC);<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
<br/>
            // Is the unit carrying passengers?<br/>
            final Vector passengers = entity.getLoadedUnits();<br/>
            if ( !passengers.isEmpty() ) {<br/>
                final Enumeration iter = passengers.elements();<br/>
                while ( iter.hasMoreElements() ) {<br/>
                    final Entity passenger = (Entity) iter.nextElement();<br/>
                    // Unit has fled the battlefield.<br/>
                    r = new Report(2010, Report.PUBLIC);<br/>
                    r.indent();<br/>
                    r.addDesc(passenger);<br/>
                    addReport(r);<br/>
                    game.removeEntity( passenger.getId(),<br/>
                            IEntityRemovalConditions.REMOVE_IN_RETREAT );<br/>
                    send( createRemoveEntityPacket(passenger.getId(),<br/>
                            IEntityRemovalConditions.REMOVE_IN_RETREAT) );<br/>
                }<br/>
            }<br/>
<br/>
            // Handle any picked up MechWarriors<br/>
            Enumeration iter = entity.getPickedUpMechWarriors().elements();<br/>
            while (iter.hasMoreElements() ) {<br/>
                Integer mechWarriorId = (Integer)iter.nextElement();<br/>
                Entity mw = game.getEntity(mechWarriorId.intValue());<br/>
<br/>
                // Is the MechWarrior an enemy?<br/>
                int condition = IEntityRemovalConditions.REMOVE_IN_RETREAT;<br/>
                r = new Report(2010);<br/>
                if (mw.isCaptured()) {<br/>
                    r = new Report(2015);<br/>
                    condition = IEntityRemovalConditions.REMOVE_CAPTURED;<br/>
                }<br/>
                game.removeEntity( mw.getId(), condition );<br/>
                send( createRemoveEntityPacket(mw.getId(), condition) );<br/>
                r.addDesc(mw);<br/>
                r.indent();<br/>
                addReport(r);<br/>
            }<br/>
<br/>
            // Is the unit being swarmed?<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
<br/>
                // Has the swarmer taken a turn?<br/>
                if ( !swarmer.isDone() ) {<br/>
<br/>
                    // Dead entities don't take turns.<br/>
                    game.removeTurnFor(swarmer);<br/>
                    send(createTurnVectorPacket());<br/>
<br/>
                } // End swarmer-still-to-move<br/>
<br/>
                // Unit has fled the battlefield.<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                r = new Report(2015, Report.PUBLIC);<br/>
                r.indent();<br/>
                r.addDesc(swarmer);<br/>
                addReport(r);<br/>
                game.removeEntity( swarmerId, IEntityRemovalConditions.REMOVE_CAPTURED );<br/>
                send( createRemoveEntityPacket(swarmerId,<br/>
                        IEntityRemovalConditions.REMOVE_CAPTURED) );<br/>
            }<br/>
            game.removeEntity( entity.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT );<br/>
            send( createRemoveEntityPacket(entity.getId(),<br/>
                    IEntityRemovalConditions.REMOVE_IN_RETREAT) );<br/>
            return;<br/>
        }<br/>
<br/>
        if (md.contains(MovePath.STEP_EJECT)) {<br/>
            if (entity instanceof Mech) {<br/>
                r = new Report(2020);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getCrew().getName());<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
            } else if (entity instanceof Tank) {<br/>
                r = new Report(2025);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
            }<br/>
            addReport( ejectEntity(entity, false));<br/>
<br/>
            return;<br/>
        }<br/>
<br/>
        // okay, proceed with movement calculations<br/>
        Coords lastPos = entity.getPosition();<br/>
        Coords curPos = entity.getPosition();<br/>
        int curFacing = entity.getFacing();<br/>
        int curVTOLElevation = entity.getElevation();<br/>
        int distance = 0;<br/>
        int mpUsed = 0;<br/>
        int moveType = IEntityMovementType.MOVE_NONE;<br/>
        int overallMoveType = IEntityMovementType.MOVE_NONE;<br/>
        // if the entity already used some MPs,<br/>
        // it previously tried to get up and fell,<br/>
        // and then got another turn. set moveType<br/>
        // and overallMoveType accordingly<br/>
        if (entity.mpUsed &gt; 0) {<br/>
            moveType = IEntityMovementType.MOVE_WALK;<br/>
            overallMoveType = IEntityMovementType.MOVE_WALK;<br/>
            if (entity.mpUsed &gt; entity.getWalkMP()) {<br/>
                moveType = IEntityMovementType.MOVE_RUN;<br/>
                overallMoveType = IEntityMovementType.MOVE_RUN;<br/>
            }<br/>
        }<br/>
        boolean firstStep;<br/>
        boolean wasProne;<br/>
        boolean fellDuringMovement;<br/>
        int prevFacing = curFacing;<br/>
        IHex prevHex = null;<br/>
        final boolean isInfantry = (entity instanceof Infantry);<br/>
        AttackAction charge = null;<br/>
        PilotingRollData rollTarget;<br/>
        // cache this here, otherwise changing MP in the turn causes <br/>
        // errorneous gravity PSRs<br/>
        int cachedGravityLimit = (IEntityMovementType.MOVE_JUMP == moveType)?<br/>
            entity.getOriginalJumpMP() : entity.getRunMP(false); <br/>
<br/>
        // Compile the move<br/>
        md.compile(game, entity);<br/>
<br/>
        if (md.contains(MovePath.STEP_CLEAR_MINEFIELD)) {<br/>
            ClearMinefieldAction cma = new ClearMinefieldAction(entity.getId());<br/>
            entity.setClearingMinefield(true);<br/>
            game.addAction(cma);<br/>
        }<br/>
<br/>
        // check for MASC failure<br/>
        if (entity instanceof Mech) {<br/>
            Vector crits = new Vector();<br/>
            Vector vReport = new Vector();<br/>
            if (((Mech)entity).checkForMASCFailure(md, vReport, crits)) {<br/>
                addReport(vReport);<br/>
                CriticalSlot cs = null;<br/>
                int loc = Entity.LOC_NONE;<br/>
                for(Enumeration e = crits.elements();e.hasMoreElements();) {<br/>
                    Object o = e.nextElement();<br/>
                    if(o instanceof Integer)<br/>
                        loc = (Integer) o;<br/>
                    else if (o instanceof CriticalSlot) {<br/>
                        cs = (CriticalSlot) o;<br/>
                        applyCriticalHit(entity, loc, cs, true);<br/>
                    }<br/>
                }<br/>
                // no movement after that<br/>
                md.clear();<br/>
            }<br/>
        }<br/>
<br/>
        overallMoveType = md.getLastStepMovementType();<br/>
<br/>
        //check for starting in liquid magma<br/>
        if(game.getBoard().getHex(entity.getPosition()).terrainLevel(Terrains.MAGMA) == 2<br/>
            &amp;&amp; entity.getElevation() == 0) {<br/>
            doMagmaDamage(entity, false);<br/>
        }            <br/>
<br/>
        // iterate through steps<br/>
        firstStep = true;<br/>
        fellDuringMovement = false;<br/>
        /* Bug 754610: Revert fix for bug 702735. */<br/>
        MoveStep prevStep = null;<br/>
<br/>
        Vector movePath = new Vector();<br/>
<br/>
        for (final Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MoveStep step = (MoveStep)i.nextElement();<br/>
            wasProne = entity.isProne();<br/>
            boolean isPavementStep = step.isPavementStep();<br/>
            boolean entityFellWhileAttemptingToStand = false;<br/>
<br/>
            // stop for illegal movement<br/>
            if (step.getMovementType() == IEntityMovementType.MOVE_ILLEGAL) {<br/>
                break;<br/>
            }<br/>
            <br/>
            //stop if the entity already killed itself<br/>
            if(entity.isDestroyed() || entity.isDoomed()) {<br/>
                break;<br/>
            }<br/>
            <br/>
            // check piloting skill for getting up<br/>
            rollTarget = entity.checkGetUp(step);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                entity.heatBuildup += 1;<br/>
                entity.setProne(false);<br/>
                entity.setHullDown(false);<br/>
                wasProne = false;<br/>
                game.resetPSRs(entity);<br/>
                entityFellWhileAttemptingToStand = !doSkillCheckInPlace(entity, rollTarget);<br/>
            }<br/>
            // did the entity just fall?<br/>
            if (entityFellWhileAttemptingToStand) {<br/>
                moveType = step.getMovementType();<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                mpUsed = step.getMpUsed();<br/>
                fellDuringMovement = true;<br/>
                break;<br/>
            }<br/>
<br/>
            if (step.getType() == MovePath.STEP_UNJAM_RAC) {<br/>
                entity.setUnjammingRAC(true);<br/>
                game.addAction(new UnjamAction(entity.getId()));<br/>
<br/>
                break;<br/>
            }<br/>
            <br/>
            if (step.getType() == MovePath.STEP_LAY_MINE) {<br/>
                LayMinefieldAction lma = new LayMinefieldAction(entity.getId(), step.getMineToLay());<br/>
                game.addLayMinefieldAction(lma);<br/>
                entity.setLayingMines(true);<br/>
                break;<br/>
            }<br/>
<br/>
            if (step.getType() == MovePath.STEP_SEARCHLIGHT &amp;&amp; entity.hasSpotlight()) {<br/>
                final boolean SearchOn = !entity.isUsingSpotlight();<br/>
                entity.setSpotlightState(SearchOn);<br/>
                sendServerChat(entity.getDisplayName() + " switched searchlight "+(SearchOn?"on":"off")+".");<br/>
            }<br/>
<br/>
            // set most step parameters<br/>
            moveType = step.getMovementType();<br/>
            distance = step.getDistance();<br/>
            mpUsed = step.getMpUsed();<br/>
<br/>
            // check for charge<br/>
            if (step.getType() == MovePath.STEP_CHARGE) {<br/>
                if (entity.canCharge()) {<br/>
                    checkExtremeGravityMovement(entity, step, curPos, cachedGravityLimit);<br/>
                    Targetable target = step.getTarget( game );<br/>
                    ChargeAttackAction caa = new ChargeAttackAction(entity.getId(), target.getTargetType(), target.getTargetId(), target.getPosition());<br/>
                    entity.setDisplacementAttack(caa);<br/>
                    game.addCharge(caa);<br/>
                    charge = caa;<br/>
                } else {<br/>
                    sendServerChat("Illegal charge!! I don't think "+entity.getDisplayName() +" should be allowed to charge,"+<br/>
                                   " but the client of "+entity.getOwner().getName()+" disagrees.");<br/>
                    sendServerChat("Please make sure "+entity.getOwner().getName()+" is running MegaMek "+MegaMek.VERSION+<br/>
                                   ", or if that is already the case, submit a bug report at http://megamek.sf.net/");<br/>
                    return;<br/>
                }<br/>
                break;<br/>
            }<br/>
<br/>
            // check for dfa<br/>
            if (step.getType() == MovePath.STEP_DFA) {<br/>
                if (entity.canDFA()) {<br/>
                    checkExtremeGravityMovement(entity, step, curPos, cachedGravityLimit);<br/>
                    Targetable target = step.getTarget( game );<br/>
                    DfaAttackAction daa = new DfaAttackAction(entity.getId(), target.getTargetType(), target.getTargetId(), target.getPosition());<br/>
                    entity.setDisplacementAttack(daa);<br/>
                    game.addCharge(daa);<br/>
                    charge = daa;<br/>
                } else {<br/>
                    sendServerChat("Illegal DFA!! I don't think "+entity.getDisplayName() +" should be allowed to DFA,"+<br/>
                                   " but the client of "+entity.getOwner().getName()+" disagrees.");<br/>
                    sendServerChat("Please make sure "+entity.getOwner().getName()+" is running MegaMek "+MegaMek.VERSION+<br/>
                                   ", or if that is already the case, submit a bug report at http://megamek.sf.net/");<br/>
                    return;<br/>
                }<br/>
                break;<br/>
            }<br/>
<br/>
            // set last step parameters<br/>
            curPos = step.getPosition();<br/>
            if(moveType != IEntityMovementType.MOVE_JUMP || entity.getJumpType() != Mech.JUMP_BOOSTER)<br/>
                curFacing = step.getFacing();<br/>
            curVTOLElevation = step.getElevation();<br/>
            //set elevation in case of collapses<br/>
            entity.setElevation(step.getElevation());<br/>
<br/>
            final IHex curHex = game.getBoard().getHex(curPos);<br/>
<br/>
            // check for automatic unstick<br/>
            if(entity.canUnstickByJumping() &amp;&amp; entity.isStuck() &amp;&amp; moveType == IEntityMovementType.MOVE_JUMP) {<br/>
                entity.setStuck(false);<br/>
                entity.setCanUnstickByJumping(false);<br/>
            }<br/>
<br/>
            // Check for skid.<br/>
            rollTarget = entity.checkSkid(moveType, prevHex, overallMoveType,<br/>
                                          prevStep, prevFacing, curFacing,<br/>
                                          lastPos, curPos, isInfantry,<br/>
                                          distance);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                // Have an entity-meaningful PSR message.<br/>
                boolean psrPassed = true;<br/>
                if ( entity instanceof Mech ) {<br/>
                    psrPassed = doSkillCheckWhileMoving( entity, lastPos,<br/>
                                                          lastPos, rollTarget,<br/>
                                                          true );<br/>
                } else {<br/>
                    psrPassed = doSkillCheckWhileMoving( entity, lastPos,<br/>
                                                          lastPos, rollTarget,<br/>
                                                          false );<br/>
                }<br/>
                // Does the entity skid?<br/>
                if ( !psrPassed ){<br/>
<br/>
                    curPos = lastPos;<br/>
                    Coords nextPos = curPos;<br/>
                    IHex    nextHex = null;<br/>
                    int    skidDistance = 0;<br/>
                    Enumeration targets = null;<br/>
                    Entity target = null;<br/>
                    int    curElevation;<br/>
                    int    nextElevation;<br/>
                    int skidDirection = prevFacing;<br/>
<br/>
                    // All charge damage is based upon<br/>
                    // the pre-skid move distance.<br/>
                    entity.delta_distance = distance-1;<br/>
<br/>
                    // Attacks against a skidding target have additional +2.<br/>
                    moveType = IEntityMovementType.MOVE_SKID;<br/>
<br/>
                    // What is the first hex in the skid?<br/>
                    if(step.isThisStepBackwards()) {<br/>
                        skidDirection = (skidDirection + 3) % 6;<br/>
                    }<br/>
                    nextPos = curPos.translated( skidDirection );<br/>
                    nextHex = game.getBoard().getHex( nextPos );<br/>
<br/>
                    // Move the entity a number hexes from curPos in the<br/>
                    // skidDirection direction equal to half the distance moved<br/>
                    // this turn (rounded up), unless something intervenes.<br/>
                    for ( skidDistance = 0;<br/>
                          skidDistance &lt; (int) Math.ceil(entity.delta_distance / 2.0);<br/>
                          skidDistance++ ) {<br/>
<br/>
                        // Is the next hex off the board?<br/>
                        if ( !game.getBoard().contains(nextPos) ) {<br/>
<br/>
                            // Can the entity skid off the map?<br/>
                            if (game.getOptions().booleanOption("push_off_board")) {<br/>
                                // Yup.  One dead entity.<br/>
                                game.removeEntity(entity.getId(),<br/>
                                        IEntityRemovalConditions.REMOVE_PUSHED);<br/>
                                send(createRemoveEntityPacket(entity.getId(),<br/>
                                        IEntityRemovalConditions.REMOVE_PUSHED));<br/>
                                r = new Report(2030, Report.PUBLIC);<br/>
                                r.addDesc(entity);<br/>
                                addReport(r);<br/>
<br/>
                                // TODO: remove passengers and swarmers.<br/>
<br/>
                                // The entity's movement is completed.<br/>
                                return;<br/>
<br/>
                            } else {<br/>
                                // Nope.  Update the report.<br/>
                                r = new Report(2035);<br/>
                                r.subject = entity.getId();<br/>
                                r.indent();<br/>
                                addReport(r);<br/>
                            }<br/>
                            // Stay in the current hex and stop skidding.<br/>
                            break;<br/>
                        }<br/>
                        <br/>
                        // Can the skiding entity enter the next hex from this?<br/>
                        // N.B. can skid along roads.<br/>
                        if ( ( entity.isHexProhibited(curHex) ||<br/>
                               entity.isHexProhibited(nextHex) ) &amp;&amp;<br/>
                             !Compute.canMoveOnPavement(game, curPos, nextPos)<br/>
                             ) {<br/>
                            // Update report.<br/>
                            r = new Report(2040);<br/>
                            r.subject = entity.getId();<br/>
                            r.indent();<br/>
                            r.add(nextPos.getBoardNum(), true);<br/>
                            addReport(r);<br/>
<br/>
                            // N.B. the BMRr pg. 22 says that the unit<br/>
                            // "crashes" into the terrain but it doesn't<br/>
                            // mention any damage.<br/>
<br/>
                            // Stay in the current hex and stop skidding.<br/>
                            break;<br/>
                        }<br/>
<br/>
                        // Hovercraft can "skid" over water.<br/>
                        // all units can skid over ice.<br/>
                        // TODO: allow entities to occupy different levels of<br/>
                        //       buildings.<br/>
                        curElevation = curHex.floor();<br/>
                        nextElevation = nextHex.floor();<br/>
                        if ( entity instanceof Tank &amp;&amp;<br/>
                             entity.getMovementMode() ==<br/>
                             IEntityMovementMode.HOVER ) {<br/>
                            if ( curHex.containsTerrain(Terrains.WATER) ) {<br/>
                                curElevation = curHex.surface();<br/>
                            }<br/>
                            if ( nextHex.containsTerrain(Terrains.WATER) ) {<br/>
                                nextElevation += nextHex.surface();<br/>
                            }<br/>
                        } else {<br/>
                            if(curHex.containsTerrain(Terrains.ICE)) {<br/>
                                curElevation = curHex.surface();<br/>
                            }<br/>
                            if(nextHex.containsTerrain(Terrains.ICE)) {<br/>
                                nextElevation = nextHex.surface();<br/>
                            }<br/>
                        }<br/>
<br/>
                        // BMRr pg. 22 - Can't skid uphill,<br/>
                        //      but can skid downhill.<br/>
                        if ( curElevation &lt; nextElevation ) {<br/>
                            r = new Report(2045);<br/>
                            r.subject = entity.getId();<br/>
                            r.indent();<br/>
                            r.add(nextPos.getBoardNum(), true);<br/>
                            addReport(r);<br/>
<br/>
                            // Stay in the current hex and stop skidding.<br/>
                            break;<br/>
                        }<br/>
<br/>
                        // Have skidding units suffer falls.<br/>
                        else if ( curElevation &gt; nextElevation + 1 ) {<br/>
                            doEntityFallsInto( entity, curPos, nextPos,<br/>
                                               entity.getBasePilotingRoll() );<br/>
                            doEntityDisplacementMinefieldCheck(entity, curPos, nextPos);<br/>
                            // Stay in the current hex and stop skidding.<br/>
                            break;<br/>
                        }<br/>
<br/>
                        // Get any building in the hex.<br/>
                        Building bldg = game.getBoard().getBuildingAt(nextPos);<br/>
                        boolean bldgSuffered = false;<br/>
                        boolean stopTheSkid = false;<br/>
                        // Does the next hex contain an entities?<br/>
                        // ASSUMPTION: hurt EVERYONE in the hex.<br/>
                        // TODO: allow entities to occupy different levels of<br/>
                        //       buildings, and only skid into a single level.<br/>
                        targets = game.getEntities( nextPos );<br/>
                        if ( targets.hasMoreElements()) {<br/>
                            boolean skidChargeHit = false;<br/>
                            while ( targets.hasMoreElements() ) {<br/>
                                target = (Entity) targets.nextElement();<br/>
<br/>
                                // TODO : allow ready targets to move out of way<br/>
<br/>
                                // Mechs and vehicles get charged,<br/>
                                // but need to make a to-hit roll<br/>
                                if ( target instanceof Mech ||<br/>
                                     target instanceof Tank ) {<br/>
                                    ChargeAttackAction caa = new ChargeAttackAction(entity.getId(), target.getTargetType(), target.getTargetId(), target.getPosition());<br/>
                                    ToHitData toHit = caa.toHit(game, true);<br/>
<br/>
                                    // Calculate hit location.<br/>
                                    if ( entity instanceof Tank<br/>
                                         &amp;&amp; ((entity.getMovementMode() == IEntityMovementMode.HOVER)<br/>
                                         || (entity.getMovementMode() == IEntityMovementMode.NAVAL)<br/>
                                         || (entity.getMovementMode() == IEntityMovementMode.HYDROFOIL))<br/>
                                         &amp;&amp; 0 &lt; nextHex.terrainLevel(Terrains.WATER)<br/>
                                         &amp;&amp; target.getElevation() &lt; 0) {<br/>
                                        if ( 2 &lt;= nextHex.terrainLevel(Terrains.WATER) ||<br/>
                                             target.isProne() ) {<br/>
                                            // Hovercraft/Naval Craft can't hit the Mek.<br/>
                                            continue;<br/>
                                        }<br/>
                                        else {<br/>
                                            toHit.setHitTable(ToHitData.HIT_PUNCH);<br/>
                                        }<br/>
                                    } else if ( entity.getHeight() &lt;<br/>
                                                target.getHeight() ) {<br/>
                                        toHit.setHitTable(ToHitData.HIT_KICK);<br/>
                                    } else {<br/>
                                        toHit.setHitTable(ToHitData.HIT_NORMAL);<br/>
                                    }<br/>
                                    toHit.setSideTable<br/>
                                        (Compute.targetSideTable(entity, target));<br/>
<br/>
                                    // roll<br/>
                                    int roll = Compute.d6(2);<br/>
                                    // Update report.<br/>
                                    r = new Report(2050);<br/>
                                    r.subject = entity.getId();<br/>
                                    r.indent();<br/>
                                    r.add(target.getShortName(), true);<br/>
                                    r.add(nextPos.getBoardNum(), true);<br/>
                                    r.newlines = 0;<br/>
                                    addReport(r);<br/>
                                    if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
                                        roll = -12;<br/>
                                        r = new Report(2055);<br/>
                                        r.subject = entity.getId();<br/>
                                        r.add(toHit.getDesc());<br/>
                                        r.newlines = 0;<br/>
                                        addReport(r);<br/>
                                    } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
                                        r = new Report(2060);<br/>
                                        r.subject = entity.getId();<br/>
                                        r.add(toHit.getDesc());<br/>
                                        r.newlines = 0;<br/>
                                        addReport(r);<br/>
                                        roll = Integer.MAX_VALUE;<br/>
                                    } else {<br/>
                                        // report the roll<br/>
                                        r = new Report(2065);<br/>
                                        r.subject = entity.getId();<br/>
                                        r.add(toHit.getValue());<br/>
                                        r.add(roll);<br/>
                                        r.newlines = 0;<br/>
                                        addReport(r);<br/>
                                    }<br/>
<br/>
                                    // Resolve a charge against the target.<br/>
                                    // ASSUMPTION: buildings block damage for<br/>
                                    //             *EACH* entity charged.<br/>
                                    if (roll &lt; toHit.getValue()) {<br/>
                                        r = new Report(2070);<br/>
                                        r.subject = entity.getId();<br/>
                                        addReport(r);<br/>
                                    } else {<br/>
                                        // Resolve the charge.<br/>
                                        resolveChargeDamage<br/>
                                            (entity, target, toHit, skidDirection);<br/>
                                        // HACK: set the entity's location<br/>
                                        // to the original hex again, for the other targets<br/>
                                        if (targets.hasMoreElements()) {<br/>
                                            entity.setPosition(curPos);<br/>
                                        }<br/>
                                        bldgSuffered = true;<br/>
                                        skidChargeHit = true;<br/>
                                    }<br/>
                                    // The skid ends here if the target lives.<br/>
                                    if ( !target.isDoomed() &amp;&amp;<br/>
                                         !target.isDestroyed() &amp;&amp;<br/>
                                         !game.isOutOfGame(target) ) {<br/>
                                        stopTheSkid = true;<br/>
                                    }<br/>
<br/>
                                    // if we don't do this here,<br/>
                                    // we can have a mech without a leg<br/>
                                    // standing on the field and moving<br/>
                                    // as if it still had his leg after<br/>
                                    // getting skid-charged.<br/>
                                    if (!target.isDone()) {<br/>
                                        resolvePilotingRolls(target);<br/>
                                        game.resetPSRs(target);<br/>
                                        target.applyDamage();<br/>
                                        addNewLines();<br/>
                                    }<br/>
<br/>
                                }<br/>
<br/>
                                // Resolve "move-through" damage on infantry.<br/>
                                // Infantry inside of a building don't get a<br/>
                                // move-through, but suffer "bleed through"<br/>
                                // from the building.<br/>
                                else if ( target instanceof Infantry &amp;&amp;<br/>
                                          bldg != null ) {<br/>
                                    // Update report.<br/>
                                    r = new Report(2075);<br/>
                                    r.subject = entity.getId();<br/>
                                    r.indent();<br/>
                                    r.add(target.getShortName(), true);<br/>
                                    r.add(nextPos.getBoardNum(), true);<br/>
                                    r.newlines = 0;<br/>
                                    addReport(r);<br/>
<br/>
                                    // Infantry don't have different<br/>
                                    // tables for punches and kicks<br/>
                                    HitData hit = target.rollHitLocation( ToHitData.HIT_NORMAL, Compute.targetSideTable(entity, target) );<br/>
<br/>
                                    // Damage equals tonnage, divided by 5.<br/>
                                    // ASSUMPTION: damage is applied in one hit.<br/>
                                    addReport(<br/>
                                      damageEntity(target, hit,<br/>
                                      Math.round(entity.getWeight()/5)));<br/>
                                    addNewLines();<br/>
                                }<br/>
<br/>
                                // Has the target been destroyed?<br/>
                                if ( target.isDoomed() ) {<br/>
<br/>
                                    // Has the target taken a turn?<br/>
                                    if ( !target.isDone() ) {<br/>
<br/>
                                        // Dead entities don't take turns.<br/>
                                        game.removeTurnFor(target);<br/>
                                        send(createTurnVectorPacket());<br/>
<br/>
                                    } // End target-still-to-move<br/>
<br/>
                                    // Clean out the entity.<br/>
                                    target.setDestroyed(true);<br/>
                                    game.moveToGraveyard(target.getId());<br/>
                                    send(createRemoveEntityPacket(target.getId()));<br/>
                                }<br/>
<br/>
                                // Update the target's position,<br/>
                                // unless it is off the game map.<br/>
                                if ( !game.isOutOfGame(target) ) {<br/>
                                    entityUpdate( target.getId() );<br/>
                                }<br/>
<br/>
                            } // Check the next entity in the hex.<br/>
<br/>
                            // if we missed all the entities in the hex,<br/>
                            // move attacker to side hex<br/>
                            if (!skidChargeHit) {<br/>
                                Coords src = entity.getPosition();<br/>
                                Coords dest = Compute.getMissedChargeDisplacement<br/>
                                    (game, entity.getId(), src, skidDirection);<br/>
                                doEntityDisplacement(entity, src, dest, null);<br/>
                            } else {<br/>
                                // HACK: otherwise, set the entities position to that<br/>
                                // hex's coords, because we had to move the entity<br/>
                                // back earlier for the other targets<br/>
                                entity.setPosition(nextPos);<br/>
                            }<br/>
                        }<br/>
<br/>
                        // Handle the building in the hex.<br/>
                        // TODO : BMRr pg. 22, only count buildings that are<br/>
                        //      higher than our starting terrain height.<br/>
                        // TODO: allow units to skid on top of buildings.<br/>
                        if ( bldg != null ) {<br/>
<br/>
                            // Report that the entity has entered the bldg.<br/>
                            r = new Report(2080);<br/>
                            r.subject = entity.getId();<br/>
                            r.indent();<br/>
                            r.add(bldg.getName());<br/>
                            r.add(nextPos.getBoardNum(), true);<br/>
                            addReport(r);<br/>
<br/>
                            // If the building hasn't already suffered<br/>
                            // damage, then apply charge damage to the<br/>
                            // building and displace the entity inside.<br/>
                            // ASSUMPTION: you don't charge the building<br/>
                            //             if Tanks or Mechs were charged.<br/>
                            int chargeDamage = ChargeAttackAction.getDamageFor<br/>
                                ( entity );<br/>
                            if ( !bldgSuffered ) {<br/>
                                Report buildingReport = damageBuilding( bldg, chargeDamage );<br/>
                                buildingReport.indent(2);<br/>
                                buildingReport.subject = entity.getId();<br/>
                                addReport(buildingReport);<br/>
<br/>
                                // Apply damage to the attacker.<br/>
                                int toAttacker = ChargeAttackAction.getDamageTakenBy<br/>
                                    ( entity, bldg );<br/>
                                HitData hit = entity.rollHitLocation( ToHitData.HIT_NORMAL,<br/>
                                                                      entity.sideTable(nextPos)<br/>
                                                                      );<br/>
                                addReport(<br/>
                                                      damageEntity( entity, hit, toAttacker ));<br/>
                                addNewLines();<br/>
<br/>
                                entity.setPosition( nextPos );<br/>
                                doEntityDisplacementMinefieldCheck(entity, curPos, nextPos);<br/>
                                curPos = nextPos;<br/>
                            } // End buildings-suffer-too<br/>
<br/>
                            // Any infantry in the building take damage<br/>
                            // equal to the building being charged.<br/>
                            // ASSUMPTION: infantry take no damage from the<br/>
                            //             building absorbing damage from<br/>
                            //             Tanks and Mechs being charged.<br/>
                            damageInfantryIn( bldg, chargeDamage );<br/>
<br/>
                            // If a building still stands, then end the skid,<br/>
                            // and add it to the list of affected buildings.<br/>
                            if ( bldg.getCurrentCF() &gt; 0 ) {<br/>
                                stopTheSkid = true;<br/>
                                this.addAffectedBldg( bldg, false );<br/>
                            }<br/>
<br/>
                        } // End handle-building.<br/>
<br/>
                        // Do we stay in the current hex and stop skidding?<br/>
                        if ( stopTheSkid ) {<br/>
                            break;<br/>
                        }<br/>
                        // is the next hex a rubble hex?<br/>
                        rollTarget = entity.checkRubbleMove(step, nextHex,<br/>
                                                curPos, nextPos);<br/>
                        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                            doSkillCheckWhileMoving(entity, curPos, nextPos,<br/>
                                                        rollTarget, true);<br/>
                            if (entity.isProne()) {<br/>
                                // if we fell, stop the skid (see bug 1115608)<br/>
                                break;<br/>
                            }<br/>
                        }<br/>
                        <br/>
                        //check for breaking magma crust<br/>
                        if(curHex.terrainLevel(Terrains.MAGMA) == 1) {<br/>
                            int roll = Compute.d6(1);<br/>
                            r = new Report(2395);<br/>
                            r.addDesc(entity);<br/>
                            r.add(roll);<br/>
                            r.subject = entity.getId();<br/>
                            addReport(r);<br/>
                            if(roll == 6) {<br/>
                                curHex.removeTerrain(Terrains.MAGMA);<br/>
                                curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.MAGMA, 2));<br/>
                                sendChangedHex(curPos);<br/>
                                for(Enumeration e=game.getEntities(curPos);e.hasMoreElements();) {<br/>
                                    Entity en = (Entity)e.nextElement();<br/>
                                    if(en != entity)<br/>
                                        doMagmaDamage(en, false);<br/>
                                }<br/>
                            }<br/>
                        }<br/>
<br/>
                        //check for entering liquid magma<br/>
                        if(curHex.terrainLevel(Terrains.MAGMA) == 2) {<br/>
                            doMagmaDamage(entity, false);<br/>
                        }            <br/>
<br/>
                        // is the next hex a swamp?<br/>
                        rollTarget = entity.checkSwampMove(step, nextHex, <br/>
                                                              curPos, nextPos);<br/>
                        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                            if (!doSkillCheckWhileMoving(entity, curPos,<br/>
                                                   nextPos, rollTarget, false)){<br/>
                                entity.setStuck(true);<br/>
                                r = new Report(2081);<br/>
                                r.subject = entity.getId();<br/>
                                r.add(entity.getDisplayName(), true);<br/>
                                // stay here and stop skidding, see bug 1115608<br/>
                                break;<br/>
                            }<br/>
                        }<br/>
<br/>
                        // Update the position and keep skidding.<br/>
                        entity.setPosition( nextPos );<br/>
                        doEntityDisplacementMinefieldCheck(entity, curPos, nextPos);<br/>
                        curPos = nextPos;<br/>
                        r = new Report(2085);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent();<br/>
                        r.add(curPos.getBoardNum(), true);<br/>
                        addReport(r);<br/>
<br/>
                        // Get the next hex in the skid?<br/>
                        nextPos = nextPos.translated( skidDirection );<br/>
                        nextHex = game.getBoard().getHex( nextPos );<br/>
<br/>
                    } // Handle the next skid hex.<br/>
<br/>
                    // If the skidding entity violates stacking,<br/>
                    // displace targets until it doesn't.<br/>
                    curPos = entity.getPosition();<br/>
                    target = Compute.stackingViolation<br/>
                        (game, entity.getId(), curPos);<br/>
                    while (target != null) {<br/>
                        nextPos = Compute.getValidDisplacement<br/>
                            (game, target.getId(),<br/>
                             target.getPosition(), skidDirection);<br/>
                        // ASSUMPTION<br/>
                        // There should always be *somewhere* that<br/>
                        // the target can go... last skid hex if<br/>
                        // nothing else is available.<br/>
                        if ( null == nextPos ) {<br/>
                            // But I don't trust the assumption fully.<br/>
                            // Report the error and try to continue.<br/>
                            System.err.println( "The skid of " +<br/>
                                                entity.getShortName() +<br/>
                                                " should displace " +<br/>
                                                target.getShortName() +<br/>
                                                " in hex " +<br/>
                                                curPos.getBoardNum() +<br/>
                                                " but there is nowhere to go."<br/>
                                                );<br/>
                            break;<br/>
                        }<br/>
                        // indent displacement<br/>
                        r = new Report(1210, Report.PUBLIC);<br/>
                        r.indent();<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                        doEntityDisplacement(target, curPos, nextPos, null);<br/>
                        doEntityDisplacementMinefieldCheck(entity, curPos, nextPos);<br/>
                        target = Compute.stackingViolation( game,<br/>
                                                            entity.getId(),<br/>
                                                            curPos );<br/>
                    }<br/>
<br/>
                    // Mechs suffer damage for every hex skidded.<br/>
                    if ( entity instanceof Mech ) {<br/>
                        // Calculate one half falling damage times skid length.<br/>
                        int damage = skidDistance * (int) Math.ceil(Math.round(entity.getWeight() / 10.0) / 2.0);<br/>
<br/>
                        // report skid damage<br/>
                        r = new Report(2090);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent();<br/>
                        r.addDesc(entity);<br/>
                        r.add(damage);<br/>
                        addReport(r);<br/>
<br/>
                        // standard damage loop<br/>
                        // All skid damage is to the front.<br/>
                        while (damage &gt; 0) {<br/>
                            int cluster = Math.min(5, damage);<br/>
                            HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);<br/>
                            addReport(<br/>
                                damageEntity(entity, hit, cluster));<br/>
                            damage -= cluster;<br/>
                        }<br/>
                        addNewLines();<br/>
                    }<br/>
<br/>
                    // Clean up the entity if it has been destroyed.<br/>
                    if ( entity.isDoomed() ) {<br/>
                        entity.setDestroyed(true);<br/>
                        game.moveToGraveyard(entity.getId());<br/>
                        send(createRemoveEntityPacket(entity.getId()));<br/>
<br/>
                        // The entity's movement is completed.<br/>
                        return;<br/>
                    }<br/>
<br/>
                    // Let the player know the ordeal is over.<br/>
                    r = new Report(2095);<br/>
                    r.subject = entity.getId();<br/>
                    r.indent();<br/>
                    addReport(r);<br/>
<br/>
                    // set entity parameters<br/>
                    curFacing = entity.getFacing();<br/>
                    curPos = entity.getPosition();<br/>
                    entity.setSecondaryFacing( curFacing );<br/>
<br/>
                    // skid consumes all movement<br/>
                    if (md.hasActiveMASC()) {<br/>
                        mpUsed = entity.getRunMP();<br/>
                    } else {<br/>
                        mpUsed = entity.getRunMPwithoutMASC();<br/>
                    }<br/>
<br/>
                    entity.moved = moveType;<br/>
                    fellDuringMovement = true;<br/>
                    distance = entity.delta_distance;<br/>
                    break;<br/>
<br/>
                } // End failed-skid-psr<br/>
<br/>
            } // End need-skid-psr<br/>
            if(entity instanceof VTOL) {<br/>
                rollTarget = ((VTOL)entity).checkSideSlip(moveType, prevHex, overallMoveType,<br/>
                                          prevStep, prevFacing, curFacing,<br/>
                                          lastPos, curPos,<br/>
                                          distance);<br/>
                if(rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                    if(!doSkillCheckWhileMoving(entity,lastPos,curPos,rollTarget, false)) {<br/>
                        //report sideslip<br/>
                        sideslipped = true;<br/>
                        r = new Report(2100);<br/>
                        r.subject = entity.getId();<br/>
                        r.addDesc(entity);<br/>
                        addReport(r);<br/>
                        Coords newPos = lastPos.translated((prevFacing));//does this work for opposing hex?<br/>
                        // Is the next hex off the board?<br/>
                        if ( !game.getBoard().contains(newPos) ) {<br/>
                            // Can the entity skid off the map?<br/>
                            if (game.getOptions().booleanOption("push_off_board")) {<br/>
                                // Yup.  One dead entity.<br/>
                                game.removeEntity(entity.getId(),<br/>
                                        IEntityRemovalConditions.REMOVE_PUSHED);<br/>
                                send(createRemoveEntityPacket(entity.getId(),<br/>
                                        IEntityRemovalConditions.REMOVE_PUSHED));<br/>
                                r = new Report(2030);<br/>
                                r.subject = entity.getId();<br/>
                                r.addDesc(entity);<br/>
                                addReport(r);<br/>
<br/>
                                // TODO: remove passengers and swarmers.<br/>
                                // The entity's movement is completed.<br/>
                                return;<br/>
                            } else {<br/>
                                // Nope.  Update the report.<br/>
                                r = new Report(2035);<br/>
                                r.subject = entity.getId();<br/>
                                addReport(r);<br/>
                            }<br/>
                            // Stay in the current hex and stop skidding.<br/>
                            break;<br/>
                        }<br/>
                        IHex hex = game.getBoard().getHex(newPos);<br/>
                        int terrainLevel = hex.ceiling() - hex.surface();<br/>
                        int newElevation=(entity.calcElevation(game.getBoard().getHex(curPos),game.getBoard().getHex(newPos),curVTOLElevation,step.climbMode()));<br/>
                        if(newElevation&lt;=terrainLevel) {                            <br/>
                            r = new Report(2105);<br/>
                            r.subject = entity.getId();<br/>
                            r.add(newPos.getBoardNum(), true);<br/>
                            addReport(r);<br/>
<br/>
                            int hitSide=curFacing-prevFacing+6;<br/>
                            hitSide=hitSide % 6;<br/>
                            int table=0;<br/>
                            switch(hitSide) {//quite hackish...I think it ought to work, though.<br/>
                                case 0://can this happen?<br/>
                                    table=ToHitData.SIDE_FRONT;<br/>
                                    break;<br/>
                                case 1:<br/>
                                case 2:<br/>
                                    table=ToHitData.SIDE_LEFT;<br/>
                                    break;<br/>
                                case 3:<br/>
                                    table=ToHitData.SIDE_REAR;<br/>
                                    break;<br/>
                                case 4:<br/>
                                case 5:<br/>
                                    table=ToHitData.SIDE_RIGHT;<br/>
                                    break;<br/>
                            }<br/>
                            curPos=newPos;<br/>
                            curVTOLElevation=newElevation;<br/>
                            addReport(crashVTOL(((VTOL)entity),true,distance,curPos,curVTOLElevation,table));<br/>
                            <br/>
                            if((hex.containsTerrain(Terrains.WATER) &amp;&amp; !hex.containsTerrain(Terrains.ICE))<br/>
                                || hex.containsTerrain(Terrains.WOODS)<br/>
                                || hex.containsTerrain(Terrains.JUNGLE)) {<br/>
                                addReport(destroyEntity(entity,"could not land in crash site"));<br/>
                            } else if(newElevation &lt; hex.terrainLevel(Terrains.BLDG_ELEV)){<br/>
                                addReport(destroyEntity(entity, "crashed into building"));<br/>
                            }<br/>
                        } else {<br/>
                            r = new Report(2110);<br/>
                            r.subject = entity.getId();<br/>
                            r.add(newPos.getBoardNum(), true);<br/>
                            addReport(r);<br/>
                            entity.setElevation(entity.calcElevation(game.getBoard().getHex(curPos),game.getBoard().getHex(newPos),curVTOLElevation,step.climbMode()));<br/>
                            curPos=newPos;<br/>
                        }<br/>
<br/>
                        if(!entity.isDestroyed() &amp;&amp; !entity.isDoomed()) {<br/>
                            fellDuringMovement= true; //No, but it should work...<br/>
                        }<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // check if we've moved into rubble<br/>
            rollTarget = entity.checkRubbleMove(step, curHex, lastPos, curPos);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                doSkillCheckWhileMoving(entity, lastPos, curPos, rollTarget,<br/>
                                         true);<br/>
            }<br/>
<br/>
            //check for breaking magma crust<br/>
            if(curHex.terrainLevel(Terrains.MAGMA) == 1<br/>
                &amp;&amp; step.getElevation() == 0<br/>
                &amp;&amp; step.getMovementType() != IEntityMovementType.MOVE_JUMP) {<br/>
                int roll = Compute.d6(1);<br/>
                r = new Report(2395);<br/>
                r.addDesc(entity);<br/>
                r.add(roll);<br/>
                r.subject = entity.getId();<br/>
                addReport(r);<br/>
                if(roll == 6) {<br/>
                    curHex.removeTerrain(Terrains.MAGMA);<br/>
                    curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.MAGMA, 2));<br/>
                    sendChangedHex(curPos);<br/>
                    for(Enumeration e=game.getEntities(curPos);e.hasMoreElements();) {<br/>
                        Entity en = (Entity)e.nextElement();<br/>
                        if(en != entity)<br/>
                            doMagmaDamage(en, false);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            //check for entering liquid magma<br/>
            if(curHex.terrainLevel(Terrains.MAGMA) == 2<br/>
                &amp;&amp; step.getElevation() == 0<br/>
                &amp;&amp; step.getMovementType() != IEntityMovementType.MOVE_JUMP) {<br/>
                doMagmaDamage(entity, false);<br/>
            }            <br/>
<br/>
            // check if we've moved into a swamp<br/>
            rollTarget = entity.checkSwampMove(step, curHex, lastPos, curPos);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                if (!doSkillCheckWhileMoving(entity, lastPos, curPos, rollTarget,<br/>
                                         false)){<br/>
                    entity.setStuck(true);<br/>
                    entity.setCanUnstickByJumping(true);<br/>
                    r = new Report(2081);<br/>
                    r.add(entity.getDisplayName());<br/>
                    r.subject = entity.getId();<br/>
                    addReport(r);<br/>
                    break;<br/>
                }<br/>
            }<br/>
<br/>
            // check to see if we are a mech and we've moved OUT of fire<br/>
            IHex lastHex = game.getBoard().getHex(lastPos);<br/>
            if (entity instanceof Mech) {<br/>
                if ( !lastPos.equals(curPos)<br/>
                    &amp;&amp; (lastHex.containsTerrain(Terrains.FIRE)<br/>
                            || lastHex.containsTerrain(Terrains.MAGMA))<br/>
                    &amp;&amp; ( step.getMovementType() != IEntityMovementType.MOVE_JUMP<br/>
                         // Bug #828741 -- jumping bypasses fire, but not on the first step<br/>
                         //   getMpUsed -- total MP used to this step<br/>
                         //   getMp -- MP used in this step<br/>
                         //   the difference will always be 0 on the "first step" of a jump,<br/>
                         //   and &gt;0 on a step in the midst of a jump<br/>
                         || ( 0 == step.getMpUsed() - step.getMp() ) ) )<br/>
                {<br/>
                    int heat=0;<br/>
                    if(lastHex.containsTerrain(Terrains.FIRE))<br/>
                        heat+=2;<br/>
                    if(lastHex.terrainLevel(Terrains.MAGMA) == 1) {<br/>
                        heat+=2;<br/>
                    }<br/>
                    else if(lastHex.terrainLevel(Terrains.MAGMA) == 2) {<br/>
                        heat+=5;<br/>
                    }<br/>
                    entity.heatBuildup+=heat;<br/>
                    r = new Report(2115);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(heat);<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            // check to see if we are not a mech and we've moved INTO fire<br/>
            if (!(entity instanceof Mech)) {<br/>
                if ( game.getBoard().getHex(curPos).containsTerrain(Terrains.FIRE)<br/>
                    &amp;&amp; !lastPos.equals(curPos)<br/>
                    &amp;&amp; step.getMovementType() != IEntityMovementType.MOVE_JUMP<br/>
                    &amp;&amp; step.getElevation() &lt;= 1 ) {<br/>
                    if(game.getOptions().booleanOption("vehicle_fires")<br/>
                            &amp;&amp; entity instanceof Tank) {<br/>
                        checkForVehicleFire((Tank)entity, false);<br/>
                    } else {<br/>
                        doFlamingDeath(entity);<br/>
                    }<br/>
                }<br/>
            }<br/>
            // check for extreme gravity movement<br/>
            if (!i.hasMoreElements() &amp;&amp; !firstStep) {<br/>
                checkExtremeGravityMovement(entity, step, curPos, cachedGravityLimit);<br/>
            }<br/>
            // check for minefields.<br/>
            if ((!lastPos.equals(curPos) &amp;&amp; (step.getMovementType() != IEntityMovementType.MOVE_JUMP))<br/>
                || ((overallMoveType == IEntityMovementType.MOVE_JUMP) &amp;&amp; (!i.hasMoreElements()))) {<br/>
                checkVibrabombs(entity, curPos, false, lastPos, curPos);<br/>
                if (game.containsMinefield(curPos)) {<br/>
                    Enumeration minefields = game.getMinefields(curPos).elements();<br/>
                    while (minefields.hasMoreElements()) {<br/>
                        Minefield mf = (Minefield) minefields.nextElement();<br/>
<br/>
                        boolean isOnGround = (!i.hasMoreElements());<br/>
                        isOnGround |= (step.getMovementType() != IEntityMovementType.MOVE_JUMP);<br/>
                        isOnGround &amp;= step.getElevation() == 0;<br/>
                        if (isOnGround) {<br/>
                            enterMinefield(entity, mf, curPos, curPos, true);<br/>
                        } else if (mf.getType() == Minefield.TYPE_THUNDER_ACTIVE) {<br/>
                            enterMinefield(entity, mf, curPos, curPos, true, 2);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // infantry discovers minefields if they end their move<br/>
            // in a minefield.<br/>
<br/>
            if (!lastPos.equals(curPos) &amp;&amp;<br/>
                !i.hasMoreElements() &amp;&amp;<br/>
                isInfantry) {<br/>
                if (game.containsMinefield(curPos)) {<br/>
                    Player owner = entity.getOwner();<br/>
                    Enumeration minefields = game.getMinefields(curPos).elements();<br/>
                    while (minefields.hasMoreElements()) {<br/>
                        Minefield mf = (Minefield) minefields.nextElement();<br/>
                        if (!owner.containsMinefield(mf)) {<br/>
                            r = new Report(2120);<br/>
                            r.subject = entity.getId();<br/>
                            r.add(entity.getShortName(), true);<br/>
                            addReport(r);<br/>
                            revealMinefield(owner, mf);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // check if we've moved into water<br/>
            rollTarget = entity.checkWaterMove(step, curHex, lastPos, curPos,<br/>
                                               isPavementStep);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                // Swarmers need special handling.<br/>
                final int swarmerId = entity.getSwarmAttackerId();<br/>
                boolean swarmerDone = true;<br/>
                Entity swarmer = null;<br/>
                if (Entity.NONE != swarmerId) {<br/>
                    swarmer = game.getEntity( swarmerId );<br/>
                    swarmerDone = swarmer.isDone();<br/>
                }<br/>
<br/>
                // Now do the skill check.<br/>
                doSkillCheckWhileMoving(entity, lastPos, curPos, rollTarget,<br/>
                                         true);<br/>
<br/>
                // Swarming infantry platoons may drown.<br/>
                if (curHex.terrainLevel(Terrains.WATER) &gt; 1) {<br/>
                    drownSwarmer(entity, curPos);<br/>
                }<br/>
<br/>
                // Do we need to remove a game turn for the swarmer<br/>
                if (!swarmerDone &amp;&amp;<br/>
                    ( swarmer.isDoomed() || swarmer.isDestroyed() )) {<br/>
                    // We have to diddle with the swarmer's<br/>
                    // status to get its turn removed.<br/>
                    swarmer.setDone( false );<br/>
                    swarmer.setUnloaded( false );<br/>
<br/>
                    // Dead entities don't take turns.<br/>
                    game.removeTurnFor( swarmer );<br/>
                    send( createTurnVectorPacket() );<br/>
<br/>
                    // Return the original status.<br/>
                    swarmer.setDone( true );<br/>
                    swarmer.setUnloaded( true );<br/>
                }<br/>
<br/>
                // check for inferno wash-off<br/>
                checkForWashedInfernos(entity, curPos);<br/>
            }<br/>
            <br/>
            // In water, may or may not be a new hex, neccessary to<br/>
            // check during movement, for breach damage, and always<br/>
            // set dry if appropriate<br/>
            //TODO: possibly make the locations local and set later<br/>
            doSetLocationsExposure(entity, curHex, <br/>
                    step.getMovementType() == IEntityMovementType.MOVE_JUMP,<br/>
                    step.getElevation());<br/>
<br/>
            //check for breaking ice by breaking through from below<br/>
            if(prevHex != null &amp;&amp; prevStep != null<br/>
                    &amp;&amp; prevStep.getElevation() &lt; 0<br/>
                    &amp;&amp; step.getElevation() == 0<br/>
                    &amp;&amp; prevHex.containsTerrain(Terrains.ICE)<br/>
                    &amp;&amp; prevHex.containsTerrain(Terrains.WATER)<br/>
                    &amp;&amp; step.getMovementType() != IEntityMovementType.MOVE_JUMP<br/>
                    &amp;&amp; !(lastPos.equals(curPos))) {<br/>
                r = new Report(2410);<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                resolveIceBroken(lastPos);<br/>
            }<br/>
            //check for breaking ice by stepping on it<br/>
            if(curHex.containsTerrain(Terrains.ICE)<br/>
                    &amp;&amp; curHex.containsTerrain(Terrains.WATER)<br/>
                    &amp;&amp; step.getMovementType() != IEntityMovementType.MOVE_JUMP<br/>
                    &amp;&amp; !(lastPos.equals(curPos))) {<br/>
                if(step.getElevation() == 0<br/>
                        ) {<br/>
                    int roll = Compute.d6(1);<br/>
                    r = new Report(2118);<br/>
                    r.addDesc(entity);<br/>
                    r.add(roll);<br/>
                    r.subject = entity.getId();<br/>
                    addReport(r);<br/>
                    if(roll == 6) {<br/>
                        resolveIceBroken(curPos);<br/>
                        doEntityFallsInto(entity, lastPos, curPos, entity.getBasePilotingRoll(), false);<br/>
                    }<br/>
                }<br/>
                //or intersecting it<br/>
                else if(step.getElevation() + entity.height() == 0) {<br/>
                    r = new Report(2410);<br/>
                    r.addDesc(entity);<br/>
                    addReport(r);<br/>
                    resolveIceBroken(curPos);<br/>
                }<br/>
            }<br/>
            <br/>
            // Handle loading units.<br/>
            if ( step.getType() == MovePath.STEP_LOAD ) {<br/>
<br/>
                // Find the unit being loaded.<br/>
                Entity loaded = null;<br/>
                Enumeration entities = game.getEntities( curPos );<br/>
                while ( entities.hasMoreElements() ) {<br/>
<br/>
                    // Is the other unit friendly and not the current entity?<br/>
                    loaded = (Entity)entities.nextElement();<br/>
                    if ( entity.getOwner() == loaded.getOwner() &amp;&amp;<br/>
                         !entity.equals(loaded) ) {<br/>
<br/>
                        // The moving unit should be able to load the other<br/>
                        // unit and the other should be able to have a turn.<br/>
                        if ( !entity.canLoad(loaded) ||<br/>
                             !loaded.isSelectableThisTurn() ) {<br/>
                            // Something is fishy in Denmark.<br/>
                            System.err.println( entity.getShortName() +<br/>
                                                " can not load " +<br/>
                                                loaded.getShortName() );<br/>
                            loaded = null;<br/>
                        }<br/>
                        else {<br/>
                            // Have the deployed unit load the indicated unit.<br/>
                            this.loadUnit( entity, loaded );<br/>
<br/>
                            // Stop looking.<br/>
                            break;<br/>
                        }<br/>
<br/>
                    } else {<br/>
                        // Nope. Discard it.<br/>
                        loaded = null;<br/>
                    }<br/>
<br/>
                } // Handle the next entity in this hex.<br/>
<br/>
                // We were supposed to find someone to load.<br/>
                if ( loaded == null ) {<br/>
                    System.err.println( "Could not find unit for " +<br/>
                                        entity.getShortName() +<br/>
                                        " to load in " + curPos );<br/>
                }<br/>
<br/>
            } // End STEP_LOAD<br/>
<br/>
            // Handle unloading units.<br/>
            if ( step.getType() == MovePath.STEP_UNLOAD ) {<br/>
                Targetable unloaded = step.getTarget( game );<br/>
                if ( !this.unloadUnit( entity, unloaded,<br/>
                                       curPos, curFacing, step.getElevation() ) ) {<br/>
                    System.err.println( "Error! Server was told to unload " +<br/>
                                        unloaded.getDisplayName() +<br/>
                                        " from " + entity.getDisplayName() +<br/>
                                        " into " + curPos.getBoardNum() );<br/>
                }<br/>
            }<br/>
<br/>
            // Handle non-infantry moving into a building.<br/>
            int buildingMove = entity.checkMovementInBuilding(step, prevStep, curPos, lastPos);<br/>
            if (buildingMove &gt; 0) {<br/>
<br/>
                // Get the building being exited.<br/>
                Building bldgExited = null;<br/>
                if((buildingMove &amp; 1) == 1)<br/>
                    bldgExited = game.getBoard().getBuildingAt( lastPos );<br/>
<br/>
                // Get the building being entered.<br/>
                Building bldgEntered = null;<br/>
                if((buildingMove &amp; 2) == 2)<br/>
                    bldgEntered = game.getBoard().getBuildingAt( curPos );<br/>
                <br/>
                // Get the building being stepped on.<br/>
                Building bldgStepped = null;<br/>
                if((buildingMove &amp; 4) == 4)<br/>
                    bldgStepped = game.getBoard().getBuildingAt( curPos );<br/>
<br/>
                boolean collapsed = false;<br/>
                //are we passing through a building wall?<br/>
                if(bldgEntered != null || bldgExited != null) {<br/>
                    // If we're not leaving a building, just handle the "entered".<br/>
                    if ( bldgExited == null) {<br/>
                        collapsed = passBuildingWall( entity, bldgEntered,<br/>
                                                      lastPos, curPos,<br/>
                                                      distance, "entering" );<br/>
                        this.addAffectedBldg( bldgEntered, collapsed );<br/>
                    }<br/>
    <br/>
                    // If we're moving withing the same building, just handle<br/>
                    // the "within".<br/>
                    else if ( bldgExited.equals( bldgEntered ) ) {<br/>
                        collapsed = passBuildingWall( entity, bldgEntered,<br/>
                                                      lastPos, curPos,<br/>
                                                      distance, "moving in" );<br/>
                        this.addAffectedBldg( bldgEntered, collapsed );<br/>
                    }<br/>
    <br/>
                    // If we have different buildings, roll for each.<br/>
                    else if ( bldgExited != null &amp;&amp; bldgEntered != null ) {<br/>
                        collapsed = passBuildingWall( entity, bldgExited,<br/>
                                                      lastPos, curPos,<br/>
                                                      distance, "exiting" );<br/>
                        this.addAffectedBldg( bldgExited, collapsed );<br/>
                        collapsed = passBuildingWall( entity, bldgEntered,<br/>
                                                      lastPos, curPos,<br/>
                                                      distance, "entering" );<br/>
                        this.addAffectedBldg( bldgEntered, collapsed );<br/>
                    }<br/>
    <br/>
                    // Otherwise, just handle the "exited".<br/>
                    else if (bldgExited != null){<br/>
                        collapsed = passBuildingWall( entity, bldgExited,<br/>
                                                      lastPos, curPos,<br/>
                                                      distance, "exiting" );<br/>
                        this.addAffectedBldg( bldgExited, collapsed );<br/>
                    }<br/>
                }<br/>
                <br/>
                //stepping on roof, no PSR just check for over weight<br/>
                if(bldgStepped != null) {<br/>
                    collapsed = checkBuildingCollapseWhileMoving(bldgStepped, entity, curPos);<br/>
                    this.addAffectedBldg( bldgStepped, collapsed );<br/>
                }<br/>
<br/>
                // Clean up the entity if it has been destroyed.<br/>
                if ( entity.isDoomed() ) {<br/>
                    entity.setDestroyed(true);<br/>
                    game.moveToGraveyard(entity.getId());<br/>
                    send(createRemoveEntityPacket(entity.getId()));<br/>
<br/>
                    // The entity's movement is completed.<br/>
                    return;<br/>
                }<br/>
<br/>
                // TODO: what if a building collapses into rubble?<br/>
            }<br/>
<br/>
            // did the entity just fall?<br/>
            if (!wasProne &amp;&amp; entity.isProne()) {<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                mpUsed = step.getMpUsed();<br/>
                fellDuringMovement = true;<br/>
                break;<br/>
            }<br/>
<br/>
            // dropping prone intentionally?<br/>
            if (step.getType() == MovePath.STEP_GO_PRONE) {<br/>
                mpUsed = step.getMpUsed();<br/>
                rollTarget = entity.checkDislodgeSwarmers(step);<br/>
                if (rollTarget.getValue() == TargetRoll.CHECK_FALSE) {<br/>
                    // Not being swarmed<br/>
                    entity.setProne(true);<br/>
                    // check to see if we washed off infernos<br/>
                    checkForWashedInfernos(entity, curPos);<br/>
                    break;<br/>
                } else {<br/>
                    // Being swarmed<br/>
                    entity.setPosition(curPos);<br/>
                    if (doDislodgeSwarmerSkillCheck(entity,<br/>
                                                    rollTarget,<br/>
                                                    curPos)) {<br/>
                        // Entity falls<br/>
                        curFacing = entity.getFacing();<br/>
                        curPos = entity.getPosition();<br/>
                        fellDuringMovement = true;<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            }<br/>
            <br/>
            //going hull down<br/>
            if(step.getType() == MovePath.STEP_HULL_DOWN) {<br/>
                mpUsed = step.getMpUsed();<br/>
                entity.setHullDown(true);<br/>
            }<br/>
<br/>
            // Track this step's location.<br/>
            movePath.addElement( new UnitLocation( entity.getId(),<br/>
                                                   curPos,<br/>
                                                   curFacing ) );<br/>
<br/>
            // update lastPos, prevStep, prevFacing &amp; prevHex<br/>
            lastPos = new Coords(curPos);<br/>
            prevStep = step;<br/>
            /* Bug 754610: Revert fix for bug 702735.<br/>
            if (prevHex != null &amp;&amp; !curHex.equals(prevHex)) {<br/>
            */<br/>
            if (!curHex.equals(prevHex)) {<br/>
                prevFacing = curFacing;<br/>
            }<br/>
            prevHex = curHex;<br/>
<br/>
            firstStep = false;<br/>
        }<br/>
<br/>
        // set entity parameters<br/>
        entity.setPosition(curPos);<br/>
        entity.setFacing(curFacing);<br/>
        entity.setSecondaryFacing(curFacing);<br/>
        entity.delta_distance = distance;<br/>
        entity.moved = moveType;<br/>
        entity.mpUsed = mpUsed;<br/>
        if (!sideslipped &amp;&amp; !fellDuringMovement) {<br/>
            entity.setElevation(curVTOLElevation);<br/>
        }<br/>
        entity.setClimbMode(md.getFinalClimbMode());<br/>
        <br/>
        <br/>
<br/>
        // if we ran with destroyed hip or gyro, we need a psr<br/>
        rollTarget = entity.checkRunningWithDamage(overallMoveType);<br/>
        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
            doSkillCheckInPlace(entity, rollTarget);<br/>
        }<br/>
<br/>
        // but the danger isn't over yet!  landing from a jump can be risky!<br/>
        if (overallMoveType == IEntityMovementType.MOVE_JUMP &amp;&amp; !entity.isMakingDfa()) {<br/>
            final IHex curHex = game.getBoard().getHex(curPos);<br/>
            // check for damaged criticals<br/>
            rollTarget = entity.checkLandingWithDamage();<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                doSkillCheckInPlace(entity, rollTarget);<br/>
            }<br/>
            // jumped into water?<br/>
            int waterLevel = curHex.terrainLevel(Terrains.WATER);<br/>
            if(curHex.containsTerrain(Terrains.ICE) &amp;&amp; waterLevel &gt; 0) {<br/>
                waterLevel = 0;<br/>
                //check for breaking ice<br/>
                int roll = Compute.d6(1);<br/>
                r = new Report(2122);<br/>
                r.add(entity.getDisplayName(), true);<br/>
                r.add(roll);<br/>
                r.subject = entity.getId();<br/>
                addReport(r);<br/>
                if(roll &gt;= 4) {<br/>
                    //oops!<br/>
                    resolveIceBroken(curPos);<br/>
                    doEntityFallsInto(entity, lastPos, curPos, entity.getBasePilotingRoll(), false);<br/>
                }<br/>
            }<br/>
            rollTarget = entity.checkWaterMove(waterLevel);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                doSkillCheckInPlace(entity, rollTarget);<br/>
            }<br/>
            if (waterLevel &gt; 1) {<br/>
                // Any swarming infantry will be destroyed.<br/>
                drownSwarmer(entity, curPos);<br/>
            }<br/>
<br/>
            //check for building collapse<br/>
            Building bldg = game.getBoard().getBuildingAt(curPos);<br/>
            if(bldg != null) {<br/>
                checkForCollapse( bldg, game.getPositionMap() );<br/>
            }<br/>
<br/>
            //check for breaking magma crust<br/>
            if(curHex.terrainLevel(Terrains.MAGMA) == 1) {<br/>
                int roll = Compute.d6(1);<br/>
                r = new Report(2395);<br/>
                r.addDesc(entity);<br/>
                r.add(roll);<br/>
                r.subject = entity.getId();<br/>
                addReport(r);<br/>
                if(roll == 6) {<br/>
                    curHex.removeTerrain(Terrains.MAGMA);<br/>
                    curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.MAGMA, 2));<br/>
                    sendChangedHex(curPos);<br/>
                    for(Enumeration e=game.getEntities(curPos);e.hasMoreElements();) {<br/>
                        Entity en = (Entity)e.nextElement();<br/>
                        if(en != entity)<br/>
                            doMagmaDamage(en, false);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            //check for entering liquid magma<br/>
            if(curHex.terrainLevel(Terrains.MAGMA) == 2) {<br/>
                doMagmaDamage(entity, false);<br/>
            }            <br/>
<br/>
            // jumped into swamp? maybe stuck!<br/>
            if (curHex.containsTerrain(Terrains.SWAMP)<br/>
                || curHex.containsTerrain(Terrains.MAGMA)<br/>
                || curHex.containsTerrain(Terrains.SNOW)<br/>
                || curHex.containsTerrain(Terrains.MUD)<br/>
                || curHex.containsTerrain(Terrains.TUNDRA)) {<br/>
                if (entity instanceof Mech) {<br/>
                    entity.setStuck(true);<br/>
                    r = new Report(2121);<br/>
                    r.add(entity.getDisplayName(), true);<br/>
                    r.subject = entity.getId();<br/>
                    addReport(r);<br/>
                } else if (entity instanceof Infantry) {<br/>
                    PilotingRollData roll = entity.getBasePilotingRoll();<br/>
                    roll.addModifier(5, "infantry jumping into swamp");<br/>
                    if (!doSkillCheckWhileMoving(entity, curPos, curPos, roll, false)) {<br/>
                        entity.setStuck(true);<br/>
                        r = new Report(2081);<br/>
                        r.add(entity.getDisplayName());<br/>
                        r.subject = entity.getId();<br/>
                        addReport(r);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // If the entity is being swarmed, jumping may dislodge the fleas.<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
                final PilotingRollData roll =<br/>
                    entity.getBasePilotingRoll();<br/>
<br/>
                entity.addPilotingModifierForTerrain(roll);<br/>
<br/>
                // Add a +4 modifier.<br/>
                roll.addModifier( 4, "dislodge swarming infantry" );<br/>
<br/>
                // If the swarmer has Assault claws, give a 1 modifier.<br/>
                // We can stop looking when we find our first match.<br/>
                for ( Enumeration iter = swarmer.getMisc();<br/>
                      iter.hasMoreElements(); ) {<br/>
                    Mounted mount = (Mounted) iter.nextElement();<br/>
                    EquipmentType equip = mount.getType();<br/>
                    if ( BattleArmor.ASSAULT_CLAW.equals<br/>
                         (equip.getInternalName()) ) {<br/>
                        roll.addModifier( 1, "swarmer has assault claws" );<br/>
                        break;<br/>
                    }<br/>
                }<br/>
<br/>
                // okay, print the info<br/>
                r = new Report(2125);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
<br/>
                // roll<br/>
                final int diceRoll = Compute.d6(2);<br/>
                r = new Report(2130);<br/>
                r.subject = entity.getId();<br/>
                r.add(roll.getValueAsString());<br/>
                r.add(roll.getDesc());<br/>
                r.add(diceRoll);<br/>
                if (diceRoll &lt; roll.getValue()) {<br/>
                    r.choose(false);<br/>
                    addReport(r);<br/>
                } else {<br/>
                    // Dislodged swarmers don't get turns.<br/>
                    game.removeTurnFor( swarmer );<br/>
                    send( createTurnVectorPacket() );<br/>
<br/>
                    // Update the report and the swarmer's status.<br/>
                    r.choose(true);<br/>
                    addReport(r);<br/>
                    entity.setSwarmAttackerId( Entity.NONE );<br/>
                    swarmer.setSwarmTargetId( Entity.NONE );<br/>
<br/>
                    // Did the infantry fall into water?<br/>
                    if ( curHex.terrainLevel(Terrains.WATER) &gt; 0 ) {<br/>
                        // Swarming infantry die.<br/>
                        swarmer.setPosition( curPos );<br/>
                        r = new Report(2135);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent();<br/>
                        r.addDesc(swarmer);<br/>
                        addReport(r);<br/>
                        addReport(<br/>
                            destroyEntity(swarmer, "a watery grave", false));<br/>
                    } else {<br/>
                        // Swarming infantry take an 11 point hit.<br/>
                        // ASSUMPTION : damage should not be doubled.<br/>
                        r = new Report(2140);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent();<br/>
                        r.addDesc(swarmer);<br/>
                        addReport(r);<br/>
                        addReport(damageEntity(swarmer, swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT), 11));<br/>
                        addNewLines();<br/>
                        swarmer.setPosition( curPos );<br/>
                    }<br/>
                    entityUpdate( swarmerId );<br/>
                } // End successful-PSR<br/>
<br/>
            } // End try-to-dislodge-swarmers<br/>
<br/>
            // one more check for inferno wash-off<br/>
            checkForWashedInfernos(entity, curPos);<br/>
<br/>
        } // End entity-is-jumping<br/>
        // update entity's locations' exposure<br/>
        doSetLocationsExposure(entity, game.getBoard().getHex(curPos), false, entity.getElevation());<br/>
<br/>
        // should we give another turn to the entity to keep moving?<br/>
        if (fellDuringMovement &amp;&amp; entity.mpUsed &lt; entity.getRunMP()<br/>
        &amp;&amp; entity.isSelectableThisTurn() &amp;&amp; !entity.isDoomed()) {<br/>
            entity.applyDamage();<br/>
            entity.setDone(false);<br/>
            GameTurn newTurn = new GameTurn.SpecificEntityTurn(entity.getOwner().getId(), entity.getId());<br/>
            game.insertNextTurn(newTurn);<br/>
            // brief everybody on the turn update<br/>
            send(createTurnVectorPacket());<br/>
            // let everyone know about what just happened<br/>
            send(entity.getOwner().getId(), createSpecialReportPacket());<br/>
        } else {<br/>
            entity.setDone(true);<br/>
        }<br/>
<br/>
        // If the entity is being swarmed, update the attacker's position.<br/>
        final int swarmerId = entity.getSwarmAttackerId();<br/>
        if ( Entity.NONE != swarmerId ) {<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            swarmer.setPosition( curPos );<br/>
            // If the hex is on fire, and the swarming infantry is<br/>
            // *not* Battle Armor, it drops off.<br/>
            if ( !(swarmer instanceof BattleArmor) &amp;&amp;<br/>
                 game.getBoard().getHex(curPos).containsTerrain(Terrains.FIRE) ) {<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                r = new Report(2145);<br/>
                r.subject = entity.getId();<br/>
                r.indent();<br/>
                r.add(swarmer.getShortName(), true);<br/>
                addReport(r);<br/>
            }<br/>
            entityUpdate( swarmerId );<br/>
        }<br/>
<br/>
        // Update the entitiy's position,<br/>
        // unless it is off the game map.<br/>
        if (!game.isOutOfGame(entity)) {<br/>
            entityUpdate( entity.getId(), movePath  );<br/>
            if (entity.isDoomed()) {<br/>
                send(createRemoveEntityPacket(entity.getId(), entity.getRemovalCondition()));<br/>
            }<br/>
        }<br/>
<br/>
        // if using double blind, update the player on new units he might see<br/>
        if (doBlind()) {<br/>
            send(entity.getOwner().getId(), createFilteredEntitiesPacket(entity.getOwner()));<br/>
        }<br/>
<br/>
        // if we generated a charge attack, report it now<br/>
        if (charge != null) {<br/>
            send(createAttackPacket(charge, 1));<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Delivers a thunder-aug shot to the targetted hex area.<br/>
     * Thunder-Augs are 7 hexes, though, so...<br/>
     */<br/>
    private void deliverThunderAugMinefield( Coords coords,<br/>
                                             int playerId, int damage ) {<br/>
        Coords mfCoord = null;<br/>
        for (int dir=0; dir &lt; 7; dir++) {<br/>
            switch (dir) {<br/>
            case 6:<br/>
                // The targeted hex.<br/>
                mfCoord = new Coords(coords);<br/>
                break;<br/>
            default:<br/>
                // The hex in the dir direction from the targeted hex.<br/>
                mfCoord = coords.translated(dir);<br/>
                break;<br/>
            }<br/>
<br/>
            // Only if this is on the board...<br/>
            if ( game.getBoard().contains(mfCoord) ) {<br/>
                Minefield minefield = null;<br/>
                Enumeration minefields = game.getMinefields(mfCoord).elements();<br/>
                // Check if there already are Thunder minefields in the hex.<br/>
                while (minefields.hasMoreElements()) {<br/>
                    Minefield mf = (Minefield) minefields.nextElement();<br/>
                    if (mf.getType() == Minefield.TYPE_THUNDER) {<br/>
                        minefield = mf;<br/>
                        break;<br/>
                    }<br/>
                }<br/>
<br/>
                // Did we find a Thunder minefield in the hex?<br/>
                // N.B. damage Thunder minefields equals the number of<br/>
                //      missiles, divided by two, rounded up.<br/>
                if (minefield == null) {<br/>
                    // Nope.  Create a new Thunder minefield<br/>
                    minefield = Minefield.createThunderMF<br/>
                        ( mfCoord, playerId, (damage/2 + damage%2) );<br/>
                    game.addMinefield(minefield);<br/>
                    revealMinefield(minefield);<br/>
                } else if (minefield.getDamage() &lt; Minefield.MAX_DAMAGE) {<br/>
                    // Yup.  Replace the old one.<br/>
                    removeMinefield(minefield);<br/>
                    int newDamage = (damage/2 + damage%2);<br/>
                    newDamage += minefield.getDamage();<br/>
<br/>
                    // Damage from Thunder minefields are capped.<br/>
                    if ( newDamage &gt; Minefield.MAX_DAMAGE ) {<br/>
                        newDamage = Minefield.MAX_DAMAGE;<br/>
                    }<br/>
                    minefield.setDamage(newDamage);<br/>
                    game.addMinefield(minefield);<br/>
                    revealMinefield(minefield);<br/>
                }<br/>
            } // End coords-on-board<br/>
<br/>
        } // Handle the next coords<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a Thunder minefield to the hex.<br/>
     * @param coords<br/>
     * @param playerId<br/>
     * @param damage<br/>
     */<br/>
    private void deliverThunderMinefield( Coords coords, int playerId,<br/>
                                          int damage ) {<br/>
        Minefield minefield = null;<br/>
        Enumeration minefields = game.getMinefields(coords).elements();<br/>
        // Check if there already are Thunder minefields in the hex.<br/>
        while (minefields.hasMoreElements()) {<br/>
            Minefield mf = (Minefield) minefields.nextElement();<br/>
            if (mf.getType() == Minefield.TYPE_THUNDER) {<br/>
                minefield = mf;<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
        // Create a new Thunder minefield<br/>
        if (minefield == null) {<br/>
            minefield = Minefield.createThunderMF(coords, playerId, damage);<br/>
            // Add to the old one<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
        } else if (minefield.getDamage() &lt; Minefield.MAX_DAMAGE) {<br/>
            removeMinefield(minefield);<br/>
            int oldDamage = minefield.getDamage();<br/>
            damage += oldDamage;<br/>
            damage = (damage &gt; Minefield.MAX_DAMAGE) ? Minefield.MAX_DAMAGE : damage;<br/>
            minefield.setDamage(damage);<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a Thunder Inferno minefield to the hex.<br/>
     * @param coords<br/>
     * @param playerId<br/>
     * @param damage<br/>
     */<br/>
    private void deliverThunderInfernoMinefield(Coords coords, int playerId, int damage) {<br/>
        Minefield minefield = null;<br/>
        Enumeration minefields = game.getMinefields(coords).elements();<br/>
        // Check if there already are Thunder minefields in the hex.<br/>
        while (minefields.hasMoreElements()) {<br/>
            Minefield mf = (Minefield) minefields.nextElement();<br/>
            if (mf.getType() == Minefield.TYPE_THUNDER_INFERNO) {<br/>
                minefield = mf;<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
        // Create a new Thunder Inferno minefield<br/>
        if (minefield == null) {<br/>
            minefield = Minefield.createThunderInfernoMF(coords, playerId, damage);<br/>
            // Add to the old one<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
       } else if (minefield.getDamage() &lt; Minefield.MAX_DAMAGE) {<br/>
            removeMinefield(minefield);<br/>
            int oldDamage = minefield.getDamage();<br/>
            damage += oldDamage;<br/>
            damage = (damage &gt; Minefield.MAX_DAMAGE) ? Minefield.MAX_DAMAGE : damage;<br/>
            minefield.setDamage(damage);<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
       }<br/>
    }<br/>
<br/>
    /**<br/>
     *Delivers a Arrow IV FASCAM shot to the targetted hex area.<br/>
     */<br/>
    private void deliverFASCAMMinefield( Coords coords, int playerId) {<br/>
        // Only if this is on the board...<br/>
        if ( game.getBoard().contains(coords) ) {<br/>
            Minefield minefield = null;<br/>
            Enumeration minefields = game.getMinefields(coords).elements();<br/>
            // Check if there already are Thunder minefields in the hex.<br/>
            while (minefields.hasMoreElements()) {<br/>
                Minefield mf = (Minefield) minefields.nextElement();<br/>
                if (mf.getType() == Minefield.TYPE_THUNDER) {<br/>
                    minefield = mf;<br/>
                    break;<br/>
                }<br/>
            }<br/>
            // Did we find a Thunder minefield in the hex?<br/>
            // N.B. damage of FASCAM minefields is 30<br/>
            if (minefield == null) minefield = Minefield.createThunderMF( coords, playerId, 30 );<br/>
            removeMinefield(minefield);<br/>
            minefield.setDamage(30);<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
        } // End coords-on-board<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a Thunder-Active minefield to the hex.<br/>
     */<br/>
    private void deliverThunderActiveMinefield(Coords coords, int playerId, int damage) {<br/>
        Minefield minefield = null;<br/>
        Enumeration minefields = game.getMinefields(coords).elements();<br/>
        // Check if there already are Thunder minefields in the hex.<br/>
        while (minefields.hasMoreElements()) {<br/>
            Minefield mf = (Minefield) minefields.nextElement();<br/>
            if (mf.getType() == Minefield.TYPE_THUNDER_ACTIVE) {<br/>
                minefield = mf;<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
        // Create a new Thunder-Active minefield<br/>
        if (minefield == null) {<br/>
            minefield = Minefield.createThunderActiveMF(coords, playerId, damage);<br/>
            // Add to the old one<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
        } else if (minefield.getDamage() &lt; Minefield.MAX_DAMAGE) {<br/>
            removeMinefield(minefield);<br/>
            int oldDamage = minefield.getDamage();<br/>
            damage += oldDamage;<br/>
            damage = (damage &gt; Minefield.MAX_DAMAGE) ? Minefield.MAX_DAMAGE : damage;<br/>
            minefield.setDamage(damage);<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a Thunder-Vibrabomb minefield to the hex.<br/>
     */<br/>
    private void deliverThunderVibraMinefield(Coords coords, int playerId, int damage, int sensitivity) {<br/>
        Minefield minefield = null;<br/>
        Enumeration minefields = game.getMinefields(coords).elements();<br/>
        // Check if there already are Thunder minefields in the hex.<br/>
        while (minefields.hasMoreElements()) {<br/>
            Minefield mf = (Minefield) minefields.nextElement();<br/>
            if (mf.getType() == Minefield.TYPE_THUNDER_VIBRABOMB) {<br/>
                minefield = mf;<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
        // Create a new Thunder-Vibra minefield<br/>
        if (minefield == null) {<br/>
            minefield = Minefield.createThunderVibrabombMF(coords, playerId, damage, sensitivity);<br/>
            // Add to the old one<br/>
            game.addVibrabomb(minefield);<br/>
            revealMinefield(minefield);<br/>
        } else if (minefield.getDamage() &lt; Minefield.MAX_DAMAGE) {<br/>
            removeMinefield(minefield);<br/>
            int oldDamage = minefield.getDamage();<br/>
            damage += oldDamage;<br/>
            damage = (damage &gt; Minefield.MAX_DAMAGE) ? Minefield.MAX_DAMAGE : damage;<br/>
            minefield.setDamage(damage);<br/>
            game.addVibrabomb(minefield);<br/>
            revealMinefield(minefield);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a flare above the target<br/>
     */<br/>
    private void deliverFlare(Coords coords, int rackSize) {<br/>
        Flare flare = new Flare(coords, Math.max(1, rackSize / 5), 3, 0);<br/>
        game.addFlare(flare);<br/>
    }<br/>
    <br/>
    private void deliverArtilleryFlare(Coords coords, int radius) {<br/>
        Flare flare = new Flare(coords, 12, radius, Flare.F_DRIFTING);<br/>
        game.addFlare(flare);<br/>
    }<br/>
<br/>
    private void deliverArtillerySmoke(Coords coords) {<br/>
        if(game.getOptions().booleanOption("maxtech_fire")) {<br/>
            IHex h = game.getBoard().getHex(coords);<br/>
            //Unless there is a heavy smoke in the hex already, add one.<br/>
            if ( h.terrainLevel( Terrains.SMOKE ) &lt; 2 ) {<br/>
                Report r = new Report(5185, Report.PUBLIC);<br/>
                r.indent(2);<br/>
                r.add(coords.getBoardNum());<br/>
                addReport(r);<br/>
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.SMOKE, 2));<br/>
                sendChangedHex(coords);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    private void deliverArtilleryInferno(Coords coords, int subjectId) {<br/>
        IHex h = game.getBoard().getHex(coords);<br/>
        Report r;<br/>
        //Unless there is a fire in the hex already, start one.<br/>
        if ( !h.containsTerrain( Terrains.FIRE ) ) {<br/>
            r = new Report(3005);<br/>
            r.subject = subjectId;<br/>
            r.indent(2);<br/>
            r.add(coords.getBoardNum());<br/>
            addReport(r);<br/>
            h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
        }<br/>
        game.getBoard().addInfernoTo( coords, InfernoTracker.INFERNO_IV_ROUND, 1 );<br/>
        sendChangedHex(coords);<br/>
        for(Enumeration impactHexHits = game.getEntities(coords);impactHexHits.hasMoreElements();) {<br/>
            Entity entity = (Entity)impactHexHits.nextElement();<br/>
            entity.infernos.add( InfernoTracker.INFERNO_IV_ROUND, 1 );<br/>
            //entity on fire now<br/>
            r = new Report(3205);<br/>
            r.indent(2);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(entity.infernos.getTurnsLeftToBurn());<br/>
            addReport(r);<br/>
        }<br/>
        for(int dir=0;dir&lt;=5;dir++) {<br/>
            Coords tempcoords=coords.translated(dir);<br/>
            if(!game.getBoard().contains(tempcoords)) {<br/>
                continue;<br/>
            }<br/>
            if(coords.equals(tempcoords)) {<br/>
                continue;<br/>
            }<br/>
            h = game.getBoard().getHex(tempcoords);<br/>
            // Unless there is a fire in the hex already, start one.<br/>
            if ( !h.containsTerrain( Terrains.FIRE ) ) {<br/>
                r = new Report(3005);<br/>
                r.subject = subjectId;<br/>
                r.indent(2);<br/>
                r.add(tempcoords.getBoardNum());<br/>
                addReport(r);<br/>
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
            }<br/>
            game.getBoard().addInfernoTo( tempcoords, InfernoTracker.INFERNO_IV_ROUND, 1 );<br/>
            sendChangedHex(tempcoords);<br/>
            for (Enumeration splashHexHits = game.getEntities(tempcoords);splashHexHits.hasMoreElements();) {<br/>
                Entity entity = (Entity)splashHexHits.nextElement();<br/>
                entity.infernos.add( InfernoTracker.INFERNO_IV_ROUND, 1 );<br/>
                //entity on fire<br/>
                r = new Report(3205);<br/>
                r.indent(2);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(entity.infernos.getTurnsLeftToBurn());<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * When an entity enters a conventional or Thunder minefield.<br/>
     */<br/>
    private void enterMinefield(Entity entity, Minefield mf, Coords src, Coords dest, boolean resolvePSRNow) {<br/>
        enterMinefield(entity, mf, src, dest, resolvePSRNow, 0);<br/>
    }<br/>
<br/>
    /**<br/>
     * When an entity enters a conventional or Thunder minefield.<br/>
     * @param entity<br/>
     *<br/>
     * @param mf<br/>
     * @param src<br/>
     * @param dest<br/>
     * @param resolvePSRNow<br/>
     * @param hitMod<br/>
     */<br/>
    private void enterMinefield(Entity entity, Minefield mf, Coords src, Coords dest, boolean resolvePSRNow, int hitMod) {<br/>
        Report r;<br/>
        // Bug 954272: Mines shouldn't work underwater<br/>
        if (!game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.WATER)<br/>
                || game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.PAVEMENT)<br/>
                || game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.ICE)) {<br/>
        switch (mf.getType()) {<br/>
            case (Minefield.TYPE_CONVENTIONAL) :<br/>
            case (Minefield.TYPE_THUNDER) :<br/>
            case (Minefield.TYPE_THUNDER_ACTIVE) :<br/>
                if (mf.getTrigger() != Minefield.TRIGGER_NONE &amp;&amp;<br/>
                    Compute.d6(2) &lt; (mf.getTrigger()+hitMod)) {<br/>
                    return;<br/>
                }<br/>
<br/>
                r = new Report(2150);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getShortName(), true);<br/>
                r.add(mf.getCoords().getBoardNum(), true);<br/>
                addReport(r);<br/>
                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);<br/>
                addReport( damageEntity(entity, hit, mf.getDamage()));<br/>
                addNewLines();<br/>
<br/>
                if (resolvePSRNow) {<br/>
                    resolvePilotingRolls(entity, true, src, dest);<br/>
                }<br/>
<br/>
                if (!mf.isOneUse()) {<br/>
                    revealMinefield(mf);<br/>
                } else {<br/>
                    removeMinefield(mf);<br/>
                }<br/>
                break;<br/>
<br/>
            case (Minefield.TYPE_THUNDER_INFERNO) :<br/>
                if (mf.getTrigger() != Minefield.TRIGGER_NONE &amp;&amp;<br/>
                    Compute.d6(2) &lt; (mf.getTrigger()+hitMod)) {<br/>
                    return;<br/>
                }<br/>
                entity.infernos.add( InfernoTracker.STANDARD_ROUND, mf.getDamage() );<br/>
                //report hitting an inferno mine<br/>
                r = new Report(2155);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getShortName(), true);<br/>
                r.add(mf.getCoords().getBoardNum(), true);<br/>
                r.addDesc(entity);<br/>
                r.add(entity.infernos.getTurnsLeftToBurn());<br/>
                addReport(r);<br/>
<br/>
                // start a fire in the targets hex<br/>
                IHex h = game.getBoard().getHex(dest);<br/>
<br/>
                // Unless there a fire in the hex already, start one.<br/>
                if ( !h.containsTerrain( Terrains.FIRE ) ) {<br/>
                    r = new Report(3005);<br/>
                    r.subject = entity.getId();<br/>
                    r.add(dest.getBoardNum(), true);<br/>
                    addReport(r);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                }<br/>
                game.getBoard().addInfernoTo(dest, InfernoTracker.STANDARD_ROUND, 1);<br/>
                sendChangedHex(dest);<br/>
                break;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if an entity sets off any vibrabombs.<br/>
     */<br/>
    private void checkVibrabombs(Entity entity, Coords coords, boolean displaced) {<br/>
        checkVibrabombs(entity, coords, displaced, null, null);<br/>
    }<br/>
<br/>
    private void checkVibrabombs(Entity entity, Coords coords, boolean displaced, Coords lastPos, Coords curPos) {<br/>
        // Only mechs can set off vibrabombs.<br/>
        if (!(entity instanceof Mech)) {<br/>
            return;<br/>
        }<br/>
<br/>
        int mass = (int) entity.getWeight();<br/>
<br/>
        Enumeration e = game.getVibrabombs().elements();<br/>
<br/>
        while (e.hasMoreElements()) {<br/>
            Minefield mf = (Minefield) e.nextElement();<br/>
<br/>
            // Bug 954272: Mines shouldn't work underwater, and BMRr says Vibrabombs are mines<br/>
            if (game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.WATER)<br/>
                    &amp;&amp; !game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.PAVEMENT)<br/>
                    &amp;&amp; !game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.ICE)) {<br/>
                continue;<br/>
            }<br/>
<br/>
            // Mech weighing 10 tons or less can't set off the bomb<br/>
            if (mass &lt;= mf.getSetting() - 10) {<br/>
                continue;<br/>
            }<br/>
<br/>
            int effectiveDistance = (mass - mf.getSetting()) / 10;<br/>
            int actualDistance = coords.distance(mf.getCoords());<br/>
<br/>
            if (actualDistance &lt;= effectiveDistance) {<br/>
                Report r = new Report(2156);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getShortName(), true);<br/>
                r.add(mf.getCoords().getBoardNum(), true);<br/>
                addReport(r);<br/>
                explodeVibrabomb(mf);<br/>
            }<br/>
<br/>
            // Hack; when moving, the Mech isn't in the hex during<br/>
            // the movement.<br/>
            if (!displaced &amp;&amp; actualDistance == 0) {<br/>
                //report getting hit by vibrabomb<br/>
                Report r = new Report(2160);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getShortName(), true);<br/>
                addReport(r);<br/>
                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);<br/>
                addReport( damageEntity(entity, hit, mf.getDamage()));<br/>
                addNewLines();<br/>
                resolvePilotingRolls(entity, true, lastPos, curPos);<br/>
                // we need to apply Damage now, in case the entity lost a leg,<br/>
                // otherwise it won't get a leg missing mod if it hasn't yet<br/>
                // moved and lost a leg, see bug 1071434 for an example<br/>
                entity.applyDamage();<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Remove all minefields in the specified coords from the game<br/>
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; from which to remove minefields<br/>
     */<br/>
    private void removeMinefieldsFrom(Coords coords) {<br/>
        Vector v = game.getMinefields(coords);<br/>
        while (v.elements().hasMoreElements()) {<br/>
            Minefield mf = (Minefield)v.elements().nextElement();<br/>
            removeMinefield(mf);<br/>
        }<br/>
        <br/>
    }<br/>
<br/>
    /**<br/>
     * Removes the minefield from the game.<br/>
     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to remove<br/>
     */<br/>
    private void removeMinefield(Minefield mf) {<br/>
        if (game.containsVibrabomb(mf)) {<br/>
            game.removeVibrabomb(mf);<br/>
        }<br/>
        game.removeMinefield(mf);<br/>
<br/>
        Enumeration players = game.getPlayers();<br/>
        while (players.hasMoreElements()) {<br/>
            Player player = (Player) players.nextElement();<br/>
            removeMinefield(player, mf);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes the minfield from a player.<br/>
     * @param player The &lt;code&gt;Player&lt;/code&gt; who's minefield should be removed<br/>
     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to be removed<br/>
     */<br/>
    private void removeMinefield(Player player, Minefield mf) {<br/>
        if (player.containsMinefield(mf)) {<br/>
            player.removeMinefield(mf);<br/>
            send(player.getId(), new Packet(Packet.COMMAND_REMOVE_MINEFIELD, mf));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Reveals a minefield for all players.<br/>
     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to be revealed<br/>
     */<br/>
    private void revealMinefield(Minefield mf) {<br/>
        Enumeration players = game.getPlayers();<br/>
        while (players.hasMoreElements()) {<br/>
            Player player = (Player) players.nextElement();<br/>
            revealMinefield(player, mf);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Reveals a minefield for a player.<br/>
     * @param player The &lt;code&gt;Player&lt;/code&gt; who's minefiled should be revealed<br/>
     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to be revealed<br/>
     */<br/>
    private void revealMinefield(Player player, Minefield mf) {<br/>
        if (!player.containsMinefield(mf)) {<br/>
            player.addMinefield(mf);<br/>
            send(player.getId(), new Packet(Packet.COMMAND_REVEAL_MINEFIELD, mf));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Explodes a vibrabomb.<br/>
     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to explode<br/>
     */<br/>
    private void explodeVibrabomb(Minefield mf) {<br/>
        Enumeration targets = game.getEntities(mf.getCoords());<br/>
        Report r;<br/>
<br/>
        while (targets.hasMoreElements()) {<br/>
            Entity entity = (Entity) targets.nextElement();<br/>
<br/>
            // check for the "no_premove_vibra" option<br/>
            // If it's set, and the target has not yet moved,<br/>
            // it doesn't get damaged.<br/>
            if (!entity.isDone() &amp;&amp; game.getOptions().booleanOption("no_premove_vibra")) {<br/>
                r = new Report(2157);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getShortName(), true);<br/>
                addReport(r);<br/>
                continue;<br/>
            }<br/>
            //report hitting vibrabomb<br/>
            r = new Report(2160);<br/>
            r.subject = entity.getId();<br/>
            r.add(entity.getShortName(), true);<br/>
            addReport(r);<br/>
<br/>
            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {<br/>
                // normal vibrabombs do all damage in one pack<br/>
                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);<br/>
                addReport( damageEntity(entity, hit, mf.getDamage()));<br/>
                addNewLines();<br/>
            } else if (mf.getType() == Minefield.TYPE_THUNDER_VIBRABOMB) {<br/>
                int damage = mf.getDamage();<br/>
                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);<br/>
                addReport( damageEntity(entity, hit, damage));<br/>
            }<br/>
<br/>
            resolvePilotingRolls(entity, true, entity.getPosition(), entity.getPosition());<br/>
            // we need to apply Damage now, in case the entity lost a leg,<br/>
            // otherwise it won't get a leg missing mod if it hasn't yet<br/>
            // moved and lost a leg, see bug 1071434 for an example<br/>
            game.resetPSRs(entity);<br/>
            entity.applyDamage();<br/>
            addNewLines();<br/>
            entityUpdate(entity.getId());<br/>
        }<br/>
<br/>
        if (!mf.isOneUse()) {<br/>
            revealMinefield(mf);<br/>
        } else {<br/>
            removeMinefield(mf);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * drowns any units swarming the entity<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is being swarmed<br/>
     * @param pos The &lt;code&gt;Coords&lt;/code&gt; the entity is at<br/>
     */<br/>
    private void drownSwarmer(Entity entity, Coords pos) {<br/>
        // Any swarming infantry will be destroyed.<br/>
        final int swarmerId = entity.getSwarmAttackerId();<br/>
        if ( Entity.NONE != swarmerId ) {<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            // Only *platoons* drown while swarming.<br/>
            if (!(swarmer instanceof BattleArmor)) {<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                swarmer.setPosition( pos );<br/>
                Report r = new Report(2165);<br/>
                r.subject = entity.getId();<br/>
                r.indent();<br/>
                r.add(entity.getShortName(), true);<br/>
                addReport(r);<br/>
                addReport( destroyEntity(swarmer, "a watery grave", false));<br/>
                entityUpdate( swarmerId );<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if we may have just washed off infernos.  Call after<br/>
     * a step which may have done this.<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is being checked<br/>
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; the entity is at<br/>
     */<br/>
    void checkForWashedInfernos(Entity entity, Coords coords) {<br/>
        IHex hex = game.getBoard().getHex(coords);<br/>
        int waterLevel = hex.terrainLevel(Terrains.WATER);<br/>
        // Mech on fire with infernos can wash them off.<br/>
        if (!(entity instanceof Mech) || !entity.infernos.isStillBurning()) {<br/>
            return;<br/>
        }<br/>
        // Check if entering depth 2 water or prone in depth 1.<br/>
        if (waterLevel &gt; 0 &amp;&amp; entity.absHeight() &lt; 0) {<br/>
            washInferno(entity, coords);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Washes off an inferno from a mech and adds it to the (water) hex.<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is taking a bath<br/>
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; the entity is at<br/>
     */<br/>
    void washInferno(Entity entity, Coords coords) {<br/>
        game.getBoard().addInfernoTo( coords, InfernoTracker.STANDARD_ROUND, 1 );<br/>
        entity.infernos.clear();<br/>
<br/>
        // Start a fire in the hex?<br/>
        IHex hex = game.getBoard().getHex(coords);<br/>
        Report r = new Report(2170);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        if ( hex.containsTerrain(Terrains.FIRE) ) {<br/>
        } else {<br/>
            r.messageId = 2175;<br/>
            hex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
        }<br/>
        addReport(r);<br/>
        sendChangedHex(coords);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add heat from the movement phase<br/>
     */<br/>
    public void addMovementHeat() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            // build up heat from movement<br/>
            if (entity.moved == IEntityMovementType.MOVE_NONE) {<br/>
                entity.heatBuildup += entity.getStandingHeat();<br/>
            } else if (entity.moved == IEntityMovementType.MOVE_WALK<br/>
                       || entity.moved == IEntityMovementType.MOVE_VTOL_WALK) {<br/>
                entity.heatBuildup += entity.getWalkHeat();<br/>
            } else if (entity.moved == IEntityMovementType.MOVE_RUN<br/>
                       || entity.moved == IEntityMovementType.MOVE_VTOL_RUN<br/>
                       || entity.moved == IEntityMovementType.MOVE_SKID) {<br/>
                entity.heatBuildup += entity.getRunHeat();<br/>
            } else if (entity.moved == IEntityMovementType.MOVE_JUMP) {<br/>
                entity.heatBuildup += entity.getJumpHeat(entity.delta_distance);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the locationsexposure of an entity<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; who's exposure is being set<br/>
     * @param hex The &lt;code&gt;IHex&lt;/code&gt; the entity is in<br/>
     * @param isJump a &lt;code&gt;boolean&lt;/code&gt; value wether the entity is jumping<br/>
     * @param elevation the elevation the entity should be at.<br/>
     */<br/>
<br/>
    public void doSetLocationsExposure(Entity entity, IHex hex, boolean isJump, int elevation) {<br/>
        if ( hex.terrainLevel(Terrains.WATER) &gt; 0<br/>
                &amp;&amp; !isJump<br/>
                &amp;&amp; elevation &lt; 0) {<br/>
            if (entity instanceof Mech<br/>
                    &amp;&amp; !entity.isProne()<br/>
                    &amp;&amp; hex.terrainLevel(Terrains.WATER) == 1) {<br/>
                for (int loop = 0; loop &lt; entity.locations(); loop++) {<br/>
                    if (game.getOptions().booleanOption("vacuum"))<br/>
                        entity.setLocationStatus(loop, ILocationExposureStatus.VACUUM);<br/>
                    else entity.setLocationStatus(loop, ILocationExposureStatus.NORMAL);<br/>
                }<br/>
                entity.setLocationStatus(Mech.LOC_RLEG, ILocationExposureStatus.WET);<br/>
                entity.setLocationStatus(Mech.LOC_LLEG, ILocationExposureStatus.WET);<br/>
                addReport(<br/>
                                      breachCheck(entity, Mech.LOC_RLEG, hex));<br/>
                addReport(<br/>
                                      breachCheck(entity, Mech.LOC_LLEG, hex));<br/>
                if (entity instanceof QuadMech) {<br/>
                    entity.setLocationStatus(Mech.LOC_RARM, ILocationExposureStatus.WET);<br/>
                    entity.setLocationStatus(Mech.LOC_LARM, ILocationExposureStatus.WET);<br/>
                    addReport(<br/>
                               breachCheck(entity, Mech.LOC_RARM, hex));<br/>
                    addReport(<br/>
                               breachCheck(entity, Mech.LOC_LARM, hex));<br/>
                }<br/>
            } else {<br/>
                for (int loop = 0; loop &lt; entity.locations(); loop++) {<br/>
                    entity.setLocationStatus(loop, ILocationExposureStatus.WET);<br/>
                    addReport( breachCheck(entity, loop, hex));<br/>
                }<br/>
            }<br/>
        } else {<br/>
            for (int loop = 0; loop &lt; entity.locations(); loop++) {<br/>
                if (game.getOptions().booleanOption("vacuum"))<br/>
                    entity.setLocationStatus(loop, ILocationExposureStatus.VACUUM);<br/>
                else entity.setLocationStatus(loop, ILocationExposureStatus.NORMAL);<br/>
            }<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a piloting skill check while standing still (during the<br/>
     *  movement phase).<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that should make the PSR<br/>
     * @param roll   The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for this PSR.<br/>
     *<br/>
     *@param Returns true if check succeeds, false otherwise.<br/>
     *<br/>
     */<br/>
    private boolean doSkillCheckInPlace(Entity entity, PilotingRollData roll) {<br/>
        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {<br/>
            return true;<br/>
        }<br/>
<br/>
        // non-mechs should never get here<br/>
        if (! (entity instanceof Mech) || entity.isProne()) {<br/>
            return true;<br/>
        }<br/>
<br/>
        // okay, print the info<br/>
        Report r = new Report(2180);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        r.add(roll.getLastPlainDesc(), true);<br/>
        addReport(r);<br/>
<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        r = new Report(2185);<br/>
        r.subject = entity.getId();<br/>
        r.add(roll.getValueAsString());<br/>
        r.add(roll.getDesc());<br/>
        r.add(diceRoll);<br/>
        boolean suc;<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            r.choose(false);<br/>
            addReport(r);<br/>
            doEntityFall(entity, roll);<br/>
            suc = false;<br/>
        } else {<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
            suc = true;<br/>
        }<br/>
<br/>
        return suc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a Piloting Skill check to dislogde swarming infantry.<br/>
     *<br/>
     * @param   entity The &lt;code&gt;Entity&lt;/code&gt; that is doing the dislodging.<br/>
     * @param   roll The &lt;code&gt;PilotingRollData&lt;/code&gt; for this PSR.<br/>
     * @param   curPos The &lt;code&gt;Coords&lt;/code&gt; the entity is at.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the dislodging is successful.<br/>
     */<br/>
    private boolean doDislodgeSwarmerSkillCheck<br/>
        (Entity entity, PilotingRollData roll, Coords curPos)<br/>
    {<br/>
        // okay, print the info<br/>
        Report r = new Report(2180);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        r.add(roll.getLastPlainDesc(), true);<br/>
        addReport(r);<br/>
<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        r = new Report(2190);<br/>
        r.subject = entity.getId();<br/>
        r.add(roll.getValueAsString());<br/>
        r.add(roll.getDesc());<br/>
        r.add(diceRoll);<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            r.choose(false);<br/>
            addReport(r);<br/>
            return false;<br/>
        } else {<br/>
            // Dislodged swarmers don't get turns.<br/>
            int swarmerId = entity.getSwarmAttackerId();<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            game.removeTurnFor( swarmer );<br/>
            send( createTurnVectorPacket() );<br/>
<br/>
            // Update the report and cause a fall.<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
            entity.setPosition( curPos );<br/>
            doEntityFallsInto(entity, curPos, curPos, roll, false);<br/>
            return true;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a piloting skill check while moving.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that must roll.<br/>
     * @param   src - the &lt;code&gt;Coords&lt;/code&gt; the entity is moving from.<br/>
     * @param   dest - the &lt;code&gt;Coords&lt;/code&gt; the entity is moving to.<br/>
     *          This value can be the same as src for in-place checks.<br/>
     * @param   reason - the &lt;code&gt;PilotingRollData&lt;/code&gt; that is causing<br/>
     *          this check.<br/>
     * @param   isFallRoll - a &lt;code&gt;boolean&lt;/code&gt; flag that indicates that<br/>
     *          failure will result in a fall or not.  Falls will be processed.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the pilot passes the skill check.<br/>
     */<br/>
    private boolean doSkillCheckWhileMoving( Entity entity,<br/>
                                             Coords src,<br/>
                                             Coords dest,<br/>
                                             PilotingRollData roll,<br/>
                                             boolean isFallRoll ) {<br/>
        boolean result = true;<br/>
        boolean fallsInPlace;<br/>
<br/>
        // Start the info for this roll.<br/>
        Report r = new Report(1210);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
<br/>
        // Will the entity fall in the source or destination hex?<br/>
        if ( src.equals(dest) ) {<br/>
            fallsInPlace = true;<br/>
            r.messageId = 2195;<br/>
            r.add(src.getBoardNum(), true);<br/>
        } else {<br/>
            fallsInPlace = false;<br/>
            r.messageId = 2200;<br/>
            r.add(src.getBoardNum(), true);<br/>
            r.add(dest.getBoardNum(), true);<br/>
        }<br/>
<br/>
        // Finish the info.<br/>
        r.add(roll.getLastPlainDesc(), true);<br/>
        addReport(r);<br/>
<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        r = new Report(2185);<br/>
        r.subject = entity.getId();<br/>
        r.add(roll.getValueAsString());<br/>
        r.add(roll.getDesc());<br/>
        r.add(diceRoll);<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            // Does failing the PSR result in a fall.<br/>
            if ( isFallRoll ) {<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
                doEntityFallsInto( entity,<br/>
                                   (fallsInPlace ? dest : src),<br/>
                                   (fallsInPlace ? src : dest),<br/>
                                   roll );<br/>
            } else {<br/>
                r.messageId = 2190;<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
                entity.setPosition( fallsInPlace ? src : dest );<br/>
            }<br/>
            result = false;<br/>
        } else {<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * The entity falls into the hex specified.  Check for any conflicts and<br/>
     * resolve them.  Deal damage to faller.<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is falling.<br/>
     * @param src The &lt;code&gt;Coords&lt;/code&gt; of the source hex.<br/>
     * @param dest The &lt;code&gt;Coords&lt;/code&gt; of the destination hex.<br/>
     * @param roll The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for PSRs induced<br/>
     * by the falling.<br/>
     */<br/>
    private void doEntityFallsInto(Entity entity, Coords src, Coords dest, PilotingRollData roll) {<br/>
        doEntityFallsInto(entity, src, dest, roll, true);<br/>
    }<br/>
<br/>
    /**<br/>
    * The entity falls into the hex specified.  Check for any conflicts and<br/>
    * resolve them.  Deal damage to faller.<br/>
    *<br/>
    * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is falling.<br/>
    * @param src The &lt;code&gt;Coords&lt;/code&gt; of the source hex.<br/>
    * @param dest The &lt;code&gt;Coords&lt;/code&gt; of the destination hex.<br/>
    * @param roll The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for PSRs induced<br/>
    * by the falling.<br/>
    * @param causeAffa The &lt;code&gt;boolean&lt;/code&gt; value wether this fall should<br/>
    * be able to cause an accidental fall from above<br/>
    */<br/>
    private void doEntityFallsInto(Entity entity, Coords src, Coords dest, PilotingRollData roll, boolean causeAffa) {<br/>
        final IHex srcHex = game.getBoard().getHex(src);<br/>
        final IHex destHex = game.getBoard().getHex(dest);<br/>
        final int srcHeightAboveFloor = entity.getElevation() + srcHex.depth(); <br/>
        final int fallElevation = Math.max(0, srcHex.floor() + srcHeightAboveFloor - destHex.floor());<br/>
        int direction = src.direction(dest);<br/>
        Report r;<br/>
        // check entity in target hex<br/>
        Entity affaTarget = game.getAffaTarget(dest, entity);<br/>
        // falling mech falls<br/>
        r = new Report(2205);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        r.add(fallElevation);<br/>
        r.add(dest.getBoardNum(), true);<br/>
        addReport(r);<br/>
<br/>
        // if hex was empty, deal damage and we're done<br/>
        if (affaTarget == null) {<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            return;<br/>
        }<br/>
<br/>
        // hmmm... somebody there... problems.<br/>
        if (fallElevation &gt;= 2 &amp;&amp; causeAffa &amp;&amp; affaTarget != null) {<br/>
            // accidental fall from above: havoc!<br/>
            r = new Report(2210);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(affaTarget);<br/>
            addReport(r);<br/>
<br/>
            // determine to-hit number<br/>
            ToHitData toHit = new ToHitData(7, "base");<br/>
            if (affaTarget instanceof Tank ) {<br/>
                toHit = new ToHitData(TargetRoll.AUTOMATIC_FAIL, "Target is a Tank");<br/>
            } else {<br/>
                toHit.append(Compute.getTargetMovementModifier(game, affaTarget.getId()));<br/>
                toHit.append(Compute.getTargetTerrainModifier(game, affaTarget));<br/>
            }<br/>
<br/>
            if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL) {<br/>
                // collision roll<br/>
                final int diceRoll = Compute.d6(2);<br/>
                r = new Report(2215);<br/>
                r.subject = entity.getId();<br/>
                r.add(toHit.getValue());<br/>
                r.add(diceRoll);<br/>
                if (diceRoll &gt;= toHit.getValue()) {<br/>
                    r.choose(true);<br/>
                    addReport(r);<br/>
                    // deal damage to target<br/>
                    int damage = Compute.getAffaDamageFor(entity);<br/>
                    r = new Report(2220);<br/>
                    r.subject = affaTarget.getId();<br/>
                    r.addDesc(affaTarget);<br/>
                    r.add(damage);<br/>
                    addReport(r);<br/>
                    while (damage &gt; 0) {<br/>
                        int cluster = Math.min(5, damage);<br/>
                        HitData hit = affaTarget.rollHitLocation(ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);<br/>
                        addReport(<br/>
                                              damageEntity(affaTarget, hit, cluster));<br/>
                        damage -= cluster;<br/>
                    }<br/>
                    addNewLines();<br/>
<br/>
                    // attacker falls as normal, on his back<br/>
                    // only given a modifier, so flesh out into a full piloting roll<br/>
                    PilotingRollData pilotRoll = entity.getBasePilotingRoll();<br/>
                    pilotRoll.append(roll);<br/>
                    entity.addPilotingModifierForTerrain(pilotRoll, dest);<br/>
                    doEntityFall(entity, dest, fallElevation, 3, pilotRoll);<br/>
                    doEntityDisplacementMinefieldCheck(entity, src, dest);<br/>
<br/>
                    // defender pushed away, or destroyed, if there is a stacking violation<br/>
                    Entity violation = Compute.stackingViolation(game, entity.getId(), dest);<br/>
                    if (violation != null) {<br/>
                        Coords targetDest = Compute.getValidDisplacement(game, violation.getId(), dest, direction);<br/>
                        if (targetDest != null) {<br/>
                            doEntityDisplacement(affaTarget, dest, targetDest, new PilotingRollData(violation.getId(), 2, "fallen on"));<br/>
                            // Update the violating entity's postion on the client.<br/>
                            entityUpdate( affaTarget.getId() );<br/>
                        } else {<br/>
                            // ack!  automatic death!  Tanks<br/>
                            // suffer an ammo/power plant hit.<br/>
                            // TODO : a Mech suffers a Head Blown Off crit.<br/>
                            addReport(<br/>
                                                  destroyEntity(affaTarget, "impossible displacement", (violation instanceof Mech), (violation instanceof Mech)));<br/>
                        }<br/>
                    }<br/>
                    return;<br/>
                } else {<br/>
                    r.choose(false);<br/>
                    addReport(r);<br/>
                }<br/>
            } else {<br/>
                //automatic miss<br/>
                r = new Report(2225);<br/>
                r.add(toHit.getDesc());<br/>
                addReport(r);<br/>
            }<br/>
            // ok, we missed, let's fall into a valid other hex and not cause an AFFA while doing so<br/>
            Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), dest, direction);<br/>
            if (targetDest != null) {<br/>
                doEntityFallsInto(entity, src, targetDest, new PilotingRollData(entity.getId(), PilotingRollData.IMPOSSIBLE, "pushed off a cliff"), false);<br/>
                // Update the entity's postion on the client.<br/>
                entityUpdate( entity.getId() );<br/>
            } else {<br/>
                // ack!  automatic death!  Tanks<br/>
                // suffer an ammo/power plant hit.<br/>
                // TODO : a Mech suffers a Head Blown Off crit.<br/>
                addReport( destroyEntity(entity, "impossible displacement", (entity instanceof Mech), (entity instanceof Mech)));<br/>
            }<br/>
        } else {<br/>
            // damage as normal<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            Entity violation = Compute.stackingViolation(game, entity.getId(), dest);<br/>
            if(violation != null) {<br/>
                // target gets displaced, because of low elevation<br/>
                Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), dest, direction);<br/>
                doEntityDisplacement(violation, dest, targetDest, new PilotingRollData(violation.getId(), 0, "domino effect"));<br/>
                // Update the violating entity's postion on the client.<br/>
                entityUpdate( violation.getId() );<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Displace a unit in the direction specified.  The unit moves in that<br/>
     * direction, and the piloting skill roll is used to determine if it<br/>
     * falls.  The roll may be unnecessary as certain situations indicate an<br/>
     * automatic fall.  Rolls are added to the piloting roll list.<br/>
     */<br/>
    private void doEntityDisplacement(Entity entity, Coords src, Coords dest,<br/>
                                      PilotingRollData roll) {<br/>
        Report r;<br/>
        if (!game.getBoard().contains(dest)) {<br/>
            // set position anyway, for pushes moving through and stuff like<br/>
            // that<br/>
            entity.setPosition(dest);<br/>
            if (!entity.isDoomed()) {<br/>
                game.removeEntity(entity.getId(),<br/>
                        IEntityRemovalConditions.REMOVE_PUSHED);<br/>
                send(createRemoveEntityPacket(entity.getId(),<br/>
                        IEntityRemovalConditions.REMOVE_PUSHED));<br/>
                //entity forced from the field<br/>
                r = new Report(2230);<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                // TODO: remove passengers and swarmers.<br/>
            }<br/>
            return;<br/>
        }<br/>
        final IHex srcHex = game.getBoard().getHex(src);<br/>
        final IHex destHex = game.getBoard().getHex(dest);<br/>
        final int direction = src.direction(dest);<br/>
<br/>
        // Handle null hexes.<br/>
        if ( srcHex == null || destHex == null ) {<br/>
            System.err.println( "Can not displace " + entity.getShortName() +<br/>
                                " from " + src +<br/>
                                " to " + dest + "." );<br/>
            return;<br/>
        }<br/>
        int fallElevation = entity.elevationOccupied(srcHex) - entity.elevationOccupied(destHex);<br/>
        if (fallElevation &gt; 1) {<br/>
            if(roll == null)<br/>
                roll = entity.getBasePilotingRoll();<br/>
            doEntityFallsInto(entity, src, dest, roll);<br/>
            return;<br/>
        } else {<br/>
            //move the entity into the new location gently<br/>
            entity.setPosition(dest);<br/>
            entity.setElevation(entity.elevationOccupied(destHex) - destHex.surface());<br/>
            Entity violation = Compute.stackingViolation(game, entity.getId(), dest);<br/>
            if (violation == null) {<br/>
                // move and roll normally<br/>
                r = new Report(2235);<br/>
                r.indent();<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(dest.getBoardNum(), true);<br/>
                addReport(r);<br/>
            } else {<br/>
                // domino effect: move &amp; displace target<br/>
                r = new Report(2240);<br/>
                r.indent();<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(dest.getBoardNum(), true);<br/>
                r.addDesc(violation);<br/>
                addReport(r);<br/>
            }<br/>
            // trigger any special things for moving to the new hex<br/>
            doEntityDisplacementMinefieldCheck(entity, src, dest);<br/>
            doSetLocationsExposure(entity, destHex, false, entity.getElevation());<br/>
            if (roll != null) {<br/>
                game.addPSR(roll);<br/>
            }<br/>
            // Update the entity's postion on the client.<br/>
            entityUpdate( entity.getId() );<br/>
            <br/>
            if(violation != null) {<br/>
                doEntityDisplacement(violation, dest, dest.translated(direction), new PilotingRollData(violation.getId(), 0, "domino effect"));<br/>
                // Update the violating entity's postion on the client,<br/>
                // if it didn't get displaced off the board.<br/>
                if ( !game.isOutOfGame(violation) ) {<br/>
                    entityUpdate( violation.getId() );<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    private void doEntityDisplacementMinefieldCheck(Entity entity, Coords src, Coords dest) {<br/>
        if (game.containsMinefield(dest)) {<br/>
            Enumeration minefields = game.getMinefields(dest).elements();<br/>
            while (minefields.hasMoreElements()) {<br/>
                Minefield mf = (Minefield) minefields.nextElement();<br/>
                enterMinefield(entity, mf, src, dest, false);<br/>
            }<br/>
        }<br/>
        checkVibrabombs(entity, dest, true);<br/>
    }<br/>
<br/>
    /**<br/>
     * Receive a deployment packet.  If valid, execute it and end the current<br/>
     * turn.<br/>
     */<br/>
    private void receiveDeployment(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        Coords coords = (Coords)packet.getObject(1);<br/>
        int nFacing = packet.getIntValue(2);<br/>
<br/>
        // Handle units that deploy loaded with other units.<br/>
        int loadedCount = packet.getIntValue(3);<br/>
        Vector loadVector = new Vector();<br/>
        for ( int i = 0; i &lt; loadedCount; i++ ){<br/>
            int loadedId = packet.getIntValue( 5 + i );<br/>
            loadVector.addElement(game.getEntity( loadedId ));<br/>
        }<br/>
<br/>
        // is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_DEPLOYMENT) {<br/>
            System.err.println("error: server got deployment packet in wrong phase");<br/>
            return;<br/>
        }<br/>
<br/>
        // can this player/entity act right now?<br/>
        final boolean assaultDrop = packet.getBooleanValue(4);<br/>
        if ( !game.getTurn().isValid(connId, entity, game)<br/>
             || !(game.getBoard().isLegalDeployment(coords, entity.getOwner()) <br/>
                     ||(assaultDrop &amp;&amp; game.getOptions().booleanOption("assault_drop") &amp;&amp; entity.canAssaultDrop()))) {<br/>
            System.err.println("error: server got invalid deployment packet");<br/>
            return;<br/>
        }<br/>
<br/>
        // looks like mostly everything's okay<br/>
        processDeployment(entity, coords, nFacing, loadVector, assaultDrop);<br/>
<br/>
        // Update visibility indications if using double blind.<br/>
        if (doBlind()) {<br/>
            updateVisibilityIndicator();<br/>
        }<br/>
<br/>
        endCurrentTurn(entity);<br/>
    }<br/>
<br/>
    /**<br/>
     * Process a deployment packet by... deploying the entity!  We load any<br/>
     * other specified entities inside of it too.  Also, check that the<br/>
     * deployment is valid.<br/>
     */<br/>
    private void processDeployment(Entity entity, Coords coords, int nFacing, Vector loadVector, boolean assaultDrop) {<br/>
        for (Enumeration i = loadVector.elements(); i.hasMoreElements();) {<br/>
            Entity loaded = (Entity)i.nextElement();<br/>
            if ( loaded == null || loaded.getPosition() != null ||<br/>
                 loaded.getTransportId() != Entity.NONE ) {<br/>
                // Something is fishy in Denmark.<br/>
                System.err.println("error: " + entity + " can not load entity #" + loaded );<br/>
                break;<br/>
            }<br/>
            else {<br/>
                // Have the deployed unit load the indicated unit.<br/>
                this.loadUnit( entity, loaded );<br/>
            }<br/>
        }<br/>
<br/>
        entity.setPosition(coords);<br/>
        entity.setFacing(nFacing);<br/>
        entity.setSecondaryFacing(nFacing);<br/>
        IHex hex = game.getBoard().getHex(coords);<br/>
        if(assaultDrop) {<br/>
            entity.setElevation(hex.ceiling() - hex.surface() + 100); //falling from the sky!<br/>
            entity.setAssaultDropInProgress(true);<br/>
        } else if (entity instanceof VTOL) {<br/>
            // We should let players pick, but this simplifies a lot.<br/>
            // Only do it for VTOLs, though; assume everything else is on the ground.<br/>
            entity.setElevation(hex.ceiling()-hex.surface()+1);<br/>
            while ((Compute.stackingViolation(game, entity, coords, null) != null) &amp;&amp; (entity.getElevation() &lt;= 50)) {<br/>
                entity.setElevation(entity.getElevation() + 1);<br/>
            }<br/>
            if (entity.getElevation() &gt; 50) {<br/>
                throw new IllegalStateException("Entity #" + entity.getId() + " appears to be in an infinite loop trying to get a legal elevation.");<br/>
            }<br/>
        } else if (entity.getMovementMode() == IEntityMovementMode.SUBMARINE) {<br/>
            // TODO: Submarines should have a selectable height.<br/>
            // For now, pretend they're regular naval.<br/>
            entity.setElevation(0);<br/>
        } else if ((entity.getMovementMode() == IEntityMovementMode.HOVER)<br/>
                || (entity.getMovementMode() == IEntityMovementMode.NAVAL)<br/>
                || (entity.getMovementMode() == IEntityMovementMode.HYDROFOIL)) {<br/>
            // For now, assume they're on the surface.<br/>
            // entity elevation is relative to hex surface<br/>
            entity.setElevation(0);<br/>
        } else if (hex.containsTerrain(Terrains.ICE)<br/>
                || hex.containsTerrain(Terrains.BRIDGE)) {<br/>
            entity.setElevation(0);<br/>
        } else {<br/>
            // For anything else, assume they're on the floor.<br/>
            // entity elevation is relative to hex surface<br/>
            entity.setElevation(hex.floor()-hex.surface());<br/>
        }<br/>
        entity.setDone(true);<br/>
        entity.setDeployed(true);<br/>
        entityUpdate(entity.getId());<br/>
    }<br/>
<br/>
    private void receiveArtyAutoHitHexes(Packet packet, int connId) {<br/>
        Vector artyAutoHitHexes = (Vector) packet.getObject(0);<br/>
<br/>
        Integer playerId = (Integer)artyAutoHitHexes.firstElement();<br/>
        artyAutoHitHexes.removeElementAt(0);<br/>
<br/>
        // is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_SET_ARTYAUTOHITHEXES) {<br/>
            System.err.println("error: server got set artyautohithexespacket in wrong phase");<br/>
            return;<br/>
        }<br/>
        game.getPlayer(playerId.intValue()).setArtyAutoHitHexes(artyAutoHitHexes);<br/>
        endCurrentTurn(null);<br/>
    }<br/>
<br/>
    private void receiveDeployMinefields(Packet packet, int connId) {<br/>
        Vector minefields = (Vector) packet.getObject(0);<br/>
<br/>
        // is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_DEPLOY_MINEFIELDS) {<br/>
            System.err.println("error: server got deploy minefields packet in wrong phase");<br/>
            return;<br/>
        }<br/>
<br/>
        // looks like mostly everything's okay<br/>
        processDeployMinefields(minefields);<br/>
        endCurrentTurn(null);<br/>
    }<br/>
<br/>
    private void processDeployMinefields(Vector minefields) {<br/>
        int playerId = Player.PLAYER_NONE;<br/>
        for (int i = 0; i &lt; minefields.size(); i++) {<br/>
            Minefield mf = (Minefield) minefields.elementAt(i);<br/>
            playerId = mf.getPlayerId();<br/>
<br/>
            game.addMinefield(mf);<br/>
            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {<br/>
                game.addVibrabomb(mf);<br/>
            }<br/>
        }<br/>
<br/>
        Player player = game.getPlayer( playerId );<br/>
        if ( null != player ) {<br/>
            int teamId = player.getTeam();<br/>
<br/>
            if (teamId != Player.TEAM_NONE) {<br/>
                Enumeration teams = game.getTeams();<br/>
                while (teams.hasMoreElements()) {<br/>
                    Team team = (Team) teams.nextElement();<br/>
                    if (team.getId() == teamId) {<br/>
                        Enumeration players = team.getPlayers();<br/>
                        while (players.hasMoreElements()) {<br/>
                            Player teamPlayer = (Player) players.nextElement();<br/>
                            if (teamPlayer.getId() != player.getId()) {<br/>
                                send(teamPlayer.getId(), new Packet(Packet.COMMAND_DEPLOY_MINEFIELDS, minefields));<br/>
                            }<br/>
                            teamPlayer.addMinefields(minefields);<br/>
                        }<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            } else {<br/>
                player.addMinefields(minefields);<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Gets a bunch of entity attacks from the packet.  If valid, processess<br/>
     * them and ends the current turn.<br/>
     */<br/>
    private void receiveAttack(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        Vector vector = (Vector)packet.getObject(1);<br/>
<br/>
        // is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_FIRING<br/>
        &amp;&amp; game.getPhase() != IGame.PHASE_PHYSICAL<br/>
        &amp;&amp; game.getPhase() != IGame.PHASE_TARGETING<br/>
        &amp;&amp; game.getPhase() != IGame.PHASE_OFFBOARD) {<br/>
            System.err.println("error: server got attack packet in wrong phase");<br/>
            return;<br/>
        }<br/>
<br/>
        // can this player/entity act right now?<br/>
        if (!game.getTurn().isValid(connId, entity, game)) {<br/>
            System.err.println("error: server got invalid attack packet");<br/>
            return;<br/>
        }<br/>
<br/>
        // looks like mostly everything's okay<br/>
        processAttack(entity, vector);<br/>
<br/>
        // Update visibility indications if using double blind.<br/>
        if (doBlind()) {<br/>
            updateVisibilityIndicator();<br/>
        }<br/>
<br/>
        endCurrentTurn(entity);<br/>
    }<br/>
<br/>
    /**<br/>
     * Process a batch of entity attack (or twist) actions by adding them to<br/>
     * the proper list to be processed later.<br/>
     */<br/>
    private void processAttack(Entity entity, Vector vector) {<br/>
<br/>
        // Not **all** actions take up the entity's turn.<br/>
        boolean setDone =<br/>
            !(game.getTurn() instanceof GameTurn.TriggerAPPodTurn);<br/>
        for (Enumeration i = vector.elements(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
<br/>
            // is this the right entity?<br/>
            if (ea.getEntityId() != entity.getId()) {<br/>
                System.err.println("error: attack packet has wrong attacker");<br/>
                continue;<br/>
            }<br/>
<br/>
            // Anti-mech and pointblank attacks from<br/>
            // hiding may allow the target to respond.<br/>
            if ( ea instanceof WeaponAttackAction ) {<br/>
                final WeaponAttackAction waa = (WeaponAttackAction) ea;<br/>
                final String weaponName = entity.getEquipment<br/>
                    ( waa.getWeaponId() ).getType().getInternalName();<br/>
<br/>
                if ( Infantry.SWARM_MEK.equals(weaponName) ||<br/>
                     Infantry.LEG_ATTACK.equals(weaponName) ) {<br/>
<br/>
                    // Does the target have any AP Pods available?<br/>
                    final Entity target = game.getEntity( waa.getTargetId() );<br/>
                    Enumeration misc = target.getMisc();<br/>
                    while ( misc.hasMoreElements() ) {<br/>
                        final Mounted equip = (Mounted) misc.nextElement();<br/>
                        if ( equip.getType().hasFlag(MiscType.F_AP_POD) &amp;&amp;<br/>
                             equip.canFire()) {<br/>
<br/>
                            // Yup.  Insert a game turn to handle AP pods.<br/>
                            // ASSUMPTION : AP pod declarations come<br/>
                            // immediately after the attack declaration.<br/>
                            game.insertNextTurn( new GameTurn.TriggerAPPodTurn<br/>
                                  ( target.getOwnerId(), target.getId() ) );<br/>
                            send(createTurnVectorPacket());<br/>
<br/>
                            // We can stop looking.<br/>
                            break;<br/>
<br/>
                        } // end found-available-ap-pod<br/>
<br/>
                    } // Check the next piece of equipment on the target.<br/>
<br/>
                } // End check-for-available-ap-pod<br/>
            }<br/>
<br/>
            // The equipment type of a club needs to be restored.<br/>
            if (ea instanceof ClubAttackAction) {<br/>
                ClubAttackAction caa = (ClubAttackAction) ea;<br/>
                Mounted club = caa.getClub();<br/>
                club.restore();<br/>
            }<br/>
<br/>
            if (ea instanceof PushAttackAction) {<br/>
                // push attacks go the end of the displacement attacks<br/>
                PushAttackAction paa = (PushAttackAction)ea;<br/>
                entity.setDisplacementAttack(paa);<br/>
                game.addCharge(paa);<br/>
            } else if (ea instanceof DodgeAction) {<br/>
                entity.dodging = true;<br/>
            } else if (ea instanceof SpotAction) {<br/>
                entity.setSpotting(true);<br/>
            } else {<br/>
                // add to the normal attack list.<br/>
                game.addAction(ea);<br/>
            }<br/>
<br/>
            // Mark any AP Pod as used in this turn.<br/>
            if ( ea instanceof TriggerAPPodAction ) {<br/>
                TriggerAPPodAction tapa = (TriggerAPPodAction) ea;<br/>
                Mounted pod = entity.getEquipment( tapa.getPodId() );<br/>
                pod.setUsedThisRound( true );<br/>
            }<br/>
        }<br/>
<br/>
        // Unless otherwise stated,<br/>
        // this entity is done for the round.<br/>
        if ( setDone ) {<br/>
            entity.setDone(true);<br/>
        }<br/>
        entityUpdate(entity.getId());<br/>
<br/>
        // update all players on the attacks.  Don't worry about pushes being a<br/>
        // "charge" attack.  It doesn't matter to the client.<br/>
        send(createAttackPacket(vector, 0));<br/>
    }<br/>
<br/>
    /**<br/>
     * Auto-target active AMS systems<br/>
     */<br/>
    private void assignAMS() {<br/>
<br/>
        // sort all missile-based attacks by the target<br/>
        Hashtable htAttacks = new Hashtable();<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements(); ) {<br/>
            Object o = i.nextElement();<br/>
            if (o instanceof WeaponAttackAction) {<br/>
                WeaponAttackAction waa = (WeaponAttackAction)o;<br/>
                Mounted weapon = game.getEntity(waa.getEntityId()).getEquipment(waa.getWeaponId());<br/>
<br/>
                // Only entities can have AMS.<br/>
                if ( Targetable.TYPE_ENTITY != waa.getTargetType() ) {<br/>
                    continue;<br/>
                }<br/>
<br/>
                // Can only use AMS versus missles.<br/>
                if (((WeaponType)weapon.getType()).getDamage() == WeaponType.DAMAGE_MISSILE) {<br/>
                    Entity target = game.getEntity(waa.getTargetId());<br/>
                    Vector v = (Vector)htAttacks.get(target);<br/>
                    if (v == null) {<br/>
                        v = new Vector();<br/>
                        htAttacks.put(target, v);<br/>
                    }<br/>
                    v.addElement(waa);<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        // let each target assign its AMS<br/>
        for (Enumeration i = htAttacks.keys(); i.hasMoreElements(); ) {<br/>
            Entity e = (Entity)i.nextElement();<br/>
            Vector vAttacks = (Vector)htAttacks.get(e);<br/>
            e.assignAMS(vAttacks);<br/>
        }<br/>
    }<br/>
<br/>
    /** <br/>
     * Called during the weapons fire phase.  Resolves anything other than<br/>
     * weapons fire that happens.  Torso twists, for example.<br/>
     */<br/>
    private void resolveAllButWeaponAttacks() {<br/>
        if (game.getPhase()==IGame.PHASE_FIRING) {<br/>
            //Phase report header<br/>
            addReport(new Report(3000, Report.PUBLIC));<br/>
            Report r;<br/>
            for (Enumeration e = game.getLayMinefieldActions(); e.hasMoreElements();) {<br/>
                LayMinefieldAction lma = (LayMinefieldAction)e.nextElement();<br/>
                Entity ent = game.getEntity(lma.getEntityId());<br/>
                Mounted mine = ent.getEquipment(lma.getMineId());<br/>
                if (!mine.isMissing()) {<br/>
                    switch (mine.getMineType()) {<br/>
                        case 0:<br/>
                            deliverThunderMinefield(ent.getPosition(), ent.getOwnerId(), 10);<br/>
                            mine.setMissing(true);<br/>
                            r = new Report(3500);<br/>
                            r.subject = ent.getId();<br/>
                            r.addDesc(ent);<br/>
                            r.add(ent.getPosition().getBoardNum());<br/>
                            addReport(r);<br/>
                            break;<br/>
                        case 1:<br/>
                            deliverThunderVibraMinefield(ent.getPosition(), ent.getOwnerId(), 10, mine.getVibraSetting());<br/>
                            mine.setMissing(true);<br/>
                            r = new Report(3505);<br/>
                            r.subject = ent.getId();<br/>
                            r.addDesc(ent);<br/>
                            r.add(ent.getPosition().getBoardNum());<br/>
                            addReport(r);<br/>
                            break;<br/>
                        //TODO: command-detonated mines<br/>
                        // case 2:<br/>
                    }<br/>
                }<br/>
            }<br/>
            game.resetLayMinefieldActions();<br/>
        }<br/>
<br/>
        Vector clearAttempts = new Vector();<br/>
        Vector triggerPodActions = new Vector();<br/>
        // loop thru actions and handle everything we expect except attacks<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
            Entity entity = game.getEntity(ea.getEntityId());<br/>
            if (ea instanceof TorsoTwistAction) {<br/>
                TorsoTwistAction tta = (TorsoTwistAction)ea;<br/>
                if ( entity.canChangeSecondaryFacing() ) {<br/>
                    entity.setSecondaryFacing(tta.getFacing());<br/>
                }<br/>
            }<br/>
            else if (ea instanceof FlipArmsAction) {<br/>
                FlipArmsAction faa = (FlipArmsAction)ea;<br/>
                entity.setArmsFlipped(faa.getIsFlipped());<br/>
            }<br/>
            else if (ea instanceof FindClubAction) {<br/>
                resolveFindClub(entity);<br/>
            }<br/>
            else if (ea instanceof UnjamAction) {<br/>
                resolveUnjam(entity);<br/>
            }<br/>
            else if (ea instanceof ClearMinefieldAction) {<br/>
                clearAttempts.addElement(entity);<br/>
            }<br/>
            else if (ea instanceof TriggerAPPodAction) {<br/>
                TriggerAPPodAction tapa = (TriggerAPPodAction) ea;<br/>
<br/>
                // Don't trigger the same pod twice.<br/>
                if ( !triggerPodActions.contains( tapa ) ) {<br/>
                    triggerAPPod(entity, tapa.getPodId());<br/>
                    triggerPodActions.addElement( tapa );<br/>
                } else {<br/>
                    System.err.print( "AP Pod #" );<br/>
                    System.err.print( tapa.getPodId() );<br/>
                    System.err.print( " on " );<br/>
                    System.err.print( entity.getDisplayName() );<br/>
                    System.err.println(" was already triggered this round!!");<br/>
                }<br/>
            }<br/>
            else if (ea instanceof SearchlightAttackAction) {<br/>
                SearchlightAttackAction saa = (SearchlightAttackAction)ea;<br/>
                addReport(<br/>
                                      saa.resolveAction(game));<br/>
            }<br/>
        }<br/>
<br/>
        resolveClearMinefieldAttempts(clearAttempts);<br/>
    }<br/>
<br/>
    private void resolveClearMinefieldAttempts(Vector clearAttempts) {<br/>
<br/>
        for (int i = 0; i &lt; clearAttempts.size(); i++) {<br/>
            Vector temp = new Vector();<br/>
            Entity e = (Entity) clearAttempts.elementAt(i);<br/>
            Coords pos = e.getPosition();<br/>
            temp.addElement(e);<br/>
<br/>
            for (int j = i + 1; j &lt; clearAttempts.size(); j++) {<br/>
                Entity ent = (Entity) clearAttempts.elementAt(j);<br/>
                if (ent.getPosition().equals(pos)) {<br/>
                    temp.addElement(ent);<br/>
                    clearAttempts.removeElement(ent);<br/>
                }<br/>
            }<br/>
<br/>
            boolean accident = false;<br/>
            boolean cleared = false;<br/>
            for (int j = 0; j &lt; temp.size(); j++) {<br/>
                Entity ent = (Entity) temp.elementAt(j);<br/>
                int roll = Compute.d6(2);<br/>
                int clear = Minefield.CLEAR_NUMBER_INFANTRY;<br/>
                int boom = Minefield.CLEAR_NUMBER_INFANTRY_ACCIDENT;<br/>
<br/>
                // Does the entity has a minesweeper?<br/>
                Enumeration equip = ent.getMisc();<br/>
                while ( equip.hasMoreElements() ) {<br/>
                    Mounted mounted = (Mounted) equip.nextElement();<br/>
                    if ( mounted.getType().hasFlag(MiscType.F_TOOLS)<br/>
                     &amp;&amp; mounted.getType().hasSubType(MiscType.S_MINESWEEPER) ) {<br/>
                        int sweeperType = mounted.getType().getToHitModifier();<br/>
                        clear = Minefield.CLEAR_NUMBER_SWEEPER[sweeperType];<br/>
                        boom = Minefield.CLEAR_NUMBER_SWEEPER_ACCIDENT[sweeperType];<br/>
                        break;<br/>
                    }<br/>
                }<br/>
                //mine clearing roll<br/>
                Report r = new Report(2245);<br/>
                r.subject = ent.getId();<br/>
                r.add(ent.getShortName(), true);<br/>
                r.add(pos.getBoardNum(), true);<br/>
                r.add(clear);<br/>
                r.add(roll);<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
<br/>
                if (roll &gt;= clear) {<br/>
                    //success<br/>
                    r = new Report(2250);<br/>
                    r.subject = ent.getId();<br/>
                    addReport(r);<br/>
                    cleared = true;<br/>
                } else if (roll &lt;= boom) {<br/>
                    //"click"...oops!<br/>
                    r = new Report(2255);<br/>
                    r.subject = ent.getId();<br/>
                    addReport(r);<br/>
                    accident = true;<br/>
                } else {<br/>
                    //failure<br/>
                    r = new Report(2260);<br/>
                    r.subject = ent.getId();<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
            if (accident) {<br/>
                Enumeration minefields = game.getMinefields(pos).elements();<br/>
                while (minefields.hasMoreElements()) {<br/>
                    Minefield mf = (Minefield) minefields.nextElement();<br/>
                    switch (mf.getType()) {<br/>
                        case (Minefield.TYPE_CONVENTIONAL) :<br/>
                        case (Minefield.TYPE_THUNDER) :<br/>
                            for (int j = 0; j &lt; temp.size(); j++) {<br/>
                                Entity entity = (Entity) temp.elementAt(j);<br/>
                                Report r = new Report(2265);<br/>
                                r.subject = entity.getId();<br/>
                                r.add(entity.getShortName(), true);<br/>
                                addReport(r);<br/>
                                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);<br/>
                                addReport( damageEntity(entity, hit, mf.getDamage()));<br/>
                                addNewLines();<br/>
                            }<br/>
                            break;<br/>
                        case (Minefield.TYPE_VIBRABOMB) :<br/>
                            explodeVibrabomb(mf);<br/>
                            break;<br/>
                    }<br/>
                }<br/>
            }<br/>
            if (cleared) {<br/>
                removeMinefieldsFrom(pos);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called during the fire phase to resolve all (and only) weapon attacks<br/>
     */<br/>
    private void resolveOnlyWeaponAttacks() {<br/>
        Vector results = new Vector(game.actionsSize());<br/>
<br/>
        // loop thru received attack actions, getting weapon results<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
            if (o instanceof WeaponAttackAction) {<br/>
                WeaponAttackAction waa = (WeaponAttackAction)o;<br/>
                results.addElement(preTreatWeaponAttack(waa));<br/>
            }<br/>
        }<br/>
<br/>
        // loop through weapon results and resolve<br/>
        int cen = Entity.NONE;<br/>
        for (Enumeration i = results.elements(); i.hasMoreElements();) {<br/>
            WeaponResult wr = (WeaponResult)i.nextElement();<br/>
            resolveWeaponAttack(wr, cen);<br/>
            cen = wr.waa.getEntityId();<br/>
        }<br/>
<br/>
        // and clear the attacks Vector<br/>
        game.resetActions();<br/>
    }<br/>
<br/>
    /**<br/>
     * Trigger the indicated AP Pod of the entity.<br/>
     *<br/>
     * @param   entity the &lt;code&gt;Entity&lt;/code&gt; triggering the AP Pod.<br/>
     * @param   podId the &lt;code&gt;int&lt;/code&gt; ID of the AP Pod.<br/>
     */<br/>
    private void triggerAPPod( Entity entity, int podId ) {<br/>
<br/>
        // Get the mount for this pod.<br/>
        Mounted mount = entity.getEquipment( podId );<br/>
<br/>
        // Confirm that this is, indeed, an AP Pod.<br/>
        if ( null == mount ) {<br/>
            System.err.print( "Expecting to find an AP Pod at " );<br/>
            System.err.print( podId );<br/>
            System.err.print( " on the unit, " );<br/>
            System.err.print( entity.getDisplayName() );<br/>
            System.err.println( " but found NO equipment at all!!!" );<br/>
            return;<br/>
        }<br/>
        EquipmentType equip = mount.getType();<br/>
        if ( !(equip instanceof MiscType) ||<br/>
             !equip.hasFlag(MiscType.F_AP_POD) ) {<br/>
            System.err.print( "Expecting to find an AP Pod at " );<br/>
            System.err.print( podId );<br/>
            System.err.print( " on the unit, " );<br/>
            System.err.print( entity.getDisplayName() );<br/>
            System.err.print( " but found " );<br/>
            System.err.print( equip.getName() );<br/>
            System.err.println( " instead!!!" );<br/>
            return;<br/>
        }<br/>
<br/>
        // Now confirm that the entity can trigger the pod.<br/>
        // Ignore the "used this round" flag.<br/>
        boolean oldFired = mount.isUsedThisRound();<br/>
        mount.setUsedThisRound( false );<br/>
        boolean canFire = mount.canFire();<br/>
        mount.setUsedThisRound( oldFired );<br/>
        if ( !canFire ) {<br/>
            System.err.print( "Can not trigger the AP Pod at " );<br/>
            System.err.print( podId );<br/>
            System.err.print( " on the unit, " );<br/>
            System.err.print( entity.getDisplayName() );<br/>
            System.err.println( "!!!" );<br/>
            return;<br/>
        }<br/>
<br/>
        Report r;<br/>
<br/>
        // Mark the pod as fired and log the action.<br/>
        mount.setFired( true );<br/>
        r = new Report(3010);<br/>
        r.newlines = 0;<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        addReport(r);<br/>
<br/>
        // Walk through ALL entities in the triggering entity's hex.<br/>
        Enumeration targets = game.getEntities( entity.getPosition() );<br/>
        while ( targets.hasMoreElements() ) {<br/>
            final Entity target = (Entity) targets.nextElement();<br/>
<br/>
            // Is this an unarmored infantry platoon?<br/>
            if ( target instanceof Infantry &amp;&amp;<br/>
                 !(target instanceof BattleArmor) ) {<br/>
<br/>
                // Roll d6-1 for damage.<br/>
                final int damage = Compute.d6() - 1;<br/>
<br/>
                // If the platoon took no damage, log it and go no further<br/>
                if ( 0 == damage ) {<br/>
                    r = new Report(3015);<br/>
                    r.indent(2);<br/>
                    r.subject = target.getId();<br/>
                    r.addDesc(target);<br/>
                    addReport(r);<br/>
                }<br/>
                else {<br/>
                    // Damage the platoon.<br/>
                    addReport( damageEntity( target, new HitData(Infantry.LOC_INFANTRY),damage ));<br/>
<br/>
                    // Damage from AP Pods is applied immediately.<br/>
                    target.applyDamage();<br/>
                }<br/>
<br/>
            } // End target-is-unarmored<br/>
<br/>
            // Nope, the target is immune.<br/>
            // Don't make a log entry for the triggering entity.<br/>
            else if ( !entity.equals( target ) ) {<br/>
                r = new Report(3020);<br/>
                r.indent(2);<br/>
                r.subject = target.getId();<br/>
                r.addDesc(target);<br/>
                addReport(r);<br/>
            }<br/>
<br/>
        } // Check the next entity in the triggering entity's hex.<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolve an Unjam Action object<br/>
     */<br/>
    private void resolveUnjam(Entity entity) {<br/>
        Report r;<br/>
        final int TN = entity.getCrew().getGunnery() + 3;<br/>
        r = new Report(3025);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        addReport(r);<br/>
        for (Enumeration i = entity.getWeapons(); i.hasMoreElements();) {<br/>
            Mounted mounted = (Mounted)i.nextElement();<br/>
            if(mounted.isJammed()) {<br/>
                WeaponType wtype = (WeaponType)mounted.getType();<br/>
                if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
                    int roll = Compute.d6(2);<br/>
                    r = new Report(3030);<br/>
                    r.indent();<br/>
                    r.subject = entity.getId();<br/>
                    r.add(wtype.getName());<br/>
                    r.add(TN);<br/>
                    r.add(roll);<br/>
                    if(roll &gt;= TN) {<br/>
                        r.choose(true);<br/>
                        mounted.setJammed(false);<br/>
                    } else {<br/>
                        r.choose(false);<br/>
                    }<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    private void resolveFindClub(Entity entity) {<br/>
        EquipmentType clubType = null;<br/>
<br/>
        entity.setFindingClub(true);<br/>
<br/>
        // Get the entity's current hex.<br/>
        Coords coords = entity.getPosition();<br/>
        IHex curHex = game.getBoard().getHex( coords );<br/>
<br/>
        Report r;<br/>
<br/>
        // Is there a blown off arm in the hex?<br/>
        if (curHex.terrainLevel(Terrains.ARMS) &gt; 0) {<br/>
            clubType = EquipmentType.get("Limb Club");<br/>
            curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ARMS, curHex.terrainLevel(Terrains.ARMS)-1));<br/>
            sendChangedHex(entity.getPosition());<br/>
            r = new Report(3035);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
        }<br/>
        // Is there a blown off leg in the hex?<br/>
        else if (curHex.terrainLevel(Terrains.LEGS) &gt; 0) {<br/>
            clubType = EquipmentType.get("Limb Club");<br/>
            curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.LEGS, curHex.terrainLevel(Terrains.LEGS)-1));<br/>
            sendChangedHex(entity.getPosition());<br/>
            r = new Report(3040);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // Is there the rubble of a medium, heavy,<br/>
        // or hardened building in the hex?<br/>
        else if ( Building.LIGHT &lt; curHex.terrainLevel( Terrains.RUBBLE ) ) {<br/>
<br/>
            // Finding a club is not guaranteed.  The chances are<br/>
            // based on the type of building that produced the<br/>
            // rubble.<br/>
            boolean found = false;<br/>
            int roll = Compute.d6(2);<br/>
            switch ( curHex.terrainLevel( Terrains.RUBBLE ) ) {<br/>
            case Building.MEDIUM:<br/>
                if ( roll &gt;= 7 ) {<br/>
                    found = true;<br/>
                }<br/>
                break;<br/>
            case Building.HEAVY:<br/>
                if ( roll &gt;= 6 ) {<br/>
                    found = true;<br/>
                }<br/>
                break;<br/>
            case Building.HARDENED:<br/>
                if ( roll &gt;= 5 ) {<br/>
                    found = true;<br/>
                }<br/>
                break;<br/>
            }<br/>
<br/>
            // Let the player know if they found a club.<br/>
            if ( found ) {<br/>
                clubType = EquipmentType.get("Girder Club");<br/>
                r = new Report(3045);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
            } else {<br/>
                // Sorry, no club for you.<br/>
                clubType = null;<br/>
                r = new Report(3050);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        // Are there woods in the hex?<br/>
        else if ( curHex.containsTerrain( Terrains.WOODS )<br/>
                || curHex.containsTerrain( Terrains.JUNGLE ) ) {<br/>
            clubType = EquipmentType.get("Tree Club");<br/>
            r = new Report(3055);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // add the club<br/>
        try {<br/>
            if (clubType != null) {<br/>
                entity.addEquipment(clubType, Mech.LOC_NONE);<br/>
            }<br/>
        } catch (LocationFullException ex) {<br/>
            // unlikely...<br/>
            r = new Report(3060);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Generates a WeaponResult object for a WeaponAttackAction.  Adds heat,<br/>
     * depletes ammo, sets weapons used.<br/>
     */<br/>
    private WeaponResult preTreatWeaponAttack(WeaponAttackAction waa) {<br/>
        final Entity ae = game.getEntity(waa.getEntityId());<br/>
        final Mounted weapon = ae.getEquipment(waa.getWeaponId());<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        // 2003-01-02 BattleArmor MG and Small Lasers have unlimited ammo.<br/>
        final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
            !wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
<br/>
        Mounted ammo = null;<br/>
        if (usesAmmo) {<br/>
            if (waa.getAmmoId() &gt; -1) {<br/>
                ammo = ae.getEquipment(waa.getAmmoId());<br/>
                weapon.setLinked(ammo);<br/>
            } else {<br/>
                ammo = weapon.getLinked();<br/>
            }<br/>
        }<br/>
        boolean streakMiss;<br/>
<br/>
        WeaponResult wr = new WeaponResult();<br/>
        wr.waa = waa;<br/>
<br/>
        // has this weapon fired already?<br/>
        if (weapon.isUsedThisRound()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon has already been used this round");<br/>
            return wr;<br/>
        }<br/>
        // is the weapon functional?<br/>
        if (weapon.isDestroyed()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon was destroyed in a previous round");<br/>
            return wr;<br/>
        }<br/>
        // is it jammed?<br/>
        if (weapon.isJammed()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon is jammed");<br/>
            return wr;<br/>
        }<br/>
        // make sure ammo is loaded<br/>
        if (usesAmmo &amp;&amp; (ammo == null || ammo.getShotsLeft() == 0 || ammo.isDumping())) {<br/>
            ae.loadWeaponWithSameAmmo(weapon);<br/>
            ammo = weapon.getLinked();<br/>
        }<br/>
<br/>
        // store the ammo type for later use (needed for artillery attacks)<br/>
        waa.setAmmoId(ae.getEquipmentNum(ammo));<br/>
<br/>
        // compute to-hit<br/>
        wr.toHit = waa.toHit(game);<br/>
        <br/>
        if (waa.isNemesisConfused()) {<br/>
            wr.toHit.addModifier(1, "iNarc Nemesis pod");<br/>
        }<br/>
        // roll dice<br/>
        wr.roll = Compute.d6(2);<br/>
<br/>
        // if the shot is possible and not a streak miss<br/>
        // and not a nemesis-confused shot, add heat and use ammo<br/>
        streakMiss = (((wtype.getAmmoType() == AmmoType.T_SRM_STREAK)<br/>
                || (wtype.getAmmoType() == AmmoType.T_LRM_STREAK))<br/>
                &amp;&amp; wr.roll &lt; wr.toHit.getValue());<br/>
        if (wr.toHit.getValue() != TargetRoll.IMPOSSIBLE<br/>
                &amp;&amp; (!streakMiss || Compute.isAffectedByAngelECM(ae, ae.getPosition(), waa.getTarget(game).getPosition()))<br/>
                &amp;&amp; !waa.isNemesisConfused()) {<br/>
            wr = addHeatUseAmmoFor(waa, wr);<br/>
        }<br/>
<br/>
        // set the weapon as having fired<br/>
        weapon.setUsedThisRound(true);<br/>
<br/>
        // if not streak miss, resolve any AMS attacks on this attack<br/>
        if (!streakMiss) {<br/>
            wr = resolveAmsFor(waa, wr);<br/>
        }<br/>
<br/>
        return wr;<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds heat and uses ammo appropriate for a single attack of this weapon.<br/>
     * Call only on a valid attack (and with a streak weapon, only on hits.)<br/>
     *<br/>
     * @returns modified WeaponResult<br/>
     */<br/>
    private WeaponResult addHeatUseAmmoFor(WeaponAttackAction waa, WeaponResult wr) {<br/>
        if (waa.isSwarmingMissiles()) return wr;<br/>
        <br/>
        final Entity ae = game.getEntity(waa.getEntityId());<br/>
        final Mounted weapon = ae.getEquipment(waa.getWeaponId());<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        // 2003-01-02 BattleArmor MG and Small Lasers have unlimited ammo.<br/>
        final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
            !wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
<br/>
        Mounted ammo = weapon.getLinked();<br/>
<br/>
        // how many shots are we firing?<br/>
        int nShots = weapon.howManyShots();<br/>
<br/>
        // do we need to revert to single shot?<br/>
        if (usesAmmo &amp;&amp; nShots &gt; 1) {<br/>
            int nAvail = ae.getTotalAmmoOfType(ammo.getType());<br/>
            if (nAvail &lt; nShots) {<br/>
                wr.revertsToSingleShot = true;<br/>
                nShots = 1;<br/>
            }<br/>
        }<br/>
<br/>
        // use up ammo<br/>
        if (usesAmmo) {<br/>
            for (int i = 0; i &lt; nShots; i++) {<br/>
                if (ammo.getShotsLeft() &lt;= 0) {<br/>
                    ae.loadWeaponWithSameAmmo(weapon);<br/>
                    ammo = weapon.getLinked();<br/>
                }<br/>
                ammo.setShotsLeft(ammo.getShotsLeft() - 1);<br/>
            }<br/>
        }<br/>
<br/>
        // build up some heat<br/>
        ae.heatBuildup += (wtype.getHeat() * nShots);<br/>
<br/>
        return wr;<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolves any AMS fire for this weapon attack, adding AMS heat, depleting<br/>
     * AMS ammo.<br/>
     * @returns the appropriately modified WeaponResult<br/>
     */<br/>
    private WeaponResult resolveAmsFor(WeaponAttackAction waa, WeaponResult wr) {<br/>
        final Entity te = game.getEntity(waa.getTargetId());<br/>
<br/>
        // any AMS attacks by the target?<br/>
        Vector vCounters = waa.getCounterEquipment();<br/>
        if (null != vCounters) {<br/>
            // resolve AMS counter-fire<br/>
            wr.amsShotDown = new int[vCounters.size()];<br/>
            for (int x = 0; x &lt; vCounters.size(); x++) {<br/>
                wr.amsShotDown[x] = 0;<br/>
<br/>
                Mounted counter = (Mounted)vCounters.elementAt(x);<br/>
                Mounted mAmmo = counter.getLinked();<br/>
                if ((!(counter.getType() instanceof WeaponType))<br/>
                        || (!(counter.getType().hasFlag(WeaponType.F_AMS)))<br/>
                        || (!counter.isReady())<br/>
                        || (counter.isMissing())) {<br/>
                    continue;<br/>
                }<br/>
                // roll hits<br/>
                int amsHits = Compute.d6(((WeaponType)counter.getType()).getDamage());<br/>
<br/>
                // build up some heat (assume target is ams owner)<br/>
                if (counter.getType().hasFlag(WeaponType.F_HEATASDICE))<br/>
                    te.heatBuildup += Compute.d6(((WeaponType)counter.getType()).getHeat());<br/>
                else<br/>
                    te.heatBuildup += ((WeaponType)counter.getType()).getHeat();<br/>
<br/>
                // decrement the ammo<br/>
                if (mAmmo != null)<br/>
                    mAmmo.setShotsLeft(Math.max(0, mAmmo.getShotsLeft() - amsHits));<br/>
<br/>
                // set the ams as having fired<br/>
                counter.setUsedThisRound(true);<br/>
<br/>
                wr.amsShotDown[x]    = amsHits;<br/>
                wr.amsShotDownTotal += amsHits;<br/>
            }<br/>
        }<br/>
<br/>
        return wr;<br/>
    }<br/>
<br/>
    /**<br/>
     * Try to ignite the hex, taking into account exisiting fires and the<br/>
     * effects of Inferno rounds.<br/>
     *<br/>
     * @param   c - the &lt;code&gt;Coords&lt;/code&gt; of the hex being lit.<br/>
     * @param   bInferno - &lt;code&gt;true&lt;/code&gt; if the weapon igniting the<br/>
     *          hex is an Inferno round.  If some other weapon or ammo<br/>
     *          is causing the roll, this should be &lt;code&gt;false&lt;/code&gt;.<br/>
     * @param   nTargetRoll - the &lt;code&gt;int&lt;/code&gt; target number for the<br/>
     *          ignition roll.<br/>
     * @param   nTargetRoll - the &lt;code&gt;int&lt;/code&gt; roll target for the attempt.<br/>
     * @param   bReportAttempt - &lt;code&gt;true&lt;/code&gt; if the attempt roll should<br/>
     *          be added to the report.<br/>
     */<br/>
    private boolean tryIgniteHex( Coords c, int entityId, boolean bInferno,<br/>
                                  int nTargetRoll, boolean bReportAttempt ) {<br/>
<br/>
        IHex hex = game.getBoard().getHex(c);<br/>
        boolean bAnyTerrain = false;<br/>
        Report r;<br/>
<br/>
        // Ignore bad coordinates.<br/>
        if ( hex == null ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // inferno always ignites<br/>
        if (bInferno) {<br/>
            game.getBoard().addInfernoTo(c, InfernoTracker.STANDARD_ROUND, 1);<br/>
            nTargetRoll = 0;<br/>
            bAnyTerrain = true;<br/>
        }<br/>
<br/>
        // The hex may already be on fire.<br/>
        if ( hex.containsTerrain( Terrains.FIRE ) ) {<br/>
            if ( bReportAttempt ) {<br/>
                r = new Report(3065);<br/>
                r.indent(3);<br/>
                r.subject = entityId;<br/>
                addReport(r);<br/>
            }<br/>
            return true;<br/>
        }<br/>
        else if ( ignite(hex, nTargetRoll, bAnyTerrain, entityId) ) {<br/>
            //hex ignites<br/>
            r = new Report(3070);<br/>
            r.indent(3);<br/>
            r.subject = entityId;<br/>
            addReport(r);<br/>
            sendChangedHex(c);<br/>
            return true;<br/>
        }<br/>
        return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Try to ignite the hex, taking into account exisiting fires and the<br/>
     * effects of Inferno rounds.  This version of the method will not report<br/>
     * the attempt roll.<br/>
     *<br/>
     * @param   c - the &lt;code&gt;Coords&lt;/code&gt; of the hex being lit.<br/>
     * @param   bInferno - &lt;code&gt;true&lt;/code&gt; if the weapon igniting the<br/>
     *          hex is an Inferno round.  If some other weapon or ammo<br/>
     *          is causing the roll, this should be &lt;code&gt;false&lt;/code&gt;.<br/>
     * @param   nTargetRoll - the &lt;code&gt;int&lt;/code&gt; roll target for the attempt.<br/>
     */<br/>
   private boolean tryIgniteHex(Coords c, int entityId, boolean bInferno,<br/>
                                int nTargetRoll) {<br/>
       return tryIgniteHex(c, entityId, bInferno, nTargetRoll, false);<br/>
   }<br/>
<br/>
    private void tryClearHex(Coords c, int nTarget, int entityId) {<br/>
        IHex h = game.getBoard().getHex(c);<br/>
        int woods = h.terrainLevel(Terrains.WOODS);<br/>
        int jungle = h.terrainLevel(Terrains.JUNGLE);<br/>
        boolean ice = h.containsTerrain(Terrains.ICE);<br/>
        Report r;<br/>
        if (woods == ITerrain.LEVEL_NONE &amp;&amp; jungle == ITerrain.LEVEL_NONE &amp;&amp; !ice) {<br/>
            //woods already cleared<br/>
            r = new Report(3075);<br/>
            r.indent(3);<br/>
            r.subject = entityId;<br/>
            addReport(r);<br/>
        } else {<br/>
            int woodsRoll = Compute.d6(2);<br/>
            r = new Report(3080);<br/>
            r.indent(3);<br/>
            r.subject = entityId;<br/>
            r.add(nTarget);<br/>
            r.add(woodsRoll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if(woodsRoll &gt;= nTarget) {<br/>
                if(woods &gt; 2) {<br/>
                    h.removeTerrain(Terrains.WOODS);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.WOODS, woods - 1));<br/>
                    //ultra heavy converted to heavy<br/>
                    r = new Report(3082);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(woods == 2) {<br/>
                    h.removeTerrain(Terrains.WOODS);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.WOODS, woods - 1));<br/>
                    //heavy converted to light<br/>
                    r = new Report(3085);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(woods == 1) {<br/>
                    h.removeTerrain(Terrains.WOODS);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ROUGH, 1));<br/>
                    //light converted to rough<br/>
                    r = new Report(3090);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(jungle &gt; 2) {<br/>
                    h.removeTerrain(Terrains.JUNGLE);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.JUNGLE, jungle - 1));<br/>
                    //ultra heavy converted to heavy<br/>
                    r = new Report(3083);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(jungle == 2) {<br/>
                    h.removeTerrain(Terrains.JUNGLE);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.JUNGLE, jungle - 1));<br/>
                    //heavy converted to light<br/>
                    r = new Report(3086);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(jungle == 1) {<br/>
                    h.removeTerrain(Terrains.JUNGLE);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ROUGH, 1));<br/>
                    //light converted to rough<br/>
                    r = new Report(3091);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(ice) {<br/>
                    h.removeTerrain(Terrains.ICE);<br/>
                    r = new Report(3092);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                    resolveIceBroken(c);<br/>
                }<br/>
                sendChangedHex(c);<br/>
            } else {<br/>
                //fails to clear woods<br/>
                r = new Report(3095);<br/>
                r.subject = entityId;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    private void resolveWeaponAttack(WeaponResult wr, int lastEntityId) {<br/>
        resolveWeaponAttack(wr, lastEntityId, false);<br/>
    }<br/>
    <br/>
    private boolean resolveWeaponAttack(WeaponResult wr, int lastEntityId, boolean isNemesisConfused) {<br/>
        return resolveWeaponAttack(wr, lastEntityId, isNemesisConfused, 0);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Resolve a single Weapon Attack object<br/>
     * @param wr The &lt;code&gt;WeaponResult&lt;/code&gt; to resolve<br/>
     * @param lastEntityId The &lt;code&gt;int&lt;/code&gt; ID of the last<br/>
     *        resolved weaponattack's attacking entity<br/>
     * @param isNemesisConfused The &lt;code&gt;boolean&lt;/code&gt; value of wether<br/>
     *        this attack is one caused by homing in on a iNarc Nemesis pod<br/>
     *        and so should not be further diverted<br/>
     * @param swarmMissilesLeft The &lt;code&gt;int&lt;/code&gt; number of remaining swarm<br/>
     *        missiles this attack has, 0 if this is not a remaining swarm<br/>
     *        missile attack <br/>
     * @return wether we hit or not, only needed for nemesis pod stuff<br/>
     */<br/>
    private boolean resolveWeaponAttack(WeaponResult wr, int lastEntityId, boolean isNemesisConfused, int swarmMissilesLeft) {<br/>
      // If it's an artillery shot, the shooting entity<br/>
      // might have died in the meantime<br/>
      Entity ae = game.getEntity( wr.waa.getEntityId() );<br/>
      if (ae == null) {<br/>
          ae = game.getOutOfGameEntity( wr.waa.getEntityId() );<br/>
      }<br/>
      final Targetable target = game.getTarget(wr.waa.getTargetType(),<br/>
                                               wr.waa.getTargetId());<br/>
      Report r;<br/>
      boolean throughFront;<br/>
      if (target instanceof Mech) {<br/>
          throughFront = Compute.isThroughFrontHex(game, wr.waa.getEntityId(), (Entity)target); <br/>
      } else {<br/>
          throughFront = true;<br/>
      }<br/>
       <br/>
      int subjectId = Entity.NONE;<br/>
      Entity entityTarget = null;<br/>
      if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
          entityTarget = (Entity) target;<br/>
          // The target of the attack should definately see the report.<br/>
          // The attacker usually will, but they might not if the attack<br/>
          // was indirect without a spotter.<br/>
          subjectId = entityTarget.getId();<br/>
      } else {<br/>
          //The target is not an entity, so we will show the report to<br/>
          // the attacker instead.<br/>
          subjectId = ae.getId();<br/>
      }<br/>
      final Mounted weapon = ae.getEquipment(wr.waa.getWeaponId());<br/>
      final WeaponType wtype = (WeaponType) weapon.getType();<br/>
      final boolean isWeaponInfantry = wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
      // 2002-09-16 Infantry weapons have unlimited ammo.<br/>
      final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
          wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
          wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
          !isWeaponInfantry;<br/>
      //retrieve ammo from the WeaponAttackAction rather than weapon.getLinked, because selected ammo may have changed<br/>
      //in the case of artillery attacks<br/>
      Mounted ammo = usesAmmo ? ae.getEquipment(wr.waa.getAmmoId()) : null;<br/>
      final AmmoType atype = ammo == null ? null : (AmmoType) ammo.getType();<br/>
      Infantry platoon = null;<br/>
      final boolean isBattleArmorAttack = wtype.hasFlag(WeaponType.F_BATTLEARMOR);<br/>
      ToHitData toHit = wr.toHit;<br/>
      boolean bInferno = (usesAmmo<br/>
                        &amp;&amp; ((atype.getAmmoType() == AmmoType.T_SRM)<br/>
                        || (atype.getAmmoType() == AmmoType.T_BA_INFERNO))<br/>
                        &amp;&amp; atype.getMunitionType() == AmmoType.M_INFERNO);<br/>
      boolean bFragmentation = (usesAmmo<br/>
                                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM) || (atype.getAmmoType() == AmmoType.T_SRM))<br/>
                                &amp;&amp; atype.getMunitionType() == AmmoType.M_FRAGMENTATION);<br/>
      boolean bAcidHead = (usesAmmo<br/>
                            &amp;&amp; atype.getAmmoType() == AmmoType.T_SRM<br/>
                            &amp;&amp; atype.getMunitionType() == AmmoType.M_AX_HEAD);<br/>
      boolean bFlechette = (usesAmmo &amp;&amp; (atype.getAmmoType() == AmmoType.T_AC)<br/>
                            &amp;&amp; atype.getMunitionType() == AmmoType.M_FLECHETTE);<br/>
      boolean bArtillery = target.getTargetType() == Targetable.TYPE_HEX_ARTILLERY;<br/>
      boolean bArtilleryFLAK = target.getTargetType() == Targetable.TYPE_ENTITY<br/>
                               &amp;&amp; wtype.hasFlag(WeaponType.F_ARTILLERY) <br/>
                               &amp;&amp; (usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_STANDARD)<br/>
                               &amp;&amp; entityTarget.getMovementMode() == IEntityMovementMode.VTOL<br/>
                               &amp;&amp; entityTarget.getElevation() &gt; 0;<br/>
      boolean bIncendiary = (usesAmmo &amp;&amp; atype.getAmmoType() == AmmoType.T_AC &amp;&amp;<br/>
              (atype.getMunitionType() == AmmoType.M_INCENDIARY_AC));<br/>
      boolean bTracer = (usesAmmo &amp;&amp; atype.getAmmoType() == AmmoType.T_AC &amp;&amp;<br/>
              (atype.getMunitionType() == AmmoType.M_TRACER));<br/>
      boolean bAntiTSM = (usesAmmo<br/>
                            &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM) || (atype.getAmmoType() == AmmoType.T_SRM))<br/>
                             &amp;&amp; atype.getMunitionType() == AmmoType.M_ANTI_TSM);<br/>
      boolean bSwarm = (usesAmmo<br/>
                            &amp;&amp; (atype.getAmmoType() == AmmoType.T_LRM)<br/>
                            &amp;&amp; atype.getMunitionType() == AmmoType.M_SWARM);<br/>
      boolean bSwarmI = (usesAmmo<br/>
                            &amp;&amp; (atype.getAmmoType() == AmmoType.T_LRM)<br/>
                            &amp;&amp; atype.getMunitionType() == AmmoType.M_SWARM_I);<br/>
      boolean isIndirect = ((wtype.getAmmoType() == AmmoType.T_LRM) || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO))<br/>
                               &amp;&amp; weapon.curMode().equals("Indirect");<br/>
      boolean isHotLoaded = ((wtype.getAmmoType() == AmmoType.T_LRM) ||                 <br/>
              (wtype.getAmmoType() == AmmoType.T_LRM_STREAK) ||<br/>
              (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO) ||<br/>
              (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO_COMBO))<br/>
               &amp;&amp; weapon.curMode().equals("Hot Load");<br/>
      boolean isAngelECMAffected = Compute.isAffectedByAngelECM(ae, ae.getPosition(), target.getPosition());<br/>
      if (isIndirect &amp;&amp; game.getOptions().booleanOption("indirect_fire") &amp;&amp;<br/>
          !game.getOptions().booleanOption("indirect_always_possible") &amp;&amp;<br/>
          LosEffects.calculateLos(game, ae.getId(), target).canSee()) {<br/>
          r = new Report(3470);<br/>
          r.subject = subjectId;<br/>
          r.addDesc(ae);<br/>
          addReport(r);<br/>
          return false;<br/>
      }<br/>
      boolean bGlancing = false; // For Glancing Hits Rule<br/>
      int swarmMissilesNowLeft = 0;<br/>
      int hits = 1, glancingMissileMod = 0;<br/>
      int glancingCritMod = 0;<br/>
<br/>
      if (!bInferno) {<br/>
        // also check for inferno infantry<br/>
        bInferno = (isWeaponInfantry &amp;&amp; wtype.hasFlag(WeaponType.F_INFERNO));<br/>
      }<br/>
      final boolean targetInBuilding =<br/>
          Compute.isInBuilding(game, entityTarget);<br/>
      if ((bArtillery||bArtilleryFLAK) &amp;&amp; game.getPhase()==IGame.PHASE_FIRING) { //if direct artillery<br/>
          wr.artyAttackerCoords=ae.getPosition();<br/>
      }<br/>
      if ( (bSwarm || bSwarmI) &amp;&amp; entityTarget != null) {<br/>
          entityTarget.addTargetedBySwarm(ae.getId(), wr.waa.getWeaponId());<br/>
      }<br/>
<br/>
      // Which building takes the damage?<br/>
      Building bldg = game.getBoard().getBuildingAt(target.getPosition());<br/>
      <br/>
      // Are we iNarc Nemesis Confusable?<br/>
      boolean isNemesisConfusable = false;<br/>
      Mounted mLinker = weapon.getLinkedBy();<br/>
      if ( wtype.getAmmoType() == AmmoType.T_ATM ||<br/>
           ( mLinker != null &amp;&amp;<br/>
             mLinker.getType() instanceof MiscType &amp;&amp;<br/>
             !mLinker.isDestroyed() &amp;&amp; !mLinker.isMissing() &amp;&amp; !mLinker.isBreached() &amp;&amp;<br/>
             mLinker.getType().hasFlag(MiscType.F_ARTEMIS) ) ) {<br/>
          if ((!weapon.getType().hasModes() ||<br/>
               !weapon.curMode().equals("Indirect")) &amp;&amp;<br/>
              ( ((atype.getAmmoType() == AmmoType.T_ATM) &amp;&amp;<br/>
                 (atype.getMunitionType() == AmmoType.M_STANDARD ||<br/>
                  atype.getMunitionType() == AmmoType.M_EXTENDED_RANGE ||<br/>
                  atype.getMunitionType() == AmmoType.M_HIGH_EXPLOSIVE) ) ||<br/>
                ((atype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 atype.getAmmoType() == AmmoType.T_SRM) &amp;&amp;<br/>
                atype.getMunitionType() == AmmoType.M_ARTEMIS_CAPABLE))) {<br/>
              isNemesisConfusable = true;<br/>
          }<br/>
      } else if (wtype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_SRM) {<br/>
          if (usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_NARC_CAPABLE) {<br/>
              isNemesisConfusable = true;<br/>
          }<br/>
      }<br/>
<br/>
      if (lastEntityId != ae.getId()) {<br/>
          //report who is firing<br/>
          r = new Report(3100);<br/>
          r.subject = subjectId;<br/>
          r.addDesc(ae);<br/>
          addReport(r);<br/>
      }<br/>
<br/>
      // Swarming infantry can stop during any weapons phase after start.<br/>
      if (Infantry.STOP_SWARM.equals(wtype.getInternalName())) {<br/>
          // ... but only as their *only* attack action.<br/>
          if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
              r = new Report(3105);<br/>
              r.subject = subjectId;<br/>
              r.add(toHit.getDesc());<br/>
              addReport(r);<br/>
              return true;<br/>
          } else {<br/>
              //swarming ended succesfully<br/>
              r = new Report(3110);<br/>
              r.subject = subjectId;<br/>
              addReport(r);<br/>
              // Only apply the "stop swarm 'attack'" to the swarmed Mek.<br/>
              if (ae.getSwarmTargetId() != target.getTargetId()) {<br/>
                  Entity other = game.getEntity(ae.getSwarmTargetId());<br/>
                  other.setSwarmAttackerId(Entity.NONE);<br/>
              }<br/>
              else {<br/>
                  entityTarget.setSwarmAttackerId(Entity.NONE);<br/>
              }<br/>
              ae.setSwarmTargetId(Entity.NONE);<br/>
              return true;<br/>
          }<br/>
      }<br/>
<br/>
      // Report weapon attack and its to-hit value.<br/>
      r = new Report(3115);<br/>
      r.indent();<br/>
      r.newlines = 0;<br/>
      r.subject = subjectId;<br/>
      r.add(wtype.getName());<br/>
      if (entityTarget != null) {<br/>
          r.addDesc(entityTarget);<br/>
      } else {<br/>
          r.messageId = 3120;<br/>
          r.add(target.getDisplayName(), true);<br/>
      }<br/>
      addReport(r);<br/>
<br/>
      boolean shotAtNemesisTarget = false;<br/>
      // check for nemesis<br/>
      if (isNemesisConfusable &amp;&amp; !isNemesisConfused) {<br/>
          // loop through nemesis targets<br/>
          for (Enumeration e = game.getNemesisTargets(ae, target.getPosition());e.hasMoreElements();) {<br/>
              Entity entity = (Entity)e.nextElement();<br/>
              //friendly unit with attached iNarc Nemesis pod standing in the way<br/>
              r = new Report(3125);<br/>
              r.subject = subjectId;<br/>
              addReport(r);<br/>
              weapon.setUsedThisRound(false);<br/>
              WeaponAttackAction newWaa = new WeaponAttackAction(ae.getId(),<br/>
                  entity.getTargetId(), wr.waa.getWeaponId());<br/>
              newWaa.setNemesisConfused(true);<br/>
              WeaponResult newWr = preTreatWeaponAttack(newWaa);<br/>
              // attack the new target, and if we hit it, return;<br/>
              if (resolveWeaponAttack(newWr, ae.getId(), true)) return true;<br/>
              shotAtNemesisTarget = true;<br/>
          }<br/>
      }<br/>
      if (shotAtNemesisTarget) {<br/>
          //back to original target<br/>
          r = new Report(3130);<br/>
          r.subject = subjectId;<br/>
          r.newlines = 0;<br/>
          addReport(r);<br/>
      }<br/>
      if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
          r = new Report(3135);<br/>
          r.subject = subjectId;<br/>
          r.add(toHit.getDesc());<br/>
          addReport(r);<br/>
          return false;<br/>
      }<br/>
      else if (toHit.getValue() == ToHitData.AUTOMATIC_FAIL) {<br/>
          r = new Report(3140);<br/>
          r.newlines = 0;<br/>
          r.subject = subjectId;<br/>
          r.add(toHit.getDesc());<br/>
          addReport(r);<br/>
      }<br/>
      else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
          r = new Report(3145);<br/>
          r.newlines = 0;<br/>
          r.subject = subjectId;<br/>
          r.add(toHit.getDesc());<br/>
          addReport(r);<br/>
      }<br/>
      else {<br/>
          //roll to hit<br/>
          r = new Report(3150);<br/>
          r.newlines = 0;<br/>
          r.subject = subjectId;<br/>
          r.add(toHit.getValue());<br/>
          addReport(r);<br/>
      }<br/>
<br/>
      // if firing an HGR unbraced, schedule a PSR<br/>
      if (wtype.getAmmoType() == AmmoType.T_GAUSS_HEAVY &amp;&amp; ae.mpUsed &gt; 0) {<br/>
          // the mod is weight-based<br/>
          int nMod;<br/>
          switch (ae.getWeightClass()) {<br/>
          case EntityWeightClass.WEIGHT_LIGHT:<br/>
              nMod = 2;<br/>
              break;<br/>
          case EntityWeightClass.WEIGHT_MEDIUM:<br/>
              nMod = 1;<br/>
              break;<br/>
          case EntityWeightClass.WEIGHT_HEAVY:<br/>
              nMod = 0;<br/>
              break;<br/>
          default:<br/>
              nMod = -1;<br/>
          }<br/>
          PilotingRollData psr = new PilotingRollData(ae.getId(), nMod,<br/>
                                          "fired HeavyGauss unbraced");<br/>
          psr.setCumulative(false);<br/>
          game.addPSR(psr);<br/>
      }<br/>
<br/>
      // dice have been rolled, thanks<br/>
      r = new Report(3155);<br/>
      r.newlines = 0;<br/>
      r.subject = subjectId;<br/>
      r.add(wr.roll);<br/>
      addReport(r);<br/>
<br/>
      // check for AC or Prototype jams<br/>
      int nShots = weapon.howManyShots();<br/>
      if (nShots &gt; 1 || <br/>
          (wtype.hasFlag(WeaponType.F_PROTOTYPE) &amp;&amp;<br/>
           wtype.getAmmoType() != AmmoType.T_NA) ) {<br/>
          int jamCheck = 0;<br/>
          if ((((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)<br/>
                || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB))<br/>
                &amp;&amp; weapon.curMode().equals("Ultra")) ||<br/>
              wtype.hasFlag(WeaponType.F_PROTOTYPE)) {<br/>
              jamCheck = 2;<br/>
              if (weapon.getType().hasModes() &amp;&amp;<br/>
                      weapon.curMode().equals("Ultra") &amp;&amp;<br/>
                      wtype.hasFlag(WeaponType.F_PROTOTYPE)) {<br/>
                  jamCheck = 4;<br/>
              }<br/>
          } else if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
              if (nShots == 2) {<br/>
                  jamCheck = 2;<br/>
              } else if (nShots == 4) {<br/>
                  jamCheck = 3;<br/>
              } else if (nShots == 6) {<br/>
                  jamCheck = 4;<br/>
              }<br/>
          }<br/>
<br/>
          if (jamCheck &gt; 0 &amp;&amp; wr.roll &lt;= jamCheck) {<br/>
              r = new Report(1210);<br/>
              // ultras and prototypes are destroyed by jamming<br/>
              if ((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)<br/>
                    || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)) {<br/>
                  r.messageId = 3160;<br/>
                  weapon.setJammed(true);<br/>
                  weapon.setHit(true);<br/>
              } else if (wtype.hasFlag(WeaponType.F_PROTOTYPE)) {<br/>
                  r.messageId = 3165;<br/>
                  weapon.setJammed(true);<br/>
                  weapon.setHit(true);<br/>
              } else {<br/>
                  r.messageId = 3170;<br/>
                  weapon.setJammed(true);<br/>
              }<br/>
              r.subject = subjectId;<br/>
              addReport(r);<br/>
              return true;<br/>
          }<br/>
      }<br/>
<br/>
      // Resolve roll for disengaged field inhibitors on PPCs, if needed<br/>
      if (game.getOptions().booleanOption("maxtech_ppc_inhibitors")<br/>
          &amp;&amp; wtype.hasModes()<br/>
          &amp;&amp; weapon.curMode().equals("Field Inhibitor OFF") ) {<br/>
          int rollTarget = 0;<br/>
          int dieRoll = Compute.d6(2);<br/>
          int distance = Compute.effectiveDistance(game, ae, target);<br/>
<br/>
          if (distance&gt;=3) {<br/>
              rollTarget = 3;<br/>
          } else if (distance == 2) {<br/>
              rollTarget = 6;<br/>
          } else if (distance == 1) {<br/>
              rollTarget = 10;<br/>
          }<br/>
          //roll to avoid damage<br/>
          r = new Report(3175);<br/>
          r.subject = ae.getId();<br/>
          r.indent();<br/>
          addReport(r);<br/>
          r = new Report(3180);<br/>
          r.subject = ae.getId();<br/>
          r.indent();<br/>
          r.add(rollTarget);<br/>
          r.add(dieRoll);<br/>
          if (dieRoll&lt;rollTarget) {<br/>
              // Oops, we ruined our day...<br/>
              int wlocation = weapon.getLocation();<br/>
              int wid = ae.getEquipmentNum(weapon);<br/>
              int slot = 0;<br/>
              weapon.setDestroyed (true);<br/>
              for (int i=0; i&lt;ae.getNumberOfCriticals(wlocation); i++) {<br/>
                  CriticalSlot slot1 = ae.getCritical (wlocation, i);<br/>
                  if (slot1 == null || slot1.getType() != CriticalSlot.TYPE_SYSTEM) {<br/>
                      continue;<br/>
                  }<br/>
                  Mounted mounted = ae.getEquipment(slot1.getIndex());<br/>
                  if (mounted.equals(weapon)) {<br/>
                      ae.hitAllCriticals(wlocation,i);<br/>
                  }<br/>
              }<br/>
              // Bug 1066147 : damage is *not* like an ammo explosion,<br/>
              //        but it *does* get applied directly to the IS.<br/>
              r.choose(false);<br/>
              addReport(r);<br/>
              addReport( damageEntity(ae, new HitData(wlocation), 10, false, 0, true));<br/>
              r = new Report(3185);<br/>
              r.subject = ae.getId();<br/>
              addReport(r);<br/>
          } else {<br/>
              r.choose(true);<br/>
              addReport(r);<br/>
          }<br/>
      }<br/>
<br/>
      // do we hit?<br/>
      boolean bMissed = wr.roll &lt; toHit.getValue();<br/>
      if (game.getOptions().booleanOption("maxtech_glancing_blows")) {<br/>
          if (wr.roll == toHit.getValue()) {<br/>
              bGlancing = true;<br/>
              glancingMissileMod = -4;<br/>
              glancingCritMod = -2;<br/>
              r = new  Report(3186);<br/>
              r.subject = ae.getId();<br/>
              r.newlines = 0;<br/>
              addReport(r);<br/>
          } else {<br/>
              bGlancing = false;<br/>
              glancingMissileMod = 0;<br/>
              glancingCritMod = 0;<br/>
          }<br/>
      } else {<br/>
          bGlancing = false;<br/>
          glancingMissileMod = 0;<br/>
          glancingCritMod = 0;<br/>
      }<br/>
<br/>
      // special case TAG.  No damage, but target is tagged until end of turn<br/>
      if (wtype.hasFlag(WeaponType.F_TAG)) {<br/>
          if (entityTarget == null) {<br/>
              r = new Report(3187);<br/>
              r.subject = ae.getId();<br/>
              addReport(r);<br/>
          } else {<br/>
              int priority = 1;<br/>
              EquipmentMode mode = (weapon.curMode());<br/>
              if (mode != null) {<br/>
                  if(mode.getName() == "1-shot") {<br/>
                      priority=1;<br/>
                  } else if(mode.getName() == "2-shot") {<br/>
                      priority=2;<br/>
                  } else if(mode.getName() == "3-shot") {<br/>
                      priority=3;<br/>
                  } else if(mode.getName() == "4-shot") {<br/>
                      priority=4;<br/>
                  }<br/>
              }<br/>
              if (priority &lt; 1) priority = 1;<br/>
              //add even misses, as they waste homing missiles.<br/>
              //it is possible for 2 or more tags to hit the same entity, <br/>
              //but this only matters in the offboard phase<br/>
              TagInfo info = new TagInfo(ae.getId(), entityTarget.getId(), priority, bMissed);<br/>
              game.addTagInfo(info);<br/>
              if (!bMissed) {<br/>
                  entityTarget.setTaggedBy(ae.getId());<br/>
                  r = new Report(3188);<br/>
                  r.subject = ae.getId();<br/>
                  addReport(r);<br/>
              } else {<br/>
                  r = new Report(3220);<br/>
                  r.subject = ae.getId();<br/>
                  addReport(r);<br/>
              }<br/>
          }<br/>
          return !bMissed;<br/>
      }<br/>
      // special case Artillery FLAK<br/>
      if (bArtilleryFLAK) {<br/>
          Coords coords = target.getPosition();<br/>
          int targEl = target.getElevation();<br/>
          // absolute height of target, so we can check units in adjacent hexes<br/>
          int absEl = targEl + game.getBoard().getHex(coords).surface();<br/>
          if (!bMissed) {<br/>
              r = new Report(3191);<br/>
              r.subject = subjectId;<br/>
              r.add(coords.getBoardNum());<br/>
              addReport(r);<br/>
          } else {<br/>
              coords = Compute.scatter(coords, game.getOptions().booleanOption("margin_scatter_distance")?toHit.getValue()-wr.roll:-1);<br/>
              if (game.getBoard().contains(coords)) {<br/>
                  r = new Report(3192);<br/>
                  r.subject = subjectId;<br/>
                  r.add(coords.getBoardNum());<br/>
                  addReport(r);<br/>
              }<br/>
              else {<br/>
                  r = new Report(3193);<br/>
                  r.subject = subjectId;<br/>
                  addReport(r);<br/>
                  return !bMissed;<br/>
              }<br/>
          }<br/>
          artilleryDamageArea(coords, wr.artyAttackerCoords, atype, subjectId, ae, true, absEl);<br/>
          return !bMissed;<br/>
      } // End artillery FLAK<br/>
      // special case BA micro bombs<br/>
      if (target.getTargetType() == Targetable.TYPE_HEX_BOMB) {<br/>
          Coords coords = target.getPosition();<br/>
          if (!bMissed) {<br/>
              r = new Report(3190);<br/>
              r.subject = subjectId;<br/>
              r.add(coords.getBoardNum());<br/>
              addReport(r);<br/>
          } else {<br/>
              coords = Compute.scatter(coords, 1);<br/>
              if (game.getBoard().contains(coords)) {<br/>
                  r = new Report(3195);<br/>
                  r.subject = subjectId;<br/>
                  r.add(coords.getBoardNum());<br/>
                  addReport(r);<br/>
              }<br/>
              else {<br/>
                  r = new Report(3200);<br/>
                  r.subject = subjectId;<br/>
                  addReport(r);<br/>
                  return !bMissed;<br/>
              }<br/>
          }<br/>
          int nCluster = 5;<br/>
          Infantry ba = (Infantry)ae;<br/>
          int ratedDamage = ba.getShootingStrength();<br/>
          artilleryDamageArea(coords, wr.artyAttackerCoords, atype, subjectId, ae, ratedDamage*2, ratedDamage, false, 0);<br/>
          return !bMissed;          <br/>
      } //end ba-micro-bombs<br/>
<br/>
      // special case minefield delivery, no damage and scatters if misses.<br/>
      if (target.getTargetType() == Targetable.TYPE_MINEFIELD_DELIVER<br/>
          || target.getTargetType() == Targetable.TYPE_FLARE_DELIVER) {<br/>
          Coords coords = target.getPosition();<br/>
          if (!bMissed) {<br/>
              r = new Report(3190);<br/>
              r.subject = subjectId;<br/>
              r.add(coords.getBoardNum());<br/>
              addReport(r);<br/>
          }<br/>
          else {<br/>
              coords = Compute.scatter(coords, game.getOptions().booleanOption("margin_scatter_distance")?toHit.getValue()-wr.roll:-1);<br/>
              if (game.getBoard().contains(coords)) {<br/>
                  //misses and scatters to another hex<br/>
                  r = new Report(3195);<br/>
                  r.subject = subjectId;<br/>
                  r.add(coords.getBoardNum());<br/>
                  addReport(r);<br/>
              }<br/>
              else {<br/>
                  //misses and scatters off-board<br/>
                  r = new Report(3200);<br/>
                  r.subject = subjectId;<br/>
                  addReport(r);<br/>
                  return !bMissed;<br/>
              }<br/>
          }<br/>
<br/>
          // Handle the thunder munitions.<br/>
          if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                &amp;&amp; atype.getMunitionType() == AmmoType.M_THUNDER_AUGMENTED) {<br/>
              deliverThunderAugMinefield(coords, ae.getOwner().getId(),<br/>
                                         atype.getRackSize());<br/>
          }<br/>
          else if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                    &amp;&amp; atype.getMunitionType() == AmmoType.M_THUNDER) {<br/>
              deliverThunderMinefield(coords, ae.getOwner().getId(),<br/>
                                      atype.getRackSize());<br/>
          }<br/>
          else if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                    &amp;&amp; atype.getMunitionType() == AmmoType.M_THUNDER_INFERNO)<br/>
              deliverThunderInfernoMinefield(coords, ae.getOwner().getId(),<br/>
                                             atype.getRackSize());<br/>
          else if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                    &amp;&amp; atype.getMunitionType() == AmmoType.M_THUNDER_VIBRABOMB)<br/>
              deliverThunderVibraMinefield(coords, ae.getOwner().getId(),<br/>
                                           atype.getRackSize(),<br/>
                                           wr.waa.getOtherAttackInfo());<br/>
          else if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                    &amp;&amp; atype.getMunitionType() == AmmoType.M_THUNDER_ACTIVE)<br/>
              deliverThunderActiveMinefield(coords, ae.getOwner().getId(),<br/>
                                        atype.getRackSize());<br/>
          else if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                    &amp;&amp; atype.getMunitionType() == AmmoType.M_FLARE)<br/>
              deliverFlare(coords, atype.getRackSize());<br/>
          //else<br/>
          //{<br/>
          //...This is an error, but I'll just ignore it for now.<br/>
          //}<br/>
          return !bMissed;<br/>
      }<br/>
      //special case artillery<br/>
      if ((target.getTargetType() == Targetable.TYPE_HEX_ARTILLERY)<br/>
          &amp;&amp; !(usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_HOMING)) { <br/>
          Coords coords = target.getPosition();<br/>
          if (!bMissed) {<br/>
              r = new Report(3190);<br/>
              r.subject = subjectId;<br/>
              r.add(coords.getBoardNum());<br/>
              addReport(r);<br/>
          }<br/>
          else {<br/>
              coords = Compute.scatter(coords, (game.getOptions().booleanOption("margin_scatter_distance"))?(toHit.getValue()-wr.roll):-1);<br/>
              if (game.getBoard().contains(coords)) {<br/>
                  //misses and scatters to another hex<br/>
                  r = new Report(3195);<br/>
                  r.subject = subjectId;<br/>
                  r.add(coords.getBoardNum());<br/>
                  addReport(r);<br/>
              }<br/>
              else {<br/>
                  //misses and scatters off-board<br/>
                  r = new Report(3200);<br/>
                  r.subject = subjectId;<br/>
                  addReport(r);<br/>
                  return !bMissed;<br/>
              }<br/>
          }<br/>
<br/>
          if (usesAmmo) {<br/>
              //Check for various non-explosive types<br/>
              if(atype.getMunitionType() == AmmoType.M_FLARE) {<br/>
                  int radius;<br/>
                  if(atype.getAmmoType() == AmmoType.T_ARROW_IV)<br/>
                      radius = 4;<br/>
                  else if(atype.getAmmoType() == AmmoType.T_LONG_TOM)<br/>
                      radius = 3;<br/>
                  else radius = Math.max(1,atype.getRackSize() / 5);<br/>
                      deliverArtilleryFlare(coords,radius);<br/>
                  return !bMissed;<br/>
              }<br/>
              if(atype.getMunitionType() == AmmoType.M_INFERNO_IV) {<br/>
                  deliverArtilleryInferno(coords, subjectId);<br/>
                  return !bMissed;<br/>
              }<br/>
              if(atype.getMunitionType() == AmmoType.M_FASCAM) {<br/>
                  deliverFASCAMMinefield(coords, ae.getOwner().getId());<br/>
                  return !bMissed;<br/>
              }<br/>
              if(atype.getMunitionType() == AmmoType.M_VIBRABOMB_IV) {<br/>
                  deliverThunderVibraMinefield(coords, ae.getOwner().getId(), 20,<br/>
                                               wr.waa.getOtherAttackInfo());<br/>
                  return !bMissed;<br/>
              }<br/>
              if(atype.getMunitionType() == AmmoType.M_SMOKE) {<br/>
                  deliverArtillerySmoke(coords);<br/>
                  return !bMissed;<br/>
              }<br/>
          }<br/>
<br/>
          artilleryDamageArea(coords, wr.artyAttackerCoords, atype, subjectId, ae, false, 0);<br/>
<br/>
          return !bMissed;<br/>
      } // End artillery<br/>
      if(bMissed &amp;&amp; usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_HOMING) {<br/>
          //Arrow IV homing missed, splash the hex<br/>
          artilleryDamageHex(target.getPosition(), wr.artyAttackerCoords, 5, atype, subjectId, ae, null, false, 0);<br/>
      }<br/>
      <br/>
      int ammoUsage=0;<br/>
      int nDamPerHit = wtype.getDamage();<br/>
      if (bMissed) {<br/>
          // Report the miss.<br/>
          // MGs in rapidfire do heat even when they miss.<br/>
          if (weapon.isRapidfire() &amp;&amp;<br/>
              !(target instanceof Infantry &amp;&amp;<br/>
              !(target instanceof BattleArmor)) ){<br/>
                // Check for rapid fire Option. Only MGs can be rapidfire.<br/>
                nDamPerHit = Compute.d6();<br/>
                ammoUsage = 3*nDamPerHit;<br/>
                if (ae.getTotalAmmoOfType(ammo.getType())&gt;0) {<br/>
                    for (int i=0; i&lt;ammoUsage; i++) {<br/>
                        if (ammo.getShotsLeft() &lt;= 0) {<br/>
                            ae.loadWeapon(weapon);<br/>
                            ammo = weapon.getLinked();<br/>
                        }<br/>
                        ammo.setShotsLeft(ammo.getShotsLeft()-1);<br/>
                    }<br/>
                    if (ae instanceof Mech) {<br/>
                        // Apply heat<br/>
                        ae.heatBuildup += nDamPerHit;<br/>
                    }<br/>
                } else {<br/>
                    hits = 0;<br/>
                }<br/>
            }<br/>
            if ((( wtype.getAmmoType() == AmmoType.T_SRM_STREAK )<br/>
                    || ( wtype.getAmmoType() == AmmoType.T_LRM_STREAK ))<br/>
                    &amp;&amp; !isAngelECMAffected) {<br/>
                //no lock<br/>
                r = new Report(3215);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else {<br/>
                //miss<br/>
                r = new Report(3220);<br/>
                r.subject = subjectId;<br/>
                if (weapon.isRapidfire() &amp;&amp;<br/>
                    !(target instanceof Infantry &amp;&amp;<br/>
                    !(target instanceof BattleArmor)) ){<br/>
                  r.messageId = 3225;<br/>
                  r.add(ammoUsage);<br/>
              }<br/>
              addReport(r);<br/>
          }<br/>
<br/>
          // Report any AMS action.<br/>
          for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
              if (wr.amsShotDown[i] &gt; 0) {<br/>
                  r = new Report(3230);<br/>
                  r.indent();<br/>
                  r.subject = subjectId;<br/>
                  r.add(wr.amsShotDown[i]);<br/>
                  addReport(r);<br/>
              }<br/>
          }<br/>
<br/>
            // Figure out the maximum number of missile hits.<br/>
            // TODO: handle this in a different place.<br/>
            int maxMissiles = 0;<br/>
            if ( usesAmmo ) {<br/>
                maxMissiles = wtype.getRackSize();<br/>
                if ( wtype.hasFlag(WeaponType.F_DOUBLE_HITS) ) {<br/>
                    maxMissiles *= 2;<br/>
                }<br/>
                if ( ae instanceof BattleArmor ) {<br/>
                    platoon = (Infantry) ae;<br/>
                    maxMissiles *= platoon.getShootingStrength();<br/>
                }<br/>
            }<br/>
            if (bSwarm || bSwarmI) {<br/>
                swarmMissilesNowLeft = swarmMissilesLeft &gt; 0 ? swarmMissilesLeft : maxMissiles;<br/>
                maxMissiles = swarmMissilesLeft &gt; 0 ? swarmMissilesLeft : maxMissiles;<br/>
            }<br/>
<br/>
            // If the AMS shot down *all* incoming missiles, if<br/>
            // the shot is an automatic failure, or if it's from<br/>
            // a Streak rack, then Infernos can't ignite the hex<br/>
            // and any building is safe from damage.<br/>
            if ( (usesAmmo &amp;&amp; wr.amsShotDownTotal &gt;= maxMissiles)<br/>
                    || toHit.getValue() == TargetRoll.AUTOMATIC_FAIL<br/>
                    || ((wtype.getAmmoType() == AmmoType.T_SRM_STREAK <br/>
                    || wtype.getAmmoType() == AmmoType.T_LRM_STREAK)<br/>
                    &amp;&amp; !isAngelECMAffected)) {<br/>
                return !bMissed;<br/>
            }<br/>
            // If we're using swarm munition, set the number of missiles that<br/>
            // are left<br/>
            if ((bSwarm || bSwarmI) &amp;&amp; entityTarget != null) {<br/>
                swarmMissilesNowLeft -= wr.amsShotDownTotal;<br/>
                Entity swarmTarget = Compute.getSwarmTarget(game, ae.getId(), entityTarget, wr.waa.getWeaponId());<br/>
                if (swarmTarget != null) {<br/>
                    r = new Report(3420);<br/>
                    r.subject = ae.getId();<br/>
                    r.indent();<br/>
                    r.add(swarmMissilesNowLeft);<br/>
                    addReport(r);<br/>
                    weapon.setUsedThisRound(false);<br/>
                    WeaponAttackAction newWaa = new WeaponAttackAction(ae.getId(),<br/>
                        swarmTarget.getTargetId(), wr.waa.getWeaponId());<br/>
                    newWaa.setSwarmingMissiles(true);<br/>
                    newWaa.setOldTargetId(target.getTargetId());<br/>
                    newWaa.setAmmoId(wr.waa.getAmmoId());<br/>
                    WeaponResult newWr = preTreatWeaponAttack(newWaa);<br/>
                    resolveWeaponAttack(newWr, ae.getId(), false, swarmMissilesNowLeft);<br/>
                } else {<br/>
                    r = new Report(3425);<br/>
                    r.subject = ae.getId();<br/>
                    r.indent();<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            // Shots that miss an entity can set fires.<br/>
            // Infernos always set fires.  Otherwise<br/>
            // Buildings can't be accidentally ignited,<br/>
            // and some weapons can't ignite fires.<br/>
            if ( entityTarget != null &amp;&amp;<br/>
                 ( bInferno ||<br/>
                   ( bldg == null &amp;&amp;<br/>
                     wtype.getFireTN() != TargetRoll.IMPOSSIBLE ) ) ) {<br/>
                tryIgniteHex(target.getPosition(), ae.getId(), bInferno, 11);<br/>
            }<br/>
<br/>
            // BMRr, pg. 51: "All shots that were aimed at a target inside<br/>
            // a building and miss do full damage to the building instead."<br/>
            // BMRr, pg. 77: If the spotting unit successfully designates the target but<br/>
            // the missile misses, it still detonates in the hex and causes 5<br/>
            // points of artillery damage each to all units in the target hex<br/>
            if ( !targetInBuilding) {<br/>
                return !bMissed;<br/>
            }<br/>
        }<br/>
<br/>
        // special case NARC hits.  No damage, but a beacon is appended<br/>
        if (!bMissed &amp;&amp;<br/>
            wtype.getAmmoType() == AmmoType.T_NARC &amp;&amp;<br/>
            atype.getMunitionType() != AmmoType.M_NARC_EX) {<br/>
<br/>
            if (wr.amsShotDownTotal &gt; 0) {<br/>
                r = new Report(3235);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
                    r = new Report(3230);<br/>
                    r.indent(1);<br/>
                    r.subject = subjectId;<br/>
                    r.add(wr.amsShotDown[i]);<br/>
                    addReport(r);<br/>
                }<br/>
                r = new Report(3240);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else if (entityTarget == null) {<br/>
                r = new Report(3245);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else {<br/>
                entityTarget.setNarcedBy(ae.getOwner().getTeam());<br/>
                //narced<br/>
                r = new Report(3250);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            }<br/>
            return !bMissed;<br/>
        }<br/>
        <br/>
        // special case iNARC hits.  No damage, but a beacon is appended<br/>
        if (!bMissed &amp;&amp;<br/>
            wtype.getAmmoType() == AmmoType.T_INARC &amp;&amp;<br/>
            atype.getMunitionType() != AmmoType.M_EXPLOSIVE) {<br/>
<br/>
            if (wr.amsShotDownTotal &gt; 0) {<br/>
                r = new Report(3235);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
                    r = new Report(3230);<br/>
                    r.indent(1);<br/>
                    r.subject = subjectId;<br/>
                    r.add(wr.amsShotDown[i]);<br/>
                    addReport(r);<br/>
                }<br/>
                r = new Report(3240);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else if (entityTarget == null) {<br/>
                r = new Report(3245);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else {<br/>
                INarcPod pod = null;<br/>
                if (atype.getMunitionType() == AmmoType.M_ECM) {<br/>
                    pod = new INarcPod( ae.getOwner().getTeam(),<br/>
                                        INarcPod.ECM );<br/>
                    r = new Report(3251);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                } else if (atype.getMunitionType() == AmmoType.M_HAYWIRE) {<br/>
                    pod = new INarcPod( ae.getOwner().getTeam(),<br/>
                                        INarcPod.HAYWIRE );<br/>
                    r = new Report(3252);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                } else if (atype.getMunitionType() == AmmoType.M_NEMESIS) {<br/>
                    pod = new INarcPod( ae.getOwner().getTeam(),<br/>
                                        INarcPod.NEMESIS );<br/>
                    r = new Report(3253);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                } else {<br/>
                    pod = new INarcPod( ae.getOwner().getTeam(),<br/>
                                        INarcPod.HOMING );<br/>
                    r = new Report(3254);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                }<br/>
                entityTarget.attachINarcPod(pod);<br/>
            }<br/>
            return !bMissed;<br/>
        }<br/>
<br/>
        // attempt to clear minefield by LRM/MRM fire.<br/>
        if (!bMissed &amp;&amp; target.getTargetType() == Targetable.TYPE_MINEFIELD_CLEAR) {<br/>
            int clearAttempt = Compute.d6(2);<br/>
<br/>
            if (clearAttempt &gt;= Minefield.CLEAR_NUMBER_WEAPON) {<br/>
                //minefield cleared<br/>
                r = new Report(3255);<br/>
                r.indent(1);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                Coords coords = target.getPosition();<br/>
<br/>
                Enumeration minefields = game.getMinefields(coords).elements();<br/>
                while (minefields.hasMoreElements()) {<br/>
                    Minefield mf = (Minefield) minefields.nextElement();<br/>
<br/>
                    removeMinefield(mf);<br/>
                }<br/>
            } else {<br/>
                //fails to clear<br/>
                r = new Report(3260);<br/>
                r.indent(1);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            }<br/>
            return !bMissed;<br/>
        }<br/>
<br/>
        // yeech.  handle damage. . different weapons do this in very different ways<br/>
        int nCluster = 1, nSalvoBonus = 0;<br/>
        boolean bSalvo = false;<br/>
        // ecm check is heavy, so only do it once<br/>
        boolean bCheckedECM = false;<br/>
        boolean bECMAffected = false;<br/>
        boolean bMekStealthActive = false;<br/>
        String sSalvoType = " shot(s) ";<br/>
        boolean bAllShotsHit = false;<br/>
        int nRange = ae.getPosition().distance(target.getPosition());<br/>
        int nMissilesModifier = 0;<br/>
        boolean maxtechmissiles = game.getOptions().booleanOption("maxtech_mslhitpen");<br/>
        if (maxtechmissiles) {<br/>
            if (nRange&lt;=1) {<br/>
                nMissilesModifier = +1;<br/>
            } else if (nRange &lt;= wtype.getShortRange()) {<br/>
                nMissilesModifier = 0;<br/>
            } else if (nRange &lt;= wtype.getMediumRange()) {<br/>
                nMissilesModifier = -1;<br/>
            } else {<br/>
                nMissilesModifier = -2;<br/>
            }<br/>
       }<br/>
        // All shots fired by a Streak SRM weapon, during<br/>
        // a Mech Swarm hit, or at an adjacent building.<br/>
        if (((wtype.getAmmoType() == AmmoType.T_SRM_STREAK<br/>
                || wtype.getAmmoType() == AmmoType.T_LRM_STREAK)<br/>
                &amp;&amp; !isAngelECMAffected)<br/>
                || wtype.getAmmoType() == AmmoType.T_NARC<br/>
                || ae.getSwarmTargetId() == wr.waa.getTargetId()<br/>
                || ((target.getTargetType() == Targetable.TYPE_BLDG_IGNITE<br/>
                || target.getTargetType() == Targetable.TYPE_BUILDING)<br/>
                &amp;&amp; ae.getPosition().distance(target.getPosition()) &lt;= 1)) {<br/>
            bAllShotsHit = true;<br/>
        }<br/>
<br/>
        // Mek swarms attach the attacker to the target.<br/>
        if ( !bMissed &amp;&amp; Infantry.SWARM_MEK.equals( wtype.getInternalName() ) ) {<br/>
            // Is the target already swarmed?<br/>
            if ( Entity.NONE != entityTarget.getSwarmAttackerId() ) {<br/>
                r = new Report(3265);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            }<br/>
            // Did the target get destroyed by weapons fire?<br/>
            else if ( entityTarget.isDoomed() || entityTarget.isDestroyed() ||<br/>
                      entityTarget.getCrew().isDead() ) {<br/>
                r = new Report(3270);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else {<br/>
                //success<br/>
                r = new Report(3275);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                ae.setSwarmTargetId( wr.waa.getTargetId() );<br/>
                entityTarget.setSwarmAttackerId( wr.waa.getEntityId() );<br/>
            }<br/>
            return !bMissed;<br/>
        }<br/>
<br/>
        // Magnetic Mine Launchers roll number of hits on battle armor<br/>
        // hits table but use # mines firing instead of men shooting.<br/>
        else if ( wtype.getInternalName().equals(BattleArmor.MINE_LAUNCHER) ) {<br/>
            hits = nShots;<br/>
            if ( !bAllShotsHit ) {<br/>
                hits = Compute.getBattleArmorHits( hits );<br/>
            }<br/>
            bSalvo = true;<br/>
            sSalvoType = " mine(s) ";<br/>
        }<br/>
<br/>
        // Other battle armor attacks use # of men firing to determine hits.<br/>
        // Each hit can be in a new location. The damage per shot comes from<br/>
        // the "racksize", or from the ammo, for ammo weapons<br/>
        else if ( isBattleArmorAttack ) {<br/>
            bSalvo = true;<br/>
            platoon = (Infantry) ae;<br/>
            nCluster = 1;<br/>
            if (usesAmmo) {<br/>
                nDamPerHit = atype.getDamagePerShot();<br/>
            }<br/>
            nDamPerHit = wtype.getRackSize();<br/>
            hits = platoon.getShootingStrength();<br/>
            // All attacks during Mek Swarms hit; all<br/>
            // others use the Battle Armor hits table.<br/>
            if ( !bAllShotsHit ) {<br/>
                hits = Compute.getBattleArmorHits( hits );<br/>
            }<br/>
<br/>
            // Handle Inferno SRM squads.<br/>
            if (bInferno) {<br/>
                nCluster = hits;<br/>
                nDamPerHit = 0;<br/>
                sSalvoType = " Inferno missle(s) ";<br/>
                bSalvo = false;<br/>
            }<br/>
            if (ae.getSwarmTargetId() == wr.waa.getTargetId())<br/>
                nDamPerHit += ((BattleArmor)ae).getVibroClawDamage();<br/>
        }<br/>
<br/>
        // Infantry damage depends on # men left in platoon.<br/>
        else if (isWeaponInfantry) {<br/>
            bSalvo = true;<br/>
            platoon = (Infantry)ae;<br/>
            nCluster = 5;<br/>
            nDamPerHit = 1;<br/>
            hits = platoon.getDamage(platoon.getShootingStrength());<br/>
            //TODO: Hmm, this should be localizable<br/>
            sSalvoType = " damage are inflicted by the shots that ";<br/>
<br/>
            // Handle Inferno SRM infantry.<br/>
            if (bInferno) {<br/>
                nCluster = hits;<br/>
                nDamPerHit = 0;<br/>
                sSalvoType = " Inferno missile(s) ";<br/>
                bSalvo = false;<br/>
            }<br/>
        } else if (wtype.getDamage() == WeaponType.DAMAGE_MISSILE ||<br/>
                   wtype.hasFlag(WeaponType.F_MISSILE_HITS) ) {<br/>
            bSalvo = true;<br/>
<br/>
            // Weapons with ammo type T_BA_MG or T_BA_SMALL_LASER<br/>
            // don't have an atype object.<br/>
            if ( wtype.getAmmoType() == AmmoType.T_BA_MG ||<br/>
                 wtype.getAmmoType() == AmmoType.T_BA_SMALL_LASER ) {<br/>
                nDamPerHit = Math.abs( wtype.getAmmoType() );<br/>
            } else {<br/>
                sSalvoType = " missile(s) ";<br/>
                // Get the damage from the linked ammo.<br/>
                nDamPerHit = atype.getDamagePerShot();<br/>
                if ((wtype.getAmmoType() == AmmoType.T_TBOLT5<br/>
                        || wtype.getAmmoType() == AmmoType.T_TBOLT10<br/>
                        || wtype.getAmmoType() == AmmoType.T_TBOLT15<br/>
                        || wtype.getAmmoType() == AmmoType.T_TBOLT20<br/>
                        ) &amp;&amp; nRange &lt;= wtype.getMinimumRange()) {<br/>
                    nDamPerHit /= 2;<br/>
                } <br/>
            }<br/>
<br/>
            if ( wtype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_LRM_STREAK ||<br/>
                 wtype.getAmmoType() == AmmoType.T_MRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_ATM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_EXLRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_ROCKET_LAUNCHER ) {<br/>
                nCluster = 5;<br/>
            }<br/>
<br/>
            // calculate # of missiles hitting<br/>
            if ( wtype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_SRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_ATM ) {<br/>
<br/>
                // check for artemis, else check for narc and similar things<br/>
                mLinker = weapon.getLinkedBy();<br/>
                if ( wtype.getAmmoType() == AmmoType.T_ATM ||<br/>
                     ( mLinker != null &amp;&amp;<br/>
                       mLinker.getType() instanceof MiscType &amp;&amp;<br/>
                       !mLinker.isDestroyed() &amp;&amp; !mLinker.isMissing() &amp;&amp; !mLinker.isBreached() &amp;&amp;<br/>
                       mLinker.getType().hasFlag(MiscType.F_ARTEMIS) ) &amp;&amp;<br/>
                       atype.getMunitionType() == AmmoType.M_ARTEMIS_CAPABLE) {<br/>
<br/>
                    // check ECM interference<br/>
                    if (!bCheckedECM) {<br/>
                        // Attacking Meks using stealth suffer ECM effects.<br/>
                        if ( ae instanceof Mech ) {<br/>
                            bMekStealthActive = ae.isStealthActive();<br/>
                        }<br/>
                        //if the attacker is effected by ECM or the target is protected by ECM then<br/>
                        //act as if effected.<br/>
                        if (Compute.isAffectedByECM(ae, ae.getPosition(), target.getPosition()) || <br/>
                                Compute.isAffectedByAngelECM(ae, ae.getPosition(), target.getPosition()))<br/>
                            bECMAffected = true;<br/>
                        else if ( Compute.isProtectedByECM((Entity)target,target.getPosition(),ae.getPosition()) ||<br/>
                                Compute.isProtectedByAngelECM((Entity)target,target.getPosition(),ae.getPosition()))<br/>
                            bECMAffected = true;<br/>
                        else<br/>
                            bECMAffected = false;<br/>
                        bCheckedECM = true;<br/>
                    }<br/>
                    // also no artemis for IDF, and only use standard ammo (excepot for ATMs)<br/>
                    if (!bECMAffected &amp;&amp; !bMekStealthActive<br/>
                        &amp;&amp; (!weapon.getType().hasModes()<br/>
                            || !weapon.curMode().equals("Indirect"))<br/>
                        &amp;&amp; ( (atype.getAmmoType() == AmmoType.T_ATM &amp;&amp;<br/>
                              (atype.getMunitionType() == AmmoType.M_STANDARD||<br/>
                               atype.getMunitionType() == AmmoType.M_EXTENDED_RANGE ||<br/>
                               atype.getMunitionType() == AmmoType.M_HIGH_EXPLOSIVE)) ||<br/>
                             ( (atype.getAmmoType() == AmmoType.T_LRM ||<br/>
                                atype.getAmmoType() == AmmoType.T_SRM) &amp;&amp;<br/>
                               atype.getMunitionType() == AmmoType.M_ARTEMIS_CAPABLE))) {<br/>
                        nSalvoBonus += 2;<br/>
                    }<br/>
                } else if (entityTarget != null &amp;&amp; <br/>
                        (entityTarget.isNarcedBy(ae.getOwner().getTeam()) || <br/>
                         entityTarget.isINarcedBy(ae.getOwner().getTeam()))) {<br/>
                    // check ECM interference<br/>
                    if (!bCheckedECM) {<br/>
                        // Attacking Meks using stealth suffer ECM effects.<br/>
                        if ( ae instanceof Mech ) {<br/>
                            bMekStealthActive = ae.isStealthActive();<br/>
                        }<br/>
                        <br/>
                        //if the attacker is effected by ECM or the target is protected by ECM then<br/>
                        //act as if effected.<br/>
                        if (Compute.isAffectedByECM(ae, ae.getPosition(), target.getPosition()) || <br/>
                                Compute.isAffectedByAngelECM(ae, ae.getPosition(), target.getPosition()))<br/>
                            bECMAffected = true;<br/>
                        else if ( Compute.isProtectedByECM((Entity)target,target.getPosition(),ae.getPosition()) ||<br/>
                                Compute.isProtectedByAngelECM((Entity)target,target.getPosition(),ae.getPosition()))<br/>
                            bECMAffected = true;<br/>
                        else<br/>
                            bECMAffected = false;<br/>
                        bCheckedECM = true;<br/>
                    }<br/>
                    // only apply Narc bonus if we're not suffering ECM effect<br/>
                    // and we are using narc ammo.<br/>
                    if (!bECMAffected<br/>
                            &amp;&amp; !bMekStealthActive<br/>
                            &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM) || (atype.getAmmoType() == AmmoType.T_SRM))<br/>
                            &amp;&amp; atype.getMunitionType() == AmmoType.M_NARC_CAPABLE) {<br/>
                        nSalvoBonus += 2;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // If dealing with Inferno rounds set damage to zero and reset<br/>
            // all salvo bonuses (cannot mix with other special munitions).<br/>
            if (bInferno) {<br/>
                    nDamPerHit = 0;<br/>
                    nSalvoBonus = 0;<br/>
                    sSalvoType = " inferno missile(s) ";<br/>
                    bSalvo = false;<br/>
            }<br/>
            if (bSwarm) {<br/>
                sSalvoType = " swarm missile(s) ";<br/>
            }<br/>
            if (bSwarmI) {<br/>
                sSalvoType = " swarm-I missile(s) ";<br/>
            }<br/>
            if (bAntiTSM) {<br/>
                sSalvoType = " anti-TSM missile(s) ";<br/>
            }<br/>
<br/>
            // If dealing with fragmentation missiles,<br/>
            // it does double damage to infantry...<br/>
            if (bFragmentation) {<br/>
                sSalvoType = " fragmentation missile(s) ";<br/>
            }<br/>
<br/>
            // Acid-heads, like infernos, can't mix with any other munitions type.<br/>
            if (bAcidHead) {<br/>
                nDamPerHit = 1;<br/>
                nSalvoBonus = -2;<br/>
                sSalvoType = " acid-head missile(s) ";<br/>
            }<br/>
<br/>
            // Large MRM missile racks roll twice.<br/>
            // MRM missiles never recieve hit bonuses.<br/>
            if ( wtype.getRackSize() == 30 || wtype.getRackSize() == 40 ) {<br/>
                hits = Compute.missilesHit(wtype.getRackSize() / 2, nMissilesModifier+glancingMissileMod, maxtechmissiles | bGlancing) +<br/>
                    Compute.missilesHit(wtype.getRackSize() / 2, nMissilesModifier+glancingMissileMod, maxtechmissiles | bGlancing);<br/>
            }<br/>
<br/>
            // Battle Armor units multiply their racksize by the number<br/>
            // of men shooting and they can't get missile hit bonuses.<br/>
            else if ( ae instanceof BattleArmor ) {<br/>
                platoon = (Infantry) ae;<br/>
                int temp = wtype.getRackSize() * platoon.getShootingStrength();<br/>
<br/>
                // Do all shots hit?<br/>
                if ( bAllShotsHit ) {<br/>
                    hits = temp;<br/>
                } else {<br/>
                    // Account for more than 20 missles hitting.<br/>
                    hits = 0;<br/>
                    while ( temp &gt; 20 ) {<br/>
                        hits += Compute.missilesHit( 20, nMissilesModifier+glancingMissileMod, maxtechmissiles | bGlancing );<br/>
                        temp -= 20;<br/>
                    }<br/>
                    hits += Compute.missilesHit( temp, nMissilesModifier+glancingMissileMod, maxtechmissiles | bGlancing );<br/>
                } // End not-all-shots-hit<br/>
            }<br/>
<br/>
            // If all shots hit, use the full racksize.<br/>
            else if ( bAllShotsHit ) {<br/>
                hits = wtype.getRackSize();<br/>
            }<br/>
            // In all other circumstances, roll for hits.<br/>
            else {<br/>
                hits = Compute.missilesHit(wtype.getRackSize(), nSalvoBonus + nMissilesModifier + glancingMissileMod, maxtechmissiles | bGlancing);<br/>
                // swarm missiles that didn't hit continue <br/>
                if ( (bSwarm || bSwarmI) &amp;&amp; swarmMissilesLeft == 0) {<br/>
                    swarmMissilesNowLeft = wtype.getRackSize() - hits;<br/>
                }<br/>
            }<br/>
            // anti TSM missiles hit with half the number, round up<br/>
            if (bAntiTSM) {<br/>
                hits = (int)Math.ceil((double)hits/2);<br/>
            }<br/>
            // swarm or swarm-I shots may just hit with the remaining missiles<br/>
            if ((bSwarm || bSwarmI) &amp;&amp; (swarmMissilesLeft &gt; 0)) {<br/>
                int swarmsForHitTable = 5;<br/>
                if (swarmMissilesLeft &gt; 5 &amp;&amp; swarmMissilesLeft &lt;= 10)<br/>
                    swarmsForHitTable = 10;<br/>
                else if (swarmMissilesLeft &gt; 10 &amp;&amp; swarmMissilesLeft &lt;= 15)<br/>
                    swarmsForHitTable = 15;<br/>
                else if (swarmMissilesLeft &gt; 15 &amp;&amp; swarmMissilesLeft &lt;= 20)<br/>
                    swarmsForHitTable = 20;<br/>
                hits = Compute.missilesHit(swarmsForHitTable, nSalvoBonus + nMissilesModifier + glancingMissileMod, maxtechmissiles | bGlancing);<br/>
                if (hits &gt; swarmMissilesLeft) {<br/>
                    hits = swarmMissilesLeft;<br/>
                }<br/>
                swarmMissilesNowLeft = swarmMissilesLeft - hits;<br/>
            }<br/>
<br/>
            // Advanced SRMs may get additional missiles<br/>
            if ( usesAmmo &amp;&amp;<br/>
                 atype.getAmmoType() == AmmoType.T_SRM_ADVANCED) {<br/>
                int tmp = wtype.getRackSize() * platoon.getShootingStrength();<br/>
                if (hits%2 == 1 &amp;&amp; hits &lt; tmp) {<br/>
                    hits++;<br/>
                }<br/>
            }<br/>
<br/>
        } else if (usesAmmo<br/>
                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC_LBX) <br/>
                || (atype.getAmmoType() == AmmoType.T_AC_LBX_THB))<br/>
                &amp;&amp; atype.getMunitionType() == AmmoType.M_CLUSTER) {<br/>
            // Cluster shots break into single point clusters.<br/>
            bSalvo = true;<br/>
            hits = wtype.getRackSize();<br/>
            // war of 3039 prototype LBXs get -1 mod on missile chart<br/>
            int nMod = wtype.hasFlag(WeaponType.F_PROTOTYPE) ? 0 : -1;<br/>
            if ( !bAllShotsHit ) {<br/>
                if (!bGlancing) {<br/>
                    hits = Compute.missilesHit( hits, nMod );<br/>
                } else {<br/>
                    // if glancing blow, half the number of missiles that hit,<br/>
                    // that halves damage. do this, and not adjust number of <br/>
                    // pellets, because maxtech only talks about missile weapons<br/>
                    hits = Compute.missilesHit(hits, nMod)/2;<br/>
                }<br/>
            }<br/>
            nDamPerHit = 1;<br/>
        } else if (nShots &gt; 1) {<br/>
            // this should handle multiple attacks from ultra and rotary ACs<br/>
            bSalvo = true;<br/>
            hits = nShots;<br/>
            if ( !bAllShotsHit ) {<br/>
                hits = Compute.missilesHit( hits );<br/>
            }<br/>
        }<br/>
        else if (wtype.getAmmoType() == AmmoType.T_GAUSS_HEAVY) {<br/>
            // HGR does range-dependent damage<br/>
            if (nRange &lt;= wtype.getShortRange()) {<br/>
                nDamPerHit = 25;<br/>
            } else if (nRange &lt;= wtype.getMediumRange()) {<br/>
                nDamPerHit = 20;<br/>
            } else {<br/>
                nDamPerHit = 10;<br/>
            }<br/>
        } else if (wtype.hasFlag(WeaponType.F_ENERGY)) {<br/>
            // Check for Altered Damage from Energy Weapons (MTR, pg.22)<br/>
            nDamPerHit = wtype.getDamage();<br/>
            if (game.getOptions().booleanOption("maxtech_altdmg")) {<br/>
                if (nRange&lt;=1) {<br/>
                    nDamPerHit++;<br/>
                } else if (nRange &lt;= wtype.getMediumRange()) {<br/>
                    // Do Nothing for Short and Medium Range<br/>
                } else if (nRange &lt;= wtype.getLongRange()) {<br/>
                    nDamPerHit--;<br/>
                } else if (nRange &lt;= wtype.getExtremeRange()) {<br/>
                    nDamPerHit = (int)Math.floor(nDamPerHit/2.0);<br/>
                }<br/>
            }<br/>
        } else if (weapon.isRapidfire() &amp;&amp;<br/>
                   !(target instanceof Infantry &amp;&amp;<br/>
                     !(target instanceof BattleArmor)) ){<br/>
            // Check for rapid fire Option. Only MGs can be rapidfire.<br/>
            nDamPerHit = Compute.d6();<br/>
            ammoUsage = 3*nDamPerHit;<br/>
            if (ae.getTotalAmmoOfType(ammo.getType())&gt;0) {<br/>
                for (int i=0; i&lt;ammoUsage; i++) {<br/>
                    if (ammo.getShotsLeft() &lt;= 0) {<br/>
                        ae.loadWeapon(weapon);<br/>
                        ammo = weapon.getLinked();<br/>
                    } <br/>
                    ammo.setShotsLeft(ammo.getShotsLeft()-1);<br/>
                }<br/>
                if (ae instanceof Mech) {<br/>
                    // Apply heat<br/>
                    ae.heatBuildup += nDamPerHit;<br/>
                }<br/>
            } else {<br/>
                hits = 0;<br/>
            }<br/>
        } <br/>
        // laser prototype weapons get 1d6 of extra heat<br/>
        if (wtype.hasFlag(WeaponType.F_LASER) &amp;&amp;<br/>
            wtype.hasFlag(WeaponType.F_PROTOTYPE)) {<br/>
            ae.heatBuildup += Compute.d6();<br/>
        }<br/>
<br/>
        // tracer rounds do -1 damage.<br/>
        if(bTracer) {<br/>
            nDamPerHit--;<br/>
        }<br/>
<br/>
        // only halve damage for non-missiles and non-cluster,<br/>
        // because cluster lbx gets handled above.<br/>
        if (bGlancing &amp;&amp; !wtype.hasFlag(WeaponType.F_MISSILE) &amp;&amp; !wtype.hasFlag(WeaponType.F_MISSILE_HITS)<br/>
                &amp;&amp; !(usesAmmo<br/>
                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC_LBX) <br/>
                || (atype.getAmmoType() == AmmoType.T_AC_LBX_THB))<br/>
                &amp;&amp; atype.getMunitionType() == AmmoType.M_CLUSTER)) {<br/>
            nDamPerHit = (int)Math.floor(nDamPerHit/2.0);<br/>
        }<br/>
<br/>
        // Some weapons double the number of hits scored.<br/>
        if ( wtype.hasFlag(WeaponType.F_DOUBLE_HITS) ) {<br/>
            hits *= 2;<br/>
        }<br/>
<br/>
        //Arrow IV homing hits single location, like an AC20<br/>
        if(usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_HOMING) {<br/>
            nDamPerHit = wtype.getRackSize();<br/>
            if (entityTarget!=null &amp;&amp; entityTarget.getTaggedBy() != -1) {<br/>
                if(wr.artyAttackerCoords != null) {<br/>
                    toHit.setSideTable(entityTarget.sideTable(wr.artyAttackerCoords));<br/>
                } else {<br/>
                    Entity tagger = game.getEntity(entityTarget.getTaggedBy());<br/>
                    if(tagger != null) { <br/>
                        toHit.setSideTable(Compute.targetSideTable(tagger, entityTarget));<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        // We've calculated how many hits.  At this point, any missed<br/>
        // shots damage the building instead of the target.<br/>
        if ( bMissed ) {<br/>
            if ( targetInBuilding &amp;&amp; bldg != null &amp;&amp; !(bSwarm || bSwarmI)) {<br/>
<br/>
                // Reduce the number of hits by AMS hits.<br/>
                if (wr.amsShotDownTotal &gt; 0) {<br/>
                    for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
                        int shotDown = Math.min(wr.amsShotDown[i], hits);<br/>
                        r = new Report(3280);<br/>
                        r.indent(1);<br/>
                        r.subject = subjectId;<br/>
                        r.add(shotDown);<br/>
                        addReport(r);<br/>
                    }<br/>
                    hits -= wr.amsShotDownTotal;<br/>
                }<br/>
<br/>
                // Is the building hit by Inferno rounds?<br/>
                if ( bInferno &amp;&amp; hits &gt; 0 ) {<br/>
<br/>
                    // start a fire in the targets hex<br/>
                    Coords c = target.getPosition();<br/>
                    IHex h = game.getBoard().getHex(c);<br/>
<br/>
                    // Is there a fire in the hex already?<br/>
                    if ( h.containsTerrain( Terrains.FIRE ) ) {<br/>
                        r = new Report(3285);<br/>
                        r.indent(2);<br/>
                        r.subject = subjectId;<br/>
                        r.add(hits);<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        r = new Report(3290);<br/>
                        r.indent(2);<br/>
                        r.subject = subjectId;<br/>
                        r.add(hits);<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                        h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                    }<br/>
                    game.getBoard().addInfernoTo<br/>
                        ( c, InfernoTracker.STANDARD_ROUND, hits );<br/>
                    sendChangedHex(c);<br/>
<br/>
                }<br/>
<br/>
                // Damage the building in one big lump.<br/>
                else {<br/>
<br/>
                    // Only report if damage was done to the building.<br/>
                    int toBldg = hits * nDamPerHit;<br/>
                    if ( toBldg &gt; 0 ) {<br/>
                        Report buildingReport = damageBuilding( bldg, toBldg );<br/>
                        buildingReport.indent(2);<br/>
                        buildingReport.newlines = 1;<br/>
                        buildingReport.subject = subjectId;<br/>
                        addReport(buildingReport);<br/>
                    }<br/>
<br/>
                } // End rounds-hit<br/>
<br/>
            } // End missed-target-in-building<br/>
            return !bMissed;<br/>
<br/>
        } // End missed-target<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        int bldgAbsorbs = 0;<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
        }<br/>
<br/>
        // All attacks (except from infantry weapons)<br/>
        // during Mek Swarms hit the same location.<br/>
        if ( !isWeaponInfantry &amp;&amp;<br/>
             ae.getSwarmTargetId() == wr.waa.getTargetId() ) {<br/>
            nCluster = hits;<br/>
        }<br/>
<br/>
        // Battle Armor MGs do one die of damage per hit to PBI.<br/>
        if ( wtype.getAmmoType() == AmmoType.T_BA_MG &amp;&amp;<br/>
             (target instanceof Infantry) &amp;&amp;<br/>
             !(target instanceof BattleArmor) ) {<br/>
<br/>
            // ASSUMPTION: Building walls protect infantry from BA MGs.<br/>
            if ( bldgAbsorbs &gt; 0 ) {<br/>
                int toBldg = nDamPerHit * hits;<br/>
                r = new Report(3295);<br/>
                r.newlines = 0;<br/>
                r.subject = subjectId;<br/>
                r.add(hits);<br/>
                r.add(sSalvoType);<br/>
                addReport(r);<br/>
<br/>
                Report buildingReport =<br/>
                    damageBuilding( bldg,<br/>
                                    Math.min( toBldg, bldgAbsorbs ),<br/>
                                    " absorbs the shots, taking "  );<br/>
                buildingReport.newlines = 1;<br/>
                buildingReport.subject = subjectId;<br/>
                addReport(buildingReport);<br/>
                return !bMissed;<br/>
            }<br/>
            nDamPerHit = Compute.d6(hits);<br/>
            r = new Report(3300);<br/>
            r.newlines = 0;<br/>
            r.subject = subjectId;<br/>
            r.add(nDamPerHit);<br/>
            r.add(sSalvoType);<br/>
            addReport(r);<br/>
            hits = 1;<br/>
        }<br/>
<br/>
        // Mech and Vehicle MGs do *DICE* of damage to PBI.<br/>
        else if (usesAmmo &amp;&amp; atype.hasFlag(AmmoType.F_MG) &amp;&amp;<br/>
                  !isWeaponInfantry &amp;&amp; (target instanceof Infantry) &amp;&amp;<br/>
                  !(target instanceof BattleArmor) &amp;&amp; !weapon.isRapidfire()) {<br/>
<br/>
            int dice = wtype.getDamage();<br/>
<br/>
            // A building may absorb the entire shot.<br/>
            if ( nDamPerHit &lt;= bldgAbsorbs ) {<br/>
                int toBldg = nDamPerHit * hits;<br/>
                int curCF = bldg.getCurrentCF();<br/>
                curCF = Math.min( curCF, toBldg );<br/>
                bldg.setCurrentCF( curCF );<br/>
                if ( bSalvo ) {<br/>
                    r = new Report(3305);<br/>
                    r.subject = subjectId;<br/>
                    r.add(hits);<br/>
                    r.add(sSalvoType);<br/>
                    addReport(r);<br/>
                } else{<br/>
                    r = new Report(3310);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                }<br/>
                r = new Report(3315);<br/>
                r.indent(2);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                Report buildingReport =<br/>
                    damageBuilding( bldg,<br/>
                                    Math.min( toBldg, bldgAbsorbs ),<br/>
                                    " absorbs the shots, taking "  );<br/>
                buildingReport.newlines = 1;<br/>
                buildingReport.subject = subjectId;<br/>
                addReport(buildingReport);<br/>
                return !bMissed;<br/>
            }<br/>
<br/>
            // If a building absorbs partial damage, reduce the dice of damage.<br/>
            else if ( bldgAbsorbs &gt; 0 ) {<br/>
                dice -= bldgAbsorbs;<br/>
            }<br/>
<br/>
            nDamPerHit = Compute.d6( dice );<br/>
            r = new Report(3320);<br/>
            r.subject = subjectId;<br/>
            r.add(nDamPerHit);<br/>
            r.add(sSalvoType);<br/>
            addReport(r);<br/>
            bSalvo = true;<br/>
<br/>
            // If a building absorbed partial damage, report it now<br/>
            // instead of later and then clear the variable.<br/>
            if ( bldgAbsorbs &gt; 0 ) {<br/>
                Report buildingReport = damageBuilding( bldg, bldgAbsorbs );<br/>
                buildingReport.indent(2);<br/>
                buildingReport.subject = subjectId;<br/>
                addReport(buildingReport);<br/>
                bldgAbsorbs = 0;<br/>
            }<br/>
<br/>
        }<br/>
<br/>
        // Report the number of hits.  Infernos have their own reporting<br/>
        else if (bSalvo &amp;&amp; !bInferno) {<br/>
            r = new Report(3325);<br/>
            r.subject = subjectId;<br/>
            r.add(hits);<br/>
            r.add(sSalvoType);<br/>
            r.add(toHit.getTableDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (bECMAffected) {<br/>
                //ECM prevents bonus<br/>
                r = new Report(3330);<br/>
                r.subject = subjectId;<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
            else if (bMekStealthActive) {<br/>
                //stealth prevents bonus<br/>
                r = new Report(3335);<br/>
                r.subject = subjectId;<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
            if (nSalvoBonus &gt; 0) {<br/>
                r = new Report(3340);<br/>
                r.subject = subjectId;<br/>
                r.add(nSalvoBonus);<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
            r = new Report(3345);<br/>
            r.subject = subjectId;<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
<br/>
            if (wr.amsShotDownTotal &gt; 0) {<br/>
                for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
                    int shotDown = Math.min(wr.amsShotDown[i], hits);<br/>
                    r = new Report(3350);<br/>
                    r.indent();<br/>
                    r.subject = subjectId;<br/>
                    r.add(wr.amsShotDown[i]);<br/>
                    r.add(shotDown);<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                }<br/>
                hits -= wr.amsShotDownTotal;<br/>
<br/>
                addNewLines();<br/>
                if (hits &lt; 1) {<br/>
                    //all missiles shot down<br/>
                    r = new Report(3355);<br/>
                    r.indent();<br/>
                    r.subject = subjectId;<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                } else {<br/>
                    r = new Report(3360);<br/>
                    r.indent();<br/>
                    r.subject = subjectId;<br/>
                    r.add(hits);<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        // convert the ATM missile damages to LRM type 5 point cluster damage<br/>
        // done here after AMS has been performed<br/>
        if (wtype.getAmmoType() == AmmoType.T_ATM) {<br/>
            hits = nDamPerHit * hits;<br/>
            nDamPerHit = 1;<br/>
        }<br/>
<br/>
        // Make sure the player knows when his attack causes no damage.<br/>
        if ( hits == 0 ) {<br/>
            r = new Report(3365);<br/>
            r.subject = subjectId;<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // for each cluster of hits, do a chunk of damage<br/>
        while (hits &gt; 0) {<br/>
            int nDamage;<br/>
<br/>
            // If the attack was with inferno rounds then<br/>
            // do heat and fire instead of damage.<br/>
            if ( bInferno ) {<br/>
                // AMS can shoot down infernos, too.<br/>
                if (wr.amsShotDownTotal &gt; 0) {<br/>
                    for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
                        int shotDown = Math.min(wr.amsShotDown[i], hits);<br/>
                        r = new Report(3350);<br/>
                        r.indent();<br/>
                        r.subject = subjectId;<br/>
                        r.add(wr.amsShotDown[i]);<br/>
                        r.add(shotDown);<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                    }<br/>
                    hits -= wr.amsShotDownTotal;<br/>
<br/>
                    addNewLines();<br/>
                    if (hits &lt; 1) {<br/>
                        //all missiles shot down<br/>
                        r = new Report(3355);<br/>
                        r.indent();<br/>
                        r.subject = subjectId;<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        r = new Report(3360);<br/>
                        r.indent();<br/>
                        r.subject = subjectId;<br/>
                        r.add(hits);<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                    }<br/>
                    if ( hits &lt;= 0 ) {<br/>
                        continue;<br/>
                    }<br/>
                }<br/>
<br/>
                // targeting a hex for ignition<br/>
                if( target.getTargetType() == Targetable.TYPE_HEX_IGNITE ||<br/>
                    target.getTargetType() == Targetable.TYPE_BLDG_IGNITE ) {<br/>
<br/>
                    //inferno missiles hit<br/>
                    r = new Report(3370);<br/>
                    r.subject = subjectId;<br/>
                    r.add(hits);<br/>
                    addReport(r);<br/>
<br/>
                    // Unless there a fire in the hex already, start one.<br/>
                    Coords c = target.getPosition();<br/>
                    IHex h = game.getBoard().getHex(c);<br/>
                    if ( !h.containsTerrain( Terrains.FIRE ) ) {<br/>
                        r = new Report(3005);<br/>
                        r.subject = subjectId;<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                        h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                    }<br/>
                    game.getBoard().addInfernoTo<br/>
                        ( c, InfernoTracker.STANDARD_ROUND, hits );<br/>
                    sendChangedHex(c);<br/>
<br/>
                    return !bMissed;<br/>
                }<br/>
<br/>
                // Targeting an entity<br/>
                if (entityTarget != null ) {<br/>
                    r = new Report(3375);<br/>
                    r.subject = subjectId;<br/>
                    r.add(hits);<br/>
                    addReport(r);<br/>
<br/>
                    if(game.getOptions().booleanOption("vehicle_fires")<br/>
                            &amp;&amp; entityTarget instanceof Tank) {<br/>
                        checkForVehicleFire((Tank)entityTarget, true);<br/>
                    } else {<br/>
                        entityTarget.infernos.add( InfernoTracker.STANDARD_ROUND,<br/>
                                hits );<br/>
                        r = new Report(3205);<br/>
                        r.indent(2);<br/>
                        r.subject = subjectId;<br/>
                        r.addDesc(entityTarget);<br/>
                        r.add(entityTarget.infernos.getTurnsLeftToBurn());<br/>
                        addReport(r);<br/>
                    }<br/>
<br/>
                    // Start a fire in the targets hex, unless already on fire.<br/>
                    Coords c = target.getPosition();<br/>
                    IHex h = game.getBoard().getHex(c);<br/>
<br/>
                    // Unless there a fire in the hex already, start one.<br/>
                    if ( !h.containsTerrain( Terrains.FIRE ) ) {<br/>
                        r = new Report(3005);<br/>
                        r.subject = subjectId;<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                        h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                    }<br/>
                    game.getBoard().addInfernoTo<br/>
                        ( c, InfernoTracker.STANDARD_ROUND, 1 );<br/>
                    sendChangedHex(c);<br/>
<br/>
                    return !bMissed;<br/>
                }<br/>
<br/>
            } // End is-inferno<br/>
<br/>
            // targeting a hex for igniting<br/>
            if( target.getTargetType() == Targetable.TYPE_HEX_IGNITE ||<br/>
                target.getTargetType() == Targetable.TYPE_BLDG_IGNITE ) {<br/>
                if ( !bSalvo ) {<br/>
                    //hits!<br/>
                    r = new Report(2270);<br/>
                    r.subject = subjectId;<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                }<br/>
                // We handle Inferno rounds above.<br/>
                int tn = wtype.getFireTN();<br/>
                if(bIncendiary) {<br/>
                    tn = 5; // Incendiary AC and LRM<br/>
                }<br/>
                if (tn != TargetRoll.IMPOSSIBLE) {<br/>
                    if ( bldg != null ) {<br/>
                        tn += bldg.getType() - 1;<br/>
                    }<br/>
                    addNewLines();<br/>
                    tryIgniteHex( target.getPosition(), ae.getId(), bInferno, tn, true );<br/>
                }<br/>
                return !bMissed;<br/>
            }<br/>
<br/>
            // targeting a hex for clearing<br/>
            if (target.getTargetType() == Targetable.TYPE_HEX_CLEAR) {<br/>
<br/>
                nDamage = nDamPerHit * hits;<br/>
                if ( !bSalvo ) {<br/>
                    //hits!<br/>
                    r = new Report(2270);<br/>
                    r.subject = subjectId;<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                }<br/>
                if (ae instanceof Infantry) {<br/>
                    //infantry cannot clear hexes<br/>
                    r = new Report(3380);<br/>
                    r.indent();<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                    return !bMissed;<br/>
                }<br/>
<br/>
<br/>
                //report that damge was "applied" to terrain<br/>
                r = new Report(3385);<br/>
                r.indent();<br/>
                r.subject = subjectId;<br/>
                r.add(nDamage);<br/>
                addReport(r);<br/>
<br/>
                // Any clear attempt can result in accidental ignition, even<br/>
                // weapons that can't normally start fires.  that's weird.<br/>
                // Buildings can't be accidentally ignited.<br/>
                if ( bldg == null) {<br/>
                    boolean alreadyIgnited = game.getBoard().getHex(target.getPosition()).containsTerrain(Terrains.FIRE);<br/>
                    boolean ignited = tryIgniteHex(target.getPosition(), subjectId, bInferno, 9);<br/>
                    if (!alreadyIgnited &amp;&amp; ignited) return !bMissed;<br/>
                }<br/>
<br/>
                int tn = 14 - nDamage;<br/>
                tryClearHex(target.getPosition(), tn, ae.getId());<br/>
<br/>
                return !bMissed;<br/>
            }<br/>
<br/>
            // Targeting a building.<br/>
            if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
                // Is the building hit by Inferno rounds?<br/>
                if ( bInferno ) {<br/>
<br/>
                    // start a fire in the targets hex<br/>
                    Coords c = target.getPosition();<br/>
                    IHex h = game.getBoard().getHex(c);<br/>
<br/>
                    // Is there a fire in the hex already?<br/>
                    if ( h.containsTerrain( Terrains.FIRE ) ) {<br/>
                        r = new Report(3285);<br/>
                        r.subject = subjectId;<br/>
                        r.add(hits);<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        r = new Report(3290);<br/>
                        r.subject = subjectId;<br/>
                        r.add(hits);<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                        h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                    }<br/>
                    game.getBoard().addInfernoTo<br/>
                        ( c, InfernoTracker.STANDARD_ROUND, hits );<br/>
                    sendChangedHex(c);<br/>
<br/>
                } else {<br/>
                    // The building takes the full brunt of the attack.<br/>
                    nDamage = nDamPerHit * hits;<br/>
                    if ( !bSalvo ) {<br/>
                        //hits!<br/>
                        r = new Report(3390);<br/>
                        r.subject = subjectId;<br/>
                        addReport(r);<br/>
                    }<br/>
                    addNewLines();<br/>
                    Report buildingReport = damageBuilding( bldg, nDamage );<br/>
                    buildingReport.indent(2);<br/>
                    buildingReport.newlines = 1;<br/>
                    buildingReport.subject = subjectId;<br/>
                    addReport(buildingReport);<br/>
    <br/>
                    // Damage any infantry in the hex.<br/>
                    this.damageInfantryIn( bldg, nDamage );<br/>
                }<br/>
<br/>
                // And we're done!<br/>
                return !bMissed;<br/>
            }<br/>
<br/>
            // Battle Armor squads equipped with fire protection<br/>
            // gear automatically avoid flaming death.<br/>
            if ( wtype.hasFlag(WeaponType.F_FLAMER) &amp;&amp;<br/>
                 target instanceof BattleArmor ) {<br/>
<br/>
                for ( Enumeration iter = entityTarget.getMisc();<br/>
                      iter.hasMoreElements(); ) {<br/>
                    Mounted mount = (Mounted) iter.nextElement();<br/>
                    EquipmentType equip = mount.getType();<br/>
                    if ( BattleArmor.FIRE_PROTECTION.equals<br/>
                         (equip.getInternalName()) ) {<br/>
                        if ( !bSalvo ) {<br/>
                            //hits<br/>
                            r = new Report(3390);<br/>
                            r.subject = subjectId;<br/>
                            addReport(r);<br/>
                        }<br/>
                        r = new Report(3395);<br/>
                        r.indent(2);<br/>
                        r.subject = subjectId;<br/>
                        r.addDesc(entityTarget);<br/>
                        addReport(r);<br/>
<br/>
                        // A building may be damaged, even if the squad is not.<br/>
                        if ( bldgAbsorbs &gt; 0 ) {<br/>
                            int toBldg = nDamPerHit * Math.min( bldgAbsorbs,<br/>
                                                                hits );<br/>
                            Report buildingReport = damageBuilding( bldg, toBldg );<br/>
                            buildingReport.indent(2);<br/>
                            buildingReport.newlines = 1;<br/>
                            buildingReport.subject = subjectId;<br/>
                            addReport(buildingReport);<br/>
                        }<br/>
<br/>
                     return !bMissed;<br/>
                    }<br/>
                }<br/>
            } // End target-may-be-immune<br/>
<br/>
            // Flamers do heat to mechs instead damage if the option is<br/>
            // available and the mode is set.<br/>
            if (entityTarget != null<br/>
                    &amp;&amp; (entityTarget instanceof Mech)<br/>
                    &amp;&amp; wtype.hasFlag(WeaponType.F_FLAMER)<br/>
                    &amp;&amp; game.getOptions().booleanOption("flamer_heat")<br/>
                    &amp;&amp; wtype.hasModes()<br/>
                    &amp;&amp; weapon.curMode().equals("Heat")) {<br/>
                nDamage = nDamPerHit * hits;<br/>
                if ( !bSalvo ) {<br/>
                    //hits<br/>
                    r = new Report(3390);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                }<br/>
                r = new Report(3400);<br/>
                r.subject = subjectId;<br/>
                r.indent(2);<br/>
                r.add(nDamage);<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
                entityTarget.heatBuildup += nDamage;<br/>
                hits = 0;<br/>
            } else if (entityTarget != null) {<br/>
                 HitData hit = entityTarget.rollHitLocation<br/>
                     ( toHit.getHitTable(),<br/>
                       toHit.getSideTable(),<br/>
                       wr.waa.getAimedLocation(),<br/>
                       wr.waa.getAimingMode() );<br/>
<br/>
                if (wtype.hasFlag(WeaponType.F_PLASMA_MFUK)<br/>
                        &amp;&amp; (entityTarget instanceof Mech)) {<br/>
                    nDamage = nDamPerHit * hits;<br/>
                    if (!bSalvo) {<br/>
                        //hits<br/>
                        r = new Report(3390);<br/>
                        r.subject = subjectId;<br/>
                        addReport(r);<br/>
                    }<br/>
                    r = new Report(3400);<br/>
                    r.subject = subjectId;<br/>
                    r.indent(2);<br/>
                    r.add(5);<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                    entityTarget.heatBuildup += 5;<br/>
                }<br/>
<br/>
                // If a leg attacks hit a leg that isn't<br/>
                // there, then hit the other leg.<br/>
                if ( wtype.getInternalName().equals("LegAttack") &amp;&amp;<br/>
                     entityTarget.getInternal(hit) &lt;= 0 ) {<br/>
                    if ( hit.getLocation() == Mech.LOC_RLEG ) {<br/>
                        hit = new HitData( Mech.LOC_LLEG );<br/>
                    }<br/>
                    else {<br/>
                        hit = new HitData( Mech.LOC_RLEG );<br/>
                    }<br/>
                }<br/>
<br/>
                // Mine Launchers automatically hit the<br/>
                // CT of a Mech or the front of a Tank.<br/>
                if ( wtype.getInternalName()<br/>
                     .equals(BattleArmor.MINE_LAUNCHER) ) {<br/>
                    if ( target instanceof Mech ) {<br/>
                        hit = new HitData( Mech.LOC_CT );<br/>
                    }<br/>
                    else { // te instanceof Tank<br/>
                        hit = new HitData( Tank.LOC_FRONT );<br/>
                    }<br/>
                }<br/>
<br/>
                // Each hit in the salvo get's its own hit location.<br/>
                if (!bSalvo) {<br/>
                    r = new Report(3405);<br/>
                    r.subject = subjectId;<br/>
                    r.add(toHit.getTableDesc());<br/>
                    r.add(entityTarget.getLocationAbbr(hit));<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                    if (hit.hitAimedLocation()) {<br/>
                        r = new Report(3410);<br/>
                        r.subject = subjectId;<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                    }<br/>
                }<br/>
<br/>
                // Special weapons do criticals instead of damage.<br/>
                if ( nDamPerHit == WeaponType.DAMAGE_SPECIAL ) {<br/>
                    // Do criticals.<br/>
                    //String specialDamage = criticalEntity( entityTarget, hit.getLocation() );<br/>
                    Vector specialDamageReport = criticalEntity( entityTarget, hit.getLocation() );<br/>
<br/>
                    // Replace "no effect" results with 4 points of damage.<br/>
                    //if ( specialDamage.endsWith(" no effect.") ) {<br/>
                    if (((Report)specialDamageReport.lastElement()).messageId == 6005) {<br/>
                        int damage = 4;<br/>
                        if (ae instanceof BattleArmor)<br/>
                            damage += ((BattleArmor)ae).getVibroClawDamage();<br/>
                        // ASSUMPTION: buildings CAN'T absorb *this* damage.<br/>
                        //specialDamage = damageEntity(entityTarget, hit, damage);<br/>
                        specialDamageReport = damageEntity(entityTarget, hit, damage, false, 0, false, false, throughFront);<br/>
                    }<br/>
                    else {<br/>
                        //add newline _before_ last report<br/>
                        try {<br/>
                            ((Report) specialDamageReport.elementAt(specialDamageReport.size() - 2)).newlines++;<br/>
                        } catch (ArrayIndexOutOfBoundsException aiobe) {<br/>
                            System.err.println("ERROR: no previous report when trying to add newline");<br/>
                        }<br/>
                    }<br/>
<br/>
                    // Report the result<br/>
                    addReport( specialDamageReport);<br/>
                }<br/>
                else if(game.getOptions().booleanOption("maxtech_partial_cover") &amp;&amp;<br/>
                  toHit.getHitTable() == ToHitData.HIT_PARTIAL_COVER &amp;&amp;<br/>
                  entityTarget.removePartialCoverHits(hit.getLocation(), toHit.getCover(), toHit.getSideTable())) {<br/>
                    r = new Report(3460);<br/>
                    r.subject = entityTarget.getId();<br/>
                    r.indent(2);<br/>
                    r.add(entityTarget.getDisplayName());<br/>
                    r.add(entityTarget.getLocationAbbr(hit));<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                }<br/>
                else {<br/>
                    // Resolve damage normally.<br/>
                    nDamage = nDamPerHit * Math.min(nCluster, hits);<br/>
<br/>
                    // A building may be damaged, even if the squad is not.<br/>
                    if ( bldgAbsorbs &gt; 0 ) {<br/>
                        int toBldg = Math.min( bldgAbsorbs, nDamage );<br/>
                        nDamage -= toBldg;<br/>
                        addNewLines();<br/>
                        Report buildingReport = damageBuilding( bldg, toBldg );<br/>
                        buildingReport.indent(2);<br/>
                        buildingReport.subject = subjectId;<br/>
                        addReport(buildingReport);<br/>
                    }<br/>
<br/>
                    // A building may absorb the entire shot.<br/>
                    if ( nDamage == 0 ) {<br/>
                        r = new Report(3415);<br/>
                        r.subject = subjectId;<br/>
                        r.indent(2);<br/>
                        r.addDesc(entityTarget);<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                    } else if (bFragmentation) {<br/>
                        // If it's a frag missile...<br/>
                        if (bGlancing) {<br/>
                            hit.makeGlancingBlow();<br/>
                        }<br/>
                        addReport(<br/>
                          damageEntity(entityTarget, hit, nDamage, false, 1, false, false, throughFront));<br/>
                    } else if (bFlechette) {<br/>
                        // If it's a frag missile...<br/>
                        if (bGlancing) {<br/>
                            hit.makeGlancingBlow();<br/>
                        }<br/>
                        addReport(<br/>
                          damageEntity(entityTarget, hit, nDamage, false, 2, false, false, throughFront));<br/>
                    } else if (bAcidHead) {<br/>
                        // If it's an acid-head warhead...<br/>
                        if (bGlancing) {<br/>
                            hit.makeGlancingBlow();<br/>
                        }<br/>
                        addReport(<br/>
                                              damageEntity(entityTarget, hit, nDamage, false, 3, false, false, throughFront) );<br/>
                    } else if(bIncendiary &amp;&amp; usesAmmo &amp;&amp; atype.getAmmoType() == AmmoType.T_AC) {<br/>
                        //incendiary AC ammo<br/>
                        if (bGlancing) {<br/>
                            hit.makeGlancingBlow();<br/>
                        }<br/>
                        addReport(<br/>
                                              damageEntity(entityTarget, hit, nDamage, false, 4, false, false, throughFront));<br/>
                    } else {<br/>
                        if (usesAmmo<br/>
                                &amp;&amp; (atype.getAmmoType() == AmmoType.T_AC)<br/>
                                &amp;&amp; (atype.getMunitionType() == AmmoType.M_ARMOR_PIERCING)<br/>
                                &amp;&amp; !(entityTarget.getArmorType() == EquipmentType.T_ARMOR_HARDENED))<br/>
                            hit.makeArmorPiercing(atype);<br/>
                        if (bGlancing) {<br/>
                            hit.makeGlancingBlow();<br/>
                        }<br/>
                        if (bAntiTSM) {<br/>
                            entityTarget.hitThisRoundByAntiTSM = true;<br/>
                        }<br/>
                        addReport(<br/>
                            damageEntity(entityTarget, hit, nDamage, false, 0, false, false, throughFront));<br/>
                    }<br/>
                }<br/>
                hits -= nCluster;<br/>
                creditKill(entityTarget, ae);<br/>
            } else {<br/>
                System.err.println("Unable to resolve hit against "+target.getDisplayName());<br/>
                if(entityTarget == null) {<br/>
                    System.err.println("   entityTarget is null");<br/>
                }<br/>
                hits = 0; //prevents server lock-up<br/>
            }<br/>
        } // Handle the next cluster.<br/>
<br/>
        //deal with splash damage from Arrow IV homing<br/>
        if(atype != null &amp;&amp; atype.getMunitionType() == AmmoType.M_HOMING) {<br/>
            artilleryDamageHex(target.getPosition(), wr.artyAttackerCoords, 5, atype, subjectId, ae, entityTarget, false, 0);<br/>
        }<br/>
<br/>
        addNewLines();<br/>
<br/>
        if (swarmMissilesNowLeft &gt; 0 &amp;&amp; entityTarget != null) {<br/>
            Entity swarmTarget = Compute.getSwarmTarget(game, ae.getId(), entityTarget, wr.waa.getWeaponId());<br/>
            if (swarmTarget != null) {<br/>
                //missiles keep swarming<br/>
                r = new Report(3420);<br/>
                r.subject = swarmTarget.getId();<br/>
                r.indent();<br/>
                r.add(swarmMissilesNowLeft);<br/>
                addReport(r);<br/>
                weapon.setUsedThisRound(false);<br/>
                WeaponAttackAction newWaa = new WeaponAttackAction(ae.getId(),<br/>
                    swarmTarget.getTargetId(), wr.waa.getWeaponId());<br/>
                newWaa.setSwarmingMissiles(true);<br/>
                newWaa.setOldTargetId(target.getTargetId());<br/>
                newWaa.setAmmoId(wr.waa.getAmmoId());<br/>
                WeaponResult newWr = preTreatWeaponAttack(newWaa);<br/>
                resolveWeaponAttack(newWr, ae.getId(), false, swarmMissilesNowLeft);<br/>
            } else {<br/>
                //missiles can't find another target<br/>
                r = new Report(3425);<br/>
                r.subject = ae.getId();<br/>
                r.indent();<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        return !bMissed;<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle all physical attacks for the round<br/>
     */<br/>
    private void resolvePhysicalAttacks() {<br/>
        //Physical phase header<br/>
        addReport(new Report(4000, Report.PUBLIC));<br/>
<br/>
        // add any pending charges<br/>
        for (Enumeration i = game.getCharges(); i.hasMoreElements();) {<br/>
            game.addAction((EntityAction)i.nextElement());<br/>
        }<br/>
        game.resetCharges();<br/>
<br/>
        // remove any duplicate attack declarations<br/>
        cleanupPhysicalAttacks();<br/>
<br/>
        // loop thru received attack actions<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
<br/>
            // verify that the attacker is still active<br/>
            AttackAction aa = (AttackAction)o;<br/>
            if (!(game.getEntity(aa.getEntityId()).isActive())<br/>
            &amp;&amp; !(o instanceof DfaAttackAction)) {<br/>
                continue;<br/>
            }<br/>
            AbstractAttackAction aaa = (AbstractAttackAction)o;<br/>
            // do searchlights immediately<br/>
            if (aaa instanceof SearchlightAttackAction) {<br/>
                SearchlightAttackAction saa = (SearchlightAttackAction)aaa;<br/>
                addReport(<br/>
                                      saa.resolveAction(game));<br/>
            } else {<br/>
                physicalResults.addElement(preTreatPhysicalAttack(aaa));<br/>
            }<br/>
        }<br/>
        int cen = Entity.NONE;<br/>
        for (Enumeration i = physicalResults.elements(); i.hasMoreElements();) {<br/>
            PhysicalResult pr = (PhysicalResult)i.nextElement();<br/>
            resolvePhysicalAttack(pr, cen);<br/>
            cen = pr.aaa.getEntityId();<br/>
        }<br/>
        physicalResults.removeAllElements();<br/>
    }<br/>
<br/>
    /**<br/>
     * Cleans up the attack declarations for the physical phase by removing<br/>
     * all attacks past the first for any one mech.  Also clears out attacks<br/>
     * by dead or disabled mechs.<br/>
     */<br/>
    private void cleanupPhysicalAttacks() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            removeDuplicateAttacks(entity.getId());<br/>
        }<br/>
        removeDeadAttacks();<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes any actions in the attack queue beyond the first by the<br/>
     * specified entity.<br/>
     */<br/>
    private void removeDuplicateAttacks(int entityId) {<br/>
        boolean attacked = false;<br/>
        Vector toKeep = new Vector(/*game.actionsSize()*/);<br/>
<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            EntityAction action = (EntityAction)i.nextElement();<br/>
            if (action.getEntityId() != entityId) {<br/>
                toKeep.addElement(action);<br/>
            } else if (!attacked) {<br/>
                toKeep.addElement(action);<br/>
                if(!(action instanceof SearchlightAttackAction)) {<br/>
                    attacked = true;<br/>
                }<br/>
            } else {<br/>
                System.err.println("server: removing duplicate phys attack for id#" + entityId);<br/>
                System.err.println("        action was "+ action.toString());<br/>
            }<br/>
        }<br/>
<br/>
        // reset actions and re-add valid elements<br/>
        game.resetActions();<br/>
        for (Enumeration i = toKeep.elements(); i.hasMoreElements();) {<br/>
            game.addAction((EntityAction)i.nextElement());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes all attacks by any dead entities.  It does this by going through<br/>
     * all the attacks and only keeping ones from active entities.  DFAs are<br/>
     * kept even if the pilot is unconscious, so that he can fail.<br/>
     */<br/>
    private void removeDeadAttacks() {<br/>
        Vector toKeep = new Vector(game.actionsSize());<br/>
<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            EntityAction action = (EntityAction)i.nextElement();<br/>
            Entity entity = game.getEntity(action.getEntityId());<br/>
            if (entity != null &amp;&amp; !entity.isDestroyed()<br/>
            &amp;&amp; (entity.isActive() || action instanceof DfaAttackAction)) {<br/>
                toKeep.addElement(action);<br/>
            }<br/>
        }<br/>
<br/>
        // reset actions and re-add valid elements<br/>
        game.resetActions();<br/>
        for (Enumeration i = toKeep.elements(); i.hasMoreElements();) {<br/>
            game.addAction((EntityAction)i.nextElement());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a punch attack<br/>
     */<br/>
    private void resolvePunchAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final PunchAttackAction paa = (PunchAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        final Targetable target = game.getTarget(paa.getTargetType(), paa.getTargetId());<br/>
        Entity te = null;<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = (Entity)target;<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, paa.getEntityId(), te);<br/>
        }<br/>
        final String armName = paa.getArm() == PunchAttackAction.LEFT<br/>
        ? "Left Arm" : "Right Arm";<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = paa.getArm() == PunchAttackAction.LEFT<br/>
        ? pr.damage : pr.damageRight;<br/>
        final ToHitData toHit = paa.getArm() == PunchAttackAction.LEFT<br/>
        ? pr.toHit : pr.toHitRight;<br/>
        int roll = paa.getArm() == PunchAttackAction.LEFT<br/>
        ? pr.roll : pr.rollRight;<br/>
        final boolean targetInBuilding = Compute.isInBuilding( game, te );<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
        Report r;<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( target.getPosition() );<br/>
<br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            //report who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4010);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(armName);<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4015);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            return;<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            r = new Report(4020);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            roll = Integer.MAX_VALUE;<br/>
        } else {<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            //nope<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
<br/>
            // If the target is in a building, the building absorbs the damage.<br/>
            if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
<br/>
                // Only report if damage was done to the building.<br/>
                if ( damage &gt; 0 ) {<br/>
                    Report buildingReport = damageBuilding( bldg, damage );<br/>
                    buildingReport.indent();<br/>
                    buildingReport.subject = ae.getId();<br/>
                    addReport(buildingReport);<br/>
                }<br/>
<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // Targeting a building.<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            r = new Report(4040);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
            // And we're done!<br/>
            return;<br/>
        }<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        r = new Report(4045);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getTableDesc());<br/>
        r.add(te.getLocationAbbr(hit));<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            int bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
            int toBldg = Math.min( bldgAbsorbs, damage );<br/>
            damage -= toBldg;<br/>
            addNewLines();<br/>
            Report buildingReport = damageBuilding( bldg, toBldg );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
        }<br/>
<br/>
        // A building may absorb the entire shot.<br/>
        if ( damage == 0 ) {<br/>
            r = new Report(4050);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getShortName());<br/>
            r.add(te.getOwner().getName());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        } else {<br/>
            if (glancing) {<br/>
                damage = (int)Math.floor(damage/2.0);<br/>
            }<br/>
            addReport(damageEntity(te, hit, damage, false, 0, false, false, throughFront));<br/>
        }<br/>
<br/>
        addNewLines();<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a kick attack<br/>
     */<br/>
    private void resolveKickAttack(PhysicalResult pr, int lastEntityId) {<br/>
        KickAttackAction kaa = (KickAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(kaa.getEntityId());<br/>
        final Targetable target = game.getTarget(kaa.getTargetType(), kaa.getTargetId());<br/>
        Entity te = null;<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = (Entity)target;<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, kaa.getEntityId(), te);<br/>
        }<br/>
        String legName = ( (kaa.getLeg() == KickAttackAction.LEFT) ||<br/>
                                 (kaa.getLeg() == KickAttackAction.LEFTMULE) )<br/>
        ? "Left "<br/>
        : "Right ";<br/>
        if (game.getOptions().booleanOption("maxtech_mulekicks")) {<br/>
            if ( (kaa.getLeg() == KickAttackAction.LEFTMULE) || <br/>
                 (kaa.getLeg() == KickAttackAction.RIGHTMULE) ) {<br/>
                legName.concat(" rear ");<br/>
            } else {<br/>
                legName.concat(" front ");<br/>
            }<br/>
        }<br/>
        legName.concat("leg");<br/>
        Report r;<br/>
<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        final boolean targetInBuilding = Compute.isInBuilding( game, te );<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( target.getPosition() );<br/>
<br/>
        if (lastEntityId != ae.getId()) {<br/>
            //who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4055);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(legName);<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4060);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a kick"));<br/>
            return;<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            r = new Report(4065);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            roll = Integer.MAX_VALUE;<br/>
        } else {<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a kick"));<br/>
<br/>
            // If the target is in a building, the building absorbs the damage.<br/>
            if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
<br/>
                // Only report if damage was done to the building.<br/>
                if ( damage &gt; 0 ) {<br/>
                    Report buildingReport = damageBuilding( bldg, damage );<br/>
                    buildingReport.indent();<br/>
                    buildingReport.subject = ae.getId();<br/>
                    addReport(buildingReport);<br/>
                }<br/>
<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // Targeting a building.<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            r = new Report(4040);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
            // And we're done!<br/>
            return;<br/>
        }<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        r = new Report(4045);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getTableDesc());<br/>
        r.add(te.getLocationAbbr(hit));<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            int bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
            int toBldg = Math.min( bldgAbsorbs, damage );<br/>
            damage -= toBldg;<br/>
            addNewLines();<br/>
            Report buildingReport = damageBuilding( bldg, toBldg );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
        }<br/>
<br/>
        // A building may absorb the entire shot.<br/>
        if ( damage == 0 ) {<br/>
            r = new Report(4050);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getShortName());<br/>
            r.add(te.getOwner().getName());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        } else {<br/>
            if (glancing) {<br/>
                damage = (int)Math.floor(damage/2.0);<br/>
            }<br/>
            addReport(damageEntity(te, hit, damage, false, 0, false, false, throughFront));<br/>
        }<br/>
<br/>
        if (te.getMovementMode() == IEntityMovementMode.BIPED || te.getMovementMode() == IEntityMovementMode.QUAD) {<br/>
            PilotingRollData kickPRD = new PilotingRollData(te.getId(), getKickPushPSRMod(ae, te, 0), "was kicked");<br/>
            kickPRD.setCumulative(false); // see Bug# 811987 for more info<br/>
            game.addPSR(kickPRD);<br/>
        }<br/>
<br/>
        addNewLines();<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a Protomech physicalattack<br/>
     */<br/>
<br/>
    private void resolveProtoAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final ProtomechPhysicalAttackAction ppaa = (ProtomechPhysicalAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(ppaa.getEntityId());<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        final Targetable target = game.getTarget(ppaa.getTargetType(), ppaa.getTargetId());<br/>
        Entity te = null;<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = (Entity)target;<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, ppaa.getEntityId(), te);<br/>
        }<br/>
        final boolean targetInBuilding = Compute.isInBuilding( game, te );<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
        Report r;<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( target.getPosition() );<br/>
<br/>
        if (lastEntityId != ae.getId()) {<br/>
            //who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4070);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4075);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            return;<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            r = new Report(4080);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            roll = Integer.MAX_VALUE;<br/>
        } else {<br/>
            // report the roll<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
<br/>
            // If the target is in a building, the building absorbs the damage.<br/>
            if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
<br/>
                // Only report if damage was done to the building.<br/>
                if ( damage &gt; 0 ) {<br/>
                    Report buildingReport = damageBuilding( bldg, damage );<br/>
                    buildingReport.indent();<br/>
                    buildingReport.subject = ae.getId();<br/>
                    addReport(buildingReport);<br/>
                }<br/>
<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // Targeting a building.<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            r = new Report(4040);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
            // And we're done!<br/>
            return;<br/>
        }<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        r = new Report(4045);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getTableDesc());<br/>
        r.add(te.getLocationAbbr(hit));<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            int bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
            int toBldg = Math.min( bldgAbsorbs, damage );<br/>
            damage -= toBldg;<br/>
            addNewLines();<br/>
            Report buildingReport = damageBuilding( bldg, toBldg );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
        }<br/>
<br/>
        // A building may absorb the entire shot.<br/>
        if ( damage == 0 ) {<br/>
            r = new Report(4050);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getShortName());<br/>
            r.add(te.getOwner().getName());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        } else {<br/>
            if (glancing) {<br/>
                damage = (int)Math.floor(damage/2.0);<br/>
            }<br/>
            addReport(damageEntity(te, hit, damage));<br/>
        }<br/>
<br/>
        addNewLines();<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Handle a brush off attack<br/>
     */<br/>
    private void resolveBrushOffAttack( PhysicalResult pr,<br/>
                                        int lastEntityId ) {<br/>
        final BrushOffAttackAction baa = (BrushOffAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(baa.getEntityId());<br/>
        // PLEASE NOTE: buildings are *never* the target<br/>
        // of a "brush off", but iNarc pods **are**.<br/>
        Targetable target = game.getTarget( baa.getTargetType(),<br/>
                                            baa.getTargetId() );<br/>
        Entity te = null;<br/>
        final String armName = baa.getArm() == BrushOffAttackAction.LEFT<br/>
            ? "Left Arm" : "Right Arm";<br/>
        Report r;<br/>
<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = game.getEntity(baa.getTargetId());<br/>
        }<br/>
<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        // ASSUMPTION: buildings can't absorb *this* damage.<br/>
        int damage = baa.getArm() == BrushOffAttackAction.LEFT<br/>
        ? pr.damage : pr.damageRight;<br/>
        final ToHitData toHit = baa.getArm() == BrushOffAttackAction.LEFT<br/>
        ? pr.toHit : pr.toHitRight;<br/>
        int roll = baa.getArm() == BrushOffAttackAction.LEFT<br/>
        ? pr.roll : pr.rollRight;<br/>
<br/>
        if (lastEntityId != baa.getEntityId()) {<br/>
            //who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4085);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4090);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        // report the roll<br/>
        r = new Report(4025);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getValue());<br/>
        r.add(roll);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            //miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
<br/>
            // Missed Brush Off attacks cause punch damage to the attacker.<br/>
            toHit.setHitTable( ToHitData.HIT_PUNCH );<br/>
            toHit.setSideTable( ToHitData.SIDE_FRONT );<br/>
            HitData hit = ae.rollHitLocation( toHit.getHitTable(),<br/>
                                              toHit.getSideTable() );<br/>
            r = new Report(4095);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            r.add(ae.getLocationAbbr(hit));<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            addReport(<br/>
                                  damageEntity(ae, hit, damage));<br/>
            addNewLines();<br/>
            return;<br/>
        }<br/>
<br/>
        // Different target types get different handling.<br/>
        switch ( target.getTargetType() ) {<br/>
        case Targetable.TYPE_ENTITY:<br/>
            // Handle Entity targets.<br/>
            HitData hit = te.rollHitLocation( toHit.getHitTable(),<br/>
                                              toHit.getSideTable() );<br/>
            r = new Report(4045);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getTableDesc());<br/>
            r.add(te.getLocationAbbr(hit));<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            addReport(<br/>
                                  damageEntity(te, hit, damage));<br/>
            addNewLines();<br/>
<br/>
            // Dislodge the swarming infantry.<br/>
            ae.setSwarmAttackerId( Entity.NONE );<br/>
            te.setSwarmTargetId( Entity.NONE );<br/>
            r = new Report(4100);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getDisplayName());<br/>
            addReport(r);<br/>
            break;<br/>
        case Targetable.TYPE_INARC_POD:<br/>
            // Handle iNarc pod targets.<br/>
            // TODO : check the return code and handle false appropriately.<br/>
            ae.removeINarcPod( (INarcPod) target );<br/>
//             // TODO : confirm that we don't need to update the attacker. //killme<br/>
//             entityUpdate( ae.getId() ); // killme<br/>
            r = new Report(4105);<br/>
            r.subject = ae.getId();<br/>
            r.add(target.getDisplayName());<br/>
            addReport(r);<br/>
            break;<br/>
            // TODO : add a default: case and handle it appropriately.<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a thrash attack<br/>
     */<br/>
    private void resolveThrashAttack( PhysicalResult pr,<br/>
                                        int lastEntityId ) {<br/>
        final ThrashAttackAction taa = (ThrashAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(taa.getEntityId());<br/>
<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int hits = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
<br/>
        // PLEASE NOTE: buildings are *never* the target of a "thrash".<br/>
        final Entity te = game.getEntity(taa.getTargetId());<br/>
        Report r;<br/>
<br/>
        if (lastEntityId != taa.getEntityId()) {<br/>
            //who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4110);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.addDesc(te);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4115);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        // Thrash attack may hit automatically<br/>
        if ( toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS ) {<br/>
            r = new Report(4120);<br/>
            r.subject = ae.getId();<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        } else {<br/>
            // report the roll<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
<br/>
            // do we hit?<br/>
            if (roll &lt; toHit.getValue()) {<br/>
                //miss<br/>
                r = new Report(4035);<br/>
                r.subject = ae.getId();<br/>
                addReport(r);<br/>
                return;<br/>
            }<br/>
            r = new Report(4125);<br/>
            r.subject = ae.getId();<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // Standard damage loop in 5 point clusters.<br/>
        if (glancing) {<br/>
            hits = (int)Math.floor(hits/2.0);<br/>
        }<br/>
<br/>
        r = new Report(4130);<br/>
        r.subject = ae.getId();<br/>
        r.add(hits);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
        if (glancing) {<br/>
            r = new Report(4030);<br/>
            r.subject = ae.getId();<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        }<br/>
        while ( hits &gt; 0 ) {<br/>
            int damage = Math.min(5, hits);<br/>
            hits -= damage;<br/>
            HitData hit = te.rollHitLocation( toHit.getHitTable(),<br/>
                                              toHit.getSideTable() );<br/>
            r = new Report(4135);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getLocationAbbr(hit));<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            addReport(<br/>
                                  damageEntity(te, hit, damage));<br/>
        }<br/>
<br/>
        addNewLines();<br/>
<br/>
        // Thrash attacks cause PSRs.  Failed PSRs cause falling damage.<br/>
        // This fall damage applies even though the Thrashing Mek is prone.<br/>
        PilotingRollData rollData = ae.getBasePilotingRoll();<br/>
        ae.addPilotingModifierForTerrain(rollData);<br/>
        rollData.addModifier( 0, "thrashing at infantry" );<br/>
        r = new Report(4140);<br/>
        r.subject = ae.getId();<br/>
        r.addDesc(ae);<br/>
        addReport(r);<br/>
        final int diceRoll = Compute.d6(2);<br/>
        r = new Report(2190);<br/>
        r.subject = ae.getId();<br/>
        r.addDesc(ae);<br/>
        r.add(rollData.getValueAsString());<br/>
        r.add(rollData.getDesc());<br/>
        r.add(diceRoll);<br/>
        if (diceRoll &lt; rollData.getValue()) {<br/>
            r.choose(false);<br/>
            addReport(r);<br/>
            doEntityFall( ae, rollData );<br/>
        } else {<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a club attack<br/>
     */<br/>
    private void resolveClubAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final ClubAttackAction caa = (ClubAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(caa.getEntityId());<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        final Targetable target = game.getTarget(caa.getTargetType(), caa.getTargetId());<br/>
        Entity te = null;<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = (Entity)target;<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, caa.getEntityId(), te);<br/>
        }<br/>
        final boolean targetInBuilding = Compute.isInBuilding( game, te );<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
        Report r;<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( target.getPosition() );<br/>
<br/>
        // restore club attack<br/>
        caa.getClub().restore();<br/>
<br/>
        if (lastEntityId != caa.getEntityId()) {<br/>
            //who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4145);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(caa.getClub().getName());<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4075);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            if (((MiscType)(caa.getClub().getType())).hasSubType(MiscType.S_MACE_THB)) {<br/>
                game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a mace attack"));<br/>
            }<br/>
            if (((MiscType)(caa.getClub().getType())).hasSubType(MiscType.S_MACE)) {<br/>
                game.addPSR(new PilotingRollData(ae.getId(), 2, "missed a mace attack"));<br/>
            }<br/>
            return;<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            r = new Report(4080);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            roll = Integer.MAX_VALUE;<br/>
        } else {<br/>
            // report the roll<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
       }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            //miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            if (((MiscType)(caa.getClub().getType())).hasSubType(MiscType.S_MACE_THB)) {<br/>
                game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a mace attack"));<br/>
            }<br/>
            if (((MiscType)(caa.getClub().getType())).hasSubType(MiscType.S_MACE)) {<br/>
                game.addPSR(new PilotingRollData(ae.getId(), 2, "missed a mace attack"));<br/>
            }<br/>
<br/>
            // If the target is in a building, the building absorbs the damage.<br/>
            if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
<br/>
                // Only report if damage was done to the building.<br/>
                if ( damage &gt; 0 ) {<br/>
                    Report buildingReport = damageBuilding( bldg, damage );<br/>
                    buildingReport.indent();<br/>
                    buildingReport.subject = ae.getId();<br/>
                    addReport(buildingReport);<br/>
                }<br/>
<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // Targeting a building.<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            r = new Report(4040);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
            // And we're done!<br/>
            return;<br/>
        }<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        r = new Report(4045);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getTableDesc());<br/>
        r.add(te.getLocationAbbr(hit));<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            int bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
            int toBldg = Math.min( bldgAbsorbs, damage );<br/>
            damage -= toBldg;<br/>
            addNewLines();<br/>
            Report buildingReport = damageBuilding( bldg, toBldg );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
        }<br/>
<br/>
        // A building may absorb the entire shot.<br/>
        if ( damage == 0 ) {<br/>
            r = new Report(4050);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getShortName());<br/>
            r.add(te.getOwner().getName());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        } else {<br/>
            if (glancing) {<br/>
                damage = (int)Math.floor(damage/2.0);<br/>
            }<br/>
            addReport(damageEntity(te, hit, damage, false, 0, false, false, throughFront));<br/>
        }<br/>
<br/>
        addNewLines();<br/>
<br/>
        if (((MiscType)caa.getClub().getType()).hasSubType(MiscType.S_TREE_CLUB)) {<br/>
            //the club breaks<br/>
            r = new Report(4150);<br/>
            r.subject = ae.getId();<br/>
            r.add(caa.getClub().getName());<br/>
            addReport(r);<br/>
            ae.removeMisc(caa.getClub().getName());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a push attack<br/>
     */<br/>
    private void resolvePushAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final PushAttackAction paa = (PushAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        // PLEASE NOTE: buildings are *never* the target of a "push".<br/>
        final Entity te = game.getEntity(paa.getTargetId());<br/>
        // get roll and ToHitData from the PhysicalResult<br/>
        int roll = pr.roll;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        Report r;<br/>
<br/>
        // was this push resolved earlier?<br/>
        if (pr.pushBackResolved) {<br/>
            return;<br/>
        }<br/>
<br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            //who is making the attack<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4155);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.addDesc(te);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4160);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        // report the roll<br/>
        r = new Report(4025);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getValue());<br/>
        r.add(roll);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // check if our target has a push against us, too, and get it<br/>
        PhysicalResult targetPushResult = null;<br/>
        for (Enumeration i = physicalResults.elements(); i.hasMoreElements();) {<br/>
            PhysicalResult tpr = (PhysicalResult)i.nextElement();<br/>
            if (tpr.aaa.getEntityId() == te.getId() &amp;&amp;<br/>
                tpr.aaa instanceof PushAttackAction &amp;&amp;<br/>
                tpr.aaa.getTargetId() == ae.getId() ) {<br/>
                targetPushResult = tpr;<br/>
            }<br/>
        }<br/>
        // if our target has a push against us, we need to resolve both now<br/>
        if (targetPushResult != null) {<br/>
            // do both hit?<br/>
            if (targetPushResult.roll &gt;= targetPushResult.toHit.getValue() &amp;&amp;<br/>
                roll &gt;= toHit.getValue()) {<br/>
                r = new Report(4165);<br/>
                r.subject = ae.getId();<br/>
                r.addDesc(te);<br/>
                r.addDesc(te);<br/>
                r.addDesc(ae);<br/>
                r.add(toHit.getValue());<br/>
                r.add(roll);<br/>
                r.addDesc(ae);<br/>
                addReport(r);<br/>
                PilotingRollData targetPushPRD = new PilotingRollData(te.getId(), getKickPushPSRMod(ae, te, 0), "was pushed");<br/>
                targetPushPRD.setCumulative(false); // see Bug# 811987 for more info<br/>
                PilotingRollData pushPRD = new PilotingRollData(ae.getId(), getKickPushPSRMod(ae, te, 0), "was pushed");<br/>
                pushPRD.setCumulative(false); // see Bug# 811987 for more info<br/>
                game.addPSR(pushPRD);<br/>
                game.addPSR(targetPushPRD);<br/>
                targetPushResult.pushBackResolved = true;<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            //miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        // we hit...<br/>
        int direction = ae.getFacing();<br/>
<br/>
        Coords src = te.getPosition();<br/>
        Coords dest = src.translated(direction);<br/>
<br/>
        PilotingRollData pushPRD = new PilotingRollData(te.getId(), getKickPushPSRMod(ae, te, 0), "was pushed");<br/>
        pushPRD.setCumulative(false); // see Bug# 811987 for more info<br/>
<br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            r = new Report(4170);<br/>
            r.subject = ae.getId();<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (game.getBoard().contains(dest)) {<br/>
                r = new Report(4175);<br/>
                r.subject = ae.getId();<br/>
                r.add(dest.getBoardNum(), true);<br/>
                addReport(r);<br/>
            } else {<br/>
                //uh-oh, pushed off board<br/>
                r = new Report(4180);<br/>
                r.subject = ae.getId();<br/>
                addReport(r);<br/>
            }<br/>
<br/>
            doEntityDisplacement(te, src, dest, pushPRD);<br/>
<br/>
            // if push actually moved the target, attacker follows thru<br/>
            if (!te.getPosition().equals(src)) {<br/>
                ae.setPosition(src);<br/>
            }<br/>
        } else {<br/>
            //targe imovable<br/>
            r = new Report(4185);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            game.addPSR(pushPRD);<br/>
        }<br/>
<br/>
        addNewLines();<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a charge attack<br/>
     */<br/>
    private void resolveChargeAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final ChargeAttackAction caa = (ChargeAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(caa.getEntityId());<br/>
        final Targetable target = game.getTarget(caa.getTargetType(), caa.getTargetId());<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        Entity te = null;<br/>
        if (target != null &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = (Entity)target;<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, caa.getEntityId(), te);<br/>
        }<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
        Report r;<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( caa.getTargetPos() );<br/>
<br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
<br/>
        final int direction = ae.getFacing();<br/>
<br/>
        // entity isn't charging any more<br/>
        ae.setDisplacementAttack(null);<br/>
<br/>
        if (lastEntityId != caa.getEntityId()) {<br/>
            //who is making the attack<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // should we even bother?<br/>
        if (target == null || (target.getTargetType() == Targetable.TYPE_ENTITY<br/>
             &amp;&amp; (te.isDestroyed() || te.isDoomed() || te.crew.isDead()))) {<br/>
            r = new Report(4190);<br/>
            r.subject = ae.getId();<br/>
            r.indent();<br/>
            addReport(r);<br/>
            // doEntityDisplacement(ae, ae.getPosition(), caa.getTargetPos(), null);<br/>
            // Randall said that if a charge fails because of target destruction,<br/>
            // the attacker stays in the hex he was in at the end of the movement phase<br/>
            // See Bug 912094<br/>
            return;<br/>
        }<br/>
<br/>
        // attacker fell down?<br/>
        if (ae.isProne()) {<br/>
            r = new Report(4195);<br/>
            r.subject = ae.getId();<br/>
            r.indent();<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        // attacker immobile?<br/>
        if (ae.isImmobile()) {<br/>
            r = new Report(4200);<br/>
            r.subject = ae.getId();<br/>
            r.indent();<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        if (te.isProne()) {<br/>
            r = new Report(4205);<br/>
            r.subject = ae.getId();<br/>
            r.indent();<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        r = new Report(4210);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // target still in the same position?<br/>
        if (!target.getPosition().equals(caa.getTargetPos())) {<br/>
            r = new Report(4215);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            doEntityDisplacement(ae, ae.getPosition(), caa.getTargetPos(), null);<br/>
            return;<br/>
        }<br/>
<br/>
        // if the attacker's prone, fudge the roll<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            roll = -12;<br/>
            r = new Report(4220);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            roll = Integer.MAX_VALUE;<br/>
            r = new Report(4225);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
        } else {<br/>
            // report the roll<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
       }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords src = ae.getPosition();<br/>
            Coords dest = Compute.getMissedChargeDisplacement(game, ae.getId(), src, direction);<br/>
<br/>
            // TODO: handle movement into/out of/through a building.  Do it here?<br/>
<br/>
            //miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            // move attacker to side hex<br/>
            doEntityDisplacement(ae, src, dest, null);<br/>
        }<br/>
<br/>
        // Targeting a building.<br/>
        else if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            r = new Report(4040);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
            // Apply damage to the attacker.<br/>
            int toAttacker = ChargeAttackAction.getDamageTakenBy( ae, bldg );<br/>
            HitData hit = ae.rollHitLocation( ToHitData.HIT_NORMAL,<br/>
                                              ae.sideTable(target.getPosition())<br/>
                                                  );<br/>
            addReport(<br/>
                                  damageEntity( ae, hit, toAttacker, false, 0, false, false, throughFront));<br/>
            addNewLines();<br/>
            entityUpdate( ae.getId() );<br/>
<br/>
            // TODO: Does the attacker enter the building?<br/>
            // TODO: What if the building collapses?<br/>
        }<br/>
        else {<br/>
            // Resolve the damage.<br/>
            resolveChargeDamage( ae, te, toHit, direction, glancing, throughFront );<br/>
        }<br/>
        return;<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a charge's damage<br/>
     */<br/>
    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit, int direction) {<br/>
        resolveChargeDamage (ae, te, toHit, direction, false, true);<br/>
    }<br/>
<br/>
    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit, int direction, boolean glancing, boolean throughFront) {<br/>
<br/>
        // we hit...<br/>
        int damage = ChargeAttackAction.getDamageFor(ae);<br/>
        int damageTaken = ChargeAttackAction.getDamageTakenBy(ae, te, game.getOptions().booleanOption("maxtech_charge_damage"));<br/>
        PilotingRollData chargePSR = null;<br/>
        if (glancing) {<br/>
            // Glancing Blow rule doesn't state whether damage to attacker on charge<br/>
            // or DFA is halved as well, assume yes. TODO: Check with PM<br/>
            damage = (int)Math.floor(damage/2.0);<br/>
            damageTaken = (int)Math.floor(damageTaken/2.0);<br/>
        }<br/>
        // Is the target inside a building?<br/>
        final boolean targetInBuilding = Compute.isInBuilding( game, te );<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( te.getPosition() );<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        int bldgAbsorbs = 0;<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
        }<br/>
<br/>
        // If we're upright, we may fall down.<br/>
        if ( !ae.isProne() ) {<br/>
            chargePSR = new PilotingRollData(ae.getId(), 2, "charging");<br/>
        }<br/>
<br/>
        Report r;<br/>
<br/>
<br/>
        r = new Report(4230);<br/>
        r.subject = ae.getId();<br/>
        r.add(damage);<br/>
        r.add(toHit.getTableDesc());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            damage -= cluster;<br/>
            if ( bldgAbsorbs &gt; 0 ) {<br/>
                int toBldg = Math.min( bldgAbsorbs, cluster );<br/>
                cluster -= toBldg;<br/>
                addNewLines();<br/>
                Report buildingReport = damageBuilding( bldg, toBldg );<br/>
                buildingReport.indent();<br/>
                buildingReport.subject = ae.getId();<br/>
                addReport(buildingReport);<br/>
            }<br/>
<br/>
            // A building may absorb the entire shot.<br/>
            if ( cluster == 0 ) {<br/>
                r = new Report(4235);<br/>
                r.subject = ae.getId();<br/>
                r.addDesc(te);<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            } else {<br/>
                HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
                addReport(<br/>
                                      damageEntity(te, hit, cluster, false, 0, false, false, throughFront));<br/>
            }<br/>
        }<br/>
<br/>
        //damage to attacker<br/>
        r = new Report(4240);<br/>
        r.subject = ae.getId();<br/>
        r.add(damageTaken);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = ae.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);<br/>
            addReport(<br/>
                                      damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
        // move attacker and target, if possible<br/>
        Coords src = te.getPosition();<br/>
        Coords dest = src.translated(direction);<br/>
<br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            addNewLines();<br/>
            doEntityDisplacement(te, src, dest, new PilotingRollData(te.getId(), 2, "was charged"));<br/>
            doEntityDisplacement(ae, ae.getPosition(), src, chargePSR);<br/>
        }<br/>
<br/>
        addNewLines();<br/>
<br/>
    } // End private void resolveChargeDamage( Entity, Entity, ToHitData )<br/>
<br/>
    private void resolveLayExplosivesAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final LayExplosivesAttackAction laa = (LayExplosivesAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(laa.getEntityId());<br/>
        final Targetable target = game.getTarget(laa.getTargetType(), laa.getTargetId());<br/>
        if(ae instanceof Infantry) {<br/>
            Infantry inf = (Infantry) ae;<br/>
            if(inf.turnsLayingExplosives &lt; 0) {<br/>
                inf.turnsLayingExplosives = 0;<br/>
                Report r = new Report(4270);<br/>
                r.subject = inf.getId();<br/>
                r.addDesc(inf);<br/>
                addReport(r);<br/>
            } else {<br/>
                Building building = game.getBoard().getBuildingAt(ae.getPosition());<br/>
                if(building != null) {<br/>
                    building.addDemolitionCharge(ae.getOwner().getId(), pr.damage);<br/>
                    Report r = new Report(4275);<br/>
                    r.subject = inf.getId();<br/>
                    r.addDesc(inf);<br/>
                    r.add(pr.damage);<br/>
                    addReport(r);<br/>
                }<br/>
                inf.turnsLayingExplosives = -1;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a death from above attack<br/>
     */<br/>
    private void resolveDfaAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final DfaAttackAction daa = (DfaAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(daa.getEntityId());<br/>
        final Targetable target = game.getTarget(daa.getTargetType(), daa.getTargetId());<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        Entity te = null;<br/>
        if (target != null &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            // Lets re-write around that horrible hack that was here before.<br/>
            // So instead of asking if a specific location is wet and praying<br/>
            // that it won't cause an NPE...<br/>
            // We'll check 1) if the hex has water, and 2) if it's deep enough<br/>
            // to cover the unit in question at its current elevation.<br/>
            // It's especially important to make sure it's done this way,<br/>
            // because some units (Sylph, submarines) can be at ANY elevation<br/>
            // underwater, and VTOLs can be well above the surface.<br/>
            te = (Entity)target;<br/>
            IHex hex = game.getBoard().getHex(te.getPosition());<br/>
            if (hex.containsTerrain(Terrains.WATER)) {<br/>
                if (te.absHeight() &lt; hex.getElevation())<br/>
                    damage = (int)Math.ceil(damage * 0.5f);<br/>
            }<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, daa.getEntityId(), te);<br/>
        }<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
        Report r;<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( daa.getTargetPos() );<br/>
<br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
<br/>
        final int direction = ae.getFacing();<br/>
<br/>
        if (lastEntityId != daa.getEntityId()) {<br/>
            //who is making the attack<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // entity isn't DFAing any more<br/>
        ae.setDisplacementAttack(null);<br/>
<br/>
        // should we even bother?<br/>
        if (target == null || (target.getTargetType() == Targetable.TYPE_ENTITY<br/>
             &amp;&amp; (te.isDestroyed() || te.isDoomed() || te.crew.isDead()))) {<br/>
            r = new Report(4245);<br/>
            r.subject = ae.getId();<br/>
            r.indent();<br/>
            addReport(r);<br/>
            if (ae.isProne()) {<br/>
                // attacker prone during weapons phase<br/>
                doEntityFall(ae, daa.getTargetPos(), 2, 3, ae.getBasePilotingRoll());<br/>
<br/>
            } else {<br/>
                // same effect as successful DFA<br/>
                doEntityDisplacement(ae, ae.getPosition(), daa.getTargetPos(), new PilotingRollData(ae.getId(), 4, "executed death from above"));<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        r = new Report(4246);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // target still in the same position?<br/>
        if ( !target.getPosition().equals(daa.getTargetPos()) ) {<br/>
            r = new Report(4215);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            doEntityFallsInto(ae, ae.getPosition(), daa.getTargetPos(), ae.getBasePilotingRoll());<br/>
            return;<br/>
        }<br/>
<br/>
        // hack: if the attacker's prone, or incapacitated, fudge the roll<br/>
        if (ae.isProne() || !ae.isActive()) {<br/>
            roll = -12;<br/>
            r = new Report(4250);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
        } else if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            roll = -12;<br/>
            r = new Report(4255);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            r = new Report(4260);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            roll = Integer.MAX_VALUE;<br/>
        } else {<br/>
            // report the roll<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords dest = te.getPosition();<br/>
            Coords targetDest = Compute.getPreferredDisplacement(game, te.getId(), dest, direction);<br/>
            //miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            if (targetDest != null) {<br/>
                // attacker falls into destination hex<br/>
                r = new Report(4265);<br/>
                r.subject = ae.getId();<br/>
                r.addDesc(ae);<br/>
                r.add(dest.getBoardNum(), true);<br/>
                addReport(r);<br/>
                doEntityFall(ae, dest, 2, 3, ae.getBasePilotingRoll());<br/>
<br/>
                // move target to preferred hex<br/>
                doEntityDisplacement(te, dest, targetDest, null);<br/>
            } else {<br/>
                // attacker destroyed  Tanks<br/>
                // suffer an ammo/power plant hit.<br/>
                // TODO : a Mech suffers a Head Blown Off crit.<br/>
                addReport(<br/>
                                      destroyEntity(ae, "impossible displacement", (ae instanceof Mech), (ae instanceof Mech)));<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // we hit...<br/>
        // Can't DFA a target inside of a building.<br/>
        int damageTaken = DfaAttackAction.getDamageTakenBy(ae);<br/>
<br/>
        r = new Report(4040);<br/>
        r.subject = ae.getId();<br/>
        addReport(r);<br/>
<br/>
        // Targeting a building.<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
        }<br/>
<br/>
        // Target isn't building.<br/>
        else {<br/>
            if (glancing) {<br/>
                damage = (int)Math.floor(damage/2.0);<br/>
            }<br/>
            //damage target<br/>
            r = new Report(4230);<br/>
            r.subject = ae.getId();<br/>
            r.add(damage);<br/>
            r.add(toHit.getTableDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            while (damage &gt; 0) {<br/>
                int cluster = Math.min(5, damage);<br/>
                HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
                addReport(<br/>
                                      damageEntity(te, hit, cluster, false, 0, false, false, throughFront));<br/>
                damage -= cluster;<br/>
            }<br/>
        }<br/>
<br/>
        if (glancing) {<br/>
            // Glancing Blow rule doesn't state whether damage to attacker on charge<br/>
            // or DFA is halved as well, assume yes. TODO: Check with PM<br/>
            damageTaken = (int)Math.floor(damageTaken/2.0);<br/>
        }<br/>
<br/>
        //damage attacker<br/>
        r = new Report(4240);<br/>
        r.subject = ae.getId();<br/>
        r.add(damageTaken);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = ae.rollHitLocation(ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);<br/>
            addReport(<br/>
                                      damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
<br/>
        addNewLines();<br/>
<br/>
        // That's it for target buildings.<br/>
        // TODO: where do I put the attacker?!?<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
            return;<br/>
        }<br/>
<br/>
        // Target entities are pushed away or destroyed.<br/>
        Coords dest = te.getPosition();<br/>
        Coords targetDest = Compute.getValidDisplacement(game, te.getId(), dest, direction);<br/>
        if (targetDest != null) {<br/>
            doEntityDisplacement(te, dest, targetDest, new PilotingRollData(te.getId(), 2, "hit by death from above"));<br/>
        } else {<br/>
            // ack!  automatic death!  Tanks<br/>
            // suffer an ammo/power plant hit.<br/>
            // TODO : a Mech suffers a Head Blown Off crit.<br/>
            addReport(destroyEntity(te, "impossible displacement", (te instanceof Mech), (te instanceof Mech)));<br/>
        }<br/>
        // HACK: to avoid automatic falls, displace from dest to dest<br/>
        doEntityDisplacement(ae, dest, dest, new PilotingRollData(ae.getId(), 4, "executed death from above"));<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the modifier for a Kick or Push PSR<br/>
     * @param attacker The attacking &lt;code&gt;Entity&gt;&lt;/code&gt;<br/>
     * @param target   The target &lt;code&gt;Entity&lt;/code&gt;<br/>
     * @param def      The &lt;code&gt;int&lt;/code&gt; default modifier <br/>
     * @return         The &lt;code&gt;int&lt;/code&gt; modifier to the PSR <br/>
     */<br/>
    private int getKickPushPSRMod(Entity attacker, Entity target, int def) {<br/>
        int mod = def;<br/>
        <br/>
        if ( game.getOptions().booleanOption("maxtech_physical_psr") ) {<br/>
            int attackerMod = 0;<br/>
            int targetMod = 0;<br/>
            <br/>
            switch ( attacker.getWeightClass() ) {<br/>
            case EntityWeightClass.WEIGHT_LIGHT:<br/>
                attackerMod = 1;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_MEDIUM:<br/>
                attackerMod = 2;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_HEAVY:<br/>
                attackerMod = 3;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_ASSAULT:<br/>
                attackerMod = 4;<br/>
                break;<br/>
            }<br/>
            switch ( target.getWeightClass() ) {<br/>
            case EntityWeightClass.WEIGHT_LIGHT:<br/>
                targetMod = 1;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_MEDIUM:<br/>
                targetMod = 2;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_HEAVY:<br/>
                targetMod = 3;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_ASSAULT:<br/>
                targetMod = 4;<br/>
                break;<br/>
            }<br/>
            mod = attackerMod - targetMod;<br/>
        }<br/>
        return mod;<br/>
    }<br/>
<br/>
    /**<br/>
     * Each mech sinks the amount of heat appropriate to its current heat<br/>
     * capacity.<br/>
     */<br/>
    private void resolveHeat() {<br/>
        Report r;<br/>
        //Heat phase header<br/>
        addReport(new Report(5000, Report.PUBLIC));<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ) {<br/>
                continue;<br/>
            }<br/>
            IHex entityHex = game.getBoard().getHex(entity.getPosition());<br/>
<br/>
            // heat doesn't matter for non-mechs<br/>
            if (!(entity instanceof Mech)) {<br/>
                entity.heatBuildup = 0;<br/>
<br/>
                if(game.getOptions().booleanOption("vehicle_fires")<br/>
                        &amp;&amp; entity instanceof Tank) {<br/>
                    resolveVehicleFire((Tank)entity, true);<br/>
                }<br/>
                // If the unit is hit with an Inferno, do flaming death test.<br/>
                else if ( entity.infernos.isStillBurning()) {<br/>
                    doFlamingDeath(entity);<br/>
                }<br/>
                continue;<br/>
            }<br/>
            else {<br/>
                // Meks gain heat from inferno hits.<br/>
                if ( entity.infernos.isStillBurning() ) {<br/>
                    int infernoHeat = entity.infernos.getHeat();<br/>
                    entity.heatBuildup += infernoHeat;<br/>
                    r = new Report(5010);<br/>
                    r.subject = entity.getId();<br/>
                    r.add(infernoHeat);<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            // should we even bother?<br/>
            if ( entity.isDestroyed() || entity.isDoomed() ||<br/>
                 entity.crew.isDoomed() || entity.crew.isDead() ) {<br/>
                continue;<br/>
            }<br/>
<br/>
            // engine hits add a lot of heat, provided the engine is on<br/>
            entity.heatBuildup += entity.getEngineCritHeat();<br/>
<br/>
            // If a Mek had an active Stealth suite, add 10 heat.<br/>
            if ( entity instanceof Mech &amp;&amp; entity.isStealthActive() ) {<br/>
                entity.heatBuildup += 10;<br/>
                r = new Report(5015);<br/>
                r.subject = entity.getId();<br/>
                addReport(r);<br/>
            }<br/>
<br/>
            // If a Mek is in extreme Temperatures, add or subtract one<br/>
            // heat per 10 degrees (or fraction of 10 degrees) above or<br/>
            // below 50 or -30 degrees Celsius<br/>
            if ( entity instanceof Mech &amp;&amp; game.getTemperatureDifference() != 0<br/>
                 &amp;&amp; !((Mech)entity).hasLaserHeatSinks()) {<br/>
                if (game.getOptions().intOption("temperature") &gt; 50) {<br/>
                    entity.heatBuildup += game.getTemperatureDifference();<br/>
                    r = new Report(5020);<br/>
                    r.subject = entity.getId();<br/>
                    r.add(game.getTemperatureDifference());<br/>
                    addReport(r);<br/>
                }<br/>
                else {<br/>
                    entity.heatBuildup -= game.getTemperatureDifference();<br/>
                    r = new Report(5025);<br/>
                    r.subject = entity.getId();<br/>
                    r.add(game.getTemperatureDifference());<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            // Add +5 Heat if the hex you're in is on fire<br/>
            // and was on fire for the full round.<br/>
            if (entityHex != null) {<br/>
                if (entityHex.terrainLevel(Terrains.FIRE) == 2) {<br/>
                    entity.heatBuildup += 5;<br/>
                    r = new Report(5030);<br/>
                    r.subject = entity.getId();<br/>
                    addReport(r);<br/>
                }<br/>
                int magma = entityHex.terrainLevel(Terrains.MAGMA);<br/>
                if(magma &gt; 0) {<br/>
                    entity.heatBuildup += 5 * magma;<br/>
                    r = new Report(5032);<br/>
                    r.subject = entity.getId();<br/>
                    r.add(5 * magma);<br/>
                    addReport(r);                    <br/>
                }<br/>
            }<br/>
            <br/>
            // if heatbuildup is negative due to temperature, set it to 0<br/>
            // for prettier turnreports<br/>
            if (entity.heatBuildup &lt; 0) {<br/>
                entity.heatBuildup = 0;<br/>
            }<br/>
<br/>
            // add the heat we've built up so far.<br/>
            entity.heat += entity.heatBuildup;<br/>
<br/>
            // how much heat can we sink?<br/>
            int tosink = entity.getHeatCapacityWithWater();<br/>
<br/>
            // should we use a coolant pod?<br/>
            int safeHeat = entity.hasInfernoAmmo() ? 9 : 13;<br/>
            int possibleSinkage = ((Mech)entity).getNumberOfSinks();<br/>
            for(Enumeration equip=entity.getEquipment();equip.hasMoreElements();) {<br/>
                Mounted m = (Mounted)equip.nextElement();<br/>
                if(m.getType() instanceof AmmoType) {<br/>
                    AmmoType at = (AmmoType)(m.getType());<br/>
                    if(at.getAmmoType() == AmmoType.T_COOLANT_POD &amp;&amp; m.isAmmoUsable()) {<br/>
                        EquipmentMode mode = m.curMode();<br/>
                        if(mode.equals("dump")) {<br/>
                            r = new Report(5260);<br/>
                            r.subject = entity.getId();<br/>
                            addReport(r);<br/>
                            m.setShotsLeft(0);<br/>
                            tosink += possibleSinkage;<br/>
                            break;<br/>
                        }<br/>
                        if(mode.equals("safe") &amp;&amp; entity.heat - tosink &gt; safeHeat) {<br/>
                            r = new Report(5265);<br/>
                            r.subject = entity.getId();<br/>
                            addReport(r);<br/>
                            m.setShotsLeft(0);<br/>
                            tosink += possibleSinkage;<br/>
                            break;<br/>
                        }<br/>
                        if(mode.equals("efficient") &amp;&amp; entity.heat - tosink &gt;= possibleSinkage) {<br/>
                            r = new Report(5270);<br/>
                            r.subject = entity.getId();<br/>
                            addReport(r);<br/>
                            m.setShotsLeft(0);<br/>
                            tosink += possibleSinkage;<br/>
                            break;<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            tosink = Math.min( tosink, entity.heat );<br/>
            entity.heat -= tosink;<br/>
            r = new Report(5035);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(entity.heatBuildup);<br/>
            r.add(tosink);<br/>
            r.add(entity.heat);<br/>
            addReport(r);<br/>
            entity.heatBuildup = 0;<br/>
<br/>
            // Does the unit have inferno ammo?<br/>
            if( entity.hasInfernoAmmo() ) {<br/>
<br/>
                // Roll for possible inferno ammo explosion.<br/>
                if (entity.heat &gt;= 10) {<br/>
                    int boom = 4 + (entity.heat &gt;= 14 ? 2 : 0) +<br/>
                        (entity.heat &gt;= 19 ? 2 : 0) +<br/>
                        (entity.heat &gt;= 23 ? 2 : 0) +<br/>
                        (entity.heat &gt;= 28 ? 2 : 0);<br/>
                    int boomroll = Compute.d6(2);<br/>
                    r = new Report(5040);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(boom);<br/>
                    r.add(boomroll);<br/>
<br/>
                    if (boomroll &gt;= boom) {<br/>
                        //avoided<br/>
                        r.choose(true);<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        r.choose(false);<br/>
                        addReport(r);<br/>
                        addReport( explodeInfernoAmmoFromHeat(entity));<br/>
                    }<br/>
                }<br/>
            } // End avoid-inferno-explosion<br/>
            int autoShutDownHeat;<br/>
            boolean mtHeat;<br/>
            <br/>
            if (game.getOptions().booleanOption("maxtech_heat")) {<br/>
                autoShutDownHeat = 50;<br/>
                mtHeat = true;<br/>
            } else {<br/>
                autoShutDownHeat = 30;<br/>
                mtHeat = false;<br/>
            }<br/>
            // heat effects: start up<br/>
            if (entity.heat &lt; autoShutDownHeat &amp;&amp; entity.isShutDown()) {<br/>
                if (entity.heat &lt; 14) {<br/>
                    //automatically starts up again<br/>
                    entity.setShutDown(false);<br/>
                    r = new Report(5045);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    addReport(r);<br/>
                } else {<br/>
                    //roll for startup<br/>
                    int startup = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    if (mtHeat) {<br/>
                        startup = entity.crew.getPiloting() + startup - 8;<br/>
                    }<br/>
                    int suroll = Compute.d6(2);<br/>
                    r = new Report(5050);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(startup);<br/>
                    r.add(suroll);<br/>
                    if (suroll &gt;= startup) {<br/>
                        //start 'er back up<br/>
                        entity.setShutDown(false);<br/>
                        r.choose(true);<br/>
                    } else {<br/>
                        r.choose(false);<br/>
                    }<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: shutdown!<br/>
            // 2003-01-26 JAD - Don't shut down if you just restarted.<br/>
            else if (entity.heat &gt;= 14 &amp;&amp; !entity.isShutDown()) {<br/>
                if (entity.heat &gt;= autoShutDownHeat) {<br/>
                    r = new Report(5055);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    addReport(r);<br/>
                    // add a piloting roll and resolve immediately<br/>
                    game.addPSR(new PilotingRollData<br/>
                        ( entity.getId(), 3, "reactor shutdown" ));<br/>
                    resolvePilotingRolls();<br/>
                    // okay, now mark shut down<br/>
                    entity.setShutDown(true);<br/>
                } else if (entity.heat &gt;= 14) {<br/>
                    int shutdown = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    if (mtHeat) {<br/>
                        shutdown = entity.crew.getPiloting() + shutdown - 8;<br/>
                    }<br/>
                    int sdroll = Compute.d6(2);<br/>
                    r = new Report(5060);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(shutdown);<br/>
                    r.add(sdroll);<br/>
                    if (sdroll &gt;= shutdown) {<br/>
                        //avoided<br/>
                        r.choose(true);<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        //shutting down...<br/>
                        r.choose(false);<br/>
                        addReport(r);<br/>
                        // add a piloting roll and resolve immediately<br/>
                        game.addPSR(new PilotingRollData<br/>
                            ( entity.getId(), 3, "reactor shutdown" ));<br/>
                        resolvePilotingRolls();<br/>
                        // okay, now mark shut down<br/>
                        entity.setShutDown(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: ammo explosion!<br/>
            if (entity.heat &gt;= 19) {<br/>
                int boom = 4 + (entity.heat &gt;= 23 ? 2 : 0) +<br/>
                    (entity.heat &gt;= 28 ? 2 : 0);<br/>
                if (mtHeat) {<br/>
                    boom += <br/>
                        (entity.heat &gt;= 35 ? 2 : 0) +<br/>
                        (entity.heat &gt;= 40 ? 2 : 0) +<br/>
                        (entity.heat &gt;= 45 ? 2 : 0);<br/>
                    // Last line is a crutch; 45 heat should be no roll<br/>
                    // but automatic explosion.<br/>
                }<br/>
                if(entity instanceof Mech &amp;&amp; ((Mech)entity).hasLaserHeatSinks())<br/>
                    boom--;<br/>
                int boomroll = Compute.d6(2);<br/>
                r = new Report(5065);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(boom);<br/>
                r.add(boomroll);<br/>
                if (boomroll &gt;= boom) {<br/>
                    //mech is ok<br/>
                    r.choose(true);<br/>
                    addReport(r);<br/>
                } else {<br/>
                    //boom!<br/>
                    r.choose(false);<br/>
                    addReport(r);<br/>
                    addReport( explodeAmmoFromHeat(entity));<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: mechwarrior damage<br/>
            // N.B. The pilot may already be dead.<br/>
            int lifeSupportCritCount = 0;<br/>
            boolean torsoMountedCockpit = ((Mech)entity).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED;<br/>
            if ((entity instanceof Mech)<br/>
                    &amp;&amp; torsoMountedCockpit) {<br/>
                lifeSupportCritCount = entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                    Mech.SYSTEM_LIFE_SUPPORT,<br/>
                    Mech.LOC_RT);<br/>
                lifeSupportCritCount += entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                    Mech.SYSTEM_LIFE_SUPPORT,<br/>
                    Mech.LOC_LT);<br/>
            } else {<br/>
                lifeSupportCritCount = entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                        Mech.SYSTEM_LIFE_SUPPORT,<br/>
                        Mech.LOC_HEAD);<br/>
            }<br/>
            if (lifeSupportCritCount &gt; 0<br/>
                    &amp;&amp; ((entity.heat &gt;= 15) || (torsoMountedCockpit &amp;&amp; (entity.heat &gt;= 0)))<br/>
                    &amp;&amp; !entity.crew.isDead() &amp;&amp; !entity.crew.isDoomed()<br/>
                    &amp;&amp; !entity.crew.isEjected()) {<br/>
                int heatLimitDesc = 1;<br/>
                int damageToCrew = 0;<br/>
                if (entity.heat &gt;= 47 &amp;&amp; mtHeat) {<br/>
                    // mechwarrior takes 5 damage<br/>
                    heatLimitDesc = 47;<br/>
                    damageToCrew = 5;<br/>
                } else if (entity.heat &gt;= 39 &amp;&amp; mtHeat) {<br/>
                    // mechwarrior takes 4 damage<br/>
                    heatLimitDesc = 39;<br/>
                    damageToCrew = 4;<br/>
                } else if (entity.heat &gt;= 32 &amp;&amp; mtHeat) {<br/>
                    // mechwarrior takes 3 damage<br/>
                    heatLimitDesc = 32;<br/>
                    damageToCrew = 3;<br/>
                } else if (entity.heat &gt;= 25) {<br/>
                    // mechwarrior takes 2 damage<br/>
                    heatLimitDesc = 25;<br/>
                    damageToCrew = 2;<br/>
                } else if (entity.heat &gt;= 15) {<br/>
                    // mechwarrior takes 1 damage<br/>
                    heatLimitDesc = 15;<br/>
                    damageToCrew = 1;<br/>
                }<br/>
                if (entity.heat &gt; 0<br/>
                        &amp;&amp; (entity instanceof Mech)<br/>
                        &amp;&amp; ((Mech)entity).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED)<br/>
                    damageToCrew += 1;<br/>
                r = new Report(5070);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(heatLimitDesc);<br/>
                r.add(damageToCrew);<br/>
                addReport(r);<br/>
                damageCrew(entity, damageToCrew);<br/>
            } else if (mtHeat &amp;&amp; entity.heat &gt;= 32<br/>
                       &amp;&amp; !entity.crew.isDead() &amp;&amp; !entity.crew.isDoomed() ) {<br/>
                // Pilot may take damage from heat if MaxTech option is set<br/>
                int heatroll = Compute.d6(2);<br/>
                int avoidNumber = -1;<br/>
                if (entity.heat &gt;= 47) {<br/>
                    avoidNumber = 12;<br/>
                } else if (entity.heat &gt;= 39) {<br/>
                    avoidNumber = 10;<br/>
                } else if (entity.heat &gt;= 32) {<br/>
                    avoidNumber = 8;<br/>
                }<br/>
                r = new Report(5075);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(avoidNumber);<br/>
                r.add(heatroll);<br/>
                if (heatroll &gt;= avoidNumber) {<br/>
                    //damage avoided<br/>
                    r.choose(true);<br/>
                } else {<br/>
                    damageCrew(entity, 1);<br/>
                    r.choose(false);<br/>
                }<br/>
                addReport(r);<br/>
            }<br/>
<br/>
            // The pilot may have just expired.<br/>
            if ( (entity.crew.isDead() || entity.crew.isDoomed() )<br/>
                 &amp;&amp; !entity.crew.isEjected() ) {<br/>
                r = new Report(5080);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
                addReport( destroyEntity(entity, "crew death", true));<br/>
            }<br/>
<br/>
            // With MaxTech Heat Scale, there may occur critical damage<br/>
            if (mtHeat) {<br/>
                if (entity.heat &gt;= 36) {<br/>
                    int damageroll = Compute.d6(2);<br/>
                    int damageNumber = -1;<br/>
                    if (entity.heat &gt;= 44) {<br/>
                        damageNumber = 10;<br/>
                    } else if (entity.heat &gt;= 36) {<br/>
                        damageNumber = 8;<br/>
                    }<br/>
                    r = new Report(5085);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(damageNumber);<br/>
                    r.add(damageroll);<br/>
                    r.newlines = 0;<br/>
                    if (damageroll &gt;= damageNumber) {<br/>
                        r.choose(true);<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        r.choose(false);<br/>
                        addReport(r);<br/>
                        addReport(oneCriticalEntity(entity, Compute.d6(2)));<br/>
                        //add an empty report, for linebreaking<br/>
                        r = new Report(1210);<br/>
                        addReport(r);<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        if (vPhaseReport.size() == 1) {<br/>
            //I guess nothing happened...<br/>
            addReport(new Report(1205, Report.PUBLIC));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * check to see if unarmored infantry is outside in extreme temperatures<br/>
     * (crude fix because infantry shouldn't be able to be deployed<br/>
     * outside of vehicles or buildings, but we can't do that because<br/>
     * we don't know wether the map has buildings or not or wether the<br/>
     * player has an apc<br/>
     */<br/>
    private void resolveExtremeTempInfantryDeath() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ) {<br/>
                continue;<br/>
            }<br/>
            IHex entityHex = game.getBoard().getHex(entity.getPosition());<br/>
            if (entity instanceof Infantry &amp;&amp;<br/>
                    !(entity instanceof BattleArmor) &amp;&amp;<br/>
                    game.getTemperatureDifference() &gt; 0 &amp;&amp;<br/>
                    !(entityHex.containsTerrain(Terrains.BUILDING)) &amp;&amp; <br/>
                    (entity.getTransportId() == Entity.NONE) ) {<br/>
                Report r = new Report(5090);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                addReport(destroyEntity(entity, "heat/cold", false, false));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolve Flaming Death for the given Entity<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that may experience flaming death.<br/>
     */<br/>
    private void doFlamingDeath(Entity entity) {<br/>
        Report r;<br/>
        int boomroll = Compute.d6(2);<br/>
        // Infantry are unaffected by fire while they're still swarming.<br/>
        if ( Entity.NONE != entity.getSwarmTargetId() ) {<br/>
            return;<br/>
        }<br/>
        if (entity.getMovementMode() == IEntityMovementMode.VTOL<br/>
                &amp;&amp; !(entity.infernos.isStillBurning())) {<br/>
            // VTOLs don't check as long as they are flying higher than<br/>
            // the burning terrain. TODO: Check for rules conformity (ATPM?)<br/>
            // according to maxtech, elevation 0 or 1 should be affected,<br/>
            // this makes sense for level 2 as well<br/>
            Coords c = entity.getPosition();<br/>
            IHex h = game.getBoard().getHex(c.x, c.y);<br/>
            if (entity.getElevation() &gt; 1) {<br/>
                return;<br/>
            }<br/>
        }<br/>
        // Battle Armor squads equipped with fire protection<br/>
        // gear automatically avoid flaming death.<br/>
        for ( Enumeration iter = entity.getMisc(); iter.hasMoreElements(); ) {<br/>
            Mounted mount = (Mounted) iter.nextElement();<br/>
            EquipmentType equip = mount.getType();<br/>
            if ( BattleArmor.FIRE_PROTECTION.equals(equip.getInternalName()) ) {<br/>
                r = new Report(5095);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        //Must roll 8+ to survive...<br/>
        r = new Report(5100);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        r.add(boomroll);<br/>
        if (boomroll &gt;= 8) {<br/>
            //phew!<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
        } else {<br/>
            //eek<br/>
            r.choose(false);<br/>
            addReport(r);<br/>
            addReport( destroyEntity(entity, "fire", false, false));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if any entity has takes 20 damage.  If so, they need a<br/>
     * piloting skill roll.<br/>
     */<br/>
    private void checkFor20Damage() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (entity instanceof Mech) {<br/>
                // if this mech has 20+ damage, add another roll to the list.<br/>
                if (entity.damageThisPhase &gt;= 20) {<br/>
                    if ( game.getOptions().booleanOption("maxtech_round_damage") ) {<br/>
                      int damMod = (entity.damageThisPhase / 20);<br/>
                      int weightMod = 0;<br/>
                      StringBuffer reportStr = new StringBuffer();<br/>
                      reportStr.append(entity.damageThisPhase)<br/>
                          .append(" damage +").append(damMod);<br/>
<br/>
                      switch ( entity.getWeightClass() ) {<br/>
                        case EntityWeightClass.WEIGHT_LIGHT:<br/>
                          weightMod = 1;<br/>
                          break;<br/>
<br/>
                        case EntityWeightClass.WEIGHT_MEDIUM:<br/>
                          weightMod = 0;<br/>
                          break;<br/>
<br/>
                        case EntityWeightClass.WEIGHT_HEAVY:<br/>
                          weightMod = -1;<br/>
                          break;<br/>
<br/>
                        case EntityWeightClass.WEIGHT_ASSAULT:<br/>
                          weightMod = -2;<br/>
                          break;<br/>
                      }<br/>
<br/>
                      PilotingRollData damPRD = new PilotingRollData(entity.getId(), damMod + weightMod, reportStr.toString());<br/>
                      damPRD.setCumulative(false);  // see Bug# 811987 for more info<br/>
                      game.addPSR(damPRD);<br/>
                    } else {<br/>
                      game.addPSR(new PilotingRollData(entity.getId(), 1, "20+ damage"));<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if any non-mech units are standing in fire.  Called at the<br/>
     * end of the movement phase<br/>
     */<br/>
    public void checkForFlamingDeath() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ||<br/>
                 entity instanceof Mech ||<br/>
                 entity.isDoomed() ||<br/>
                 entity.isDestroyed() ||<br/>
                 entity.isOffBoard()) {<br/>
                continue;<br/>
            }<br/>
            final IHex curHex = game.getBoard().getHex(entity.getPosition());<br/>
            if (curHex.containsTerrain(Terrains.FIRE)<br/>
                    &amp;&amp; entity.getElevation() &lt;= 1) {<br/>
                if(game.getOptions().booleanOption("vehicle_fires")<br/>
                        &amp;&amp; entity instanceof Tank) {<br/>
                    checkForVehicleFire((Tank)entity, false);<br/>
                } else {<br/>
                    doFlamingDeath(entity);<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Check to see if anyone dies due to being in a vacuum.<br/>
     */<br/>
    private void checkForVacuumDeath() {<br/>
        Report r;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (null == entity.getPosition() || entity.isOffBoard()) {<br/>
                // If it's not on the board - aboard something else, for example...<br/>
                continue;<br/>
            }<br/>
            if (entity.doomedInVacuum()) {<br/>
                r = new Report(6015);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                addReport(destroyEntity(entity, "being in a vacuum where it can't survive", true, true));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if any entities are underwater with damaged life support.<br/>
     * Called during the end phase.<br/>
     */<br/>
    private void checkForSuffocation() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ||<br/>
                 entity.isOffBoard()) {<br/>
                continue;<br/>
            }<br/>
            final IHex curHex = game.getBoard().getHex(entity.getPosition());<br/>
            if (entity.getElevation()&lt;0 &amp;&amp; (curHex.terrainLevel(Terrains.WATER) &gt; 1<br/>
            || (curHex.terrainLevel(Terrains.WATER) == 1 &amp;&amp; entity.isProne()))<br/>
            &amp;&amp; entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) &gt; 0) {<br/>
                Report r = new Report(6020);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                addReport(damageCrew(entity, 1));<br/>
<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolves all built up piloting skill rolls.<br/>
     * Used at end of weapons, physical phases.<br/>
     */<br/>
    private void resolvePilotingRolls() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            resolvePilotingRolls((Entity)i.nextElement());<br/>
        }<br/>
        game.resetPSRs();<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolves and reports all piloting skill rolls for a single mech.<br/>
     */<br/>
    void resolvePilotingRolls(Entity entity) {<br/>
        resolvePilotingRolls(entity, false, null, null);<br/>
    }<br/>
    void resolvePilotingRolls( Entity entity, boolean moving,<br/>
                               Coords src, Coords dest ) {<br/>
        // dead units don't need to.<br/>
        if ( entity.isDoomed() || entity.isDestroyed() ) {<br/>
            return;<br/>
        }<br/>
        Report r;<br/>
<br/>
        // first, do extreme gravity PSR, because non-mechs do these, too<br/>
        PilotingRollData rollTarget = null;<br/>
        for (Enumeration i = game.getExtremeGravityPSRs();i.hasMoreElements();) {<br/>
            final PilotingRollData roll = (PilotingRollData)i.nextElement();<br/>
            if (roll.getEntityId() != entity.getId()) {<br/>
                continue;<br/>
            }<br/>
            // found a roll, use it (there can be only 1 per entity)<br/>
            rollTarget = roll;<br/>
            game.resetExtremeGravityPSRs(entity);<br/>
        }<br/>
        if (rollTarget != null &amp;&amp;<br/>
            rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
            // okay, print the info<br/>
            r = new Report(2180);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(rollTarget.getLastPlainDesc());<br/>
            addReport(r);<br/>
            // roll<br/>
            final int diceRoll = Compute.d6(2);<br/>
            r = new Report(2190);<br/>
            r.subject = entity.getId();<br/>
            r.add(rollTarget.getValueAsString());<br/>
            r.add(rollTarget.getDesc());<br/>
            r.add(diceRoll);<br/>
            if (diceRoll &lt; rollTarget.getValue()) {<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
                // walking and running, 1 damage per MP used more than we would<br/>
                // have normally<br/>
                if (entity.moved == IEntityMovementType.MOVE_WALK<br/>
                        || entity.moved == IEntityMovementType.MOVE_VTOL_WALK<br/>
                        || entity.moved == IEntityMovementType.MOVE_RUN<br/>
                        || entity.moved == IEntityMovementType.MOVE_VTOL_RUN) {<br/>
                    if (entity instanceof Mech) {<br/>
                        int j = entity.mpUsed;<br/>
                        int damage = 0;<br/>
                        while (j &gt; entity.getRunMP(false)) {<br/>
                            j--;<br/>
                            damage++;<br/>
                        }<br/>
                        // Wee, direct internal damage<br/>
                        doExtremeGravityDamage(entity, damage);<br/>
                    } else if (entity instanceof Tank) {<br/>
                        // if we got a pavement bonus, take care of it<br/>
                        int k = entity.gotPavementBonus ? 1 : 0;  <br/>
                        if (!entity.gotPavementBonus) {<br/>
                            int j = entity.mpUsed;<br/>
                            int damage = 0;<br/>
                            while (j &gt; entity.getRunMP(false) + k) {<br/>
                                j--;<br/>
                                damage++;<br/>
                            }<br/>
                            doExtremeGravityDamage(entity, damage);<br/>
                        }                      <br/>
                    }<br/>
                }<br/>
                // jumping<br/>
                if (entity.moved == IEntityMovementType.MOVE_JUMP &amp;&amp; entity instanceof Mech) {<br/>
                    // low g, 1 damage for each hex jumped further than<br/>
                    // possible normally<br/>
                    if (game.getOptions().floatOption("gravity") &lt; 1) {<br/>
                        int j = entity.mpUsed;<br/>
                        int damage = 0;<br/>
                        while (j &gt; entity.getOriginalJumpMP()) {<br/>
                            j--;<br/>
                            damage++;<br/>
                        }<br/>
                        // Wee, direct internal damage<br/>
                        doExtremeGravityDamage(entity, damage);<br/>
                    }<br/>
                    // high g, 1 damage for each MP we have less than normally<br/>
                    else if (game.getOptions().floatOption("gravity") &gt; 1) {<br/>
                            int damage = entity.getWalkMP(false) - entity.getWalkMP();<br/>
                            // Wee, direct internal damage<br/>
                            doExtremeGravityDamage(entity, damage);                    <br/>
                    }<br/>
                }                <br/>
            } else {<br/>
                r.choose(true);<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
        // non mechs and prone mechs can now return<br/>
        if ( !(entity instanceof Mech) || entity.isProne()) {<br/>
            return;<br/>
        }<br/>
        // add all cumulative rolls, count all rolls<br/>
        Vector rolls = new Vector();<br/>
        StringBuffer reasons = new StringBuffer();<br/>
        PilotingRollData base = entity.getBasePilotingRoll();<br/>
        entity.addPilotingModifierForTerrain(base);<br/>
        for (Enumeration i = game.getPSRs(); i.hasMoreElements();) {<br/>
            final PilotingRollData modifier = (PilotingRollData)i.nextElement();<br/>
            if (modifier.getEntityId() != entity.getId()) {<br/>
                continue;<br/>
            }<br/>
            // found a roll, add it<br/>
            rolls.addElement(modifier);<br/>
            if (reasons.length() &gt; 0) {<br/>
                reasons.append(", ");<br/>
            }<br/>
            reasons.append(modifier.getPlainDesc());<br/>
            // only cumulative rolls get added to the base roll<br/>
            if (modifier.isCumulative()) {<br/>
                base.append(modifier);<br/>
            }<br/>
        }<br/>
        // any rolls needed?<br/>
        if (rolls.size() == 0) {<br/>
            return;<br/>
        }<br/>
        // is our base roll impossible?<br/>
        if (base.getValue() == PilotingRollData.AUTOMATIC_FAIL || base.getValue() == PilotingRollData.IMPOSSIBLE) {<br/>
            r = new Report(2275);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(rolls.size());<br/>
            r.add(reasons.toString()); //international issue<br/>
            r.add(base.getDesc()); //international issue<br/>
            addReport(r);<br/>
            if (moving) {<br/>
                doEntityFallsInto( entity, src, dest, base );<br/>
            } else {<br/>
                doEntityFall(entity, base);<br/>
            }<br/>
            return;<br/>
        }<br/>
        // loop thru rolls we do have to make...<br/>
        r = new Report(2280);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        r.add(rolls.size());<br/>
        r.add(reasons.toString()); //international issue<br/>
        addReport(r);<br/>
        r = new Report(2285);<br/>
        r.subject = entity.getId();<br/>
        r.add(base.getValueAsString());<br/>
        r.add(base.getDesc()); //international issue<br/>
        addReport(r);<br/>
        for (int i = 0; i &lt; rolls.size(); i++) {<br/>
            PilotingRollData modifier = (PilotingRollData)rolls.elementAt(i);<br/>
            PilotingRollData target = base;<br/>
            r = new Report(2290);<br/>
            r.subject = entity.getId();<br/>
            r.indent();<br/>
            r.newlines = 0;<br/>
            r.add(i+1);<br/>
            r.add(modifier.getPlainDesc()); //international issue<br/>
            addReport(r);<br/>
            if (!modifier.isCumulative()) {<br/>
                // non-cumulative rolls only happen due to weight class adj.<br/>
                r = new Report(2295);<br/>
                r.subject = entity.getId();<br/>
                r.newlines = 0;<br/>
                r.add(modifier.getValueAsString()); //international issue<br/>
                target = new PilotingRollData(entity.getId());<br/>
                target.append(base);<br/>
                target.append(modifier);<br/>
            }<br/>
            int diceRoll = Compute.d6(2);<br/>
            r = new Report(2300);<br/>
            r.subject = entity.getId();<br/>
            r.add(target.getValueAsString());<br/>
            r.add(diceRoll);<br/>
            if (diceRoll &lt; target.getValue()) {<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
                if (moving) {<br/>
                    doEntityFallsInto( entity, src, dest, base );<br/>
                } else {<br/>
                    doEntityFall(entity, base);<br/>
                }<br/>
                return;<br/>
            } else {<br/>
                r.choose(true);<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Inflict damage on a pilot<br/>
     *<br/>
     * @param en     The &lt;code&gt;Entity&lt;/code&gt; who's pilot gets damaged.<br/>
     * @param damage The &lt;code&gt;int&lt;/code&gt; amount of damage.<br/>
     */<br/>
    private Vector damageCrew(Entity en, int damage) {<br/>
        Vector vDesc = new Vector();<br/>
        Pilot crew = en.getCrew();<br/>
<br/>
        if (!crew.isDead() &amp;&amp; !crew.isEjected() &amp;&amp; !crew.isDoomed()) {<br/>
            crew.setHits( crew.getHits() + damage );<br/>
            Report r = new Report(6025);<br/>
            r.subject = en.getId();<br/>
            r.indent(2);<br/>
            r.addDesc(en);<br/>
            r.add(crew.getName());<br/>
            r.add(damage);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            if ( Pilot.DEATH &gt; crew.getHits() ) {<br/>
                crew.setRollsNeeded( crew.getRollsNeeded() + damage );<br/>
            } else if ( !crew.isDoomed() ) {<br/>
                crew.setDoomed(true);<br/>
                vDesc.addAll( destroyEntity(en, "pilot death", true));<br/>
            }<br/>
        }<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * This checks if the mech pilot goes unconscious from the damage he has<br/>
     * taken this phase.<br/>
     */<br/>
    private void resolveCrewDamage() {<br/>
        boolean anyRolls = false;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
            if (resolveCrewDamage(e, anyRolls)) {<br/>
                anyRolls = true;<br/>
            }<br/>
        }<br/>
        if (anyRolls) {<br/>
            addNewLines();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * resolves consciousness rolls for one entity<br/>
     */<br/>
    private boolean resolveCrewDamage(Entity e, boolean anyRolls) {<br/>
        final int totalHits = e.getCrew().getHits();<br/>
        final int rollsNeeded = e.getCrew().getRollsNeeded();<br/>
        e.crew.setRollsNeeded(0);<br/>
        if (!e.isTargetable() || !e.getCrew().isActive() || rollsNeeded == 0) {<br/>
            return false;<br/>
        }<br/>
        for (int hit = totalHits - rollsNeeded + 1; hit &lt;= totalHits; hit++) {<br/>
            int rollTarget = Compute.getConsciousnessNumber( hit );<br/>
            boolean edgeUsed = false;<br/>
            do {<br/>
                if (edgeUsed)<br/>
                    e.crew.decreaseEdge();<br/>
                int roll = Compute.d6(2);<br/>
                if ( e.getCrew().getOptions().booleanOption("pain_resistance") )<br/>
                  roll = Math.min(12, roll + 1);<br/>
                Report r = new Report(6030);<br/>
                r.subject = e.getId();<br/>
                r.addDesc(e);<br/>
                r.add(e.getCrew().getName());<br/>
                r.add(rollTarget);<br/>
                r.add(roll);<br/>
                if (roll &gt;= rollTarget) {<br/>
                    e.crew.setKoThisRound(false);<br/>
                    r.choose(true);<br/>
                } else {<br/>
                    e.crew.setKoThisRound(true);<br/>
                    r.choose(false);<br/>
                    if (e.crew.hasEdgeRemaining()<br/>
                            &amp;&amp; e.crew.getOptions().booleanOption("edge_when_ko")) {<br/>
                        edgeUsed = true;<br/>
                        vPhaseReport.addElement(r);<br/>
                        r = new Report(6520);<br/>
                        r.subject = e.getId();<br/>
                        r.addDesc(e);<br/>
                        r.add(e.getCrew().getName());<br/>
                        r.add(e.crew.getOptions().intOption("edge"));<br/>
                    } // if<br/>
                    //return true;<br/>
                } // else<br/>
                addReport(r);<br/>
            } while (e.crew.hasEdgeRemaining() &amp;&amp; e.crew.isKoThisRound()<br/>
                    &amp;&amp; e.crew.getOptions().booleanOption("edge_when_ko"));<br/>
            // end of do-while<br/>
            if (e.crew.isKoThisRound()) {<br/>
                e.crew.setUnconscious(true);  <br/>
                return true;<br/>
            }<br/>
        }<br/>
        return true;<br/>
    }<br/>
<br/>
    /**<br/>
     * Make the rolls indicating whether any unconscious crews wake up<br/>
     */<br/>
    private void resolveCrewWakeUp() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
<br/>
            // only unconscious pilots of mechs and protos and MechWarrirs<br/>
            // can roll to wake up<br/>
            if ( !e.isTargetable() || !e.crew.isUnconscious() ||<br/>
                 e.crew.isKoThisRound() ||<br/>
                !(e instanceof Mech || e instanceof Protomech || e instanceof MechWarrior)) {<br/>
                continue;<br/>
            }<br/>
            int roll = Compute.d6(2);<br/>
<br/>
            if ( e.getCrew().getOptions().booleanOption("pain_resistance") )<br/>
              roll = Math.min(12, roll + 1);<br/>
<br/>
            int rollTarget = Compute.getConsciousnessNumber( e.crew.getHits() );<br/>
            Report r = new Report(6029);<br/>
            r.subject = e.getId();<br/>
            r.addDesc(e);<br/>
            r.add(e.getCrew().getName());<br/>
            r.add(rollTarget);<br/>
            r.add(roll);<br/>
            if (roll &gt;= rollTarget) {<br/>
                r.choose(true);<br/>
                e.crew.setUnconscious(false);<br/>
            } else {<br/>
                r.choose(false);<br/>
            }<br/>
            addReport(r);<br/>
        }<br/>
    }<br/>
<br/>
    public Vector damageEntity(Entity te, HitData hit, int damage, boolean ammoExplosion) {<br/>
        return damageEntity(te, hit, damage, ammoExplosion, 0, false, false);<br/>
    }<br/>
<br/>
    public Vector damageEntity(Entity te, HitData hit, int damage) {<br/>
        return damageEntity(te, hit, damage, false, 0, false, false);<br/>
    }<br/>
<br/>
    public Vector damageEntity(Entity te, HitData hit, int damage,<br/>
                               boolean ammoExplosion, int bFrag) {<br/>
        return damageEntity(te, hit, damage, ammoExplosion, bFrag,<br/>
                            false, false);<br/>
    }<br/>
<br/>
    public Vector damageEntity(Entity te, HitData hit, int damage,<br/>
                               boolean ammoExplosion, int bFrag,<br/>
                               boolean damageIS) {<br/>
        return damageEntity(te, hit, damage, ammoExplosion, bFrag,<br/>
                            damageIS, false);<br/>
    }<br/>
<br/>
    public Vector damageEntity(Entity te, HitData hit, int damage,<br/>
                               boolean ammoExplosion, int bFrag,<br/>
                               boolean damageIS, boolean areaSatArty) {<br/>
        return damageEntity (te, hit, damage, ammoExplosion, bFrag, damageIS,<br/>
                             false, true);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Deals the listed damage to an entity.  Returns a vector of Reports<br/>
     * for the phase report<br/>
     *<br/>
     * @param te the target entity<br/>
     * @param hit the hit data for the location hit<br/>
     * @param damage the damage to apply<br/>
     * @param ammoExplosion ammo explosion type damage is applied<br/>
     *          directly to the IS, hurts the pilot, causes auto-ejects,<br/>
     *          and can blow the unit to smithereens<br/>
     * @param bFrag If 0, nothing; if 1, Fragmentation; if 2, Flechette.<br/>
     * @param damageIS Should the target location's internal structure be<br/>
     *          damaged directly?<br/>
     * @param areaSatArty Is the damage from an area saturating artillery<br/>
     *          attack?<br/>
     * @param throughFront Is the damage coming through the hex the unit<br/>
     *          is facing?<br/>
     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt;s<br/>
     */<br/>
    private Vector damageEntity(Entity te, HitData hit, int damage,<br/>
                                boolean ammoExplosion, int bFrag,<br/>
                                boolean damageIS, boolean areaSatArty,<br/>
                                boolean throughFront) {<br/>
<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
        int te_n = te.getId();<br/>
        //This is good for shields if a shield absorps the hit it shouldn't<br/>
        //effect the pilot.<br/>
        boolean isHeadHit = (te instanceof Mech<br/>
            &amp;&amp; ((Mech)te).getCockpitType() != Mech.COCKPIT_TORSO_MOUNTED<br/>
            &amp;&amp; hit.getLocation() == Mech.LOC_HEAD);<br/>
        <br/>
        // show Locations which have rerolled with Edge<br/>
        HitData undoneLocation = hit.getUndoneLocation();<br/>
        while (undoneLocation != null) {<br/>
            r = new Report(6500);<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            r.addDesc(te);<br/>
            r.add(te.getLocationAbbr(undoneLocation));<br/>
            vDesc.addElement(r);            <br/>
            undoneLocation = undoneLocation.getUndoneLocation();<br/>
        } // while<br/>
        // if edge was uses, give at end overview of remainings<br/>
        if (hit.getUndoneLocation() != null) {<br/>
            r = new Report(6510);<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            r.addDesc(te);<br/>
            r.add(te.crew.getOptions().intOption("edge"));<br/>
            vDesc.addElement(r);            <br/>
        } // if<br/>
        <br/>
        boolean autoEject = false;<br/>
        if (ammoExplosion) {<br/>
            if (te instanceof Mech) {<br/>
                Mech mech = (Mech)te;<br/>
                if (mech.isAutoEject()) {<br/>
                    autoEject = true;<br/>
                    vDesc.addAll(ejectEntity(te, true));<br/>
                }<br/>
            }<br/>
        }<br/>
        boolean isBattleArmor = (te instanceof BattleArmor);<br/>
        boolean isPlatoon = !isBattleArmor &amp;&amp; (te instanceof Infantry);<br/>
        boolean isFerroFibrousTarget = false;<br/>
        boolean wasDamageIS = false;<br/>
        boolean tookInternalDamage = damageIS;<br/>
        IHex te_hex = null;<br/>
<br/>
        boolean hardenedArmor = false;<br/>
        if ((te instanceof Mech)<br/>
                &amp;&amp; (te.getArmorType() == EquipmentType.T_ARMOR_HARDENED))<br/>
            hardenedArmor = true;<br/>
        int crits = ((hit.getEffect() == HitData.EFFECT_CRITICAL) &amp;&amp; (!hardenedArmor)) ? 1 : 0;<br/>
        int specCrits = ((hit.getEffect() == HitData.EFFECT_CRITICAL) &amp;&amp; (hardenedArmor)) ? 1 : 0;<br/>
        HitData nextHit = null;<br/>
<br/>
        // Some "hits" on a Protomech are actually misses.<br/>
        if( te instanceof Protomech &amp;&amp;<br/>
            hit.getLocation() == Protomech.LOC_NMISS ) {<br/>
            r = new Report(6035);<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        // check for critical hit/miss vs. a BA<br/>
        if( crits &gt; 0 &amp;&amp; te instanceof BattleArmor) {<br/>
            //possible critical miss if the rerolled location isn't alive<br/>
            if(hit.getLocation() &gt;= te.locations()<br/>
            || te.getInternal(hit.getLocation()) &lt;= 0) {<br/>
                r = new Report(6037);<br/>
                r.add(hit.getLocation());<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
                return vDesc;<br/>
            }<br/>
            //otherwise critical hit<br/>
            r = new Report(6225);<br/>
            r.add(te.getLocationAbbr(hit));<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
<br/>
            crits = 0;<br/>
            damage = Math.max(te.getInternal(hit.getLocation()) + <br/>
                              te.getArmor(hit.getLocation()),<br/>
                              damage);<br/>
        }<br/>
<br/>
        if ((te != null) &amp;&amp;<br/>
            (te.getArmor(hit) &gt; 0) &amp;&amp;<br/>
            ((te.getArmorType() == EquipmentType.T_ARMOR_FERRO_FIBROUS) ||<br/>
             (te.getArmorType() == EquipmentType.T_ARMOR_LIGHT_FERRO) ||<br/>
             (te.getArmorType() == EquipmentType.T_ARMOR_HEAVY_FERRO))) {<br/>
            isFerroFibrousTarget = true;<br/>
        }<br/>
<br/>
        // Is the infantry in the open?<br/>
        if ( isPlatoon &amp;&amp; !te.isDestroyed() &amp;&amp; !te.isDoomed() ) {<br/>
            te_hex = game.getBoard().getHex( te.getPosition() );<br/>
            if ( te_hex != null &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.WOODS ) &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.JUNGLE ) &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.ROUGH ) &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.RUBBLE ) &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.SWAMP ) &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.BUILDING ) &amp;&amp;<br/>
                 !te_hex.containsTerrain(Terrains.FORTIFIED)) {<br/>
                // PBI.  Damage is doubled.<br/>
                damage = damage * 2;<br/>
                r = new Report(6040);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
        }<br/>
        // Is the infantry in vacuum?<br/>
        if ( (isPlatoon || isBattleArmor ) &amp;&amp; !te.isDestroyed()<br/>
                &amp;&amp; !te.isDoomed() &amp;&amp; game.getOptions().booleanOption("vacuum")) {<br/>
            // PBI. Double damage.<br/>
            damage = damage * 2;<br/>
            r = new Report(6041);<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
        }<br/>
        // If dealing with fragmentation missiles,<br/>
        // it does double damage to infantry...<br/>
        // We're actually going to abuse this for AX-head warheads, too, so as to not add another parameter.<br/>
        switch (bFrag)<br/>
        {<br/>
        case 1:<br/>
            if (isPlatoon) {<br/>
                damage *= 2;<br/>
                r = new Report(6045);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            else if (te != null) {<br/>
                damage = 0;<br/>
                r = new Report(6050);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            break;<br/>
        case 2:<br/>
            if (isPlatoon) {<br/>
                damage *= 2;<br/>
                r = new Report(6055);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            else if ((te != null) &amp;&amp; (!isBattleArmor)) {<br/>
                damage /= 2;<br/>
                r = new Report(6060);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            break;<br/>
        case 3:<br/>
            if (isFerroFibrousTarget) {<br/>
                damage = te.getArmor(hit) &gt;=3?3:te.getArmor(hit);<br/>
                r = new Report(6061);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                r.add(damage);<br/>
                vDesc.addElement(r);<br/>
            } else if (te != null) {<br/>
                r = new Report(6062);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            break;<br/>
        case 4:<br/>
            //Incendiary AC ammo does +2 damage to unarmoured infantry<br/>
            if(isPlatoon ) {<br/>
                damage += 2;<br/>
            }<br/>
            break;<br/>
<br/>
        default:<br/>
            // We can ignore this.<br/>
            break;<br/>
        }<br/>
<br/>
        //save EI status, in case sensors crit destroys it<br/>
        final boolean eiStatus = te.hasActiveEiCockpit();<br/>
        // BA using EI implants receive +1 damage from attacks<br/>
        if (!(te instanceof Mech) &amp;&amp; !(te instanceof Protomech) &amp;&amp; eiStatus) {<br/>
            damage += 1;<br/>
        }<br/>
<br/>
        // Allocate the damage<br/>
        while (damage &gt; 0) {<br/>
<br/>
            // let's resolve some damage!<br/>
            r = new Report(6065);<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            r.addDesc(te);<br/>
            r.add(damage);<br/>
            if (damageIS) r.messageId = 6070;<br/>
            r.add(te.getLocationAbbr(hit));<br/>
            vDesc.addElement(r);<br/>
<br/>
            // was the section destroyed earlier this phase?<br/>
            if (te.getInternal(hit) == IArmorState.ARMOR_DOOMED) {<br/>
                // cannot transfer a through armor crit if so<br/>
                crits = 0;<br/>
            }<br/>
<br/>
            //here goes the fun :)<br/>
            //Shields take damage first then cowls then armor whee<br/>
            //Shield does not protect from ammo explosions or falls.<br/>
            if ( !ammoExplosion &amp;&amp; !hit.isFallDamage() &amp;&amp; te.hasShield() ){<br/>
                Mech me = (Mech)te;<br/>
                int damageNew = me.shieldAbsorptionDamage(damage,hit.getLocation(),hit.isRear());<br/>
                //if a shield absorbed the damage then lets tell the world about it.<br/>
                if ( damageNew != damage){<br/>
                    int damageDiff = damage - damageNew;<br/>
                    damage = damageNew;<br/>
                    <br/>
                    r = new Report (3530);<br/>
                    r.subject = te_n;<br/>
                    r.indent(3);<br/>
                    r.newlines=0;<br/>
                    r.add(damageDiff);<br/>
                    vDesc.addElement(r);<br/>
                    <br/>
                    if ( damage &lt;= 0 ){<br/>
                        crits = 0;<br/>
                        specCrits = 0;<br/>
                        isHeadHit = false;<br/>
                    }<br/>
                        <br/>
                }<br/>
            }<br/>
            <br/>
            // Armored Cowl may absorb some damage from hit<br/>
            if (te instanceof Mech) {<br/>
                Mech me = (Mech)te;<br/>
                if (me.hasCowl() &amp;&amp; hit.getLocation()==Mech.LOC_HEAD &amp;&amp;<br/>
                    !throughFront ) {<br/>
                    int damageNew = me.damageCowl(damage);<br/>
                    int damageDiff = damage-damageNew;<br/>
                    damage = damageNew;<br/>
                    <br/>
                    r = new Report (3520);<br/>
                    r.subject = te_n;<br/>
                    r.indent(3);<br/>
                    r.newlines=0;<br/>
                    r.add(damageDiff);<br/>
                    vDesc.addElement(r);<br/>
                }<br/>
            }<br/>
            <br/>
            // Destroy searchlights on 7+ (torso hits on mechs)<br/>
            boolean spotlightHittable = false;<br/>
            if  (te.hasSpotlight()) {<br/>
                spotlightHittable = true;<br/>
                int loc = hit.getLocation();<br/>
                if (te instanceof Mech) {<br/>
                    if (loc != Mech.LOC_CT &amp;&amp; loc != Mech.LOC_LT &amp;&amp; loc != Mech.LOC_RT) {<br/>
                        spotlightHittable = false;<br/>
                    }<br/>
                } else if (te instanceof Tank) {<br/>
                    if (loc != Tank.LOC_FRONT &amp;&amp; loc != Tank.LOC_RIGHT &amp;&amp; loc != Tank.LOC_LEFT) {<br/>
                        spotlightHittable = false;<br/>
                    }<br/>
                }<br/>
                if (spotlightHittable) {<br/>
                    int spotroll = Compute.d6(2);<br/>
                    r = new Report(6072);<br/>
                    r.indent(2);<br/>
                    r.subject = te_n;<br/>
                    r.add(spotroll);<br/>
                    vDesc.addElement(r);<br/>
                    if (spotroll &gt;= 7) {<br/>
                        r = new Report(6071);<br/>
                        r.subject = te_n;<br/>
                        r.indent(2);<br/>
                        vDesc.addElement(r);<br/>
                        te.setSpotlightState(false);<br/>
                        te.setSpotlight(false);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // Does an exterior passenger absorb some of the damage?<br/>
            if (!damageIS) {<br/>
                int nLoc = hit.getLocation();<br/>
                Entity passenger = te.getExteriorUnitAt( nLoc, hit.isRear() );<br/>
                // Does an exterior passenger absorb some of the damage?<br/>
                if ( !ammoExplosion &amp;&amp; null != passenger<br/>
                        &amp;&amp; !passenger.isDoomed() ) {<br/>
                    // Yup.  Roll up some hit data for that passenger.<br/>
                    r = new Report(6075);<br/>
                    r.subject = passenger.getId();<br/>
                    r.indent(3);<br/>
                    r.addDesc(passenger);<br/>
                    vDesc.addElement(r);<br/>
<br/>
                    HitData passHit = passenger.getTrooperAtLocation<br/>
                        ( hit, te);<br/>
<br/>
                    // How much damage will the passenger absorb?<br/>
                    int absorb = 0;<br/>
                    HitData nextPassHit = passHit;<br/>
                    do {<br/>
                        if ( 0 &lt; passenger.getArmor( nextPassHit ) ) {<br/>
                            absorb += passenger.getArmor( nextPassHit );<br/>
                        }<br/>
                        if ( 0 &lt; passenger.getInternal( nextPassHit ) ) {<br/>
                            absorb += passenger.getInternal( nextPassHit );<br/>
                        }<br/>
                        nextPassHit = passenger.getTransferLocation( nextPassHit );<br/>
                    } while ( damage &gt; absorb &amp;&amp; nextPassHit.getLocation() &gt;= 0 );<br/>
<br/>
                    // Damage the passenger.<br/>
                    vDesc.addAll( damageEntity(passenger, passHit, damage));<br/>
<br/>
                    // Did some damage pass on?<br/>
                    if ( damage &gt; absorb ) {<br/>
                        // Yup.  Remove the absorbed damage.<br/>
                        damage -= absorb;<br/>
                        r = new Report(6080);<br/>
                        r.subject = te_n;<br/>
                        r.indent(1);<br/>
                        r.add(damage);<br/>
                        r.addDesc(te);<br/>
                        vDesc.addElement(r);<br/>
                    } else {<br/>
                        // Nope.  Return our description.<br/>
                        return vDesc;<br/>
                    }<br/>
<br/>
                } // End nLoc-has-exterior-passenger<br/>
<br/>
                // is this a mech dumping ammo being hit in the rear torso?<br/>
                boolean bTorso = (nLoc == Mech.LOC_CT || nLoc == Mech.LOC_RT ||<br/>
                                  nLoc == Mech.LOC_LT);<br/>
                if (te instanceof Mech &amp;&amp; hit.isRear() &amp;&amp; bTorso) {<br/>
                    for (Enumeration e = te.getAmmo(); e.hasMoreElements(); ) {<br/>
                        Mounted mAmmo = (Mounted)e.nextElement();<br/>
                        if (mAmmo.isDumping() &amp;&amp; !mAmmo.isDestroyed() &amp;&amp;<br/>
                            !mAmmo.isHit()) {<br/>
                            // doh.  explode it<br/>
                            vDesc.addAll( explodeEquipment(te, mAmmo.getLocation(), mAmmo) );<br/>
                            mAmmo.setHit(true);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // is there armor in the location hit?<br/>
            if (!ammoExplosion &amp;&amp; te.getArmor(hit) &gt; 0 &amp;&amp; !damageIS) {<br/>
                int tmpDamageHold = -1;<br/>
<br/>
                // If the target has hardened armor, we need to adjust damage.<br/>
                if (hardenedArmor) {<br/>
                    tmpDamageHold = damage;<br/>
                    damage /= 2;<br/>
                    damage += (tmpDamageHold%2);<br/>
                }<br/>
                <br/>
                if (te.getArmor(hit) &gt; damage) {<br/>
                    // armor absorbs all damage<br/>
                    te.setArmor(te.getArmor(hit) - damage, hit);<br/>
                    if (tmpDamageHold &gt;= 0)<br/>
                        te.damageThisPhase += tmpDamageHold;<br/>
                    else<br/>
                        te.damageThisPhase += damage;<br/>
                    damage = 0;<br/>
                    r = new Report(6085);<br/>
                    r.subject = te_n;<br/>
                    r.newlines = 0;<br/>
                    if(spotlightHittable)r.indent(3);<br/>
                    r.add(te.getArmor(hit));<br/>
                    vDesc.addElement(r);<br/>
                } else {<br/>
                    // damage goes on to internal<br/>
                    int absorbed = Math.max(te.getArmor(hit), 0);<br/>
                    te.setArmor(IArmorState.ARMOR_DESTROYED, hit);<br/>
                    if (tmpDamageHold &gt;= 0)<br/>
                        te.damageThisPhase += 2*absorbed;<br/>
                    else<br/>
                        te.damageThisPhase += absorbed;<br/>
                    damage -= absorbed;<br/>
                    r = new Report(6090);<br/>
                    r.subject = te_n;<br/>
                    r.newlines = 0;<br/>
                    if(spotlightHittable)r.indent(3);<br/>
                    vDesc.addElement(r);<br/>
                    if (te instanceof GunEmplacement) {<br/>
                        // gun emplacements have no internal,<br/>
                        // destroy the section<br/>
                        destroyLocation(te, hit.getLocation());<br/>
                        r = new Report(6115);<br/>
                        r.subject = te_n;<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
<br/>
                        if (te.getTransferLocation(hit).getLocation() ==<br/>
                            Entity.LOC_DESTROYED) {<br/>
                            vDesc.addAll(<br/>
                                                  destroyEntity(te,<br/>
                                                                "damage",<br/>
                                                                false));<br/>
                        }<br/>
                    }<br/>
                }<br/>
                <br/>
                // If it has hardened armor, now we need to "correct" any remaining damage.<br/>
                if (tmpDamageHold &gt; 0) {<br/>
                    if (hardenedArmor) {<br/>
                        damage *= 2;<br/>
                        damage -= (tmpDamageHold%2);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // is there damage remaining?<br/>
            if (damage &gt; 0) {<br/>
                tookInternalDamage = true;<br/>
                // is there internal structure in the location hit?<br/>
                if (te.getInternal(hit) &gt; 0) {<br/>
                    // Triggers a critical hit on Vehicles and Mechs.<br/>
                    if ( !isPlatoon &amp;&amp; !isBattleArmor ) {<br/>
                        crits++;<br/>
                    }<br/>
<br/>
                    // Now we need to consider alternate structure types!<br/>
                    int tmpDamageHold = -1;<br/>
                    if ((te instanceof Mech) &amp;&amp; (((Mech)te).hasCompositeStructure())) {<br/>
                        tmpDamageHold = damage;<br/>
                        damage *= 2;<br/>
                    }<br/>
                    if ((te instanceof Mech) &amp;&amp; (((Mech)te).hasReinforcedStructure())) {<br/>
                        tmpDamageHold = damage;<br/>
                        damage /= 2;<br/>
                        damage += (tmpDamageHold%2);<br/>
                    }<br/>
<br/>
                    if (te.getInternal(hit) &gt; damage) {<br/>
                        // internal structure absorbs all damage<br/>
                        te.setInternal(te.getInternal(hit) - damage, hit);<br/>
                        te.damageThisPhase += damage;<br/>
                        damage = 0;<br/>
                        r = new Report(1210);<br/>
                        r.subject = te_n;<br/>
                        r.newlines = 0;<br/>
                        // Infantry platoons have men not "Internals".<br/>
                        if ( isPlatoon ) {<br/>
                            r.messageId = 6095;<br/>
                        } else {<br/>
                            r.messageId = 6100;<br/>
                        }<br/>
                        r.add(te.getInternal(hit));<br/>
                        vDesc.addElement(r);<br/>
                    } else {<br/>
                        // damage transfers, maybe<br/>
                        int absorbed = Math.max(te.getInternal(hit), 0);<br/>
<br/>
                        // Handle Protomech pilot damage<br/>
                        // due to location destruction<br/>
                        if ( te instanceof Protomech ) {<br/>
                            int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()] -<br/>
                                ((Protomech)te).getPilotDamageTaken(hit.getLocation());<br/>
                            if ( hits &gt; 0 ) {<br/>
                                vDesc.addAll( damageCrew( te, hits ));<br/>
                                ((Protomech)te).setPilotDamageTaken<br/>
                                     (hit.getLocation(),<br/>
                                      Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]);<br/>
                            }<br/>
                        }<br/>
<br/>
                        // Platoon, Trooper, or Section destroyed message<br/>
                        r = new Report(1210);<br/>
                        r.subject = te_n;<br/>
                        r.newlines = 0;<br/>
                        if ( isPlatoon ) {<br/>
                            // Infantry have only one section, and<br/>
                            //  are therefore destroyed.<br/>
                            r.messageId = 6105;<br/>
                        } else if ( isBattleArmor ) {<br/>
                            r.messageId = 6110;<br/>
                        } else {<br/>
                            r.messageId = 6115;<br/>
                        }<br/>
                        vDesc.addElement(r);<br/>
<br/>
                        // If a sidetorso got destroyed, and the<br/>
                        // corresponding arm is not yet destroyed, add<br/>
                        // it as a club to that hex (p.35 BMRr)<br/>
                        if (te instanceof Mech &amp;&amp;<br/>
                            ((hit.getLocation() == Mech.LOC_RT &amp;&amp;<br/>
                              te.getInternal(Mech.LOC_RARM) &gt; 0) ||<br/>
                             (hit.getLocation() == Mech.LOC_LT &amp;&amp;<br/>
                              te.getInternal(Mech.LOC_LARM) &gt; 0))) {<br/>
                            int blownOffLocation = -1; //good initial value?<br/>
                            if (hit.getLocation() == Mech.LOC_RT) {<br/>
                                blownOffLocation = Mech.LOC_RARM;<br/>
                            } else {<br/>
                                blownOffLocation = Mech.LOC_LARM;<br/>
                            }<br/>
                            r = new Report(6120);<br/>
                            r.subject = te_n;<br/>
                            r.add(te.getLocationName(blownOffLocation));<br/>
                            r.newlines = 0;<br/>
                            vDesc.addElement(r);<br/>
                            IHex h = game.getBoard().getHex(te.getPosition());<br/>
                            if (te instanceof BipedMech) {<br/>
                                if (!h.containsTerrain( Terrains.ARMS)) {<br/>
                                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ARMS, 1));<br/>
                                }<br/>
                                else h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ARMS, h.terrainLevel(Terrains.ARMS)+1));<br/>
                            } else if (!h.containsTerrain( Terrains.LEGS)) {<br/>
                                h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.LEGS, 1));<br/>
                            } else h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.LEGS, h.terrainLevel(Terrains.LEGS)+1));<br/>
                            sendChangedHex(te.getPosition());<br/>
                        }<br/>
<br/>
                        // Level 3 mechanized BA, troopers riding on a location <br/>
                        // all die when the location is destroyed.<br/>
                        if(game.getOptions().booleanOption("maxtech_mechanized_ba") &amp;&amp;<br/>
                           te instanceof Mech) {<br/>
                            Entity passenger = te.getExteriorUnitAt( hit.getLocation(), hit.isRear() );<br/>
                            if(null != passenger &amp;&amp; !passenger.isDoomed()) {<br/>
                                HitData passHit = passenger.getTrooperAtLocation( hit, te);<br/>
                                passHit.setEffect(HitData.EFFECT_CRITICAL); //ensures a kill<br/>
                                if(passenger.getInternal(passHit) &gt; 0) {<br/>
                                    vDesc.addAll(damageEntity(passenger, passHit, damage));<br/>
                                }<br/>
                                passHit = new HitData(hit.getLocation(), !(hit.isRear()));<br/>
                                passHit = passenger.getTrooperAtLocation( passHit, te);<br/>
                                passHit.setEffect(HitData.EFFECT_CRITICAL); //ensures a kill<br/>
                                if(passenger.getInternal(passHit) &gt; 0) {<br/>
                                    vDesc.addAll(damageEntity(passenger, passHit, damage));<br/>
                                }<br/>
                            }<br/>
                        }<br/>
<br/>
                        // Destroy the location.<br/>
                        destroyLocation(te, hit.getLocation());<br/>
                        te.damageThisPhase += absorbed;<br/>
                        damage -= absorbed;<br/>
<br/>
                        // Now we need to consider alternate structure types!<br/>
                        if (tmpDamageHold &gt; 0) {<br/>
                            if (((Mech)te).hasCompositeStructure()) {<br/>
                                // If there's a remainder, we can actually ignore it.<br/>
                                damage /= 2;<br/>
                            } else if (((Mech)te).hasReinforcedStructure()) {<br/>
                                damage *= 2;<br/>
                                damage -= (tmpDamageHold%2);<br/>
                            }<br/>
                        }<br/>
<br/>
                        if (te instanceof Mech &amp;&amp;<br/>
                            (hit.getLocation() == Mech.LOC_RT ||<br/>
                             hit.getLocation() == Mech.LOC_LT)) {<br/>
<br/>
                            boolean engineExploded = false;<br/>
<br/>
<br/>
                            int numEngineHits = 0;<br/>
                            numEngineHits +=<br/>
                                te.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                                                   Mech.SYSTEM_ENGINE,<br/>
                                                   Mech.LOC_CT);<br/>
                            numEngineHits +=<br/>
                                te.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                                                   Mech.SYSTEM_ENGINE,<br/>
                                                   Mech.LOC_RT);<br/>
                            numEngineHits +=<br/>
                                te.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                                                   Mech.SYSTEM_ENGINE,<br/>
                                                   Mech.LOC_LT);<br/>
<br/>
                            engineExploded = checkEngineExplosion(te, vDesc, numEngineHits);<br/>
                            if ( !engineExploded &amp;&amp; numEngineHits &gt; 2  ) {<br/>
                                // third engine hit<br/>
                                vDesc.addAll( destroyEntity(te, "engine destruction"));<br/>
                                if ( game.getOptions().booleanOption("auto_abandon_unit") )<br/>
                                    vDesc.addAll(abandonEntity(te));<br/>
<br/>
                            }<br/>
                        }<br/>
                        <br/>
                        if (te instanceof VTOL &amp;&amp; hit.getLocation() == VTOL.LOC_ROTOR) {<br/>
                            //if rotor is destroyed, movement goes bleh.<br/>
                            //I think this will work?<br/>
                            hit.setEffect(HitData.EFFECT_VEHICLE_MOVE_DESTROYED);<br/>
                            <br/>
                        }<br/>
                    }<br/>
                } if (te.getInternal(hit) &lt;= 0) {<br/>
                    // internal structure is gone, what are the transfer potentials?<br/>
                    nextHit = te.getTransferLocation(hit);<br/>
                    if (nextHit.getLocation() == Entity.LOC_DESTROYED) {<br/>
                        if (te instanceof Mech) {<br/>
                            // add all non-destroyed engine crits<br/>
                            te.engineHitsThisRound += te.getGoodCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, hit.getLocation());<br/>
                            // and substract those that where hit previously this round<br/>
                            // hackish, but works.<br/>
                            te.engineHitsThisRound -= te.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, hit.getLocation());<br/>
                        }<br/>
<br/>
                        boolean engineExploded = false;<br/>
<br/>
                        engineExploded = checkEngineExplosion(te, vDesc, te.engineHitsThisRound);<br/>
<br/>
                        if ( !engineExploded &amp;&amp; !((te instanceof VTOL) &amp;&amp; hit.getLocation() == VTOL.LOC_ROTOR)) {<br/>
                            // Entity destroyed.  Ammo explosions are<br/>
                            // neither survivable nor salvagable.<br/>
                            // Only ammo explosions in the CT are devastating.<br/>
                            vDesc.addAll( destroyEntity( te, "damage",<br/>
                                                      !ammoExplosion,<br/>
                                                      !( (ammoExplosion || areaSatArty) &amp;&amp;<br/>
                                                         hit.getLocation() ==<br/>
                                                         Mech.LOC_CT ) ) );<br/>
                            // If the head is destroyed, kill the crew.<br/>
                            if (hit.getLocation() == Mech.LOC_HEAD ||<br/>
                                (hit.getLocation() == Mech.LOC_CT &amp;&amp; ((ammoExplosion &amp;&amp; !autoEject) || areaSatArty))) {<br/>
                                te.getCrew().setDoomed(true);<br/>
                            }<br/>
                            if (game.getOptions().booleanOption("auto_abandon_unit")) {<br/>
                                vDesc.addAll(abandonEntity(te));<br/>
                            }<br/>
                        }<br/>
<br/>
                        // nowhere for further damage to go<br/>
                        damage = 0;<br/>
                    } else if ( nextHit.getLocation() == Entity.LOC_NONE ) {<br/>
                        // Rest of the damage is wasted.<br/>
                        damage = 0;<br/>
                    } else if (ammoExplosion &amp;&amp; te.locationHasCase(hit.getLocation())) {<br/>
                        // Remaining damage prevented by CASE<br/>
                        r = new Report(6125);<br/>
                        r.subject = te_n;<br/>
                        r.add(damage);<br/>
                        r.indent(3);<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
<br/>
                        // ... but page 21 of the Ask The Precentor Martial FAQ<br/>
                        // www.classicbattletech.com/PDF/AskPMForumArchiveandFAQ.pdf<br/>
                        // says that the damage counts for making PSRs.<br/>
                        te.damageThisPhase += damage;<br/>
<br/>
                        // The target takes no more damage from the explosion.<br/>
                        damage = 0;<br/>
                    } else if (damage &gt; 0) {<br/>
                        // remaining damage transfers<br/>
                        r = new Report(6130);<br/>
                        r.subject = te_n;<br/>
                        r.indent(2);<br/>
                        r.newlines = 0;<br/>
                        r.add(damage);<br/>
                        r.add(te.getLocationAbbr(nextHit));<br/>
                        vDesc.addElement(r);<br/>
<br/>
                        // If there are split weapons in this location, mark it as<br/>
                        // destroyed, even if it took no criticals.<br/>
                        for (Enumeration weapons=te.getWeapons(); weapons.hasMoreElements(); ) {<br/>
                            Mounted m = (Mounted)weapons.nextElement();<br/>
                            if (m.isSplit()) {<br/>
                                if (m.getLocation() == hit.getLocation() ||<br/>
                                    m.getLocation() == nextHit.getLocation()) {<br/>
                                    te.setWeaponDestroyed(m);<br/>
                                }<br/>
                            }<br/>
                        }<br/>
                    }<br/>
                }<br/>
            } else if (hit.getSpecCritMod() &lt; 0) {<br/>
                // If there ISN'T any armor left but we did damage, then there's a chance of a crit, using Armor Piercing.<br/>
                specCrits++;<br/>
            }<br/>
            // check for breaching<br/>
            vDesc.addAll( breachCheck(te, hit.getLocation(), null));<br/>
<br/>
            // resolve special results<br/>
            if (hit.getEffect() == HitData.EFFECT_VEHICLE_MOVE_DAMAGED) {<br/>
                r = new Report(6135);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                int nMP = te.getOriginalWalkMP();<br/>
                if (nMP &gt; 0) {<br/>
                    te.setOriginalWalkMP(nMP - 1);<br/>
<br/>
                    if (te.getOriginalWalkMP()==0) {<br/>
                        // From http://www.classicbattletech.com/PDF/AskPMForumArchiveandFAQ.pdf<br/>
                        // page 19, tanks are only immobile if they take that critical hit.<br/>
                        // ((Tank)te).immobilize();<br/>
<br/>
                        // Hovercraft reduced to 0MP over water sink<br/>
                        if ( te.getMovementMode() == IEntityMovementMode.HOVER &amp;&amp;<br/>
                             game.getBoard().getHex( te.getPosition() ).terrainLevel(Terrains.WATER) &gt; 0 <br/>
                             &amp;&amp;!(game.getBoard().getHex( te.getPosition() ).containsTerrain(Terrains.ICE))) {<br/>
                            vDesc.addAll( destroyEntity(te, "a watery grave", false) );<br/>
                        }<br/>
                    }<br/>
                }<br/>
            } else if (hit.getEffect() == HitData.EFFECT_VEHICLE_MOVE_DESTROYED) {<br/>
                r = new Report(6140);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                ((Tank)te).immobilize();<br/>
                // Does the hovercraft sink?<br/>
                te_hex = game.getBoard().getHex( te.getPosition() );<br/>
                if ( te.getMovementMode() == IEntityMovementMode.HOVER &amp;&amp;<br/>
                     te_hex.terrainLevel(Terrains.WATER) &gt; 0 &amp;&amp;<br/>
                     !(te_hex.containsTerrain(Terrains.ICE))) {<br/>
                    vDesc.addAll( destroyEntity(te, "a watery grave", false) );<br/>
                }<br/>
                if(te instanceof VTOL) {<br/>
                    Report.addNewline(vDesc);<br/>
                    //report problem: add tab<br/>
                    vDesc.addAll( crashVTOL((VTOL)te));<br/>
                }<br/>
            } else if (hit.getEffect() == HitData.EFFECT_VEHICLE_TURRETLOCK) {<br/>
                r = new Report(6145);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                ((Tank)te).lockTurret();<br/>
            }<br/>
            else if (hit.getEffect() ==<br/>
                     HitData.EFFECT_GUN_EMPLACEMENT_WEAPONS) {<br/>
                r = new Report(6146);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                Enumeration weapons = te.getWeapons();<br/>
                while (weapons.hasMoreElements()) {<br/>
                    ((Mounted) weapons.nextElement()).setDestroyed(true);<br/>
                }<br/>
            }<br/>
            else if (hit.getEffect() == HitData.EFFECT_GUN_EMPLACEMENT_TURRET) {<br/>
                r = new Report(6147);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                ((GunEmplacement)te).setTurretLocked(true);<br/>
            }<br/>
            else if (hit.getEffect() == HitData.EFFECT_GUN_EMPLACEMENT_CREW) {<br/>
                r = new Report(6148);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                ((GunEmplacement)te).getCrew().setDoomed(true);<br/>
            }<br/>
            // roll all critical hits against this location<br/>
            // unless the section destroyed in a previous phase?<br/>
            if (te.getInternal(hit) != IArmorState.ARMOR_DESTROYED) {<br/>
                for (int i = 0; i &lt; crits; i++) {<br/>
                    ((Report) vDesc.elementAt(vDesc.size() - 1)).newlines++;<br/>
                    vDesc.addAll( criticalEntity(te, hit.getLocation(), hit.glancingMod()) );<br/>
                }<br/>
                crits = 0;<br/>
<br/>
                for (int i = 0; i &lt; specCrits; i++) {<br/>
                    ((Report) vDesc.elementAt(vDesc.size() - 1)).newlines++;<br/>
                    vDesc.addAll( criticalEntity(te, hit.getLocation(), (hardenedArmor?-2:hit.getSpecCritMod())+hit.glancingMod()) );<br/>
                }<br/>
                specCrits = 0;<br/>
            }<br/>
<br/>
            if (isHeadHit) {<br/>
                Report.addNewline(vDesc);<br/>
                vDesc.addAll( damageCrew(te, 1) );<br/>
            }<br/>
<br/>
            // loop to next location<br/>
            hit = nextHit;<br/>
            if (damageIS) {<br/>
                wasDamageIS = true;<br/>
                damageIS = false;<br/>
            }<br/>
        }<br/>
        //Mechs using EI implants take pilot damage each time a hit <br/>
        //inflicts IS damage<br/>
        if (tookInternalDamage<br/>
                &amp;&amp; ((te instanceof Mech) || (te instanceof Protomech))<br/>
                &amp;&amp; te.hasActiveEiCockpit()) {<br/>
            Report.addNewline(vDesc);<br/>
            int roll = Compute.d6(2);<br/>
            r = new Report(5075);<br/>
            r.subject = te.getId();<br/>
            r.addDesc(te);<br/>
            r.add(7);<br/>
            r.add(roll);<br/>
            r.choose(roll&gt;=7);<br/>
            r.indent(2);<br/>
            vDesc.add(r);<br/>
            if(roll &lt; 7) {<br/>
                vDesc.addAll( damageCrew(te, 1) );<br/>
            }<br/>
        }<br/>
<br/>
        //damage field guns on infantry platoons if there arent enough men left to man it<br/>
        if(isPlatoon) {<br/>
            float tons = 0.0f;<br/>
            for(Enumeration&lt;Mounted&gt; weapons = te.getWeapons();weapons.hasMoreElements();) {<br/>
                Mounted weap = weapons.nextElement();<br/>
                WeaponType wtype = (WeaponType)weap.getType();<br/>
                if(!wtype.hasFlag(WeaponType.F_INFANTRY)) {<br/>
                    tons += wtype.getTonnage(te);<br/>
                    if(tons &gt; te.getInternal(Infantry.LOC_INFANTRY)) {<br/>
                        weap.setDestroyed(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        //This flag indicates the hit was directly to IS<br/>
        if (wasDamageIS) {<br/>
            Report.addNewline(vDesc);<br/>
        }<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Check to see if the entity's engine explodes.  <br/>
     * Rules for ICE explosions are different to fusion engines.<br/>
     * @param   en - the &lt;code&gt;Entity&lt;/code&gt; in question.<br/>
     *          This value must not be &lt;code&gt;null&lt;/code&gt;.<br/>
     * @param   vDesc - the &lt;code&gt;Vector&lt;/code&gt; that this function should<br/>
     *          add its &lt;code&gt;Report&lt;code&gt;s to.  It may be empty, but not<br/>
     *          &lt;code&gt;null&lt;/code&gt;.<br/>
     * @param   hits - the number of criticals on the engine<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the unit's engine exploded,<br/>
     *          &lt;code&gt;false&lt;/code&gt; if not.<br/>
     */<br/>
    private boolean checkEngineExplosion(Entity en, Vector vDesc, int hits) {<br/>
        if (!(en instanceof Mech)<br/>
                &amp;&amp; !(en instanceof QuadMech)<br/>
                &amp;&amp; !(en instanceof BipedMech)) {<br/>
            return false;<br/>
        }<br/>
        if(en.isDoomed() || en.isDestroyed())<br/>
            return false;<br/>
        Mech mech = (Mech)en;<br/>
<br/>
        //ICE can always explode and roll every time hit<br/>
        if (mech.getEngine().isFusion()<br/>
                &amp;&amp; (!game.getOptions().booleanOption("engine_explosions")<br/>
                    || en.rolledForEngineExplosion<br/>
                    || en.engineHitsThisRound &lt; 2) )<br/>
            return false;<br/>
        int explosionBTH = 12;<br/>
        if(!mech.getEngine().isFusion()) {<br/>
            switch (hits) {<br/>
                case 0: <br/>
                    return false;<br/>
                case 1:<br/>
                    explosionBTH = 10;<br/>
                    break;<br/>
                case 2:<br/>
                    explosionBTH = 7;<br/>
                    break;<br/>
                case 3:<br/>
                default:<br/>
                    explosionBTH = 4;<br/>
                    break;<br/>
            }<br/>
        }<br/>
        int explosionRoll = Compute.d6(2);<br/>
        boolean didExplode = explosionRoll &gt;= explosionBTH;<br/>
<br/>
        Report r;<br/>
        r = new Report(6150);<br/>
        r.subject = en.getId();<br/>
        r.indent(2);<br/>
        r.addDesc(en);<br/>
        r.add(en.engineHitsThisRound);<br/>
        vDesc.addElement(r);<br/>
        r = new Report(6155);<br/>
        r.subject = en.getId();<br/>
        r.indent(2);<br/>
        r.add(explosionBTH);<br/>
        r.add(explosionRoll);<br/>
        vDesc.addElement(r);<br/>
        en.rolledForEngineExplosion = true;<br/>
<br/>
        if ( !didExplode ) {<br/>
            //whew!<br/>
            r = new Report(6160);<br/>
            r.subject = en.getId();<br/>
            r.indent(2);<br/>
            vDesc.addElement(r);<br/>
        } else {<br/>
            r = new Report(6165, Report.PUBLIC);<br/>
            r.subject = en.getId();<br/>
            r.indent(2);<br/>
            vDesc.addElement(r);<br/>
            vDesc.addAll( destroyEntity(en, "engine explosion", false, false));<br/>
            //kill the crew<br/>
            en.getCrew().setDoomed(true);<br/>
<br/>
            //This is a hack so MM.NET marks the mech as not salvageable<br/>
            if ( en instanceof Mech )<br/>
                destroyLocation(en, Mech.LOC_CT);<br/>
<br/>
            //Light our hex on fire<br/>
            final IHex curHex = game.getBoard().getHex(en.getPosition());<br/>
<br/>
            if ((null != curHex)<br/>
                    &amp;&amp; !curHex.containsTerrain(Terrains.FIRE)<br/>
                    &amp;&amp; (curHex.containsTerrain(Terrains.WOODS)<br/>
                    || curHex.containsTerrain(Terrains.JUNGLE))) {<br/>
                curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                r = new Report(6170, Report.PUBLIC);<br/>
                r.subject = en.getId();<br/>
                r.indent(2);<br/>
                r.add(en.getPosition().getBoardNum());<br/>
                vDesc.addElement(r);<br/>
                sendChangedHex(en.getPosition());<br/>
            }<br/>
          <br/>
            //ICE explosions don't hurt anyone else, but fusion do<br/>
            if (mech.getEngine().isFusion()) {<br/>
                //Nuke anyone that is in our hex<br/>
                Enumeration entitesWithMe = game.getEntities(en.getPosition());<br/>
                Hashtable entitesHit = new Hashtable();<br/>
<br/>
                entitesHit.put(en, en);<br/>
    <br/>
                while (entitesWithMe.hasMoreElements()) {<br/>
                    Entity entity = (Entity)entitesWithMe.nextElement();<br/>
                    if ( entity.equals(en) )<br/>
                        continue;<br/>
                    vDesc.addAll( destroyEntity(entity, "engine explosion proximity", false, false));<br/>
                    // Kill the crew<br/>
                    entity.getCrew().setDoomed(true);<br/>
                    entitesHit.put(entity, entity);<br/>
                }<br/>
    <br/>
                //Now we damage people near us<br/>
                int engineRating = en.getEngine().getRating();<br/>
                int[] damages = { 999, (engineRating / 10), (engineRating / 20), (engineRating / 40) };<br/>
                Vector entites = game.getEntitiesVector();<br/>
                for (int i = 0; i &lt; entites.size(); i++) {<br/>
                    Entity entity = (Entity)entites.elementAt(i);<br/>
    <br/>
                    if (entitesHit.containsKey(entity))<br/>
                        continue;<br/>
    <br/>
                    if ( entity.isDoomed() || entity.isDestroyed() || !entity.isDeployed() )<br/>
                        continue;<br/>
<br/>
                    int range = en.getPosition().distance(entity.getPosition());<br/>
<br/>
                    if ( range &gt; 3 )<br/>
                        continue;<br/>
<br/>
                    int damage = damages[range];<br/>
<br/>
                    r = new Report(6175);<br/>
                    r.subject = entity.getId();<br/>
                    r.indent(2);<br/>
                    r.addDesc(entity);<br/>
                    r.add(damage);<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
<br/>
                    while (damage &gt; 0) {<br/>
                        int cluster = Math.min(5, damage);<br/>
                        HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, Compute.targetSideTable(en, entity));<br/>
                        vDesc.addAll( damageEntity(entity, hit, cluster));<br/>
                        damage -= cluster;<br/>
                    }<br/>
                    Report.addNewline(vDesc);<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        return didExplode;<br/>
    }<br/>
<br/>
    /**<br/>
     * Apply a single critical hit.<br/>
     *<br/>
     * The following private member of Server are accessed from this function,<br/>
     * preventing it from being factored out of the Server class:<br/>
     * destroyEntity()<br/>
     * destroyLocation()<br/>
     * checkEngineExplosion()<br/>
     * damageCrew()<br/>
     * explodeEquipment()<br/>
     * game<br/>
     *<br/>
     * @param   en the &lt;code&gt;Entity&lt;/code&gt; that is being damaged.<br/>
     *          This value may not be &lt;code&gt;null&lt;/code&gt;.<br/>
     * @param   loc the &lt;code&gt;int&lt;/code&gt; location of critical hit.<br/>
     *          This value may be &lt;code&gt;Entity.NONE&lt;/code&gt; for hits<br/>
     *          to &lt;code&gt;Tank&lt;/code&gt;s and for hits to a &lt;code&gt;Protomech&lt;/code&gt;<br/>
     *          torso weapon.<br/>
     * @param   cs the &lt;code&gt;CriticalSlot&lt;/code&gt; being damaged.<br/>
     *          This value may not be &lt;code&gt;null&lt;/code&gt;.<br/>
     *          For critical hits on a &lt;code&gt;Tank&lt;/code&gt;, the index of<br/>
     *          the slot should be the index of the critical hit table.<br/>
     * @param   secondaryEffects the &lt;code&gt;boolean&lt;/code&gt; flag that indicates<br/>
     *          whether to allow critical hits to cause secondary effects (such<br/>
     *          as triggering an ammo explosion, sending hovercraft to watery<br/>
     *          graves, or damaging Protomech torso weapons). This value is<br/>
     *          normally &lt;code&gt;true&lt;/code&gt;, but it will be &lt;code&gt;false&lt;/code&gt;<br/>
     *          when the hit is being applied from a saved game or scenario.<br/>
     */<br/>
    public Vector applyCriticalHit( Entity en, int loc, CriticalSlot cs,<br/>
                                     boolean secondaryEffects ) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // Handle hits on "critical slots" of tanks.<br/>
        if ( en instanceof Tank ) {<br/>
            Tank tank = (Tank)en;<br/>
            VTOL vtol = null;<br/>
            if (en instanceof VTOL)<br/>
                vtol = (VTOL)en;<br/>
            r = new Report(6180);<br/>
            r.subject = en.getId();<br/>
            r.indent(3);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            switch ( cs.getIndex() ) {<br/>
                case 1 : //crew stunned, or killed if VTOL<br/>
                    if (vtol == null) {<br/>
                        r = new Report(6185);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        // Carried units can't unload from a stunned transport.<br/>
                        // Units that escape a transport don't need to un-stun.<br/>
                        tank.stunCrew();<br/>
                    } else { //VTOL's suffer crew death instead<br/>
                        r = new Report(6190);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        vDesc.addAll(<br/>
                                              destroyEntity(vtol, "crew death", true));<br/>
                        en.getCrew().setDoomed(true);<br/>
                        vDesc.addAll( crashVTOL(vtol));<br/>
                    }<br/>
                    break;<br/>
                case 2 : //this one's ridiculous.  the 'main weapon' jams.<br/>
                    Mounted mWeap = tank.getMainWeapon();<br/>
                    if (mWeap == null) { //no main weapon, no crit<br/>
                        r = new Report(6195);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                    }<br/>
                    else {<br/>
                        r = new Report(6200);<br/>
                        r.subject = en.getId();<br/>
                        r.add(mWeap.getName());<br/>
                        int jamTurns = tank.getJammedTurns() + 1;<br/>
                        if ( jamTurns &gt; 1 ) {<br/>
                            r.messageId = 6205;<br/>
                            r.add(jamTurns);<br/>
                        }<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        tank.setJammedTurns( jamTurns );<br/>
                    }<br/>
                    break;<br/>
                case 3 : //engine destroyed<br/>
                    r = new Report(6210);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    tank.immobilize();<br/>
                    // Does the hovercraft sink?<br/>
                    // Sinking immobile hovercraft is a secondary effect<br/>
                    // and does not occur when loading from a scenario.<br/>
                    if ( secondaryEffects ) {<br/>
                        IHex te_hex = game.getBoard().getHex( en.getPosition() );<br/>
                        if (vtol == null) {<br/>
                            if ( en.getMovementMode() == IEntityMovementMode.HOVER<br/>
                                 &amp;&amp; te_hex.terrainLevel(Terrains.WATER) &gt; 0<br/>
                                 &amp;&amp; !(te_hex.containsTerrain(Terrains.ICE))) {<br/>
                                vDesc.addAll(<br/>
                                                      destroyEntity(en,"a watery grave", false));<br/>
                            }<br/>
                        } else { //VTOLs may land or crash<br/>
                            //TODO: Nothing if VTOL is landed.  If over clear,<br/>
                            // paved, rough, or building, VTOL must make PSR<br/>
                            // to land or crash.  Other terrain is automatic<br/>
                            // crash.<br/>
                            Report.addNewline(vDesc);<br/>
                            //report problem: add 3 tabs<br/>
                            vDesc.addAll( crashVTOL(vtol));<br/>
                        }<br/>
                    }<br/>
                    break;<br/>
                case 4 : //crew killed<br/>
                    r = new Report(6190);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    vDesc.addAll(<br/>
                        destroyEntity(en, "crew death", true));<br/>
                    en.getCrew().setDoomed(true);<br/>
                    if (vtol != null) { //VTOL's crash too<br/>
                        Report.addNewline(vDesc);<br/>
                        //report problem: add 3 tabs<br/>
                        vDesc.addAll( crashVTOL(vtol));<br/>
                    }<br/>
                    break;<br/>
                case 5 : //fuel tank/engine shielding, vehicle explodes<br/>
                    r = new Report(6215);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    if (vtol == null) {<br/>
                        vDesc.addAll(destroyEntity(en, "fuel tank explosion", false, false));<br/>
                    } else { //VTOL's explode and scatter burning fuel<br/>
                        Report.addNewline(vDesc);<br/>
                        //report problem: add 3 tabs<br/>
                        vDesc.addAll( explodeVTOL(vtol));<br/>
                    }<br/>
                    en.getCrew().setDoomed(true);<br/>
                    break;<br/>
                case 6 : //power plant hit, vehicle explodes<br/>
                    r = new Report(6220);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    boolean hasCASE = en.locationHasCase(Tank.LOC_BODY);<br/>
                    if (vtol == null) {<br/>
                        vDesc.addAll(destroyEntity(en, "power plant destruction", hasCASE, hasCASE));<br/>
                    } else { //VTOL's explode and scatter burning fuel<br/>
                        Report.addNewline(vDesc);<br/>
                        //report problem: add 3 tabs<br/>
                        vDesc.addAll( explodeVTOL(vtol));<br/>
                    }<br/>
                    en.getCrew().setDoomed(!hasCASE);<br/>
                    break;<br/>
            }<br/>
<br/>
        } // End entity-is-tank<br/>
<br/>
        // Handle critical hits on system slots.<br/>
        else if ( CriticalSlot.TYPE_SYSTEM == cs.getType() ) {<br/>
            cs.setHit(true);<br/>
            if (en instanceof Protomech) {<br/>
                int numHit=((Protomech)en).getCritsHit(loc);<br/>
                if ( cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_A &amp;&amp;<br/>
                     cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_B ) {<br/>
                    r = new Report(6225);<br/>
                    r.subject = en.getId();<br/>
                    r.indent(3);<br/>
                    r.newlines = 0;<br/>
                    r.add(Protomech.systemNames[cs.getIndex()]);<br/>
                    vDesc.addElement(r);<br/>
                }<br/>
                switch (cs.getIndex()) {<br/>
                case Protomech.SYSTEM_HEADCRIT:<br/>
                    if (2==numHit) {<br/>
                        r = new Report(6230);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        destroyLocation(en, loc);<br/>
                    }<br/>
                    break;<br/>
                case Protomech.SYSTEM_ARMCRIT:<br/>
                    if (2==numHit) {<br/>
                        r = new Report(6235);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        destroyLocation(en,loc);<br/>
                    }<br/>
                    break;<br/>
                case Protomech.SYSTEM_LEGCRIT:<br/>
                    if (3==numHit) {<br/>
                        r = new Report(6240);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        destroyLocation(en,loc);<br/>
                    }<br/>
                    break;<br/>
                case Protomech.SYSTEM_TORSOCRIT:<br/>
                    if (3==numHit) {<br/>
                        vDesc.addAll(<br/>
                            destroyEntity(en, "torso destruction"));<br/>
                    }<br/>
                    // Torso weapon hits are secondary effects and<br/>
                    // do not occur when loading from a scenario.<br/>
                    else if ( secondaryEffects ) {<br/>
                        int tweapRoll=Compute.d6(1);<br/>
                        CriticalSlot newSlot = null;<br/>
                        switch (tweapRoll) {<br/>
                        case 1:<br/>
                        case 2:<br/>
                            newSlot = new CriticalSlot<br/>
                                ( CriticalSlot.TYPE_SYSTEM,<br/>
                                  Protomech.SYSTEM_TORSO_WEAPON_A );<br/>
                            vDesc.addAll(<br/>
                                applyCriticalHit(en, Entity.NONE,<br/>
                                                  newSlot, secondaryEffects));<br/>
                            break;<br/>
                        case 3:<br/>
                        case 4:<br/>
                            newSlot = new CriticalSlot<br/>
                                ( CriticalSlot.TYPE_SYSTEM,<br/>
                                  Protomech.SYSTEM_TORSO_WEAPON_B );<br/>
                            vDesc.addAll(<br/>
                                applyCriticalHit(en, Entity.NONE,<br/>
                                                  newSlot, secondaryEffects));<br/>
                            break;<br/>
                        case 5:<br/>
                        case 6:<br/>
                            //no effect<br/>
                        }<br/>
                    }<br/>
                    break;<br/>
                case Protomech.SYSTEM_TORSO_WEAPON_A:<br/>
                    Mounted weaponA =( (Protomech) en ).getTorsoWeapon(true);<br/>
                    if ( null != weaponA ) {<br/>
                        weaponA.setHit(true);<br/>
                        r = new Report(6245);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                    }<br/>
                    break;<br/>
                case Protomech.SYSTEM_TORSO_WEAPON_B:<br/>
                    Mounted weaponB = ( (Protomech) en ).getTorsoWeapon(false);<br/>
                    if ( null != weaponB ) {<br/>
                        weaponB.setHit(true);<br/>
                        r = new Report(6250);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                    }<br/>
                    break;<br/>
<br/>
<br/>
                } // End switch( cs.getType() )<br/>
<br/>
                // Shaded hits cause pilot damage.<br/>
                if ( ((Protomech)en).shaded(loc, numHit) ) {<br/>
                    // Destroyed Protomech sections have<br/>
                    // already damaged the pilot.<br/>
                    int pHits =<br/>
                        Protomech.POSSIBLE_PILOT_DAMAGE[ loc ] -<br/>
                        ((Protomech)en).getPilotDamageTaken( loc );<br/>
                    if (  Math.min(1, pHits) &gt; 0 ) {<br/>
                        Report.addNewline(vDesc);<br/>
                        vDesc.addAll(<br/>
                                              damageCrew(en, 1));<br/>
                        pHits = 1 + ((Protomech)en)<br/>
                            .getPilotDamageTaken( loc );<br/>
                        ((Protomech)en).setPilotDamageTaken<br/>
                            ( loc, pHits );<br/>
                    }<br/>
                } // End have-shaded-hit<br/>
<br/>
            } // End entity-is-protomech<br/>
            else {<br/>
                r = new Report(6225);<br/>
                r.subject = en.getId();<br/>
                r.indent(3);<br/>
                r.add(((Mech)en).getSystemName(cs.getIndex()));<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
                switch(cs.getIndex()) {<br/>
                case Mech.SYSTEM_COCKPIT :<br/>
                    // Don't kill a pilot multiple times.<br/>
                    if ( Pilot.DEATH &gt; en.getCrew().getHits() ) {<br/>
                        // boink!<br/>
                        en.getCrew().setDoomed(true);<br/>
                        Report.addNewline(vDesc);<br/>
                        vDesc.addAll(<br/>
                            destroyEntity(en, "pilot death", true));<br/>
                    }<br/>
                    break;<br/>
                case Mech.SYSTEM_ENGINE :<br/>
                    en.engineHitsThisRound++;<br/>
<br/>
                    boolean engineExploded = false;<br/>
<br/>
                    int numEngineHits = 0;<br/>
                    numEngineHits += en.getHitCriticals<br/>
                        (CriticalSlot.TYPE_SYSTEM,<br/>
                         Mech.SYSTEM_ENGINE, Mech.LOC_CT);<br/>
                    numEngineHits += en.getHitCriticals<br/>
                        (CriticalSlot.TYPE_SYSTEM,<br/>
                         Mech.SYSTEM_ENGINE, Mech.LOC_RT);<br/>
                    numEngineHits += en.getHitCriticals<br/>
                        (CriticalSlot.TYPE_SYSTEM,<br/>
                         Mech.SYSTEM_ENGINE, Mech.LOC_LT);<br/>
<br/>
                    engineExploded = checkEngineExplosion(en, vDesc, numEngineHits);<br/>
                    if ( !engineExploded &amp;&amp; numEngineHits &gt; 2 ) {<br/>
                        // third engine hit<br/>
                        vDesc.addAll(<br/>
                            destroyEntity(en, "engine destruction"));<br/>
                        if (game.getOptions().booleanOption("auto_abandon_unit")) {<br/>
                            vDesc.addAll(abandonEntity(en));<br/>
                        }<br/>
                    }<br/>
                    break;<br/>
                case Mech.SYSTEM_GYRO :<br/>
                    if (en.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                                           Mech.SYSTEM_GYRO, loc) &gt; 1) {<br/>
                                // gyro destroyed<br/>
                        game.addPSR( new PilotingRollData<br/>
                            (en.getId(), PilotingRollData.AUTOMATIC_FAIL,<br/>
                             3, "gyro destroyed") );<br/>
                    } else {<br/>
                                // first gyro hit<br/>
                        game.addPSR( new PilotingRollData<br/>
                            (en.getId(), 3, "gyro hit") );<br/>
                    }<br/>
                    break;<br/>
                case Mech.ACTUATOR_UPPER_LEG :<br/>
                case Mech.ACTUATOR_LOWER_LEG :<br/>
                case Mech.ACTUATOR_FOOT :<br/>
                    // leg/foot actuator piloting roll<br/>
                    game.addPSR( new PilotingRollData<br/>
                        (en.getId(), 1, "leg/foot actuator hit") );<br/>
                    break;<br/>
                case Mech.ACTUATOR_HIP :<br/>
                    // hip piloting roll<br/>
                    game.addPSR( new PilotingRollData<br/>
                        (en.getId(), 2, "hip actuator hit") );<br/>
                    break;<br/>
                }<br/>
<br/>
            } // End entity-is-mek<br/>
<br/>
        } // End crit-on-system-slot<br/>
<br/>
        // Handle critical hits on equipment slots.<br/>
        else if ( CriticalSlot.TYPE_EQUIPMENT == cs.getType() ) {<br/>
            cs.setHit(true);<br/>
            Mounted mounted = en.getEquipment(cs.getIndex());<br/>
            EquipmentType eqType = mounted.getType();<br/>
            boolean hitBefore = mounted.isHit();<br/>
<br/>
            r = new Report(6225);<br/>
            r.subject = en.getId();<br/>
            r.indent(3);<br/>
            r.add(mounted.getDesc());<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            <br/>
            //Shield objects are not useless when they take one crit.<br/>
            //Shields can be critted and still be usable.<br/>
            if (eqType instanceof MiscType &amp;&amp; ((MiscType)eqType).isShield())<br/>
                mounted.setHit(false);<br/>
            else<br/>
                mounted.setHit(true);<br/>
            <br/>
            if (eqType instanceof MiscType &amp;&amp; eqType.hasFlag(MiscType.F_HARJEL)) {<br/>
                r = new Report(6254);<br/>
                r.subject = en.getId();<br/>
                r.indent(2);<br/>
                breachLocation(en, loc, null, true);<br/>
            }<br/>
<br/>
            // If the item is the ECM suite of a Mek Stealth system<br/>
            // then it's destruction turns off the stealth.<br/>
            if ( !hitBefore &amp;&amp; eqType instanceof MiscType &amp;&amp;<br/>
                 eqType.hasFlag(MiscType.F_ECM) &amp;&amp;<br/>
                 mounted.getLinkedBy() != null ) {<br/>
                Mounted stealth = mounted.getLinkedBy();<br/>
                r = new Report(6255);<br/>
                r.subject = en.getId();<br/>
                r.indent(2);<br/>
                r.add(stealth.getType().getName());<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
                stealth.setMode( "Off" );<br/>
            }<br/>
<br/>
            // Handle equipment explosions.<br/>
            // Equipment explosions are secondary effects and<br/>
            // do not occur when loading from a scenario.<br/>
            if ( secondaryEffects &amp;&amp; eqType.isExplosive() &amp;&amp; !hitBefore ) {<br/>
                vDesc.addAll(explodeEquipment(en, loc, mounted));<br/>
            }<br/>
<br/>
            // Make sure that ammo in this slot is exhaused.<br/>
            if ( mounted.getShotsLeft() &gt; 0 ) {<br/>
                mounted.setShotsLeft(0);<br/>
            }<br/>
<br/>
        } // End crit-on-equipment-slot<br/>
        // mechs with TSM hit by anti-tsm missiles this round get another crit<br/>
        if (en instanceof Mech &amp;&amp; en.hitThisRoundByAntiTSM) {<br/>
            Mech mech = (Mech)en;<br/>
            if (mech.hasTSM()) {<br/>
                r = new Report(6430);<br/>
                r.subject = en.getId();<br/>
                r.indent(2);<br/>
                r.addDesc(en);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
                vDesc.addAll(oneCriticalEntity(en, Compute.d6(2)));<br/>
            }<br/>
            en.hitThisRoundByAntiTSM = false;<br/>
        }<br/>
<br/>
        // Return the results of the damage.<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Rolls and resolves critical hits with no die roll modifiers.<br/>
     */<br/>
    private Vector criticalEntity(Entity en, int loc) {<br/>
        return criticalEntity(en, loc, 0, true);<br/>
    }<br/>
<br/>
    private Vector criticalEntity(Entity en, int loc, int critMod) {<br/>
        return criticalEntity(en, loc, critMod, true);<br/>
    }<br/>
<br/>
    /**<br/>
     * Rolls one critical hit<br/>
     */<br/>
    private Vector oneCriticalEntity(Entity en, int loc) {<br/>
        return criticalEntity(en, loc, 0, false);<br/>
    }<br/>
<br/>
    private Vector crashVTOL(VTOL en,Coords crashPos,int curElevation) {<br/>
        return crashVTOL(en, false, 0,crashPos,curElevation,0);<br/>
    }<br/>
    private Vector crashVTOL(VTOL en) {<br/>
        return crashVTOL(en, false, 0 , en.getPosition(),en.getElevation(),0);<br/>
    }<br/>
<br/>
    /**<br/>
     * Crash a VTOL<br/>
     * @param en             The &lt;code&gt;VTOL&lt;/code&gt; to crash<br/>
     * @param sideSlipCrash  A &lt;code&gt;boolean&lt;/code&gt; value indicating wether this<br/>
     *                       is a sideslip crash or not.<br/>
     * @param hexesMoved     The &lt;code&gt;int&lt;/code&gt; number of hexes moved.<br/>
     * @param crashPos       The &lt;code&gt;Coords&lt;/code&gt; of the crash<br/>
     * @param crashElevation The &lt;code&gt;int&lt;/code&gt; elevation of the VTOL<br/>
     * @param impactSide     The &lt;code&gt;int&lt;/code&gt; describing the side on which<br/>
     *                       the VTOL falls<br/>
     * @return               a &lt;code&gt;Vector&lt;/code&gt; of Reports.<br/>
     */<br/>
    private Vector crashVTOL(VTOL en, boolean sideSlipCrash, int hexesMoved, Coords crashPos, int crashElevation,int impactSide) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        if(!sideSlipCrash) {<br/>
            //report lost movement and crashing<br/>
            r = new Report(6260);<br/>
            r.subject = en.getId();<br/>
            r.newlines = 0;<br/>
            r.addDesc(en);<br/>
            vDesc.addElement(r);<br/>
            int newElevation = 0;<br/>
            IHex fallHex = game.getBoard().getHex(crashPos);<br/>
<br/>
            //May land on roof of building or bridge<br/>
            if(fallHex.containsTerrain(Terrains.BLDG_ELEV))<br/>
                newElevation = fallHex.terrainLevel(Terrains.BLDG_ELEV);<br/>
            else if(fallHex.containsTerrain(Terrains.BRIDGE_ELEV)) {<br/>
                newElevation = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);<br/>
                if(newElevation &gt; crashElevation)<br/>
                    newElevation = 0; //vtol was under bridge already<br/>
            }<br/>
<br/>
            int fall = crashElevation - newElevation;<br/>
            if(fall==0) {<br/>
                //already on ground, no harm done<br/>
                r = new Report(6265);<br/>
                r.subject = en.getId();<br/>
                vDesc.addElement(r);<br/>
            } else {<br/>
                //set elevation 1st to avoid multiple crashes<br/>
                en.setElevation(newElevation);<br/>
<br/>
                //plummets to ground<br/>
                r = new Report(6270);<br/>
                r.subject = en.getId();<br/>
                r.add(fall);<br/>
                vDesc.addElement(r);<br/>
<br/>
                // facing after fall<br/>
                String side;<br/>
                int table;<br/>
                int facing = Compute.d6();<br/>
                switch(facing) {<br/>
                    case 1:<br/>
                    case 2:<br/>
                        side = "right side";<br/>
                        table = ToHitData.SIDE_RIGHT;<br/>
                        break;<br/>
                    case 3:<br/>
                        side = "rear";<br/>
                        table = ToHitData.SIDE_REAR;<br/>
                        break;<br/>
                    case 4:<br/>
                    case 5:<br/>
                        side = "left side";<br/>
                        table = ToHitData.SIDE_LEFT;<br/>
                        break;<br/>
                    case 0:<br/>
                    default:<br/>
                        side = "front";<br/>
                        table = ToHitData.SIDE_FRONT;<br/>
                }<br/>
<br/>
                if(newElevation &lt;= 0) {<br/>
                    boolean waterFall= fallHex.containsTerrain(Terrains.WATER);<br/>
                    if(waterFall &amp;&amp; fallHex.containsTerrain(Terrains.ICE)) {<br/>
                        int roll = Compute.d6(1);<br/>
                        r = new Report(2118);<br/>
                        r.subject = en.getId();<br/>
                        r.add(en.getDisplayName(), true);<br/>
                        r.add(roll);<br/>
                        r.subject = en.getId();<br/>
                        addReport(r);<br/>
                        if(roll == 6) {<br/>
                            resolveIceBroken(crashPos);<br/>
                        } else {<br/>
                            waterFall = false; //saved by ice<br/>
                        }<br/>
                    }<br/>
                    if(waterFall) {<br/>
                        //falls into water and is destroyed<br/>
                        r = new Report(6275);<br/>
                        r.subject = en.getId();<br/>
                        vDesc.addElement(r);<br/>
                        en.destroy("Fell into water",false, false);//not sure, is this salvagable?<br/>
                    }<br/>
                }<br/>
<br/>
                // calculate damage for hitting the surface<br/>
                int damage = (int)Math.round(en.getWeight() / 10.0) * (fall + 1);<br/>
<br/>
                // adjust damage for gravity<br/>
                damage = Math.round(damage * game.getOptions().floatOption("gravity"));<br/>
                // report falling<br/>
                r = new Report(6280);<br/>
                r.subject = en.getId();<br/>
                r.indent();<br/>
                r.addDesc(en);<br/>
                r.add(side);<br/>
                r.add(damage);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
<br/>
                en.setFacing((en.getFacing() + (facing - 1)) % 6);<br/>
<br/>
                boolean exploded=false;<br/>
    <br/>
                // standard damage loop<br/>
                while (damage &gt; 0) {<br/>
                    int cluster = Math.min(5, damage);<br/>
                    HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, table);<br/>
                    int ISBefore[]={en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT), en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};//hack?<br/>
                    vDesc.addAll(<br/>
                                          damageEntity(en, hit, cluster));<br/>
                    int ISAfter[]={en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT), en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};<br/>
                    for(int x=0;x&lt;=3;x++) {<br/>
                        if(ISBefore[x]!=ISAfter[x]) {<br/>
                            exploded=true;<br/>
                        }<br/>
                    }<br/>
                    damage -= cluster;<br/>
                }<br/>
                if (exploded) {<br/>
                    r = new Report(6285);<br/>
                    r.subject = en.getId();<br/>
                    r.addDesc(en);<br/>
                    vDesc.addElement(r);<br/>
                    vDesc.addAll( explodeVTOL(en));<br/>
                }<br/>
<br/>
                //check for location exposure<br/>
                doSetLocationsExposure(en, fallHex, false, newElevation);<br/>
                <br/>
            }<br/>
        } else {<br/>
            en.setElevation(0);//considered landed in the hex.<br/>
            //crashes into ground thanks to sideslip<br/>
            r = new Report(6290);<br/>
            r.subject = en.getId();<br/>
            r.addDesc(en);<br/>
            vDesc.addElement(r);<br/>
            int damage = (int)Math.round(en.getWeight() / 10.0) * (hexesMoved + 1);<br/>
            boolean exploded=false;<br/>
<br/>
            // standard damage loop<br/>
            while (damage &gt; 0) {<br/>
                int cluster = Math.min(5, damage);<br/>
                HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, impactSide);<br/>
                int ISBefore[]={en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT), en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};//hack?<br/>
                vDesc.addAll( damageEntity(en, hit, cluster));<br/>
                int ISAfter[]={en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT), en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};<br/>
                for(int x=0;x&lt;=3;x++) {<br/>
                    if(ISBefore[x]!=ISAfter[x]) {<br/>
                        exploded=true;<br/>
                    }<br/>
                }<br/>
                damage -= cluster;<br/>
            }<br/>
            if(exploded) {<br/>
                r = new Report(6295);<br/>
                r.subject = en.getId();<br/>
                r.addDesc(en);<br/>
                vDesc.addElement(r);<br/>
                vDesc.addAll( explodeVTOL(en));<br/>
            }<br/>
<br/>
        }<br/>
        return vDesc;<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Explode a VTOL<br/>
     * @param en  The &lt;code&gt;VTOL&lt;/code&gt; to explode.<br/>
     * @return a &lt;code&gt;Vector&lt;/code&gt; of reports<br/>
     */<br/>
    private Vector explodeVTOL(VTOL en) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        if(en.getEngine().isFusion()) {<br/>
            //fusion engine, no effect<br/>
            r = new Report(6300);<br/>
            r.subject = en.getId();<br/>
            vDesc.addElement(r);<br/>
        } else {<br/>
            Coords pos=en.getPosition();<br/>
            IHex hex = game.getBoard().getHex(pos);<br/>
            if(hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE)) {<br/>
                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
            } else {<br/>
                game.getBoard().addInfernoTo(pos, InfernoTracker.STANDARD_ROUND, 1);<br/>
                ((InfernoTracker)(game.getBoard().getInfernos().get(pos))).setTurnsLeftToBurn(game.getBoard().getInfernoBurnTurns(pos)-game.getBoard().getInfernoIVBurnTurns(pos)-2);  //massive hack<br/>
            }<br/>
        }<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Rolls and resolves critical hits on mechs or vehicles.<br/>
     * if rollNumber is false, a single hit is applied - needed for<br/>
     * MaxTech Heat Scale rule.<br/>
     */<br/>
    private Vector criticalEntity(Entity en, int loc, int critMod, boolean rollNumber) {<br/>
        CriticalSlot slot = null;<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
        Coords coords = en.getPosition();<br/>
        IHex hex = null;<br/>
        int hits;<br/>
        if (rollNumber) {<br/>
            if (null != coords) hex = game.getBoard().getHex(coords);<br/>
            r = new Report(6305);<br/>
            r.subject = en.getId();<br/>
            r.indent(2);<br/>
            r.add(en.getLocationAbbr(loc));<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            hits = 0;<br/>
            int roll = Compute.d6(2);<br/>
            r = new Report(6310);<br/>
            r.subject = en.getId();<br/>
            String rollString = new String();<br/>
            if ( critMod != 0 ) {<br/>
                rollString = "(" + roll;<br/>
                if ( critMod &gt; 0 ) {<br/>
                    rollString += "+";<br/>
                }<br/>
                rollString += critMod + ") = ";<br/>
                roll += critMod;<br/>
            }<br/>
            rollString += roll;<br/>
            r.add(rollString);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            if (roll &lt;= 7) {<br/>
                //no effect<br/>
                r = new Report(6005);<br/>
                r.subject = en.getId();<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
                return vDesc;<br/>
            } else if (roll &gt;= 8 &amp;&amp; roll &lt;= 9) {<br/>
                hits = 1;<br/>
                r = new Report(6315);<br/>
                r.subject = en.getId();<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            } else if (roll &gt;= 10 &amp;&amp; roll &lt;= 11) {<br/>
                hits = 2;<br/>
                r = new Report(6320);<br/>
                r.subject = en.getId();<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            } else if (roll == 12) {<br/>
                if (en instanceof Tank || en instanceof Protomech) {<br/>
                    hits = 3;<br/>
                    r = new Report(6325);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                } else if (en.locationIsLeg(loc)) {<br/>
                    //limb blown off<br/>
                    r = new Report(6120);<br/>
                    r.subject = en.getId();<br/>
                    r.add(en.getLocationName(loc));<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    if (en.getInternal(loc) &gt; 0) {<br/>
                        destroyLocation(en, loc);<br/>
                    }<br/>
                    if (null != hex) {<br/>
                        if (!hex.containsTerrain (Terrains.LEGS)) {<br/>
                            hex.addTerrain (Terrains.getTerrainFactory().createTerrain(Terrains.LEGS, 1));<br/>
                        }<br/>
                        else {<br/>
                            hex.addTerrain (Terrains.getTerrainFactory().createTerrain<br/>
                                            (Terrains.LEGS,<br/>
                                             hex.terrainLevel(Terrains.LEGS)+1));<br/>
                        }<br/>
                    }<br/>
                    sendChangedHex(en.getPosition());<br/>
                    return vDesc;<br/>
                } else if (loc == Mech.LOC_RARM || loc == Mech.LOC_LARM) {<br/>
                    //limb blown off<br/>
                    r = new Report(6120);<br/>
                    r.subject = en.getId();<br/>
                    r.add(en.getLocationName(loc));<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    destroyLocation(en, loc);<br/>
                    if (null != hex) {<br/>
                        if (!hex.containsTerrain( Terrains.ARMS)) {<br/>
                            hex.addTerrain (Terrains.getTerrainFactory().createTerrain(Terrains.ARMS, 1));<br/>
                        }<br/>
                        else {<br/>
                            hex.addTerrain (Terrains.getTerrainFactory().createTerrain<br/>
                                            (Terrains.ARMS,<br/>
                                             hex.terrainLevel(Terrains.ARMS)+1));<br/>
                        }<br/>
                    }<br/>
                    sendChangedHex(en.getPosition());<br/>
                    return vDesc;<br/>
                } else if (loc == Mech.LOC_HEAD) {<br/>
                    //head blown off<br/>
                    r = new Report(6330);<br/>
                    r.subject = en.getId();<br/>
                    r.add(en.getLocationName(loc));<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    destroyLocation(en, loc);<br/>
                    // Don't kill a pilot multiple times.<br/>
                    if ( Pilot.DEATH &gt; en.getCrew().getHits() ) {<br/>
                        en.crew.setDoomed(true);<br/>
                        Report.addNewline(vDesc);<br/>
                        vDesc.addAll( destroyEntity(en, "pilot death", true));<br/>
                    }<br/>
                    return vDesc;<br/>
                } else {<br/>
                    // torso hit<br/>
                    hits = 3;<br/>
                    r = new Report(6325);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                }<br/>
            }<br/>
        } else {<br/>
            hits = 1;<br/>
        }<br/>
<br/>
        // vehicle handle crits in their own 'special' way<br/>
        if (en instanceof Tank) {<br/>
            Tank tank = (Tank)en;<br/>
            for (int x = 0; x &lt; hits; x++) {<br/>
                slot = new CriticalSlot( CriticalSlot.TYPE_SYSTEM,<br/>
                                         Compute.d6(1) );<br/>
                vDesc.addAll( applyCriticalHit(en, Entity.NONE, slot, true));<br/>
            }<br/>
        }<br/>
        else {<br/>
            // transfer criticals, if needed<br/>
            while (hits &gt; 0 &amp;&amp; en.canTransferCriticals(loc)<br/>
                   &amp;&amp; en.getTransferLocation(loc) != Entity.LOC_DESTROYED<br/>
                   &amp;&amp; en.getTransferLocation(loc) != Entity.LOC_NONE) {<br/>
                loc = en.getTransferLocation(loc);<br/>
                r = new Report(6335);<br/>
                r.subject = en.getId();<br/>
                r.indent(3);<br/>
                r.add(en.getLocationAbbr(loc));<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
<br/>
            // Roll critical hits in this location.<br/>
            while (hits &gt; 0) {<br/>
<br/>
                // Have we hit all available slots in this location?<br/>
                if (en.getHittableCriticals(loc) &lt;= 0) {<br/>
                    r = new Report(6340);<br/>
                    r.subject = en.getId();<br/>
                    r.indent(3);<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    break;<br/>
                }<br/>
<br/>
                // Randomly pick a slot to be hit.<br/>
                int slotIndex = Compute.randomInt<br/>
                    ( en.getNumberOfCriticals(loc) );<br/>
                slot = en.getCritical(loc, slotIndex);<br/>
<br/>
                // Ignore empty or unhitable slots (this<br/>
                // includes all previously hit slots).<br/>
                <br/>
                if (slot != null &amp;&amp; slot.isHittable()) {<br/>
                    // if explosive use edge<br/>
                    if (<span class="mv">(en instanceof Mech) <br/>
                       &amp;&amp; ( en.crew.hasEdgeRemaining()<br/>
                            &amp;&amp; en.crew.getOptions().booleanOption("edge_when_explosion"))<br/>
                       &amp;&amp; <span class="mv">en.getEquipment(slot.getIndex()).getType().isExplosive()</span></span>) {<br/>
                       en.crew.decreaseEdge();<br/>
                       r = new Report(6530);<br/>
                       r.subject = en.getId();<br/>
                       r.indent(3);<br/>
                       r.newlines = 0;<br/>
                       r.add(en.crew.getOptions().intOption("edge"));<br/>
                       vDesc.addElement(r);<br/>
                       continue;<br/>
                    }<br/>
                    vDesc.addAll( applyCriticalHit(en, loc, slot, true));<br/>
                    hits--;<br/>
                }<br/>
<br/>
            } // Hit another slot in this location.<br/>
        }<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks for location breach and returns phase logging.<br/>
     * &lt;p/&gt;<br/>
     * Please note that dependent locations ARE NOT considered breached!<br/>
     *<br/>
     * @param   entity the &lt;code&gt;Entity&lt;/code&gt; that needs to be checked.<br/>
     * @param   loc the &lt;code&gt;int&lt;/code&gt; location on the entity that needs<br/>
     *          to be checked for a breach.<br/>
     * @param   hex the &lt;code&gt;IHex&lt;/code&gt; the enitity occupies when checking<br/>
     *          This value will be &lt;code&gt;null&lt;/code&gt; if the check is the<br/>
     *          result of an attack, and non-null if it occurs during movement.<br/>
     */<br/>
    private Vector breachCheck(Entity entity, int loc, IHex hex) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // BattleArmor does not breach<br/>
        if (entity instanceof Infantry) {<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        if (entity instanceof VTOL) {<br/>
            return vDesc;<br/>
        }<br/>
        <br/>
        // functional HarJel prevents breach<br/>
        if (entity instanceof Mech &amp;&amp; ((Mech)entity).hasHarJelIn(loc)) {<br/>
            r = new Report(6342);<br/>
            r.subject = entity.getId();<br/>
            r.indent(3);<br/>
            vDesc.addElement(r);<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        // This handles both water and vacuum breaches.<br/>
        if (entity.getLocationStatus(loc) &gt; ILocationExposureStatus.NORMAL) {<br/>
            // Does the location have armor (check rear armor on Mek)<br/>
            // and is the check due to damage?<br/>
            int breachroll = 0;<br/>
            if (entity.getArmor(loc) &gt; 0 &amp;&amp;<br/>
                (entity instanceof Mech ? (entity.getArmor(loc,true)&gt;0) : true)<br/>
                &amp;&amp; null == hex) {<br/>
                breachroll = Compute.d6(2);<br/>
                r = new Report(6345);<br/>
                r.subject = entity.getId();<br/>
                r.indent(3);<br/>
                r.add(entity.getLocationAbbr(loc));<br/>
                r.add(breachroll);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            // Breach by damage or lack of armor.<br/>
            if ( breachroll &gt;= 10<br/>
                 || !(entity.getArmor(loc) &gt; 0)<br/>
                 || !(entity instanceof Mech ? (entity.getArmor(loc,true)&gt;0) :<br/>
                      true) ) {<br/>
                vDesc.addAll( breachLocation(entity, loc, hex, false));<br/>
            }<br/>
        }<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks all equipment in a location on an entity as useless.<br/>
     *<br/>
     * @param   entity the &lt;code&gt;Entity&lt;/code&gt; that needs to be checked.<br/>
     * @param   loc the &lt;code&gt;int&lt;/code&gt; location on the entity that needs<br/>
     *          to be checked for a breach.<br/>
     * @param   hex the &lt;code&gt;IHex&lt;/code&gt; the enitity occupies when checking<br/>
     *          This value will be &lt;code&gt;null&lt;/code&gt; if the check is the<br/>
     *          result of an attack, and non-null if it occurs during movement.<br/>
     * @param   harJel a &lt;code&gt;boolean&lt;/code&gt; value indicating if the uselessness<br/>
     *          is the cause of a critically hit HarJel system<br/>
     */<br/>
    private Vector breachLocation(Entity entity, int loc, IHex hex, boolean harJel) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        if (entity.getInternal(loc) &lt; 0 ||<br/>
            entity.getLocationStatus(loc) &lt; ILocationExposureStatus.NORMAL) {<br/>
            //already destroyed or breached? don't bother<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        r = new Report(6350);<br/>
        if (harJel) r.messageId = 6351;<br/>
        r.subject = entity.getId();<br/>
        r.add(entity.getShortName());<br/>
        r.add(entity.getLocationAbbr(loc));<br/>
        r.newlines = 0;<br/>
        vDesc.addElement(r);<br/>
<br/>
        if (entity instanceof Tank) {<br/>
            vDesc.addAll(<br/>
                destroyEntity(entity, "hull breach", true, true));<br/>
            return vDesc;<br/>
        }<br/>
        // equipment and crits will be marked in applyDamage?<br/>
<br/>
        // equipment marked missing<br/>
        for (Enumeration i = entity.getEquipment(); i.hasMoreElements();) {<br/>
            Mounted mounted = (Mounted)i.nextElement();<br/>
            if (mounted.getLocation() == loc) {<br/>
                mounted.setBreached(true);<br/>
            }<br/>
        }<br/>
        // all critical slots set as useless<br/>
        for (int i = 0; i &lt; entity.getNumberOfCriticals(loc); i++) {<br/>
            final CriticalSlot cs = entity.getCritical(loc, i);<br/>
            if (cs != null) {<br/>
                // for every undamaged actuator destroyed by breaching,<br/>
                // we make a PSR (see bug 1040858)<br/>
                if (entity.locationIsLeg(loc)) {<br/>
                    if (cs.isHittable()) {<br/>
                        switch(cs.getIndex()) {<br/>
                            case Mech.ACTUATOR_UPPER_LEG :<br/>
                            case Mech.ACTUATOR_LOWER_LEG :<br/>
                            case Mech.ACTUATOR_FOOT :<br/>
                                // leg/foot actuator piloting roll<br/>
                                game.addPSR( new PilotingRollData<br/>
                                    (entity.getId(), 1, "leg/foot actuator hit") );<br/>
                                break;<br/>
                            case Mech.ACTUATOR_HIP :<br/>
                                // hip piloting roll (at +0, because we get the +2<br/>
                                // anyway because the location is breached<br/>
                                // phase report will look a bit weird, but the roll<br/>
                                // is correct<br/>
                                game.addPSR( new PilotingRollData<br/>
                                    (entity.getId(), 0, "hip actuator hit") );<br/>
                                break;<br/>
                        }<br/>
                    }<br/>
                }<br/>
                cs.setBreached(true);<br/>
            }<br/>
        }<br/>
<br/>
        //Check location for engine/cockpit breach and report accordingly<br/>
        if (loc == Mech.LOC_CT) {<br/>
            vDesc.addAll( destroyEntity(entity, "hull breach"));<br/>
            if (game.getOptions().booleanOption("auto_abandon_unit")) {<br/>
                vDesc.addAll(abandonEntity(entity));<br/>
            }<br/>
        }<br/>
        if (loc == Mech.LOC_HEAD) {<br/>
            entity.crew.setDoomed(true);<br/>
            vDesc.addAll( destroyEntity(entity, "hull breach"));<br/>
            if (entity.getLocationStatus(loc) == ILocationExposureStatus.WET) {<br/>
                r = new Report(6355);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                vDesc.addElement(r);<br/>
            } else {<br/>
                r = new Report(6360);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                vDesc.addElement(r);<br/>
            }<br/>
        }<br/>
<br/>
        // Set the status of the location.<br/>
        // N.B. if we set the status before rolling water PSRs, we get a<br/>
        // "LEG DESTROYED" modifier; setting the status after gives a hip<br/>
        // actuator modifier.<br/>
        entity.setLocationStatus(loc, ILocationExposureStatus.BREACHED);<br/>
<br/>
        // Did the hull breach destroy the engine?<br/>
        if (entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE,<br/>
                               Mech.LOC_LT) +<br/>
            entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE,<br/>
                               Mech.LOC_CT) +<br/>
            entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE,<br/>
                               Mech.LOC_RT)<br/>
            &gt;= 3) {<br/>
            vDesc.addAll( destroyEntity(entity, "engine destruction"));<br/>
            if (game.getOptions().booleanOption("auto_abandon_unit")) {<br/>
                vDesc.addAll(abandonEntity(entity));<br/>
            }<br/>
        }<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks all equipment in a location on an entity as destroyed.<br/>
     */<br/>
    void destroyLocation(Entity en, int loc) {<br/>
        // if it's already marked as destroyed, don't bother<br/>
        if (en.getInternal(loc) &lt; 0) {<br/>
            return;<br/>
        }<br/>
        // mark armor, internal as doomed<br/>
        en.setArmor(IArmorState.ARMOR_DOOMED, loc, false);<br/>
        en.setInternal(IArmorState.ARMOR_DOOMED, loc);<br/>
        if (en.hasRearArmor(loc)) {<br/>
            en.setArmor(IArmorState.ARMOR_DOOMED, loc, true);<br/>
        }<br/>
        // equipment marked missing<br/>
        for (Enumeration i = en.getEquipment(); i.hasMoreElements();) {<br/>
            Mounted mounted = (Mounted)i.nextElement();<br/>
            if (mounted.getLocation() == loc) {<br/>
                mounted.setMissing(true);<br/>
            }<br/>
        }<br/>
        // all critical slots set as missing<br/>
        for (int i = 0; i &lt; en.getNumberOfCriticals(loc); i++) {<br/>
            final CriticalSlot cs = en.getCritical(loc, i);<br/>
            if (cs != null) {<br/>
                // count engine hits for maxtech engine explosions<br/>
                if (cs.getType() == CriticalSlot.TYPE_SYSTEM &amp;&amp;<br/>
                    cs.getIndex() == Mech.SYSTEM_ENGINE &amp;&amp;<br/>
                    !cs.isDamaged()) {<br/>
                        en.engineHitsThisRound++;<br/>
                }<br/>
                cs.setMissing(true);<br/>
            }<br/>
        }<br/>
        // if it's a leg, the entity falls<br/>
        if (en instanceof Mech &amp;&amp; en.locationIsLeg(loc)) {<br/>
            game.addPSR(new PilotingRollData(en.getId(), PilotingRollData.AUTOMATIC_FAIL, 5, "leg destroyed"));<br/>
        }<br/>
        // dependent locations destroyed<br/>
        if (en.getDependentLocation(loc) != Entity.LOC_NONE) {<br/>
            destroyLocation(en, en.getDependentLocation(loc));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Mark the unit as destroyed!  Units transported in the destroyed unit<br/>
     * will get a chance to escape.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @return  a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt; objects<br/>
     *          that can be sent to the output log.<br/>
     */<br/>
    private Vector destroyEntity(Entity entity, String reason) {<br/>
        return destroyEntity( entity, reason, true );<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks a unit as destroyed!  Units transported inside the destroyed<br/>
     * unit will get a chance to escape unless the destruction was not<br/>
     * survivable.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @param   survivable - a &lt;code&gt;boolean&lt;/code&gt; that identifies the<br/>
     *          desctruction as unsurvivable for transported units.<br/>
     * @return  a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt; objects<br/>
     *          that can be sent to the output log.<br/>
     */<br/>
    private Vector destroyEntity(Entity entity, String reason,<br/>
                                 boolean survivable) {<br/>
        // Generally, the entity can still be salvaged.<br/>
        return this.destroyEntity( entity, reason, survivable, true );<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks a unit as destroyed!  Units transported inside the destroyed<br/>
     * unit will get a chance to escape unless the destruction was not<br/>
     * survivable.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @param   survivable - a &lt;code&gt;boolean&lt;/code&gt; that identifies the<br/>
     *          desctruction as unsurvivable for transported units.<br/>
     * @param   canSalvage - a &lt;code&gt;boolean&lt;/code&gt; that indicates if<br/>
     *          the unit can be salvaged (or cannibalized for spare parts).<br/>
     *          If &lt;code&gt;true&lt;/code&gt;, salvage operations are possible, if<br/>
     *          &lt;code&gt;false&lt;/code&gt;, the unit is too badly damaged.<br/>
     * @return  a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt; objects<br/>
     *          that can be sent to the output log.<br/>
     */<br/>
    private Vector destroyEntity(Entity entity, String reason,<br/>
                                 boolean survivable, boolean canSalvage) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // The unit can suffer an ammo explosion after it has been destroyed.<br/>
        int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;<br/>
        if ( !canSalvage ) {<br/>
            entity.setSalvage( canSalvage );<br/>
            condition = IEntityRemovalConditions.REMOVE_DEVASTATED;<br/>
        }<br/>
<br/>
        // Destroy the entity, unless it's already destroyed.<br/>
        if (!entity.isDoomed() &amp;&amp; !entity.isDestroyed()) {<br/>
            r = new Report(6365);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(reason);<br/>
            r.newlines=0;<br/>
            vDesc.addElement(r);<br/>
<br/>
            entity.setDoomed(true);<br/>
<br/>
            // Kill any picked up MechWarriors<br/>
            Enumeration iter = entity.getPickedUpMechWarriors().elements();<br/>
            while (iter.hasMoreElements() ) {<br/>
                Integer mechWarriorId = (Integer)iter.nextElement();<br/>
                Entity mw = game.getEntity(mechWarriorId.intValue());<br/>
                mw.setDestroyed(true);<br/>
                game.removeEntity( mw.getId(), condition );<br/>
                this.entityUpdate(mw.getId());<br/>
                send( createRemoveEntityPacket(mw.getId(), condition) );<br/>
                r = new Report(6370);<br/>
                r.subject = mw.getId();<br/>
                r.addDesc(mw);<br/>
                vDesc.addElement(r);<br/>
            }<br/>
<br/>
            // Handle escape of transported units.<br/>
            iter = entity.getLoadedUnits().elements();<br/>
            if ( iter.hasMoreElements() ) {<br/>
                Entity other = null;<br/>
                Coords curPos = entity.getPosition();<br/>
                IHex entityHex = game.getBoard().getHex( curPos );<br/>
                int curFacing = entity.getFacing();<br/>
                while ( iter.hasMoreElements() ) {<br/>
                    other = (Entity) iter.nextElement();<br/>
<br/>
                    // Can the other unit survive?<br/>
                    if ( !survivable ) {<br/>
<br/>
                        // Nope.<br/>
                        other.setDestroyed(true);<br/>
                        game.moveToGraveyard( other.getId() );<br/>
                        this.entityUpdate(other.getId());<br/>
                        send( createRemoveEntityPacket(other.getId(),<br/>
                                                       condition) );<br/>
                        r = new Report(6370);<br/>
                        r.subject = other.getId();<br/>
                        r.addDesc(other);<br/>
                        vDesc.addElement(r);<br/>
                    }<br/>
                    // Can we unload the unit to the current hex?<br/>
                    // TODO : unloading into stacking violation is not<br/>
                    //        explicitly prohibited in the BMRr.<br/>
                    else if (null != Compute.stackingViolation(game, other.getId(), curPos)<br/>
                             || other.isHexProhibited(entityHex) ) {<br/>
                        // Nope.<br/>
                        other.setDestroyed(true);<br/>
                        game.moveToGraveyard( other.getId() );<br/>
                        this.entityUpdate(other.getId());<br/>
                        send( createRemoveEntityPacket(other.getId(),<br/>
                                                       condition) );<br/>
                        r = new Report(6375);<br/>
                        r.subject = other.getId();<br/>
                        r.addDesc(other);<br/>
                        vDesc.addElement(r);<br/>
                    } // End can-not-unload<br/>
                    else {<br/>
                        // The other unit survives.<br/>
                        this.unloadUnit( entity, other, curPos, curFacing, entity.getElevation() );<br/>
                    }<br/>
<br/>
                } // Handle the next transported unit.<br/>
<br/>
            } // End has-transported-unit<br/>
<br/>
            // Handle transporting unit.<br/>
            if ( Entity.NONE != entity.getTransportId() ) {<br/>
                final Entity transport = game.getEntity<br/>
                    ( entity.getTransportId() );<br/>
                Coords curPos = transport.getPosition();<br/>
                int curFacing = transport.getFacing();<br/>
                this.unloadUnit( transport, entity, curPos, curFacing, transport.getElevation() );<br/>
                this.entityUpdate( transport.getId() );<br/>
            } // End unit-is-transported<br/>
<br/>
            // Is this unit being swarmed?<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
<br/>
                // remove the swarmer from the move queue<br/>
                game.removeTurnFor(swarmer);<br/>
                send(createTurnVectorPacket());<br/>
<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                r = new Report(6380);<br/>
                r.subject = swarmerId;<br/>
                r.addDesc(swarmer);<br/>
                vDesc.addElement(r);<br/>
                this.entityUpdate( swarmerId );<br/>
            }<br/>
<br/>
            // Is this unit swarming somebody?<br/>
            final int swarmedId = entity.getSwarmTargetId();<br/>
            if ( Entity.NONE != swarmedId ) {<br/>
                final Entity swarmed = game.getEntity( swarmedId );<br/>
                swarmed.setSwarmAttackerId( Entity.NONE );<br/>
                entity.setSwarmTargetId( Entity.NONE );<br/>
                r = new Report(6385);<br/>
                r.subject = swarmed.getId();<br/>
                r.addDesc(swarmed);<br/>
                vDesc.addElement(r);<br/>
                this.entityUpdate( swarmedId );<br/>
            }<br/>
<br/>
        } // End entity-not-already-destroyed.<br/>
        <br/>
        // update our entity, so clients have correct data<br/>
        // needed for MekWars stuff<br/>
        this.entityUpdate(entity.getId());<br/>
<br/>
        return vDesc;<br/>
    }<br/>
    <br/>
<br/>
    /**<br/>
     * Makes a piece of equipment on a mech explode!  POW!  This expects either<br/>
     * ammo, or an explosive weapon.  Returns a vector of Report objects.<br/>
     */<br/>
    private Vector explodeEquipment(Entity en, int loc, int slot) {<br/>
        return explodeEquipment(en, loc, en.getEquipment(en.getCritical(loc, slot).getIndex()));<br/>
    }<br/>
<br/>
    private Vector explodeEquipment(Entity en, int loc, Mounted mounted) {<br/>
        Vector vDesc = new Vector();<br/>
        // is this already destroyed?<br/>
        if (mounted.isDestroyed()) {<br/>
            System.err.println("server: explodeEquipment called on destroyed"<br/>
            + " equipment (" + mounted.getName() + ")");<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        // special-case.  RACs only explode when jammed<br/>
        if (mounted.getType() instanceof WeaponType &amp;&amp;<br/>
                ((WeaponType)mounted.getType()).getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
            if (!mounted.isJammed()) {<br/>
                return vDesc;<br/>
            }<br/>
        }<br/>
<br/>
        // special case.  ACs only explode when firing incendiary ammo<br/>
        if (mounted.getType() instanceof WeaponType &amp;&amp;<br/>
                ((WeaponType)mounted.getType()).getAmmoType() == AmmoType.T_AC) {<br/>
            if (!mounted.isUsedThisRound()) {<br/>
                return vDesc;<br/>
            }<br/>
            Mounted ammo = mounted.getLinked();<br/>
            if(ammo == null || !(ammo.getType() instanceof AmmoType) || <br/>
            ((AmmoType)ammo.getType()).getMunitionType() != AmmoType.M_INCENDIARY_AC ) {<br/>
                return vDesc;<br/>
            }<br/>
            <br/>
            WeaponType wtype = (WeaponType)mounted.getType();<br/>
            if ( ((wtype.getAmmoType() == AmmoType.T_LRM) ||                 <br/>
                    (wtype.getAmmoType() == AmmoType.T_LRM_STREAK) ||<br/>
                    (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO) ||<br/>
                    (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO_COMBO))){<br/>
                return vDesc;<br/>
            }<br/>
            <br/>
        }<br/>
<br/>
        // Inferno ammo causes heat buildup as well as the damage<br/>
        if (mounted.getType() instanceof AmmoType<br/>
                &amp;&amp; ((((AmmoType)mounted.getType()).getAmmoType() == AmmoType.T_SRM)<br/>
                || (((AmmoType)mounted.getType()).getAmmoType() == AmmoType.T_BA_INFERNO))<br/>
                &amp;&amp; ((AmmoType)mounted.getType()).getMunitionType() == AmmoType.M_INFERNO<br/>
                &amp;&amp; mounted.getShotsLeft() &gt; 0) {<br/>
            en.heatBuildup += 30;<br/>
        }<br/>
<br/>
        // determine and deal damage<br/>
        int damage = mounted.getExplosionDamage();<br/>
<br/>
        if (damage &lt;= 0) {<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        Report r = new Report(6390);<br/>
        r.subject = en.getId();<br/>
        r.add(mounted.getName());<br/>
        r.add(damage);<br/>
        r.indent(3);<br/>
        r.newlines = 0;<br/>
        vDesc.addElement(r);<br/>
        mounted.setShotsLeft(0);<br/>
        vDesc.addAll( damageEntity(en, new HitData(loc), damage, true));<br/>
        Report.addNewline(vDesc);<br/>
<br/>
        <br/>
        int pilotDamage = 2;<br/>
        if (en.getCrew().getOptions().booleanOption("pain_resistance")) pilotDamage = 1;<br/>
        if (en.getCrew().getOptions().booleanOption("iron_man")) pilotDamage = 1;<br/>
        vDesc.addAll( damageCrew(en, pilotDamage));<br/>
        if ( en.crew.isDoomed() || en.crew.isDead() ) {<br/>
            vDesc.addAll( destroyEntity(en, "crew death", true) );<br/>
        } else {<br/>
            Report.addNewline(vDesc);<br/>
        }<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes one slot of ammo, determined by certain rules, explode on a mech.<br/>
     */<br/>
    private Vector explodeAmmoFromHeat(Entity entity) {<br/>
        int damage = 0;<br/>
        int rack = 0;<br/>
        int boomloc = -1;<br/>
        int boomslot = -1;<br/>
        Vector vDesc = new Vector();<br/>
<br/>
        for (int j = 0; j &lt; entity.locations(); j++) {<br/>
            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {<br/>
                CriticalSlot cs = entity.getCritical(j, k);<br/>
                if (cs == null || cs.isDestroyed() || cs.isHit() || cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {<br/>
                    continue;<br/>
                }<br/>
                Mounted mounted = entity.getEquipment(entity.getCritical(j, k).getIndex());<br/>
                if (!(mounted.getType() instanceof AmmoType)) {<br/>
                    continue;<br/>
                }<br/>
                AmmoType atype = (AmmoType)mounted.getType();<br/>
                if (!atype.isExplosive()) {<br/>
                    continue;<br/>
                }<br/>
                //ignore empty bins<br/>
                if (atype.getShots() == 0) {<br/>
                    continue;<br/>
                }<br/>
                // BMRr, pg. 48, compare one rack's<br/>
                // damage.  Ties go to most rounds.<br/>
                int newRack = atype.getDamagePerShot() * atype.getRackSize();<br/>
                int newDamage = mounted.getExplosionDamage();<br/>
                if ( !mounted.isHit() &amp;&amp; ( rack &lt; newRack ||<br/>
                       (rack == newRack &amp;&amp; damage &lt; newDamage) ) ) {<br/>
                    rack = newRack;<br/>
                    damage = newDamage;<br/>
                    boomloc = j;<br/>
                    boomslot = k;<br/>
                }<br/>
            }<br/>
        }<br/>
        if (boomloc != -1 &amp;&amp; boomslot != -1) {<br/>
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);<br/>
            slot.setHit(true);<br/>
            entity.getEquipment(slot.getIndex()).setHit(true);<br/>
            vDesc = explodeEquipment(entity, boomloc, boomslot);<br/>
        } else {<br/>
            //Luckily, there is no ammo to explode.<br/>
            Report r = new Report(5105);<br/>
            r.subject = entity.getId();<br/>
            r.indent();<br/>
            vDesc.addElement(r);<br/>
        }<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes a mech fall.<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height, int facing, PilotingRollData roll) {<br/>
        Report r;<br/>
<br/>
        IHex fallHex = game.getBoard().getHex(fallPos);<br/>
<br/>
        // we don't need to deal damage yet, if the entity is doing DFA<br/>
        if (entity.isMakingDfa()) {<br/>
            r = new Report(2305);<br/>
            r.subject = entity.getId();<br/>
            addReport(r);<br/>
            entity.setProne(true);<br/>
            return;<br/>
        }<br/>
        // facing after fall<br/>
        String side;<br/>
        int table;<br/>
        switch(facing) {<br/>
            case 1:<br/>
            case 2:<br/>
                side = "right side";<br/>
                table = ToHitData.SIDE_RIGHT;<br/>
                break;<br/>
            case 3:<br/>
                side = "rear";<br/>
                table = ToHitData.SIDE_REAR;<br/>
                break;<br/>
            case 4:<br/>
            case 5:<br/>
                side = "left side";<br/>
                table = ToHitData.SIDE_LEFT;<br/>
                break;<br/>
            case 0:<br/>
            default:<br/>
                side = "front";<br/>
                table = ToHitData.SIDE_FRONT;<br/>
        }<br/>
<br/>
        int waterDepth = fallHex.terrainLevel(Terrains.WATER);<br/>
        int damageHeight = height;<br/>
<br/>
<br/>
        // HACK: if the dest hex is water, assume that the fall height given is<br/>
        // to the floor of the hex, and modifiy it so that it's to the surface<br/>
        if (waterDepth &gt; 0) {<br/>
            damageHeight = height - waterDepth;<br/>
        } else {<br/>
            waterDepth = 0; //because it will be used to set elevation<br/>
        }<br/>
<br/>
        if(fallHex.containsTerrain(Terrains.ICE)) {<br/>
            waterDepth = 0;<br/>
        }<br/>
        <br/>
        //Falling into water instantly destroys most non-mechs<br/>
        if(waterDepth &gt; 0<br/>
                &amp;&amp; !(entity instanceof Mech)<br/>
                &amp;&amp; !(entity instanceof Protomech)<br/>
                &amp;&amp; (entity.getRunMP() &gt; 0 &amp;&amp; entity.getMovementMode() != IEntityMovementMode.HOVER)<br/>
                &amp;&amp; entity.getMovementMode() != IEntityMovementMode.HYDROFOIL<br/>
                &amp;&amp; entity.getMovementMode() != IEntityMovementMode.NAVAL<br/>
                &amp;&amp; entity.getMovementMode() != IEntityMovementMode.SUBMARINE) {<br/>
            addReport(<br/>
                    destroyEntity(entity, "a watery grave", false));<br/>
            return;<br/>
        }<br/>
<br/>
        // calculate damage for hitting the surface<br/>
        int damage = (int)Math.round(entity.getWeight() / 10.0) * (damageHeight + 1);<br/>
        // calculate damage for hitting the ground, but only if we actually fell<br/>
        // into water<br/>
        // if we fell onto the water surface, that damage is halved.<br/>
        int waterDamage = 0;<br/>
        if (waterDepth &gt; 0) {<br/>
            damage /= 2;<br/>
            waterDamage = (int)Math.round(entity.getWeight() / 10.0) * (waterDepth + 1) /2;<br/>
        }<br/>
<br/>
        // If the waterDepth is larger than the fall height,<br/>
        // we fell underwater<br/>
        if (waterDepth &gt; height) {<br/>
            damage = 0;<br/>
            waterDamage = (int)Math.round(entity.getWeight() / 10.0) * (height + 1) /2;<br/>
        }<br/>
        // adjust damage for gravity<br/>
        damage = Math.round(damage * game.getOptions().floatOption("gravity"));<br/>
        waterDamage = Math.round(waterDamage * game.getOptions().floatOption("gravity"));<br/>
<br/>
        // report falling<br/>
        if (waterDamage == 0) {<br/>
            r = new Report(2310);<br/>
            r.subject = entity.getId();<br/>
            r.indent();<br/>
            r.newlines = 0;<br/>
            r.addDesc(entity);<br/>
            r.add(side); //international issue<br/>
            r.add(damage);<br/>
        } else if (damage &gt; 0) {<br/>
            r = new Report(2315);<br/>
            r.subject = entity.getId();<br/>
            r.indent();<br/>
            r.newlines = 0;<br/>
            r.addDesc(entity);<br/>
            r.add(side); //international issue<br/>
            r.add(damage);<br/>
            r.add(waterDamage);<br/>
        } else {<br/>
            r = new Report(2310);<br/>
            r.subject = entity.getId();<br/>
            r.indent();<br/>
            r.newlines = 0;<br/>
            r.addDesc(entity);<br/>
            r.add(side); //international issue<br/>
            r.add(waterDamage);<br/>
        }<br/>
        addReport(r);<br/>
        damage += waterDamage;<br/>
<br/>
        // Any swarming infantry will be dislodged, but we don't want to<br/>
        // interrupt the fall's report.  We have to get the ID now because<br/>
        // the fall may kill the entity which will reset the attacker ID.<br/>
        final int swarmerId = entity.getSwarmAttackerId();<br/>
<br/>
        // Positioning must be prior to damage for proper handling of breaches<br/>
        // Only Mechs can fall prone.<br/>
        if ( entity instanceof Mech ) {<br/>
            entity.setProne(true);<br/>
        }<br/>
        entity.setPosition(fallPos);<br/>
        entity.setFacing((entity.getFacing() + (facing - 1)) % 6);<br/>
        entity.setSecondaryFacing(entity.getFacing());<br/>
        entity.setElevation(-waterDepth);<br/>
        if (waterDepth &gt; 0) {<br/>
            for (int loop=0; loop&lt; entity.locations();loop++){<br/>
                entity.setLocationStatus(loop, ILocationExposureStatus.WET);<br/>
            }<br/>
        }<br/>
<br/>
        // standard damage loop<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, table);<br/>
            hit.makeFallDamage(true);<br/>
            addReport( damageEntity(entity, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
<br/>
        //check for location exposure<br/>
        doSetLocationsExposure(entity, fallHex, false, -waterDepth);<br/>
<br/>
        // we want to be able to avoid pilot damage even when it was<br/>
        // an automatic fall, only unconsciousness should cause auto-damage<br/>
        roll.removeAutos();<br/>
<br/>
        if (height &gt; 0) {<br/>
            roll.addModifier(height, "height of fall");<br/>
        }<br/>
<br/>
        entity.addPilotingModifierForTerrain(roll, fallPos);<br/>
<br/>
        if (roll.getValue() == PilotingRollData.IMPOSSIBLE) {<br/>
            r = new Report(2320);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(entity.crew.getName());<br/>
            r.indent();<br/>
            addReport(r);<br/>
            addReport( damageCrew(entity, 1));<br/>
            ((Report) vPhaseReport.elementAt(vPhaseReport.size() - 1)).newlines++;<br/>
        } else {<br/>
            int diceRoll = Compute.d6(2);<br/>
            r = new Report(2325);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(entity.crew.getName());<br/>
            r.add(roll.getValueAsString());<br/>
            r.add(diceRoll);<br/>
            if (diceRoll &gt;= roll.getValue()) {<br/>
                r.choose(true);<br/>
                addReport(r);<br/>
            } else {<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
                addReport( damageCrew(entity, 1));<br/>
                ((Report) vPhaseReport.elementAt(vPhaseReport.size() - 1)).newlines++;<br/>
            }<br/>
        }<br/>
<br/>
        // Now dislodge any swarming infantry.<br/>
        if ( Entity.NONE != swarmerId ) {<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            entity.setSwarmAttackerId( Entity.NONE );<br/>
            swarmer.setSwarmTargetId( Entity.NONE );<br/>
            // Did the infantry fall into water?<br/>
            if ( waterDepth &gt; 0 ) {<br/>
                // Swarming infantry die.<br/>
                swarmer.setPosition( fallPos );<br/>
                r = new Report(2330);<br/>
                r.newlines = 0;<br/>
                r.subject = swarmer.getId();<br/>
                r.addDesc(swarmer);<br/>
                addReport(r);<br/>
                addReport( destroyEntity(swarmer, "a watery grave", false));<br/>
            } else {<br/>
                // Swarming infantry take an 11 point hit.<br/>
                // ASSUMPTION : damage should not be doubled.<br/>
                r = new Report(2335);<br/>
                r.newlines = 0;<br/>
                r.subject = swarmer.getId();<br/>
                r.addDesc(swarmer);<br/>
                addReport(r);<br/>
                addReport( damageEntity(swarmer, swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT), 11));<br/>
                ((Report) vPhaseReport.elementAt(vPhaseReport.size() - 1)).newlines++;<br/>
            }<br/>
            swarmer.setPosition( fallPos );<br/>
            entityUpdate( swarmerId );<br/>
        } // End dislodge-infantry<br/>
<br/>
        // clear all PSRs after a fall -- the Mek has already failed ONE and fallen, it'd be cruel to make it fail some more!<br/>
        game.resetPSRs(entity);<br/>
    }<br/>
<br/>
    /**<br/>
     * The mech falls into an unoccupied hex from the given height above<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height, PilotingRollData roll) {<br/>
        doEntityFall(entity, fallPos, height, Compute.d6(1), roll);<br/>
    }<br/>
<br/>
    /**<br/>
     * The mech falls down in place<br/>
     */<br/>
    private void doEntityFall(Entity entity, PilotingRollData roll) {<br/>
        doEntityFall(entity, entity.getPosition(), 0, roll);<br/>
    }<br/>
<br/>
    /**<br/>
     * Report:<br/>
     * - Any ammo dumps beginning the following round.<br/>
     * - Any ammo dumps that have ended with the end of this round.<br/>
     */<br/>
    private void resolveAmmoDumps() {<br/>
        Report r;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            for (Enumeration j = entity.getAmmo(); j.hasMoreElements(); ) {<br/>
                Mounted m = (Mounted)j.nextElement();<br/>
                if (m.isPendingDump()) {<br/>
                    //report dumping next round<br/>
                    r = new Report(5110);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(m.getName());<br/>
                    addReport(r);<br/>
                    //update status<br/>
                    m.setPendingDump(false);<br/>
                    m.setDumping(true);<br/>
                }<br/>
                else if (m.isDumping()) {<br/>
                    //report finished dumping<br/>
                    r = new Report(5115);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(m.getName());<br/>
                    addReport(r);<br/>
                    //update status<br/>
                    m.setDumping(false);<br/>
                    m.setShotsLeft(0);<br/>
                }<br/>
            }<br/>
            entity.reloadEmptyWeapons();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the hex is set on fire with the specified roll.  Of<br/>
     * course, also checks to see that fire is possible in the specified hex.<br/>
     *<br/>
     * @param   hex - the &lt;code&gt;IHex&lt;/code&gt; to be lit.<br/>
     * @param   roll - the &lt;code&gt;int&lt;/code&gt; target number for the ignition roll<br/>
     * @param   bAnyTerrain - &lt;code&gt;true&lt;/code&gt; if the fire can be lit in any<br/>
     *          terrain.  If this value is &lt;code&gt;false&lt;/code&gt; the hex will be<br/>
     *          lit only if it contains Woods,jungle or a Building.<br/>
     * @param   entityId - the entityId responsible for the ignite attempt.<br/>
     *          If the value is Entity.NONE, then the roll attempt will not<br/>
     *          be included in the report.<br/>
     */<br/>
   public boolean ignite( IHex hex, int roll, boolean bAnyTerrain,<br/>
                          int entityId ) {<br/>
<br/>
        // The hex might be null due to spreadFire translation<br/>
        // goes outside of the board limit.<br/>
        if ( !game.getOptions().booleanOption("fire") || null == hex ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // The hex may already be on fire.<br/>
        if ( hex.containsTerrain( Terrains.FIRE ) ) {<br/>
            return true;<br/>
        }<br/>
<br/>
        if ( !bAnyTerrain &amp;&amp;<br/>
             !(hex.containsTerrain(Terrains.WOODS)) &amp;&amp;<br/>
             !(hex.containsTerrain(Terrains.JUNGLE)) &amp;&amp;<br/>
             !(hex.containsTerrain(Terrains.BUILDING)) ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        int fireRoll = Compute.d6(2);<br/>
        if (entityId != Entity.NONE) {<br/>
            Report r = new Report(3430);<br/>
            r.indent(3);<br/>
            r.subject = entityId;<br/>
            r.add(roll);<br/>
            r.add(fireRoll);<br/>
            addReport(r);<br/>
        }<br/>
        if (fireRoll &gt;= roll) {<br/>
            hex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
            return true;<br/>
        } else {<br/>
            return false;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the hex is set on fire with the specified roll.  Of<br/>
     * course, also checks to see that fire is possible in the specified hex.<br/>
     * This version of the method will not report the attempt roll.<br/>
     *<br/>
     * @param   hex - the &lt;code&gt;IHex&lt;/code&gt; to be lit.<br/>
     * @param   roll - the &lt;code&gt;int&lt;/code&gt; target number for the ignition roll<br/>
     * @param   bAnyTerrain - &lt;code&gt;true&lt;/code&gt; if the fire can be lit in any<br/>
     *          terrain.  If this value is &lt;code&gt;false&lt;/code&gt; the hex will be<br/>
     *          lit only if it contains Woods, jungle or a Building.<br/>
     */<br/>
    public boolean ignite(IHex hex, int roll, boolean bAnyTerrain)  {<br/>
       return ignite(hex, roll, bAnyTerrain, Entity.NONE);<br/>
    }<br/>
<br/>
    public boolean ignite(IHex hex, int roll) {<br/>
        // default signature, assuming only woods can burn<br/>
        return ignite(hex, roll, false, Entity.NONE);<br/>
    }<br/>
<br/>
    public void removeFire(int x, int y, IHex hex) {<br/>
        Coords fireCoords = new Coords(x, y);<br/>
        hex.removeTerrain(Terrains.FIRE);<br/>
        sendChangedHex(fireCoords);<br/>
        if (!game.getOptions().booleanOption("maxtech_fire")) {<br/>
            // only remove the 3 smoke hexes if under L2 rules!<br/>
            int windDir = game.getWindDirection();<br/>
            removeSmoke(x, y, windDir);<br/>
            removeSmoke(x, y, (windDir + 1) % 6);<br/>
            removeSmoke(x, y, (windDir + 5) % 6);<br/>
        }<br/>
        //fire goes out due to lack of fuel<br/>
        Report r = new Report(5170, Report.PUBLIC);<br/>
        r.add(fireCoords.getBoardNum());<br/>
        addReport(r);<br/>
    }<br/>
<br/>
    /**<br/>
     * called when a fire is burning.  Adds smoke to hex in the direction<br/>
     * specified.  Called 3 times per fire hex<br/>
     * @param x       The &lt;code&gt;int&lt;/code&gt; x-coordinate of the hex<br/>
     * @param y       The &lt;code&gt;int&lt;/code&gt; y-coordinate of the hex<br/>
     * @param windDir The &lt;code&gt;int&lt;/code&gt; specifying the winddirection<br/>
     */<br/>
    public void addSmoke(int x, int y, int windDir) {<br/>
        Coords smokeCoords = new Coords(Coords.xInDir(x, y, windDir), Coords.yInDir(x, y, windDir));<br/>
        IHex nextHex = game.getBoard().getHex(smokeCoords);<br/>
        if (nextHex != null &amp;&amp; !(nextHex.containsTerrain(Terrains.SMOKE))) {<br/>
            nextHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.SMOKE, 1));<br/>
            sendChangedHex(smokeCoords);<br/>
            Report r = new Report(5175, Report.PUBLIC);<br/>
            r.add(smokeCoords.getBoardNum());<br/>
            addReport(r);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Add lvl3 smoke to the hex specified by the parameters. Called once.<br/>
     * @param x       The &lt;code&gt;int&lt;/code&gt; x-coordinate of the hex<br/>
     * @param y       The &lt;code&gt;int&lt;/code&gt; y-coordinate of the hex<br/>
     */<br/>
    public void addL3Smoke(int x, int y) {<br/>
        IBoard board = game.getBoard();<br/>
        Coords smokeCoords = new Coords(x, y);<br/>
        IHex smokeHex = game.getBoard().getHex(smokeCoords);<br/>
        boolean infernoBurning = board.isInfernoBurning( smokeCoords );<br/>
        Report r;<br/>
        if (smokeHex == null) {<br/>
            return;<br/>
        }<br/>
        // Have to check if it's inferno smoke or from a heavy/hardened building - heavy smoke from those<br/>
        if (infernoBurning || Building.MEDIUM &lt; smokeHex.terrainLevel(Terrains.BUILDING)) {<br/>
            if (smokeHex.terrainLevel(Terrains.SMOKE) == 2){<br/>
                //heavy smoke fills hex<br/>
                r = new Report(5180, Report.PUBLIC);<br/>
                r.add(smokeCoords.getBoardNum());<br/>
                addReport(r);<br/>
            } else {<br/>
                if (smokeHex.terrainLevel(Terrains.SMOKE) == 1){<br/>
                    //heavy smoke overrides light<br/>
                    smokeHex.removeTerrain(Terrains.SMOKE);<br/>
                }<br/>
                smokeHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.SMOKE, 2));<br/>
                sendChangedHex(smokeCoords);<br/>
                r = new Report(5185, Report.PUBLIC);<br/>
                r.add(smokeCoords.getBoardNum());<br/>
                addReport(r);<br/>
            }<br/>
        } else {<br/>
            if (smokeHex.terrainLevel(Terrains.SMOKE) == 2){<br/>
                //heavy smoke overpowers light<br/>
                r = new Report(5190, Report.PUBLIC);<br/>
                r.add(smokeCoords.getBoardNum());<br/>
                addReport(r);<br/>
            } else if (smokeHex.terrainLevel(Terrains.SMOKE) == 1){<br/>
                //light smoke continue to fill hex<br/>
                r = new Report(5195, Report.PUBLIC);<br/>
                r.add(smokeCoords.getBoardNum());<br/>
                addReport(r);<br/>
            } else {<br/>
                smokeHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.SMOKE, 1));<br/>
                sendChangedHex(smokeCoords);<br/>
                //light smoke fills hex<br/>
                r = new Report(5200, Report.PUBLIC);<br/>
                r.add(smokeCoords.getBoardNum());<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    public void removeSmoke(int x, int y, int windDir) { // L2 smoke removal<br/>
        Coords smokeCoords = new Coords(Coords.xInDir(x, y, windDir), Coords.yInDir(x, y, windDir));<br/>
        IHex nextHex = game.getBoard().getHex(smokeCoords);<br/>
        if (nextHex != null &amp;&amp; nextHex.containsTerrain(Terrains.SMOKE)) {<br/>
            nextHex.removeTerrain(Terrains.SMOKE);<br/>
            sendChangedHex(smokeCoords);<br/>
            Report r = new Report(5205, Report.PUBLIC);<br/>
            r.add(smokeCoords.getBoardNum());<br/>
            addReport(r);<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Scans the boards directory for map boards of the appropriate size<br/>
     * and returns them.<br/>
     */<br/>
    private Vector scanForBoardsInDir (File dir, String addPath, int w, int h) {<br/>
        String fileList[] = dir.list();<br/>
        Vector tempList = new Vector();<br/>
        Comparator sortComp = StringUtil.stringComparator();<br/>
        for (int i = 0; i &lt; fileList.length; i++) {<br/>
            if (fileList[i].indexOf(".board") == -1) {<br/>
                continue;<br/>
            }<br/>
            if (Board.boardIsSize(addPath.concat("/").concat(fileList[i]), w, h)) {<br/>
                tempList.addElement(addPath.concat("/").concat(fileList[i].substring(0, fileList[i].lastIndexOf(".board"))));<br/>
            }<br/>
        }<br/>
        return tempList;<br/>
    }<br/>
    <br/>
    private Vector scanForBoards(int boardWidth, int boardHeight) {<br/>
        return scanForBoards (boardWidth, boardHeight, game.getOptions().booleanOption("maps_include_subdir"));<br/>
    }<br/>
    <br/>
    private Vector scanForBoards(int boardWidth, int boardHeight, boolean subdirs) {<br/>
        Vector boards = new Vector();<br/>
<br/>
        File boardDir = new File("data/boards");<br/>
        boards.addElement(MapSettings.BOARD_GENERATED);<br/>
        // just a check...<br/>
        if (!boardDir.isDirectory()) {<br/>
            return boards;<br/>
        }<br/>
<br/>
        // scan files<br/>
        String[] fileList = boardDir.list();<br/>
        Vector tempList = new Vector();<br/>
        Comparator sortComp = StringUtil.stringComparator();<br/>
        for (int i = 0; i &lt; fileList.length; i++) {<br/>
            File x = new File (new String("data/boards/").concat(fileList[i]));<br/>
            if (x.isDirectory() &amp;&amp; subdirs) {<br/>
                tempList.addAll(scanForBoardsInDir(x, fileList[i], boardWidth, boardHeight));<br/>
                continue;<br/>
            }<br/>
            if (fileList[i].indexOf(".board") == -1) {<br/>
                continue;<br/>
            }<br/>
            if (Board.boardIsSize(fileList[i], boardWidth, boardHeight)) {<br/>
                tempList.addElement(fileList[i].substring(0, fileList[i].lastIndexOf(".board")));<br/>
            }<br/>
        }<br/>
<br/>
        // if there are any boards, add these:<br/>
        if (tempList.size() &gt; 0) {<br/>
            boards.addElement( MapSettings.BOARD_RANDOM );<br/>
            boards.addElement( MapSettings.BOARD_SURPRISE );<br/>
            Collections.sort(tempList, sortComp);<br/>
            for ( int loop = 0; loop &lt; tempList.size(); loop++ ) {<br/>
                boards.addElement( tempList.elementAt(loop) );<br/>
            }<br/>
        }<br/>
<br/>
        //TODO: alphabetize files?<br/>
<br/>
        return boards;<br/>
    }<br/>
<br/>
    private boolean doBlind() {<br/>
        return (game.getOptions().booleanOption("double_blind") &amp;&amp;<br/>
        game.getPhase() &gt;= IGame.PHASE_DEPLOYMENT);<br/>
    }<br/>
<br/>
    /**<br/>
     * In a double-blind game, update only visible entities.  Otherwise,<br/>
     * update everyone<br/>
     */<br/>
    private void entityUpdate(int nEntityID) {<br/>
        entityUpdate(nEntityID, new Vector());<br/>
    }<br/>
<br/>
    private void entityUpdate(int nEntityID, Vector movePath) {<br/>
        Entity eTarget = game.getEntity(nEntityID);<br/>
        if(eTarget == null) {<br/>
            if(game.getOutOfGameEntity(nEntityID) != null) {<br/>
                System.err.printf("S: attempted to send entity update for out of game entity, id was %d\n", nEntityID);<br/>
            } else {<br/>
                System.err.printf("S: attempted to send entity update for null entity, id was %d\n", nEntityID);<br/>
            }<br/>
            return; //do not send the update it will crash the client<br/>
        }<br/>
        if (doBlind()) {<br/>
            Vector vPlayers = game.getPlayersVector();<br/>
            Vector vCanSee = whoCanSee(eTarget);<br/>
            // send an entity update to everyone who can see<br/>
            Packet pack = createEntityPacket(nEntityID, movePath);<br/>
            for (int x = 0; x &lt; vCanSee.size(); x++) {<br/>
                Player p = (Player)vCanSee.elementAt(x);<br/>
                send(p.getId(), pack);<br/>
            }<br/>
            // send an entity delete to everyone else<br/>
            pack = createRemoveEntityPacket( nEntityID,<br/>
                                             eTarget.getRemovalCondition() );<br/>
            for (int x = 0; x &lt; vPlayers.size(); x++) {<br/>
                if (!vCanSee.contains(vPlayers.elementAt(x))) {<br/>
                    Player p = (Player)vPlayers.elementAt(x);<br/>
                    send(p.getId(), pack);<br/>
                }<br/>
            }<br/>
        }<br/>
        else {<br/>
            // everyone can see<br/>
            send(createEntityPacket(nEntityID, movePath));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a vector of which players can see this entity.<br/>
     */<br/>
    private Vector whoCanSee(Entity entity) {<br/>
        <br/>
        //Some times Null entities are sent to this<br/>
        if ( entity == null )<br/>
            return new Vector();<br/>
        <br/>
        boolean bTeamVision = game.getOptions().booleanOption("team_vision");<br/>
        Vector vEntities = game.getEntitiesVector();<br/>
<br/>
        Vector vCanSee = new Vector();<br/>
        vCanSee.addElement(entity.getOwner());<br/>
        if (bTeamVision) {<br/>
            addTeammates(vCanSee, entity.getOwner());<br/>
        }<br/>
<br/>
        for (Enumeration p = game.getPlayers(); p.hasMoreElements();) {<br/>
            Player player = (Player)p.nextElement();<br/>
<br/>
            if (player.canSeeAll() &amp;&amp; !vCanSee.contains(p))<br/>
                vCanSee.addElement(player);<br/>
        }<br/>
<br/>
        for (int i = 0; i &lt; vEntities.size(); i++) {<br/>
            Entity e = (Entity)vEntities.elementAt(i);<br/>
            if (vCanSee.contains(e.getOwner()) || !e.isActive()) {<br/>
                continue;<br/>
            }<br/>
            if(e.isOffBoard()) {<br/>
                continue; //Off board units should not spot on board units<br/>
            }<br/>
            if (Compute.canSee(game, e, entity)) {<br/>
                vCanSee.addElement(e.getOwner());<br/>
                if (bTeamVision) {<br/>
                    addTeammates(vCanSee, e.getOwner());<br/>
                }<br/>
            }<br/>
        }<br/>
        return vCanSee;<br/>
    }<br/>
<br/>
    private boolean canSee(Player p, Entity e) {<br/>
        if (e.getOwner().getId() == p.getId()) {<br/>
            //The owner of an entity should be able to see it, of course.<br/>
            return true;<br/>
        }<br/>
        Vector playersWhoCanSee = whoCanSee(e);<br/>
        for (int i = 0; i &lt; playersWhoCanSee.size(); i++) {<br/>
            Player currentPlayer = (Player)playersWhoCanSee.elementAt(i);<br/>
            if (currentPlayer.equals(p)) {<br/>
                return true;<br/>
            }<br/>
        }<br/>
<br/>
        return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds teammates of a player to the Vector.<br/>
     * Utility function for whoCanSee.<br/>
     */<br/>
    private void addTeammates(Vector vector, Player player) {<br/>
        Vector vPlayers = game.getPlayersVector();<br/>
        for (int j = 0; j &lt; vPlayers.size(); j++) {<br/>
            Player p = (Player)vPlayers.elementAt(j);<br/>
            if (!player.isEnemyOf(p) &amp;&amp; !vector.contains(p)) {<br/>
                vector.addElement(p);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Send the complete list of entities to the players.<br/>
     * If double_blind is in effect, enforce it by filtering the entities<br/>
     */<br/>
    private void entityAllUpdate() {<br/>
        if (doBlind()) {<br/>
            Vector vPlayers = game.getPlayersVector();<br/>
            for (int x = 0; x &lt; vPlayers.size(); x++) {<br/>
                Player p = (Player)vPlayers.elementAt(x);<br/>
                send(p.getId(), createFilteredEntitiesPacket(p));<br/>
            }<br/>
        }<br/>
        else {<br/>
            send(createEntitiesPacket());<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Filters an entity vector according to LOS<br/>
     */<br/>
    private Vector filterEntities(Player pViewer, Vector vEntities) {<br/>
        Vector vCanSee = new Vector();<br/>
        Vector vAllEntities = game.getEntitiesVector();<br/>
        Vector vMyEntities = new Vector();<br/>
        boolean bTeamVision = game.getOptions().booleanOption("team_vision");<br/>
<br/>
        // If they can see all, return the input list<br/>
        if (pViewer.canSeeAll()) {<br/>
            return vEntities;<br/>
        }<br/>
<br/>
        for (int x = 0; x &lt; vAllEntities.size(); x++) {<br/>
            Entity e = (Entity)vAllEntities.elementAt(x);<br/>
            if (e.getOwner() == pViewer || (bTeamVision &amp;&amp; !e.getOwner().isEnemyOf(pViewer))) {<br/>
                vMyEntities.addElement(e);<br/>
            }<br/>
        }<br/>
<br/>
        for (int x = 0; x &lt; vEntities.size(); x++) {<br/>
            Entity e = (Entity)vEntities.elementAt(x);<br/>
            if (vMyEntities.contains(e)) {<br/>
                vCanSee.addElement(e);<br/>
                continue;<br/>
            }<br/>
            for (int y = 0; y &lt; vMyEntities.size(); y++) {<br/>
                Entity e2 = (Entity)vMyEntities.elementAt(y);<br/>
                if(e2.isOffBoard()) {<br/>
                    continue;<br/>
                }<br/>
                if (Compute.canSee(game, e2, e)) {<br/>
                    vCanSee.addElement(e);<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
        return vCanSee;<br/>
    }<br/>
<br/>
    //optimize and document me<br/>
    private Vector filterReportVector(Vector originalReportVector, Player p) {<br/>
        if (!doBlind()) {<br/>
            //don't bother filtering if double-blind rules aren't in effect<br/>
            return (Vector)originalReportVector.clone();<br/>
        }<br/>
        Vector filteredReportVector = new Vector();<br/>
        Report r;<br/>
        for (int i = 0; i &lt; originalReportVector.size(); i++) {<br/>
            r = (Report)originalReportVector.elementAt(i);<br/>
            filteredReportVector.addElement(filterReport(r, p, false));<br/>
        }<br/>
<br/>
        return filteredReportVector;<br/>
    }<br/>
<br/>
    /**<br/>
     * Filter a single report so that the correct double-blind<br/>
     * obscuration takes place.<br/>
     *<br/>
     * @param r the Report to filter<br/>
     * @param p the Player that we are going to send the filtered report to<br/>
     * @param omitCheck boolean indicating that this report hapened in<br/>
     * the past, so we no longer have access to the Player<br/>
     * @return a new Report, which has possibly been obscured<br/>
     */<br/>
    private Report filterReport(Report r, Player p, boolean omitCheck) {<br/>
        if (r.subject == Entity.NONE &amp;&amp; r.type != Report.PUBLIC) {<br/>
            //Reports that don't have a subject should be public.<br/>
            System.err.println("Error: Attempting to filter a Report object that is not public yet has no subject.\n\t\tmessageId: " + r.messageId);<br/>
            return r;<br/>
        }<br/>
        if (r.type == Report.PUBLIC || (p == null &amp;&amp; !omitCheck)) {<br/>
            return r;<br/>
        }<br/>
        Entity entity = game.getEntity(r.subject);<br/>
        Player owner = null;<br/>
        if (entity != null)<br/>
            owner = entity.getOwner();<br/>
        if (!omitCheck &amp;&amp; (entity == null || owner == null)) {<br/>
            System.err.println("Error: Attempting to filter a Report object that is not public but has a subject (" + entity + ") with owner (" + owner + ").\n\tmessageId: " + r.messageId);<br/>
            return r;<br/>
        }<br/>
        //off board (Artillery) units get treated as public messages<br/>
        if ( entity.isOffBoard() )<br/>
            return r;<br/>
        Report copy = new Report(r);<br/>
        for (int j = 0; j &lt; copy.dataCount(); j++) {<br/>
            if (omitCheck || !canSee(p, entity)) {<br/>
                if (r.isValueObscured(j)) {<br/>
                    copy.hideData(j);<br/>
                    //Mark the original report to indicate which players<br/>
                    // received an obscured version of it.<br/>
                    if (p != null)<br/>
                        r.addObscuredRecipient(p.getName());<br/>
                }<br/>
                //simulate hiding the report for *true* double-blind play<br/>
                //***DEBUG*** TESTING ONLY<br/>
                //copy.markForTesting();<br/>
            }<br/>
        }<br/>
        return copy;<br/>
    }<br/>
<br/>
    private Vector filterPastReports(Vector pastReports, Player p) {<br/>
        //This stuff really only needs to be printed for debug reasons. other wise the logs get<br/>
        //filled to the brim when ever someone connects. --Torren.<br/>
        System.err.println("filterPastReports() begin");<br/>
        System.err.println("  player is " + p.getName());<br/>
        if (doBlind()) {<br/>
            //System.err.println("  pastReports vector is\n" + pastReports);<br/>
            Vector filteredReports = new Vector();<br/>
            Vector filteredRoundReports = new Vector();<br/>
            Vector roundReports = new Vector();<br/>
            Report r;<br/>
            for (int i = 0; i &lt; pastReports.size(); i++) {<br/>
                roundReports = (Vector)pastReports.elementAt(i);<br/>
                //System.err.println("  roundReports vector is\n" + roundReports);<br/>
                for (int j = 0; j &lt; roundReports.size(); j++) {<br/>
                    r = (Report)roundReports.elementAt(j);<br/>
                    if (r.isObscuredRecipient(p.getName())) {<br/>
                        //System.err.println("  report is " + r + " -obscuring-");<br/>
                        filteredRoundReports.addElement(filterReport(r, null, true));<br/>
                    } else {<br/>
                        //System.err.println("  report is " + r);<br/>
                        filteredRoundReports.addElement(r);<br/>
                    }<br/>
                }<br/>
                //System.err.println("  filteredRoundReport is\n" + filteredRoundReports);<br/>
                filteredReports.addElement(filteredRoundReports.clone());<br/>
                filteredRoundReports.removeAllElements();<br/>
            }<br/>
            System.err.println("filterPastReports() end");<br/>
            return filteredReports;<br/>
        } else {<br/>
            //don't bother filtering if double-blind rules aren't in effect<br/>
            System.err.println("filterPastReports() end");<br/>
            return pastReports;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Updates entities graphical "visibility indications" which are used<br/>
     *  in double-blind games.<br/>
     */<br/>
    private void updateVisibilityIndicator() {<br/>
        Vector vAllEntities = game.getEntitiesVector();<br/>
        for (int x = 0; x &lt; vAllEntities.size(); x++) {<br/>
            Entity e = (Entity)vAllEntities.elementAt(x);<br/>
            boolean previousVisibleValue = e.isVisibleToEnemy();<br/>
            boolean previousSeenValue = e.isSeenByEnemy();<br/>
            e.setVisibleToEnemy(false);<br/>
            Vector vCanSee = whoCanSee(e);<br/>
            for (int y = 0; y &lt; vCanSee.size(); y++) {<br/>
                Player p = (Player)vCanSee.elementAt(y);<br/>
                if (e.getOwner().isEnemyOf(p) &amp;&amp; !p.isObserver()) {<br/>
                    e.setVisibleToEnemy(true);<br/>
                    e.setSeenByEnemy(true);<br/>
                }<br/>
            }<br/>
            if (previousVisibleValue != e.isVisibleToEnemy()<br/>
                || previousSeenValue != e.isSeenByEnemy()) {<br/>
                sendVisibilityIndicator(e);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks if an entity added by the client is valid and if so, adds it to the list<br/>
     */<br/>
    private void receiveEntityAdd(Packet c, int connIndex) {<br/>
        final Entity entity = (Entity)c.getObject(0);<br/>
<br/>
        //Verify the entity's design<br/>
        if (Server.entityVerifier == null)<br/>
            Server.entityVerifier = new EntityVerifier(new File(VERIFIER_CONFIG_FILENAME));<br/>
        // we can only test meks and vehicles right now<br/>
        if (entity instanceof Mech || entity instanceof Tank) {<br/>
            TestEntity testEntity = null;<br/>
            entity.restore();<br/>
            if (entity instanceof Mech)<br/>
                testEntity = new TestMech((Mech)entity, Server.entityVerifier.mechOption, null);<br/>
            if (entity instanceof VTOL)<br/>
                testEntity = new TestTank((Tank)entity, Server.entityVerifier.tankOption, null);//not implemented yet.<br/>
            if (entity instanceof Tank)<br/>
                testEntity = new TestTank((Tank)entity, Server.entityVerifier.tankOption, null);<br/>
            StringBuffer sb = new StringBuffer();<br/>
            if (testEntity.correctEntity(sb, !game.getOptions().booleanOption("is_eq_limits"))) {<br/>
                entity.setDesignValid(true);<br/>
            } else {<br/>
                if (game.getOptions().booleanOption("allow_illegal_units")) {<br/>
                    entity.setDesignValid(false);<br/>
                } else {<br/>
                    Player cheater = game.getPlayer( connIndex );<br/>
                    sendServerChat("Player " + cheater.getName() + " attempted to add an illegal unit design (" + entity.getShortNameRaw() + "), the unit was rejected.");<br/>
                    System.err.println(sb);<br/>
                    return;<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        // If we're adding a Protomech, calculate it's unit number.<br/>
        if ( entity instanceof Protomech ) {<br/>
<br/>
            // How many Protomechs does the player already have?<br/>
            int numPlayerProtos = game.getSelectedEntityCount<br/>
                ( new EntitySelector() {<br/>
                        private final int ownerId = entity.getOwnerId();<br/>
                        public boolean accept( Entity entity ) {<br/>
                            if ( entity instanceof Protomech &amp;&amp;<br/>
                                 ownerId == entity.getOwnerId() )<br/>
                                return true;<br/>
                            return false;<br/>
                        }<br/>
                    } );<br/>
<br/>
            // According to page 54 of the BMRr, Protomechs must be<br/>
            // deployed in full Points of five, unless circumstances have<br/>
            // reduced the number to less that that.<br/>
            entity.setUnitNumber( (char) (numPlayerProtos / 5) );<br/>
<br/>
        } // End added-Protomech<br/>
<br/>
        // Only assign an entity ID when the client hasn't.<br/>
        if ( Entity.NONE == entity.getId() ) {<br/>
            entity.setId(getFreeEntityId());<br/>
        }<br/>
<br/>
        game.addEntity(entity.getId(), entity);<br/>
        send(createAddEntityPacket(entity.getId()));<br/>
    }<br/>
<br/>
    /**<br/>
     * Updates an entity with the info from the client.  Only valid to do this<br/>
     * during the lounge phase, except for heat sink changing.<br/>
     */<br/>
    private void receiveEntityUpdate(Packet c, int connIndex) {<br/>
        Entity entity = (Entity)c.getObject(0);<br/>
        Entity oldEntity = game.getEntity(entity.getId());<br/>
        if (oldEntity != null &amp;&amp; oldEntity.getOwner() == getPlayer(connIndex)) {<br/>
            game.setEntity(entity.getId(), entity);<br/>
            entityUpdate(entity.getId());<br/>
            // In the chat lounge, notify players of customizing of unit<br/>
            if (game.getPhase() == IGame.PHASE_LOUNGE) {<br/>
                StringBuffer message = new StringBuffer();<br/>
                message.append( "Unit " );<br/>
                if(game.getOptions().booleanOption("blind_drop")<br/>
                    || game.getOptions().booleanOption("real_blind_drop")) {<br/>
                    if(Entity.NONE != entity.getExternalId()) {<br/>
                        message.append("[").append(entity.getExternalId()).append("] ");<br/>
                    }<br/>
                    message.append(entity.getId())<br/>
                        .append("(")<br/>
                        .append(entity.getOwner().getName())<br/>
                        .append(")");<br/>
                } else {<br/>
                    message.append( entity.getDisplayName() );<br/>
                }<br/>
                message.append( " has been customized." );<br/>
                sendServerChat( message.toString() );<br/>
            }<br/>
        } else {<br/>
            // hey!<br/>
        }<br/>
    }<br/>
<br/>
    private void receiveEntityModeChange(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        int equipId = c.getIntValue(1);<br/>
        int mode = c.getIntValue(2);<br/>
        Entity e = game.getEntity(entityId);<br/>
        if (e.getOwner() != getPlayer(connIndex)) {<br/>
            return;<br/>
        }<br/>
        Mounted m = e.getEquipment(equipId);<br/>
<br/>
        // a mode change for ammo means dumping<br/>
        if (m.getType() instanceof AmmoType<br/>
            &amp;&amp; !(m.getType().hasInstantModeSwitch())) {<br/>
            m.setPendingDump(mode == 1);<br/>
        }<br/>
        else {<br/>
            m.setMode(mode);<br/>
        }<br/>
    }<br/>
<br/>
    private void receiveEntitySystemModeChange(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        int equipId = c.getIntValue(1);<br/>
        int mode = c.getIntValue(2);<br/>
        Entity e = game.getEntity(entityId);<br/>
        if (e.getOwner() != getPlayer(connIndex)) {<br/>
            return;<br/>
        }<br/>
        if(e instanceof Mech &amp;&amp; equipId == Mech.SYSTEM_COCKPIT) {<br/>
            ((Mech)e).setCockpitStatus(mode);<br/>
        }<br/>
    }<br/>
<br/>
    private void receiveEntityAmmoChange(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        int weaponId = c.getIntValue(1);<br/>
        int ammoId = c.getIntValue(2);<br/>
        Entity e = game.getEntity(entityId);<br/>
<br/>
        // Did we receive a request for a valid Entity?<br/>
        if ( null == e ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: could not find entity #" );<br/>
            System.err.println( entityId );<br/>
            return;<br/>
        }<br/>
        Player player = getPlayer( connIndex );<br/>
        if ( null != player &amp;&amp; e.getOwner() != player ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: player " );<br/>
            System.err.print( player.getName() );<br/>
            System.err.print( " does not own the entity " );<br/>
            System.err.println( e.getDisplayName() );<br/>
            return;<br/>
        }<br/>
<br/>
        // Make sure that the entity has the given equipment.<br/>
        Mounted mWeap = e.getEquipment(weaponId);<br/>
        Mounted mAmmo = e.getEquipment(ammoId);<br/>
        if ( null == mAmmo ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " does not have ammo #" );<br/>
            System.err.println( ammoId );<br/>
            return;<br/>
        }<br/>
        if ( !(mAmmo.getType() instanceof AmmoType) ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: item # " );<br/>
            System.err.print( ammoId );<br/>
            System.err.print( " of entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " is a " );<br/>
            System.err.print( mAmmo.getName() );<br/>
            System.err.println( " and not ammo." );<br/>
            return;<br/>
        }<br/>
        if ( null == mWeap ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " does not have weapon #" );<br/>
            System.err.println( weaponId );<br/>
            return;<br/>
        }<br/>
        if ( !(mWeap.getType() instanceof WeaponType) ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: item # " );<br/>
            System.err.print( weaponId );<br/>
            System.err.print( " of entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " is a " );<br/>
            System.err.print( mWeap.getName() );<br/>
            System.err.println( " and not a weapon." );<br/>
            return;<br/>
        }<br/>
        if ( ((WeaponType) mWeap.getType()).getAmmoType() == AmmoType.T_NA ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: item # " );<br/>
            System.err.print( weaponId );<br/>
            System.err.print( " of entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " is a " );<br/>
            System.err.print( mWeap.getName() );<br/>
            System.err.println( " and does not use ammo." );<br/>
            return;<br/>
        }<br/>
        if ( ((WeaponType) mWeap.getType()).hasFlag(WeaponType.F_ONESHOT)) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: item # " );<br/>
            System.err.print( weaponId );<br/>
            System.err.print( " of entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " is a " );<br/>
            System.err.print( mWeap.getName() );<br/>
            System.err.println( " and cannot use external ammo." );<br/>
            return;<br/>
        }<br/>
<br/>
        // Load the weapon.<br/>
        e.loadWeapon( mWeap, mAmmo );<br/>
    }<br/>
<br/>
    /**<br/>
     * Deletes an entity owned by a certain player from the list<br/>
     */<br/>
    private void receiveEntityDelete(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        final Entity entity = game.getEntity(entityId);<br/>
<br/>
        // Only allow players to delete their *own* entities.<br/>
        if ( entity != null &amp;&amp; entity.getOwner() == getPlayer(connIndex) ) {<br/>
<br/>
            // If we're deleting a Protomech, recalculate unit numbers.<br/>
            if ( entity instanceof Protomech ) {<br/>
<br/>
                // How many Protomechs does the player have (include this one)?<br/>
                int numPlayerProtos = game.getSelectedEntityCount<br/>
                    ( new EntitySelector() {<br/>
                            private final int ownerId = entity.getOwnerId();<br/>
                            public boolean accept( Entity entity ) {<br/>
                                if ( entity instanceof Protomech &amp;&amp;<br/>
                                     ownerId == entity.getOwnerId() )<br/>
                                    return true;<br/>
                                return false;<br/>
                            }<br/>
                        } );<br/>
<br/>
                // According to page 54 of the BMRr, Protomechs must be<br/>
                // deployed in full Points of five, unless "losses" have<br/>
                // reduced the number to less that that.<br/>
                final char oldMax =<br/>
                    (char)(Math.ceil( numPlayerProtos / 5.0 )-1);<br/>
                char newMax =<br/>
                    (char)(Math.ceil( (numPlayerProtos-1)/ 5.0 )-1);<br/>
                char deletedUnitNum = entity.getUnitNumber();<br/>
<br/>
                // Do we have to update a Protomech from the last unit?<br/>
                if ( oldMax != deletedUnitNum &amp;&amp; oldMax != newMax ) {<br/>
<br/>
                    // Yup.  Find a Protomech from the last unit, and<br/>
                    // set it's unit number to the deleted entity.<br/>
                    Enumeration lastUnit = game.getSelectedEntities<br/>
                        ( new EntitySelector() {<br/>
                            private final int ownerId = entity.getOwnerId();<br/>
                            private final char lastUnitNum = oldMax;<br/>
                            public boolean accept( Entity entity ) {<br/>
                                if ( entity instanceof Protomech &amp;&amp;<br/>
                                     ownerId == entity.getOwnerId() &amp;&amp;<br/>
                                     lastUnitNum == entity.getUnitNumber() )<br/>
                                    return true;<br/>
                                return false;<br/>
                            }<br/>
                        } );<br/>
                    Entity lastUnitMember = (Entity) lastUnit.nextElement();<br/>
                    lastUnitMember.setUnitNumber( deletedUnitNum );<br/>
                    this.entityUpdate( lastUnitMember.getId() );<br/>
<br/>
                } // End update-unit-numbetr<br/>
<br/>
            } // End added-Protomech<br/>
<br/>
            game.removeEntity(entityId, IEntityRemovalConditions.REMOVE_NEVER_JOINED);<br/>
            send(createRemoveEntityPacket(entityId, IEntityRemovalConditions.REMOVE_NEVER_JOINED));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a player's ready status<br/>
     */<br/>
    private void receivePlayerDone(Packet pkt, int connIndex) {<br/>
        boolean ready = pkt.getBooleanValue(0);<br/>
        Player player = getPlayer(connIndex);<br/>
        if ( null != player ) {<br/>
            player.setDone(ready);<br/>
        }<br/>
    }<br/>
<br/>
    private void receiveInitiativeRerollRequest(Packet pkt, int connIndex) {<br/>
        Player player = getPlayer(connIndex);<br/>
        if ( IGame.PHASE_INITIATIVE_REPORT != game.getPhase() ) {<br/>
            StringBuffer message = new StringBuffer();<br/>
            if ( null == player ) {<br/>
                message.append( "Player #" )<br/>
                    .append( connIndex );<br/>
            } else {<br/>
                message.append( player.getName() );<br/>
            }<br/>
            message.append( " is not allowed to ask for a reroll at this time." );<br/>
            System.err.println( message.toString() );<br/>
            sendServerChat( message.toString() );<br/>
            return;<br/>
        }<br/>
        if (game.hasTacticalGenius(player)) {<br/>
            game.addInitiativeRerollRequest(game.getTeamForPlayer(player));<br/>
        }<br/>
        if ( null != player ) {<br/>
            player.setDone(true);<br/>
        }<br/>
        checkReady();<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets game options, providing that the player has specified the password<br/>
     * correctly.<br/>
     *<br/>
     * @return true if any options have been successfully changed.<br/>
     */<br/>
    private boolean receiveGameOptions(Packet packet, int connId) {<br/>
        Player player = game.getPlayer( connId );<br/>
        // Check player<br/>
        if ( null == player ) {<br/>
            System.err.print<br/>
                ( "Server does not recognize player at connection " );<br/>
            System.err.println( connId );<br/>
            return false;<br/>
        }<br/>
<br/>
        // check password<br/>
        if (password != null &amp;&amp; password.length() &gt; 0 &amp;&amp; !password.equals(packet.getObject(0))) {<br/>
            sendServerChat(connId, "The password you specified to change game options is incorrect.");<br/>
            return false;<br/>
        }<br/>
<br/>
        int changed = 0;<br/>
<br/>
        for (Enumeration i = ((Vector)packet.getObject(1)).elements(); i.hasMoreElements();) {<br/>
            IBasicOption option = (IBasicOption)i.nextElement();<br/>
            IOption originalOption = game.getOptions().getOption(option.getName());<br/>
<br/>
            if (originalOption == null) {<br/>
                continue;<br/>
            }<br/>
<br/>
            StringBuffer message = new StringBuffer();<br/>
            message.append( "Player " )<br/>
                .append( player.getName() )<br/>
                .append( " changed option \"" )<br/>
                .append( originalOption.getDisplayableName() )<br/>
                .append( "\" to " )<br/>
                .append( option.getValue().toString() )<br/>
                .append( "." );<br/>
            sendServerChat( message.toString() );<br/>
            originalOption.setValue(option.getValue());<br/>
            changed++;            <br/>
        }<br/>
<br/>
        // Set proper RNG<br/>
        Compute.setRNG(game.getOptions().intOption("rng_type"));<br/>
<br/>
        return changed &gt; 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Performs the additional processing of the received options after the the <br/>
     * &lt;code&gt;receiveGameOptions&lt;code&gt; done its job; should be called after<br/>
     * &lt;code&gt;receiveGameOptions&lt;code&gt; only if the &lt;code&gt;receiveGameOptions&lt;code&gt; <br/>
     * returned &lt;code&gt;true&lt;/code&gt;    <br/>
     * @param packet<br/>
     * @param connId<br/>
     */<br/>
    private void receiveGameOptionsAux(Packet packet, int connId) {<br/>
<br/>
        for (Enumeration i = ((Vector)packet.getObject(1)).elements(); i.hasMoreElements();) {<br/>
            IBasicOption option = (IBasicOption)i.nextElement();<br/>
            IOption originalOption = game.getOptions().getOption(option.getName());<br/>
            if (originalOption != null) {<br/>
                if ("maps_include_subdir".equals(originalOption.getName())) {<br/>
                    mapSettings.setBoardsAvailableVector(scanForBoards(mapSettings.getBoardWidth(), mapSettings.getBoardHeight()));<br/>
                    mapSettings.removeUnavailable();<br/>
                    mapSettings.setNullBoards(DEFAULT_BOARD);<br/>
                    send(createMapSettingsPacket());                                    <br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out all player info to the specified connection<br/>
     */<br/>
    private void transmitAllPlayerConnects(int connId) {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            send(connId, createPlayerConnectPacket(player.getId()));<br/>
        }<br/>
    }<br/>
<br/>
<br/>
<br/>
    /**<br/>
     * Creates a packet informing that the player has connected<br/>
     */<br/>
    private Packet createPlayerConnectPacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_ADD, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the player info, for update<br/>
     */<br/>
    private Packet createPlayerUpdatePacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_UPDATE, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out the player info updates for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerUpdates() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if ( null != player ) {<br/>
                send(createPlayerUpdatePacket(player.getId()));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out the player ready stats for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerDones() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            send(createPlayerDonePacket(player.getId()));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the player ready status<br/>
     */<br/>
    private Packet createPlayerDonePacket(int playerId) {<br/>
        Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = new Boolean(getPlayer(playerId).isDone());<br/>
        return new Packet(Packet.COMMAND_PLAYER_READY, data);<br/>
    }<br/>
<br/>
    /** Creates a packet containing the current turn vector */<br/>
    private Packet createTurnVectorPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_TURNS, game.getTurnVector());<br/>
    }<br/>
<br/>
    /** Creates a packet containing the current turn index */<br/>
    private Packet createTurnIndexPacket() {<br/>
        return new Packet(Packet.COMMAND_TURN, new Integer(game.getTurnIndex()));<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the map settings<br/>
     */<br/>
    private Packet createMapSettingsPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_MAP_SETTINGS, mapSettings);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing temporary map settings as a response to a<br/>
     * client query<br/>
     */<br/>
    private Packet createMapQueryPacket(MapSettings temp) {<br/>
        return new Packet(Packet.COMMAND_QUERY_MAP_SETTINGS, temp);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the game settingss<br/>
     */<br/>
    private Packet createGameSettingsPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_GAME_SETTINGS, game.getOptions());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the game board<br/>
     */<br/>
    private Packet createBoardPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_BOARD, game.getBoard());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a single entity, for update<br/>
     */<br/>
    private Packet createEntityPacket(int entityId) {<br/>
        return createEntityPacket(entityId, new Vector());<br/>
    }<br/>
    private Packet createEntityPacket(int entityId, Vector movePath) {<br/>
        final Entity entity = game.getEntity(entityId);<br/>
        final Object[] data = new Object[3];<br/>
        data[0] = new Integer(entityId);<br/>
        data[1] = entity;<br/>
        data[2] = movePath;<br/>
        return new Packet(Packet.COMMAND_ENTITY_UPDATE, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a Vector of Reports<br/>
     */<br/>
    private Packet createReportPacket(Player p) {<br/>
        //when the final report is created MM sends a null player to create the <br/>
        //report so this will handel that issue.<br/>
        if ( p == null || !doBlind() )<br/>
            return new Packet(Packet.COMMAND_SENDING_REPORTS, filterReportVector(vPhaseReport, p));<br/>
        else<br/>
            return new Packet(Packet.COMMAND_SENDING_REPORTS, p.getTurnReport());   <br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a Vector of special Reports which<br/>
     * needs to be sent during a phase that is not a report phase.<br/>
     */<br/>
    private Packet createSpecialReportPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_REPORTS_SPECIAL, vPhaseReport.clone());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a Vector of Reports that represent<br/>
     * a Tactical Genius re-roll request which needs to update a<br/>
     * current phase's report.<br/>
     */<br/>
    private Packet createTacticalGeniusReportPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_REPORTS_TACTICAL_GENIUS, vPhaseReport.clone());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all the round reports<br/>
     */<br/>
    private Packet createAllReportsPacket(Player p) {<br/>
        return new Packet(Packet.COMMAND_SENDING_REPORTS_ALL, filterPastReports(game.getAllReports(), p));<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all current entities<br/>
     */<br/>
    private Packet createEntitiesPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, game.getEntitiesVector());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all current and out-of-game entities<br/>
     */<br/>
    private Packet createFullEntitiesPacket() {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = game.getEntitiesVector();<br/>
        data[1] = game.getOutOfGameEntitiesVector();<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all entities visible to the player in a blind game<br/>
     */<br/>
    private Packet createFilteredEntitiesPacket(Player p) {<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, filterEntities(p, game.getEntitiesVector()));<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all entities, including wrecks, visible to the player in a blind game<br/>
     */<br/>
    private Packet createFilteredFullEntitiesPacket(Player p) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = filterEntities(p, game.getEntitiesVector());<br/>
        data[1] = game.getOutOfGameEntitiesVector();<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet detailing the addition of an entity<br/>
     */<br/>
    private Packet createAddEntityPacket(int entityId) {<br/>
        final Entity entity = game.getEntity(entityId);<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(entityId);<br/>
        data[1] = entity;<br/>
        return new Packet(Packet.COMMAND_ENTITY_ADD, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet detailing the removal of an entity.<br/>
     * Maintained for backwards compatability.<br/>
     *<br/>
     * @param   entityId - the &lt;code&gt;int&lt;/code&gt; ID of the entity being removed.<br/>
     * @return  A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.<br/>
     */<br/>
    private Packet createRemoveEntityPacket(int entityId) {<br/>
        return this.createRemoveEntityPacket(entityId, IEntityRemovalConditions.REMOVE_SALVAGEABLE);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet detailing the removal of an entity.<br/>
     *<br/>
     * @param   entityId - the &lt;code&gt;int&lt;/code&gt; ID of the entity being removed.<br/>
     * @param   condition - the &lt;code&gt;int&lt;/code&gt; condition the unit was in.<br/>
     *          This value must be one of &lt;code&gt;Game.UNIT_IN_RETREAT&lt;/code&gt;,<br/>
     *          &lt;code&gt;Game.UNIT_PUSHED&lt;/code&gt;, or<br/>
     *          &lt;code&gt;Game.UNIT_SALVAGEABLE&lt;/code&gt;, or<br/>
     *          &lt;code&gt;Game.UNIT_EJECTED&lt;/code&gt;, or<br/>
     *          &lt;code&gt;Game.UNIT_DEVASTATED&lt;/code&gt; or an<br/>
     *          &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.<br/>
     * @return  A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.<br/>
     */<br/>
    private Packet createRemoveEntityPacket(int entityId, int condition) {<br/>
        if ( condition != IEntityRemovalConditions.REMOVE_UNKNOWN &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_IN_RETREAT &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_PUSHED &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_SALVAGEABLE &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_EJECTED &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_CAPTURED &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_DEVASTATED &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_NEVER_JOINED ) {<br/>
            throw new IllegalArgumentException( "Unknown unit condition: " +<br/>
                                                condition );<br/>
        }<br/>
        Object[] array = new Object[2];<br/>
        array[0] = new Integer(entityId);<br/>
        array[1] = new Integer(condition);<br/>
        return new Packet(Packet.COMMAND_ENTITY_REMOVE, array);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet indicating end of game, including detailed unit status<br/>
     */<br/>
    private Packet createEndOfGamePacket() {<br/>
        Object[] array = new Object[3];<br/>
        array[0] = getDetailedVictoryReport();<br/>
        array[1] = new Integer(game.getVictoryPlayerId());<br/>
        array[2] = new Integer(game.getVictoryTeam());<br/>
        return new Packet(Packet.COMMAND_END_OF_GAME, array);<br/>
    }<br/>
<br/>
    /**<br/>
     * Transmits a chat message to all players<br/>
     */<br/>
    private void sendChat(int connId, String origin, String message) {<br/>
        send(connId, new Packet(Packet.COMMAND_CHAT, origin + ": " + message));<br/>
    }<br/>
<br/>
    /**<br/>
     * Transmits a chat message to all players<br/>
     */<br/>
    private void sendChat(String origin, String message) {<br/>
        String chat = origin + ": " + message;<br/>
        send(new Packet(Packet.COMMAND_CHAT, chat));<br/>
    }<br/>
<br/>
    public void sendServerChat(int connId, String message) {<br/>
        sendChat(connId, "***Server", message);<br/>
    }<br/>
<br/>
    public void sendServerChat(String message) {<br/>
        sendChat("***Server", message);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a hex, and the coordinates it goes at.<br/>
     */<br/>
    private Packet createHexChangePacket(Coords coords, IHex hex) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = coords;<br/>
        data[1] = hex;<br/>
        return new Packet(Packet.COMMAND_CHANGE_HEX, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends notification to clients that the specified hex has changed.<br/>
     */<br/>
    public void sendChangedHex(Coords coords) {<br/>
        send(createHexChangePacket(coords, game.getBoard().getHex(coords)));<br/>
    }<br/>
<br/>
    public void sendVisibilityIndicator(Entity e) {<br/>
        final Object[] data = new Object[3];<br/>
        data[0] = new Integer(e.getId());<br/>
        data[1] = new Boolean(e.isSeenByEnemy());<br/>
        data[2] = new Boolean(e.isVisibleToEnemy());<br/>
        send(new Packet(Packet.COMMAND_ENTITY_VISIBILITY_INDICATOR, data));<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet for an attack<br/>
     */<br/>
    private Packet createAttackPacket(Vector vector, int charges) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = vector;<br/>
        data[1] = new Integer(charges);<br/>
        return new Packet(Packet.COMMAND_ENTITY_ATTACK, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet for an attack<br/>
     */<br/>
    private Packet createAttackPacket(EntityAction ea, int charge) {<br/>
        Vector vector = new Vector(1);<br/>
        vector.addElement(ea);<br/>
        Object[] data = new Object[2];<br/>
        data[0] = vector;<br/>
        data[1] = new Integer(charge);<br/>
        return new Packet(Packet.COMMAND_ENTITY_ATTACK, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing offboard artillery attacks<br/>
     **/<br/>
    private Packet createArtilleryPacket(Player p) {<br/>
        <br/>
        if(p.getSeeAll()) {<br/>
            return new Packet(Packet.COMMAND_SENDING_ARTILLERYATTACKS, game.getArtilleryVector());<br/>
        }<br/>
        Vector v = new Vector();<br/>
        int team = p.getTeam();<br/>
        for(Enumeration i = game.getArtilleryAttacks();i.hasMoreElements();) {<br/>
            ArtilleryAttackAction aaa = (ArtilleryAttackAction)i.nextElement();<br/>
            if(aaa.getPlayerId() == p.getId() ||<br/>
                    (team != Player.TEAM_NONE &amp;&amp; team == game.getPlayer(aaa.getPlayerId()).getTeam())) {<br/>
                v.addElement(aaa);<br/>
            }<br/>
        }<br/>
        return new Packet(Packet.COMMAND_SENDING_ARTILLERYATTACKS, v);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing flares<br/>
     **/<br/>
    private Packet createFlarePacket() {<br/>
        <br/>
        return new Packet(Packet.COMMAND_SENDING_FLARES, game.getFlares());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Send a packet to all connected clients.<br/>
     */<br/>
    private void send(Packet packet) {<br/>
        if (connections == null) {<br/>
            return;<br/>
        }<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.send(packet);<br/>
        }<br/>
    }<br/>
<br/>
    private void sendReport() {<br/>
        sendReport(false);<br/>
    }<br/>
<br/>
    /**<br/>
     * Send the round report to all connected clients.<br/>
     */<br/>
    private void sendReport(boolean tacticalGeniusReport) {<br/>
        if (connections == null) {<br/>
            return;<br/>
        }<br/>
<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            Player p = game.getPlayer(conn.getId());<br/>
            Packet packet;<br/>
            if (tacticalGeniusReport)<br/>
                packet = createTacticalGeniusReportPacket();<br/>
            else<br/>
                packet = createReportPacket(p);<br/>
            conn.send(packet);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Send a packet to a specific connection.<br/>
     */<br/>
    private void send(int connId, Packet packet) {<br/>
        if (getClient(connId) != null) {<br/>
            getClient(connId).send(packet);<br/>
        } else {<br/>
            //What should we do if we've lost this client?<br/>
            // For now, nothing.<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Send a packet to a pending connection<br/>
     */<br/>
    private void sendToPending(int connId, Packet packet) {<br/>
        if (getPendingConnection(connId) != null) {<br/>
            getPendingConnection(connId).send(packet);<br/>
        } else {<br/>
            //What should we do if we've lost this client?<br/>
            // For now, nothing.<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Process an in-game command<br/>
     */<br/>
    private void processCommand(int connId, String commandString) {<br/>
        String[] args;<br/>
        String commandName;<br/>
        // all tokens are read as strings; if they're numbers, string-ize 'em.<br/>
        StringTokenizer st = new StringTokenizer(commandString);<br/>
        args = new String[st.countTokens()];<br/>
        for (int i = 0; i &lt; args.length; i++) {<br/>
            args[i] = st.nextToken();<br/>
        }<br/>
<br/>
        // figure out which command this is<br/>
        commandName = args[0].substring(1);<br/>
<br/>
        // process it<br/>
        ServerCommand command = getCommand(commandName);<br/>
        if (command != null) {<br/>
            command.run(connId, args);<br/>
        } else {<br/>
            sendServerChat(connId, "Command not recognized.  Type /help for a list of commands.");<br/>
        }<br/>
    }<br/>
<br/>
    // Easter eggs.  Happy April Fool's Day!!<br/>
    private static final String DUNE_CALL = "They tried and failed?";<br/>
    private static final String DUNE_RESPONSE = "They tried and died!";<br/>
    private static final String STAR_WARS_CALL = "I'd just as soon kiss a Wookiee.";<br/>
    private static final String STAR_WARS_RESPONSE = "I can arrange that!";<br/>
<br/>
    /**<br/>
     * Process a packet from a connection.<br/>
     *<br/>
     * @param   id - the &lt;code&gt;int&lt;/code&gt; ID the connection that<br/>
     *          received the packet.<br/>
     * @param   packet - the &lt;code&gt;Packet&lt;/code&gt; to be processed.<br/>
     */<br/>
    protected synchronized void handle(int connId, Packet packet) {<br/>
        Player player = game.getPlayer( connId );<br/>
        // Check player.  Please note, the connection may be pending.<br/>
        if ( null == player &amp;&amp; null == getPendingConnection(connId) ) {<br/>
            System.err.print<br/>
                ( "Server does not recognize player at connection " );<br/>
            System.err.println( connId );<br/>
            return;<br/>
        }<br/>
<br/>
        //System.out.println("s(" + cn + "): received command");<br/>
        if (packet == null) {<br/>
            System.out.println("server.connection.handle: got null packet");<br/>
            return;<br/>
        }<br/>
        // act on it<br/>
        switch(packet.getCommand()) {<br/>
            case Packet.COMMAND_CLOSE_CONNECTION :<br/>
                // We have a client going down!<br/>
                Connection c = getConnection(connId);<br/>
                if ( c!= null) {<br/>
                    c.close();<br/>
                }<br/>
                break;<br/>
            case Packet.COMMAND_CLIENT_NAME :<br/>
                receivePlayerName(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_UPDATE :<br/>
                receivePlayerInfo(packet, connId);<br/>
                validatePlayerInfo(connId);<br/>
                send(createPlayerUpdatePacket(connId));<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_READY :<br/>
                receivePlayerDone(packet, connId);<br/>
                send(createPlayerDonePacket(connId));<br/>
                checkReady();<br/>
                break;<br/>
            case Packet.COMMAND_REROLL_INITIATIVE :<br/>
                receiveInitiativeRerollRequest(packet, connId);<br/>
                send(createPlayerDonePacket(connId));<br/>
                break;<br/>
            case Packet.COMMAND_CHAT :<br/>
                String chat = (String)packet.getObject(0);<br/>
                if (chat.startsWith("/")) {<br/>
                    processCommand(connId, chat);<br/>
                } else {<br/>
                    sendChat(player.getName(), chat);<br/>
                }<br/>
                // Easter eggs.  Happy April Fool's Day!!<br/>
                if ( DUNE_CALL.equals(chat) ) {<br/>
                    sendServerChat( DUNE_RESPONSE );<br/>
                }<br/>
                else if ( STAR_WARS_CALL.equals(chat) ) {<br/>
                    sendServerChat( STAR_WARS_RESPONSE );<br/>
                }<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_MOVE :<br/>
                receiveMovement(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_DEPLOY :<br/>
                receiveDeployment(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_DEPLOY_MINEFIELDS :<br/>
                receiveDeployMinefields(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ATTACK :<br/>
                receiveAttack(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ADD :<br/>
                receiveEntityAdd(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_UPDATE :<br/>
                receiveEntityUpdate(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_MODECHANGE :<br/>
                receiveEntityModeChange(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_SYSTEMMODECHANGE :<br/>
                receiveEntitySystemModeChange(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_AMMOCHANGE :<br/>
                receiveEntityAmmoChange(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_REMOVE :<br/>
                receiveEntityDelete(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_SENDING_GAME_SETTINGS :<br/>
                if (receiveGameOptions(packet, connId)) {<br/>
                    resetPlayersDone();<br/>
                    transmitAllPlayerDones();<br/>
                    send(createGameSettingsPacket());<br/>
                    receiveGameOptionsAux(packet, connId);<br/>
                }<br/>
                break;<br/>
            case Packet.COMMAND_SENDING_MAP_SETTINGS :<br/>
                MapSettings newSettings=(MapSettings)packet.getObject(0);<br/>
                if (!mapSettings.equalMapGenParameters(newSettings)) {<br/>
                    sendServerChat("Player " + player.getName() +<br/>
                                   " changed mapsettings");<br/>
                }<br/>
                mapSettings = newSettings;<br/>
                newSettings = null;<br/>
                mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                send(createMapSettingsPacket());<br/>
                break;<br/>
            case Packet.COMMAND_QUERY_MAP_SETTINGS :<br/>
                MapSettings temp = (MapSettings)packet.getObject(0);<br/>
                temp.setBoardsAvailableVector(scanForBoards(temp.getBoardWidth(), temp.getBoardHeight()));<br/>
                temp.removeUnavailable();<br/>
                temp.setNullBoards(DEFAULT_BOARD);<br/>
                temp.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
                temp.removeUnavailable();<br/>
                send(connId, createMapQueryPacket(temp));<br/>
                break;<br/>
            case Packet.COMMAND_UNLOAD_STRANDED :<br/>
                receiveUnloadStranded(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_SET_ARTYAUTOHITHEXES :<br/>
                receiveArtyAutoHitHexes(packet, connId);<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Listen for incoming clients.<br/>
     */<br/>
    public void run() {<br/>
        Thread currentThread = Thread.currentThread();<br/>
        System.out.println("s: listening for clients...");<br/>
        while (connector == currentThread) {<br/>
            try {<br/>
                Socket s = serverSocket.accept();<br/>
<br/>
                int id = getFreeConnectionId();<br/>
                System.out.println("s: accepting player connection #" + id + " ...");<br/>
<br/>
                Connection c =  ConnectionFactory.getInstance().createServerConnection(s, id);<br/>
                c.addConnectionListener(connectionListener);<br/>
                c.open();<br/>
                connectionsPending.addElement(c);<br/>
<br/>
                greeting(id);<br/>
            } catch(IOException ex) {<br/>
<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes one slot of inferno ammo, determined<br/>
     * by certain rules, explode on a mech.<br/>
     *<br/>
     * @param entity  The &lt;code&gt;Entity&lt;/code&gt; that should suffer an<br/>
     *                inferno ammo explosion.<br/>
     */<br/>
    private Vector explodeInfernoAmmoFromHeat(Entity entity) {<br/>
        int damage = 0;<br/>
        int rack = 0;<br/>
        int boomloc = -1;<br/>
        int boomslot = -1;<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // Find the most destructive Inferno ammo.<br/>
        for (int j = 0; j &lt; entity.locations(); j++) {<br/>
            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {<br/>
                CriticalSlot cs = entity.getCritical(j, k);<br/>
                // Ignore empty, destroyed, hit, and structure slots.<br/>
                if ( cs == null || cs.isDestroyed() || cs.isHit() ||<br/>
                     cs.getType() != CriticalSlot.TYPE_EQUIPMENT ) {<br/>
                    continue;<br/>
                }<br/>
                // Ignore everything but weapons slots.<br/>
                Mounted mounted = entity.getEquipment<br/>
                    ( entity.getCritical(j, k).getIndex() );<br/>
                if (!(mounted.getType() instanceof AmmoType)) {<br/>
                    continue;<br/>
                }<br/>
                // Ignore everything but Inferno ammo.<br/>
                AmmoType atype = (AmmoType)mounted.getType();<br/>
                if ( !atype.isExplosive() ||<br/>
                     atype.getMunitionType() != AmmoType.M_INFERNO) {<br/>
                    continue;<br/>
                }<br/>
                // Find the most destructive undamaged ammo.<br/>
                // BMRr, pg. 48, compare one rack's<br/>
                // damage.  Ties go to most rounds.<br/>
                int newRack = atype.getDamagePerShot() * atype.getRackSize();<br/>
                int newDamage = mounted.getExplosionDamage();<br/>
                if ( !mounted.isHit() &amp;&amp; ( rack &lt; newRack ||<br/>
                       (rack == newRack &amp;&amp; damage &lt; newDamage) ) ) {<br/>
                    rack = newRack;<br/>
                    damage = newDamage;<br/>
                    boomloc = j;<br/>
                    boomslot = k;<br/>
                }<br/>
            }<br/>
        }<br/>
        // Did we find anything to explode?<br/>
        if (boomloc != -1 &amp;&amp; boomslot != -1) {<br/>
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);<br/>
            slot.setHit(true);<br/>
            entity.getEquipment(slot.getIndex()).setHit(true);<br/>
            // We've allocated heatBuildup to heat in resolveHeat(),<br/>
            // so need to add to the entity's heat instead.<br/>
            vDesc.addAll( explodeEquipment(entity, boomloc, boomslot));<br/>
            entity.heat += 30;<br/>
            r = new Report(5155);<br/>
            r.indent();<br/>
            r.subject = entity.getId();<br/>
            r.add(entity.heat);<br/>
            vDesc.addElement(r);<br/>
            entity.heatBuildup = 0;<br/>
        } else { //no ammo to explode<br/>
            r = new Report(5160);<br/>
            r.indent();<br/>
            r.subject = entity.getId();<br/>
            vDesc.addElement(r);<br/>
        }<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine the results of an entity moving through a wall of a building<br/>
     * after having moved a certain distance.  This gets called when a Mech<br/>
     * or a Tank enters a building, leaves a building, or travels from one<br/>
     * hex to another inside a multi-hex building.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that passed through a wall.<br/>
     *          Don't pass &lt;code&gt;Infantry&lt;/code&gt; units to this method.<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; the entity is passing through.<br/>
     * @param   lastPos - the &lt;code&gt;Coords&lt;/code&gt; of the hex the entity is<br/>
     *          exiting.<br/>
     * @param   curPos - the &lt;code&gt;Coords&lt;/code&gt; of the hex the entity is<br/>
     *          entering<br/>
     * @param   distance - the &lt;code&gt;int&lt;/code&gt; number of hexes the entity<br/>
     *          has moved already this phase.<br/>
     * @param   why - the &lt;code&gt;String&lt;/code&gt; explanatin for this action.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the building collapses due to overloading.<br/>
     */<br/>
    private boolean passBuildingWall( Entity entity,<br/>
                                      Building bldg,<br/>
                                      Coords lastPos,<br/>
                                      Coords curPos,<br/>
                                      int distance,<br/>
                                      String why ) {<br/>
<br/>
        Report r;<br/>
<br/>
        // Need to roll based on building type.<br/>
        PilotingRollData psr = entity.rollMovementInBuilding(bldg, distance, why);<br/>
<br/>
        // Did the entity make the roll?<br/>
        if ( !doSkillCheckWhileMoving( entity, lastPos,<br/>
                                       curPos, psr, false ) ) {<br/>
<br/>
            // Divide the building's current CF by 10, round up.<br/>
            int damage = (int) Math.ceil( bldg.getCurrentCF() / 10.0 );<br/>
<br/>
            // It is possible that the unit takes no damage.<br/>
            if ( damage == 0 ) {<br/>
                r = new Report(6440);<br/>
                r.add(entity.getDisplayName());<br/>
                r.subject = entity.getId();<br/>
                r.indent(2);<br/>
                addReport(r);<br/>
            } else {<br/>
                // BMRr, pg. 50: The attack direction for this damage is the front.<br/>
                HitData hit = entity.rollHitLocation( ToHitData.HIT_NORMAL,<br/>
                                                      ToHitData.SIDE_FRONT );<br/>
                addReport( damageEntity(entity, hit, damage));<br/>
            }<br/>
        }<br/>
<br/>
        // Damage the building.  The CF can never drop below 0.<br/>
        int toBldg = (int) Math.ceil( entity.getWeight() / 10.0 );<br/>
        int curCF = bldg.getCurrentCF();<br/>
        curCF -= Math.min( curCF, toBldg );<br/>
        bldg.setCurrentCF( curCF );<br/>
<br/>
        // Apply the correct amount of damage to infantry in the building.<br/>
        // ASSUMPTION: We inflict toBldg damage to infantry and<br/>
        //             not the amount to bring building to 0 CF.<br/>
        this.damageInfantryIn( bldg, toBldg );<br/>
<br/>
        return checkBuildingCollapseWhileMoving(bldg, entity, curPos);<br/>
    }<br/>
    <br/>
    private boolean checkBuildingCollapseWhileMoving(Building bldg, Entity entity, Coords curPos) {<br/>
        // Get the position map of all entities in the game.<br/>
        Hashtable positionMap = game.getPositionMap();<br/>
<br/>
        // Count the moving entity in its current position, not<br/>
        // its pre-move postition.  Be sure to handle nulls.<br/>
        Vector entities = null;<br/>
        if ( entity.getPosition() != null ) {<br/>
            entities = (Vector) positionMap.get( entity.getPosition() );<br/>
            entities.removeElement( entity );<br/>
        }<br/>
        entities = (Vector) positionMap.get( curPos );<br/>
        if ( entities == null ) {<br/>
            entities = new Vector();<br/>
            positionMap.put( curPos, entities );<br/>
        }<br/>
        entities.addElement( entity );<br/>
<br/>
        // Check for collapse of this building due to overloading, and return.<br/>
        return this.checkForCollapse( bldg, positionMap );<br/>
    }<br/>
<br/>
    /**<br/>
     * Apply the correct amount of damage that passes on to any infantry unit<br/>
     * in the given building, based upon the amount of damage the building<br/>
     * just sustained.  This amount is a percentage dictated by pg. 52 of BMRr.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that sustained the damage.<br/>
     * @param   damage - the &lt;code&gt;int&lt;/code&gt; amount of damage.<br/>
     */<br/>
    private void damageInfantryIn( Building bldg, int damage ) {<br/>
        // Calculate the amount of damage the infantry will sustain.<br/>
        float percent = 0.0f;<br/>
        Report r;<br/>
        switch( bldg.getType() ) {<br/>
        case Building.LIGHT: percent = 0.75f; break;<br/>
        case Building.MEDIUM: percent = 0.5f; break;<br/>
        case Building.HEAVY: percent = 0.25f; break;<br/>
        }<br/>
<br/>
        // Round up at .5 points of damage.<br/>
        int toInf = Math.round( damage * percent );<br/>
<br/>
        // Record if we find any infantry.<br/>
        boolean foundInfantry = false;<br/>
<br/>
        // Walk through the entities in the game.<br/>
        Enumeration entities = game.getEntities();<br/>
        while ( entities.hasMoreElements() ) {<br/>
            Entity entity = (Entity) entities.nextElement();<br/>
            final Coords coords = entity.getPosition();<br/>
<br/>
            // If the entity is infantry in one of the building's hexes?<br/>
            if ( entity instanceof Infantry &amp;&amp;<br/>
                 bldg.isIn( coords ) ) {<br/>
<br/>
                // Is the entity is inside of the building<br/>
                // (instead of just on top of it)?<br/>
                if ( Compute.isInBuilding( game, entity, coords ) ) {<br/>
                    <br/>
                    // Report if the infantry receive no points of damage.<br/>
                    if ( toInf == 0 ) {<br/>
                        r = new Report(6445);<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        // Yup.  Damage the entity.<br/>
                        // Battle Armor units use 5 point clusters.<br/>
                        r = new Report(6450);<br/>
                        r.indent(2);<br/>
                        r.subject = entity.getId();<br/>
                        r.add(entity.getDisplayName());<br/>
                        r.add(toInf);<br/>
                        addReport(r);<br/>
                        int remaining = toInf;<br/>
                        int cluster = toInf;<br/>
                        if ( entity instanceof BattleArmor ) {<br/>
                            cluster = 5;<br/>
                        }<br/>
                        while ( remaining &gt; 0 ) {<br/>
                            int next = Math.min( cluster, remaining );<br/>
                            HitData hit = entity.rollHitLocation<br/>
                                ( ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT );<br/>
                            addReport( damageEntity(entity, hit, next) );<br/>
                            remaining -= next;<br/>
                        }<br/>
                        addReport(new Report(1210));<br/>
                    }<br/>
<br/>
                } // End infantry-inside-building<br/>
<br/>
            } // End entity-is-infantry-in-building-hex<br/>
<br/>
        } // Handle the next entity<br/>
<br/>
        // If we found any infantry, add a line to the phase report.<br/>
        if ( foundInfantry ) {<br/>
            addReport(new Report(1210));<br/>
        }<br/>
<br/>
    } // End private void damageInfantryIn( Building, int )<br/>
<br/>
    /**<br/>
     * Determine if the given building should collapse.  If so,<br/>
     * inflict the appropriate amount of damage on each entity in<br/>
     * the building and update the clients.  If the building does<br/>
     * not collapse, determine if any entities crash through its<br/>
     * floor into its basement.  Again, apply appropriate damage.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; being checked.<br/>
     *          This value should not be &lt;code&gt;null&lt;/code&gt;.<br/>
     * @param   positionMap - a &lt;code&gt;Hashtable&lt;/code&gt; that maps<br/>
     *          the &lt;code&gt;Coords&lt;/code&gt; positions or each unit<br/>
     *          in the game to a &lt;code&gt;Vector&lt;/code&gt; of<br/>
     *          &lt;code&gt;Entity&lt;/code&gt;s at that position.<br/>
     *          This value should not be &lt;code&gt;null&lt;/code&gt;.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the building collapsed.<br/>
     */<br/>
    public boolean checkForCollapse( Building bldg, Hashtable positionMap ) {<br/>
<br/>
        // If the input is meaningless, do nothing and throw no exception.<br/>
        if ( bldg == null ||<br/>
             positionMap == null || positionMap.isEmpty() ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // Get the building's current CF.<br/>
        final int currentCF = bldg.getCurrentCF();<br/>
<br/>
        // Track all units that fall into the building's basement by Coords.<br/>
        Hashtable basementMap = new Hashtable();<br/>
<br/>
        // Walk through the hexes in the building, looking for a collapse.<br/>
        Enumeration bldgCoords = bldg.getCoords();<br/>
        boolean collapse = false;<br/>
        while ( !collapse &amp;&amp; bldgCoords.hasMoreElements() ) {<br/>
            final Coords coords = (Coords) bldgCoords.nextElement();<br/>
<br/>
            // Get the Vector of Entities at these coordinates.<br/>
            final Vector vector = (Vector) positionMap.get( coords );<br/>
<br/>
            // Are there any Entities at these coords?<br/>
            if ( vector != null ) {<br/>
<br/>
                // How many levels does this building have in this hex?<br/>
                final IHex curHex = game.getBoard().getHex( coords );<br/>
                final int hexElev = curHex.surface();<br/>
                final int numFloors = Math.max(0,curHex.terrainLevel( Terrains.BLDG_ELEV )); <br/>
                final int bridgeEl = curHex.terrainLevel(Terrains.BRIDGE_ELEV);<br/>
                int numLoads = numFloors;<br/>
                if(bridgeEl != ITerrain.LEVEL_NONE) {<br/>
                    numLoads ++;<br/>
                }<br/>
                if(numLoads &lt; 1) {<br/>
                    System.err.println("Check for collapse: hex "+coords.toString()+" has no bridge or building");<br/>
                    continue;<br/>
                }<br/>
<br/>
                // Track the load of each floor (and of the roof) separately.<br/>
                // Track all units that fall into the basement in this hex.<br/>
                // N.B. don't track the ground floor, the first floor is at<br/>
                // index 0, the second is at index 1, etc., and the roof is<br/>
                // at index (numFloors-1).<br/>
                // if bridge is present, bridge will be numFloors<br/>
                int[] loads = new int[numLoads];<br/>
                Vector basement = new Vector();<br/>
                for ( int loop = 0; loop &lt; numLoads; loop++ ) {<br/>
                    loads[loop] = 0;<br/>
                }<br/>
<br/>
                // Walk through the entities in this position.<br/>
                Enumeration entities = vector.elements();<br/>
                while ( !collapse &amp;&amp; entities.hasMoreElements() ) {<br/>
                    final Entity entity = (Entity) entities.nextElement();<br/>
                    final int entityElev = entity.getElevation();<br/>
<br/>
                    if(entityElev != bridgeEl) {<br/>
                          // Ignore entities not *inside* the building<br/>
                          if ( entityElev &gt; numFloors) {<br/>
                              continue;<br/>
                          }<br/>
                    }<br/>
                    <br/>
                    if(entity.getMovementMode() == IEntityMovementMode.HYDROFOIL<br/>
                            || entity.getMovementMode() == IEntityMovementMode.NAVAL<br/>
                            || entity.getMovementMode() == IEntityMovementMode.SUBMARINE) {<br/>
                        continue; //under the bridge even at same level<br/>
                    }<br/>
<br/>
                    // Add the weight of a Mek or tank to the correct floor.<br/>
                    if ( entity instanceof Mech || entity instanceof Tank ) {<br/>
                        int load = (int) entity.getWeight();<br/>
                        int floor = entityElev;<br/>
                        if(floor == bridgeEl) {<br/>
                            floor = numLoads;<br/>
                        }<br/>
<br/>
                        // Entities on the ground floor may fall into the<br/>
                        // basement, but they won't collapse the building.<br/>
                        if ( numFloors &gt; 0 &amp;&amp; floor == 0 &amp;&amp; load &gt; currentCF ) {<br/>
                            basement.addElement( entity );<br/>
                        } else if ( floor &gt; 0 ) {<br/>
<br/>
                            // If the load on any floor but the ground floor<br/>
                            // exceeds the building's current CF it collapses.<br/>
                            floor--;<br/>
                            loads[ floor ] += load;<br/>
                            if ( loads[ floor ] &gt; currentCF ) {<br/>
                                collapse = true;<br/>
                            }<br/>
<br/>
                        } // End not-ground-floor<br/>
<br/>
                    } // End increase-load<br/>
<br/>
                } // Handle the next entity.<br/>
<br/>
                // Track all entities that fell into the basement.<br/>
                if ( !basement.isEmpty() ) {<br/>
                    basementMap.put( coords, basement );<br/>
                }<br/>
<br/>
            } // End have-entities-here<br/>
<br/>
        } // Check the next hex of the building.<br/>
<br/>
        // Collapse the building if the flag is set.<br/>
        if ( collapse ) {<br/>
            Report r = new Report(2375);<br/>
            r.add(bldg.getName());<br/>
            addReport(r);<br/>
            this.collapseBuilding( bldg, positionMap );<br/>
        }<br/>
<br/>
        // Otherwise, did any entities fall into the basement?<br/>
        else if ( !basementMap.isEmpty() ) {<br/>
            // TODO: implement basements<br/>
        }<br/>
<br/>
        // Return true if the building collapsed.<br/>
        return collapse;<br/>
<br/>
    } // End private boolean checkForCollapse( Building, Hashtable )<br/>
<br/>
    /**<br/>
     * Collapse the building.  Inflict the appropriate amount of damage<br/>
     * on all entities in the building.  Update all clients.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that has collapsed.<br/>
     * @param   positionMap - a &lt;code&gt;Hashtable&lt;/code&gt; that maps<br/>
     *          the &lt;code&gt;Coords&lt;/code&gt; positions or each unit<br/>
     *          in the game to a &lt;code&gt;Vector&lt;/code&gt; of<br/>
     *          &lt;code&gt;Entity&lt;/code&gt;s at that position.<br/>
     *          This value should not be &lt;code&gt;null&lt;/code&gt;.<br/>
     */<br/>
    public void collapseBuilding( Building bldg, Hashtable positionMap ) {<br/>
        // Loop through the hexes in the building, and apply<br/>
        // damage to all entities inside or on top of the building.<br/>
        Report r;<br/>
        final int phaseCF = bldg.getPhaseCF();<br/>
        Enumeration bldgCoords = bldg.getCoords();<br/>
        while ( bldgCoords.hasMoreElements() ) {<br/>
            final Coords coords = (Coords) bldgCoords.nextElement();<br/>
<br/>
            // Get the Vector of Entities at these coordinates.<br/>
            final Vector vector = (Vector) positionMap.get( coords );<br/>
<br/>
            // Are there any Entities at these coords?<br/>
            if ( vector != null ) {<br/>
<br/>
                // How many levels does this building have in this hex?<br/>
                final IHex curHex = game.getBoard().getHex( coords );<br/>
                final int hexElev = curHex.surface();<br/>
                final int bridgeEl = curHex.terrainLevel(Terrains.BRIDGE_ELEV);<br/>
                final int numFloors = Math.max(bridgeEl, curHex.terrainLevel( Terrains.BLDG_ELEV ));<br/>
<br/>
                // Sort in elevation order<br/>
                Collections.sort(vector, new Comparator&lt;Entity&gt;() {<br/>
                    public int compare(Entity a, Entity b) {<br/>
                        if(a.getElevation() &gt; b.getElevation())<br/>
                            return -1;<br/>
                        else if(a.getElevation() &gt; b.getElevation())<br/>
                            return 1;<br/>
                        return 0;<br/>
                    }<br/>
                });<br/>
                // Walk through the entities in this position.<br/>
                Enumeration entities = vector.elements();<br/>
                while ( entities.hasMoreElements() ) {<br/>
                    final Entity entity = (Entity) entities.nextElement();<br/>
                    //final int entityElev = entity.elevationOccupied( curHex );<br/>
                    int floor = entity.getElevation();<br/>
<br/>
                    // Ignore units above the building / bridge.<br/>
                    if ( floor &gt; numFloors) {<br/>
                        continue;<br/>
                    }<br/>
<br/>
                    // Treat units on the roof like<br/>
                    // they were in the top floor.<br/>
                    if ( floor == numFloors ) {<br/>
                        floor--;<br/>
                    }<br/>
<br/>
                    // Calculate collapse damage for this entity.<br/>
                    int damage = (int) Math.ceil<br/>
                        ( phaseCF * (numFloors-floor) / 10.0 );<br/>
<br/>
                    // Infantry suffer triple damage.<br/>
                    if ( entity instanceof Infantry ) {<br/>
                        damage *= 3;<br/>
                    }<br/>
<br/>
                    // Apply collapse damage the entity.<br/>
                    // ASSUMPTION: use 5 point clusters.<br/>
                    r = new Report(6455);<br/>
                    r.indent();<br/>
                    r.subject = entity.getId();<br/>
                    r.add(entity.getDisplayName());<br/>
                    r.add(damage);<br/>
                    addReport(r);<br/>
                    int remaining = damage;<br/>
                    int cluster = damage;<br/>
                    if ( entity instanceof BattleArmor ||<br/>
                         entity instanceof Mech ||<br/>
                         entity instanceof Tank ) {<br/>
                        cluster = 5;<br/>
                    }<br/>
                    while ( remaining &gt; 0 ) {<br/>
                        int next = Math.min( cluster, remaining );<br/>
                        // In www.classicbattletech.com/PDF/AskPMForumArchiveandFAQ.pdf,<br/>
                        // pg. 18, Randall Bills says that all damage from a<br/>
                        // collapsing building is applied to the front.<br/>
<br/>
                        HitData hit = entity.rollHitLocation<br/>
                            (ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT );<br/>
                        addReport( damageEntity(entity, hit, next) );<br/>
                        remaining -= next;<br/>
                    }<br/>
                    addReport(new Report(1210));<br/>
                    // TODO: Why are dead entities showing up on firing phase?<br/>
<br/>
                    // Do we need to handle falling Meks?<br/>
                    // BMRr, pg. 53 only mentions falling BattleMechs;<br/>
                    // Tanks can't be above the floor and I guess that<br/>
                    // infantry don't suffer falling damage.<br/>
                    // TODO: implement basements, then fall into it.<br/>
                    // ASSUMPTION: we'll let the Mech fall twice: once<br/>
                    // during damageEntity() above and once here.<br/>
                    floor = entity.getElevation();<br/>
                    if ( floor &gt; 0 || floor == bridgeEl) {<br/>
                        // ASSUMPTION: PSR to avoid pilot damage<br/>
                        // should use mods for entity damage and<br/>
                        // 20+ points of collapse damage (if any).<br/>
                        PilotingRollData psr = entity.getBasePilotingRoll();<br/>
                        entity.addPilotingModifierForTerrain(psr, coords);<br/>
                        if ( damage &gt;= 20 ) {<br/>
                            psr.addModifier( 1, "20+ damage" );<br/>
                        }<br/>
                        this.doEntityFallsInto( entity, coords, coords, psr );<br/>
                    }<br/>
<br/>
                    // Update this entity.<br/>
                    // ASSUMPTION: this is the correct thing to do.<br/>
                    this.entityUpdate( entity.getId() );<br/>
<br/>
                } // Handle the next entity.<br/>
<br/>
            } // End have-entities-here.<br/>
<br/>
        } // Handle the next hex of the building.<br/>
<br/>
        // Update the building.<br/>
        bldg.setCurrentCF( 0 );<br/>
        bldg.setPhaseCF( 0 );<br/>
        send( createCollapseBuildingPacket(bldg) );<br/>
        game.getBoard().collapseBuilding( bldg );<br/>
<br/>
    } // End private void collapseBuilding( Building )<br/>
<br/>
    /**<br/>
     * Tell the clients to replace the given building with rubble hexes.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that has collapsed.<br/>
     * @return  a &lt;code&gt;Packet&lt;/code&gt; for the command.<br/>
     */<br/>
    private Packet createCollapseBuildingPacket( Building bldg ) {<br/>
        Vector buildings = new Vector();<br/>
        buildings.addElement( bldg );<br/>
        return this.createCollapseBuildingPacket( buildings );<br/>
    }<br/>
<br/>
    /**<br/>
     * Tell the clients to replace the given buildings with rubble hexes.<br/>
     *<br/>
     * @param   buildings - a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Building&lt;/code&gt;s<br/>
     *          that has collapsed.<br/>
     * @return  a &lt;code&gt;Packet&lt;/code&gt; for the command.<br/>
     */<br/>
    private Packet createCollapseBuildingPacket( Vector buildings ) {<br/>
        return new Packet( Packet.COMMAND_BLDG_COLLAPSE, buildings );<br/>
    }<br/>
<br/>
    /**<br/>
     * Tell the clients to update the CFs of the given buildings.<br/>
     *<br/>
     * @param   buildings - a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Building&lt;/code&gt;s<br/>
     *          that need to be updated.<br/>
     * @return  a &lt;code&gt;Packet&lt;/code&gt; for the command.<br/>
     */<br/>
    private Packet createUpdateBuildingCFPacket( Vector buildings ) {<br/>
        return new Packet( Packet.COMMAND_BLDG_UPDATE_CF, buildings );<br/>
    }<br/>
<br/>
    /**<br/>
     * Apply this phase's damage to all buildings.  Buildings may<br/>
     * collapse due to damage.<br/>
     */<br/>
    private void applyBuildingDamage() {<br/>
<br/>
        // Walk through the buildings in the game.<br/>
        // Build the collapse and update vectors as you go.<br/>
        // N.B. never, NEVER, collapse buildings while you are walking through<br/>
        //      the Enumeration from megamek.common.Board#getBuildings.<br/>
        Vector collapse = new Vector();<br/>
        Vector update = new Vector();<br/>
        Enumeration buildings = game.getBoard().getBuildings();<br/>
        while ( buildings.hasMoreElements() ) {<br/>
            Building bldg = (Building) buildings.nextElement();<br/>
<br/>
            // If the CF is zero, the building should fall.<br/>
            if ( bldg.getCurrentCF() == 0 ) {<br/>
                collapse.addElement( bldg );<br/>
            }<br/>
<br/>
            // If the building took damage this round, update it.<br/>
            else if ( bldg.getPhaseCF() != bldg.getCurrentCF() ) {<br/>
                bldg.setPhaseCF( bldg.getCurrentCF() );<br/>
                update.addElement( bldg );<br/>
            }<br/>
<br/>
        } // Handle the next building<br/>
<br/>
        // If we have any buildings to collapse, collapse them now.<br/>
        if ( !collapse.isEmpty() ) {<br/>
<br/>
            // Get the position map of all entities in the game.<br/>
            Hashtable positionMap = game.getPositionMap();<br/>
<br/>
            // Walk through the buildings that have collapsed.<br/>
            buildings = collapse.elements();<br/>
            while ( buildings.hasMoreElements() ) {<br/>
                Building bldg = (Building) buildings.nextElement();<br/>
                Report r = new Report(6460,Report.PUBLIC);<br/>
                r.add(bldg.getName());<br/>
                addReport(r);<br/>
                this.collapseBuilding( bldg, positionMap );<br/>
            }<br/>
<br/>
        }<br/>
<br/>
        //check for buildings which should collapse due to being overloaded now CF is reduced<br/>
        if(!update.isEmpty()) {<br/>
            Hashtable positionMap = game.getPositionMap();<br/>
            for(Iterator i=update.iterator();i.hasNext();) {<br/>
                Building bldg = (Building) i.next();<br/>
                if(checkForCollapse(bldg, positionMap)) i.remove();<br/>
            }<br/>
        }<br/>
<br/>
        // If we have any buildings to update, send the message.<br/>
        if ( !update.isEmpty() ) {<br/>
            sendChangedCFBuildings( update );<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Apply the given amount of damage to the building.  Please note,<br/>
     * this method does &lt;b&gt;not&lt;/b&gt; apply any damage to units inside the<br/>
     * building, update the clients, or check for the building's collapse.<br/>
     * &lt;p/&gt;<br/>
     * A default message will be used to describe why the building<br/>
     * took the damage.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that has been damaged.<br/>
     *          This value should not be &lt;code&gt;null&lt;/code&gt;, but no<br/>
     *          exception will occur.<br/>
     * @param   damage - the &lt;code&gt;int&lt;/code&gt; amount of damage.<br/>
     * @return  a &lt;code&gt;Report&lt;/code&gt; to be shown to the players.<br/>
     */<br/>
    private Report damageBuilding( Building bldg, int damage ) {<br/>
        final String defaultWhy = " absorbs ";<br/>
        return damageBuilding( bldg, damage, defaultWhy );<br/>
    }<br/>
<br/>
    /**<br/>
     * Apply the given amount of damage to the building.  Please note,<br/>
     * this method does &lt;b&gt;not&lt;/b&gt; apply any damage to units inside the<br/>
     * building, update the clients, or check for the building's collapse.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that has been damaged.<br/>
     *          This value should not be &lt;code&gt;null&lt;/code&gt;, but no<br/>
     *          exception will occur.<br/>
     * @param   damage - the &lt;code&gt;int&lt;/code&gt; amount of damage.<br/>
     * @param   why - the &lt;code&gt;String&lt;/code&gt; message that describes<br/>
     *          why the building took the damage.<br/>
     * @return  a &lt;code&gt;Report&lt;/code&gt; to be shown to the players.<br/>
     */<br/>
    private Report damageBuilding( Building bldg, int damage, String why ) {<br/>
        Report r = new Report(1210);<br/>
        r.newlines = 0;<br/>
<br/>
        // Do nothing if no building or no damage was passed.<br/>
        if ( bldg != null &amp;&amp; damage &gt; 0 ) {<br/>
            int curCF = bldg.getCurrentCF();<br/>
            final int startingCF = curCF;<br/>
            curCF -= Math.min( curCF, damage );<br/>
            bldg.setCurrentCF( curCF );<br/>
            r.messageId = 3435;<br/>
            r.add( bldg.getName() );<br/>
            r.add( why );<br/>
            r.add( damage );<br/>
<br/>
            // If the CF is zero, the building should fall.<br/>
            if ( curCF == 0 &amp;&amp; startingCF != 0 ) {<br/>
                r.messageId = 3440;<br/>
            }<br/>
<br/>
        }<br/>
        return r;<br/>
    }<br/>
<br/>
    public void sendChangedCFBuildings(Vector&lt;Building&gt; buildings) {<br/>
        send(createUpdateBuildingCFPacket(buildings));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Receives an packet to unload entityis stranded on immobile transports,<br/>
     * and queue all valid requests for execution.  If all players that have<br/>
     * stranded entities have answered, executes the pending requests and end<br/>
     * the current turn.<br/>
     */<br/>
    private void receiveUnloadStranded( Packet packet, int connId ) {<br/>
        GameTurn.UnloadStrandedTurn turn = null;<br/>
        final Player player = game.getPlayer( connId );<br/>
        int[] entityIds = (int[]) packet.getObject(0);<br/>
        Vector declared = null;<br/>
        Player other = null;<br/>
        Enumeration pending = null;<br/>
        UnloadStrandedAction action = null;<br/>
        Entity entity = null;<br/>
<br/>
        // Is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_MOVEMENT) {<br/>
            System.err.println<br/>
                ("error: server got unload stranded packet in wrong phase");<br/>
            return;<br/>
        }<br/>
<br/>
        // Are we in an "unload stranded entities" turn?<br/>
        if ( game.getTurn() instanceof GameTurn.UnloadStrandedTurn ) {<br/>
            turn = (GameTurn.UnloadStrandedTurn) game.getTurn();<br/>
        } else {<br/>
            System.err.println<br/>
                ("error: server got unload stranded packet out of sequence");<br/>
            StringBuffer message = new StringBuffer();<br/>
            message.append( player.getName() )<br/>
                .append( " should not be sending 'unload stranded entity' packets at this time." );<br/>
            sendServerChat( message.toString() );<br/>
            return;<br/>
        }<br/>
<br/>
        // Can this player act right now?<br/>
        if (!turn.isValid(connId, game)) {<br/>
            System.err.println<br/>
                ("error: server got unload stranded packet from invalid player");<br/>
            StringBuffer message = new StringBuffer();<br/>
            message.append( player.getName() )<br/>
                .append( " should not be sending 'unload stranded entity' packets." );<br/>
            sendServerChat( message.toString() );<br/>
            return;<br/>
        }<br/>
<br/>
        // Did the player already send an 'unload' request?<br/>
        // N.B. we're also building the list of players who<br/>
        //      have declared their "unload stranded" actions.<br/>
        declared = new Vector();<br/>
        pending = game.getActions();<br/>
        while ( pending.hasMoreElements() ) {<br/>
            action = (UnloadStrandedAction) pending.nextElement();<br/>
            if ( action.getPlayerId() == connId ) {<br/>
                System.err.println("error: server got multiple unload stranded packets from player");<br/>
                StringBuffer message = new StringBuffer();<br/>
                message.append( player.getName() )<br/>
                    .append( " should not send multiple 'unload stranded entity' packets." );<br/>
                sendServerChat( message.toString() );<br/>
                return;<br/>
            } else {<br/>
                // This player is not from the current connection.<br/>
                // Record this player to determine if this turn is done.<br/>
                other = game.getPlayer( action.getPlayerId() );<br/>
                if ( !declared.contains( other ) ) {<br/>
                    declared.addElement( other );<br/>
                }<br/>
            }<br/>
        } // Handle the next "unload stranded" action.<br/>
<br/>
        // Make sure the player selected at least *one* valid entity ID.<br/>
        boolean foundValid = false;<br/>
        for ( int index = 0; null != entityIds &amp;&amp; index &lt; entityIds.length;<br/>
              index++ ) {<br/>
            entity = game.getEntity( entityIds[index] );<br/>
            if (!game.getTurn().isValid(connId, entity, game)) {<br/>
                System.err.println("error: server got unload stranded packet for invalid entity");<br/>
                StringBuffer message = new StringBuffer();<br/>
                message.append( player.getName() )<br/>
                    .append( " can not unload stranded entity " );<br/>
                if ( null == entity ) {<br/>
                    message.append( "#" )<br/>
                        .append( entityIds[index] );<br/>
                } else {<br/>
                    message.append( entity.getDisplayName() );<br/>
                }<br/>
                message.append( " at this time." );<br/>
                sendServerChat( message.toString() );<br/>
            } else {<br/>
                foundValid = true;<br/>
                game.addAction( new UnloadStrandedAction( connId,<br/>
                                                          entityIds[index] ) );<br/>
            }<br/>
        }<br/>
<br/>
        // Did the player choose not to unload any valid stranded entity?<br/>
        if ( !foundValid ) {<br/>
            game.addAction( new UnloadStrandedAction( connId, Entity.NONE ) );<br/>
        }<br/>
<br/>
        // Either way, the connection's player has now declared.<br/>
        declared.addElement( player );<br/>
<br/>
        // Are all players who are unloading entities done? Walk<br/>
        // through the turn's stranded entities, and look to see<br/>
        // if their player has finished their turn.<br/>
        entityIds = turn.getEntityIds();<br/>
        for ( int index = 0; index &lt; entityIds.length; index++ ) {<br/>
            entity = game.getEntity( entityIds[index] );<br/>
            other = entity.getOwner();<br/>
            if ( !declared.contains( other ) ) {<br/>
                // At least one player still needs to declare.<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // All players have declared whether they're unloading stranded units.<br/>
        // Walk the list of pending actions and unload the entities.<br/>
        pending = game.getActions();<br/>
        while ( pending.hasMoreElements() ) {<br/>
            action = (UnloadStrandedAction) pending.nextElement();<br/>
<br/>
            // Some players don't want to unload any stranded units.<br/>
            if ( Entity.NONE != action.getEntityId() ) {<br/>
                entity = game.getEntity( action.getEntityId() );<br/>
                if ( null == entity ) {<br/>
                    // After all this, we couldn't find the entity!!!<br/>
                    System.err.print<br/>
                        ("error: server could not find stranded entity #");<br/>
                    System.err.print( action.getEntityId() );<br/>
                    System.err.println( " to unload!!!");<br/>
                } else {<br/>
                    // Unload the entity.  Get the unit's transporter.<br/>
                    Entity transporter =<br/>
                        game.getEntity( entity.getTransportId() );<br/>
                    this.unloadUnit( transporter, entity,<br/>
                                     transporter.getPosition(),<br/>
                                     transporter.getFacing(),<br/>
                                     transporter.getElevation());<br/>
                }<br/>
            }<br/>
<br/>
        } // Handle the next pending unload action<br/>
<br/>
        // Clear the list of pending units and move to the next turn.<br/>
        game.resetActions();<br/>
        changeToNextTurn();<br/>
    }<br/>
    /**<br/>
     * For all current artillery attacks in the air from this entity<br/>
     * with this weapon, clear the list of spotters.  Needed because<br/>
     * firing another round before first lands voids spotting.<br/>
     *<br/>
     * @param entityID int<br/>
     */<br/>
    private void clearArtillerySpotters(int entityID,int weaponID)  {<br/>
        for (Enumeration i = game.getArtilleryAttacks(); i.hasMoreElements();) {<br/>
            ArtilleryAttackAction aaa = (ArtilleryAttackAction) i.nextElement();<br/>
            if ( aaa.getWR().waa.getEntityId()==entityID &amp;&amp;<br/>
                 aaa.getWR().waa.getWeaponId()==weaponID ) {<br/>
                aaa.setSpotterIds(null);<br/>
            }<br/>
<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
    * Find the tagged entity for this attack<br/>
    *<br/>
    * Each TAG will attract a number of shots up to its priority number (mode setting)<br/>
    * When all the TAGs are used up, the shots fired are reset.<br/>
    * So if you leave them all on 1-shot, then homing attacks will be evenly split, however many shots you fire.<br/>
    *<br/>
    * Priority setting is to allocate more homing attacks to a more important target as decided by player.<br/>
    * <br/>
    * TAGs fired by the enemy aren't eligable, nor are TAGs fired at a target on a different map sheet.<br/>
    */<br/>
    private WeaponResult convertHomingShotToEntityTarget(ArtilleryAttackAction aaa, Entity ae) {<br/>
        WeaponResult wr = aaa.getWR();<br/>
        Targetable target = wr.waa.getTarget(game);<br/>
        <br/>
        final Coords tc = target.getPosition();<br/>
        Entity entityTarget = null;<br/>
<br/>
        TagInfo info = null;<br/>
        Entity tagger = null;<br/>
<br/>
        for(int pass=0;pass&lt;2;pass++) {<br/>
            int bestDistance = Integer.MAX_VALUE;<br/>
            int bestIndex = -1;<br/>
            Vector v = game.getTagInfo();<br/>
            for(int i=0;i&lt;v.size();i++) {<br/>
                info = (TagInfo)v.elementAt(i);<br/>
                tagger = game.getEntity(info.attackerId);<br/>
                if(info.shots &lt; info.priority &amp;&amp; !ae.isEnemyOf(tagger)) {<br/>
                    System.err.println("Checking TAG "+i+" with priority "+info.priority);<br/>
                    entityTarget = game.getEntity(info.targetId);<br/>
                    if(entityTarget != null &amp;&amp; entityTarget.isOnSameSheet(tc)) {<br/>
                        if(tc.distance(entityTarget.getPosition()) &lt; bestDistance) {<br/>
                            bestIndex = i;<br/>
                            bestDistance = tc.distance(entityTarget.getPosition());<br/>
                            if(!game.getOptions().booleanOption("a4homing_target_area")) {<br/>
                                break; //first will do if mapsheets can't overlap<br/>
                            }<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
            if(bestIndex != -1) {<br/>
                info = (TagInfo)v.elementAt(bestIndex);<br/>
                entityTarget = game.getEntity(info.targetId);<br/>
                tagger = game.getEntity(info.attackerId);<br/>
                System.err.println("attacker: " + ae.getDisplayName());<br/>
                System.err.println("   " + tagger.getDisplayName() + " selected to TAG");<br/>
                System.err.println("   " + entityTarget.getDisplayName() + " selected as target");<br/>
                info.shots++;<br/>
                game.updateTagInfo(info,bestIndex);<br/>
                break; //got a target, stop searching<br/>
            } else {<br/>
                entityTarget = null;<br/>
            }<br/>
            //nothing found on 1st pass, so clear shots fired to 0<br/>
            System.err.println("nothing on 1st pass");<br/>
            game.clearTagInfoShots(ae, tc);<br/>
        }<br/>
<br/>
        if(entityTarget == null || info == null) {<br/>
            wr.toHit = new ToHitData(ToHitData.IMPOSSIBLE, "no targets tagged on map sheet");<br/>
        } <br/>
        else if(info.missed) {<br/>
            wr.waa.setTargetId(entityTarget.getId());<br/>
            wr.waa.setTargetType(Targetable.TYPE_ENTITY);<br/>
            wr.toHit = new ToHitData(ToHitData.IMPOSSIBLE, "tag missed the target");<br/>
        } else {<br/>
            //update for hit table resolution<br/>
            wr.artyAttackerCoords = tagger.getPosition();<br/>
            wr.waa.setTargetId(entityTarget.getId());<br/>
            wr.waa.setTargetType(Targetable.TYPE_ENTITY);<br/>
        }<br/>
<br/>
        return wr;<br/>
    }<br/>
<br/>
    /**<br/>
     * resolve Indirect Artillery Attacks for this turn<br/>
     */<br/>
    private void resolveIndirectArtilleryAttacks()  {<br/>
        Vector results = new Vector(game.getArtillerySize());<br/>
        Vector attacks = new Vector(game.getArtillerySize());<br/>
<br/>
        // loop thru received attack actions, getting weapon results<br/>
        for (Enumeration i = game.getArtilleryAttacks(); i.hasMoreElements();) {<br/>
            ArtilleryAttackAction aaa =<br/>
                (ArtilleryAttackAction) i.nextElement();<br/>
<br/>
            // Does the attack land this turn?<br/>
            if (aaa.turnsTilHit &lt;= 0) {<br/>
                WeaponResult wr = aaa.getWR();<br/>
                //HACK, for correct hit table resolution.<br/>
                wr.artyAttackerCoords=aaa.getCoords();<br/>
                final Vector spottersBefore=aaa.getSpotterIds();<br/>
                final Targetable target = wr.waa.getTarget(game);<br/>
                final Coords targetPos = target.getPosition();<br/>
                final int playerId = aaa.getPlayerId();<br/>
                Entity bestSpotter=null;<br/>
<br/>
                Entity ae = game.getEntity(wr.waa.getEntityId());<br/>
                if (ae == null) {<br/>
                  ae = game.getOutOfGameEntity( wr.waa.getEntityId() );<br/>
                }<br/>
                Mounted ammo = ae.getEquipment(wr.waa.getAmmoId());<br/>
                final AmmoType atype = ammo == null ? null : (AmmoType) ammo.getType();<br/>
                if(atype != null &amp;&amp; atype.getMunitionType() == AmmoType.M_HOMING) {<br/>
                    wr = convertHomingShotToEntityTarget(aaa, ae);<br/>
                } else {<br/>
                    // Are there any valid spotters?<br/>
                    if ( null != spottersBefore ) {<br/>
<br/>
                        //fetch possible spotters now<br/>
                        Enumeration spottersAfter=<br/>
                            game.getSelectedEntities( new EntitySelector() {<br/>
                                    public int player = playerId;<br/>
                                    public Targetable targ = target;<br/>
                                    public boolean accept(Entity entity) {<br/>
                                        Integer id = new Integer( entity.getId() );<br/>
                                        if ( player == entity.getOwnerId() &amp;&amp;<br/>
                                             spottersBefore.contains(id) &amp;&amp;<br/>
                                             !( LosEffects.calculateLos<br/>
                                                (game, entity.getId(), targ)<br/>
                                                ).isBlocked() &amp;&amp;<br/>
                                             entity.isActive() &amp;&amp;<br/>
                                             !entity.isINarcedWith(INarcPod.HAYWIRE)) {<br/>
                                            return true;<br/>
                                        }<br/>
                                        return false;<br/>
                                    }<br/>
                                } );<br/>
<br/>
                        // Out of any valid spotters, pick the best.<br/>
                        while ( spottersAfter.hasMoreElements() ) {<br/>
                            Entity ent = (Entity) spottersAfter.nextElement();<br/>
                            if ( bestSpotter == null || ent.crew.getGunnery() &lt;<br/>
                                 bestSpotter.crew.getGunnery() ){<br/>
                                bestSpotter = ent;<br/>
                            }<br/>
                        }<br/>
<br/>
                    } // End have-valid-spotters<br/>
<br/>
                    //If at least one valid spotter, then get the benefits thereof.<br/>
                    if (null != bestSpotter) {<br/>
                        int mod = (bestSpotter.crew.getGunnery() - 4) / 2;<br/>
                        wr.toHit.addModifier(mod, "Spotting modifier");<br/>
                    }<br/>
<br/>
                    // Is the attacker still alive?<br/>
                    Entity artyAttacker = wr.waa.getEntity( game );<br/>
                    if (null != artyAttacker) {<br/>
<br/>
                        // Get the arty weapon.<br/>
                        Mounted weapon = artyAttacker.getEquipment<br/>
                            ( wr.waa.getWeaponId() );<br/>
<br/>
                        // If the shot hit the target hex, then all subsequent<br/>
                        // fire will hit the hex automatically.<br/>
                        if(wr.roll &gt;= wr.toHit.getValue()) {<br/>
                            artyAttacker.aTracker.setModifier<br/>
                                ( weapon,<br/>
                                  ToHitData.AUTOMATIC_SUCCESS,<br/>
                                  targetPos );<br/>
                        }<br/>
                        // If the shot missed, but was adjusted by a<br/>
                        // spotter, future shots are more likely to hit.<br/>
                        else if (null != bestSpotter) {<br/>
                            artyAttacker.aTracker.setModifier<br/>
                                ( weapon,<br/>
                                  artyAttacker.aTracker.getModifier<br/>
                                  ( weapon, targetPos ) - 1,<br/>
                                  targetPos );<br/>
                        }<br/>
<br/>
                    } // End artyAttacker-alive<br/>
                }<br/>
<br/>
                // Schedule this attack to be resolved.<br/>
                results.addElement(wr);<br/>
                attacks.addElement( aaa );<br/>
<br/>
            } // End attack-hits-this-turn<br/>
<br/>
            // This attack is one round closer to hitting.<br/>
            aaa.turnsTilHit--;<br/>
<br/>
        } // Handle the next attack<br/>
<br/>
        // loop through weapon results and resolve<br/>
        int lastEntityId = Entity.NONE;<br/>
        for (Enumeration i = results.elements();i.hasMoreElements();) {<br/>
            WeaponResult wr = (WeaponResult) i.nextElement();<br/>
            resolveWeaponAttack(wr, lastEntityId);<br/>
            lastEntityId = wr.waa.getEntityId();<br/>
        }<br/>
<br/>
        // Clear out all resolved attacks.<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            game.removeArtilleryAttack<br/>
                ( (ArtilleryAttackAction) i.nextElement() );<br/>
        }<br/>
        for(Enumeration i = game.getPlayers();i.hasMoreElements();) {<br/>
            Player player = (Player)i.nextElement();<br/>
            int connId = player.getId();<br/>
            send(connId, createArtilleryPacket(player));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * enqueues any indirect artillery attacks made this turn<br/>
     */<br/>
    private void enqueueIndirectArtilleryAttacks() {<br/>
        resolveAllButWeaponAttacks();<br/>
        ArtilleryAttackAction aaa;<br/>
        for (Enumeration i = game.getActions();i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction) i.nextElement();<br/>
            final Entity firingEntity = game.getEntity(ea.getEntityId());<br/>
            if (ea instanceof WeaponAttackAction) {<br/>
                final WeaponAttackAction waa = (WeaponAttackAction) ea;<br/>
                WeaponResult wr = preTreatWeaponAttack(waa);<br/>
                boolean firingAtNewHex = false;<br/>
                for (Enumeration j = game.getArtilleryAttacks();<br/>
                     !firingAtNewHex &amp;&amp; j.hasMoreElements();) {<br/>
                    ArtilleryAttackAction oaaa = (ArtilleryAttackAction) j.nextElement();<br/>
                    if ( oaaa.getWR().waa.getEntityId() == wr.waa.getEntityId() &amp;&amp;<br/>
                         !oaaa.getWR().waa.getTarget(game).getPosition().equals(wr.waa.getTarget(game).getPosition())) {<br/>
                        firingAtNewHex = true;<br/>
                    }<br/>
                }<br/>
                if (firingAtNewHex) {<br/>
                    clearArtillerySpotters( firingEntity.getId(),<br/>
                                            waa.getWeaponId() );<br/>
                }<br/>
                Enumeration spotters = game.getSelectedEntities(new EntitySelector() {<br/>
                    public int player = firingEntity.getOwnerId();<br/>
                    public Targetable target = waa.getTarget(game);<br/>
                    public boolean accept(Entity entity) {<br/>
                        if ( (player == entity.getOwnerId()) &amp;&amp;<br/>
                            !((LosEffects.calculateLos(game, entity.getId(), target)).isBlocked()) &amp;&amp; entity.isActive()) {<br/>
                            return true;<br/>
                        } else {<br/>
                            return false;<br/>
                        }<br/>
<br/>
                    }<br/>
                } );<br/>
<br/>
                Vector spotterIds = new Vector();<br/>
                while ( spotters.hasMoreElements() ) {<br/>
                    Integer id = new Integer<br/>
                        ( ((Entity) spotters.nextElement() ).getId() );<br/>
                    spotterIds.addElement( id );<br/>
                }<br/>
                aaa = new ArtilleryAttackAction( wr, game,<br/>
                                                 firingEntity.getOwnerId(),<br/>
                                                 spotterIds, firingEntity.getPosition());<br/>
                game.addArtilleryAttack(aaa);<br/>
            }<br/>
        }<br/>
        game.resetActions();<br/>
        for(Enumeration i = game.getPlayers();i.hasMoreElements();) {<br/>
            Player player = (Player)i.nextElement();<br/>
            int connId = player.getId();<br/>
            send(connId, createArtilleryPacket(player));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Credits a Kill for an entity, if the target got killed.<br/>
     *<br/>
     * @param target   The &lt;code&gt;Entity&lt;/code&gt; that got killed.<br/>
     * @param attacker The &lt;code&gt;Entity&lt;/code&gt; that did the killing.<br/>
     */<br/>
    private void creditKill(Entity target, Entity attacker) {<br/>
        if (target.isDoomed() &amp;&amp; !target.getGaveKillCredit()) {<br/>
            attacker.addKill(target);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * pre-treats a physical attack<br/>
     *<br/>
     * @param aaa The &lt;code&gt;AbstractAttackAction&lt;/code&gt; of the physical attack<br/>
     *            to pre-treat<br/>
     *<br/>
     * @return    The &lt;code&gt;PhysicalResult&lt;/code&gt; of that action, including<br/>
     *            possible damage.<br/>
     */<br/>
    private PhysicalResult preTreatPhysicalAttack(AbstractAttackAction aaa) {<br/>
        final Entity ae = game.getEntity(aaa.getEntityId());<br/>
        int damage = 0;<br/>
        PhysicalResult pr = new PhysicalResult();<br/>
        ToHitData toHit = new ToHitData();<br/>
        pr.roll = Compute.d6(2);<br/>
        pr.aaa = aaa;<br/>
        if (aaa instanceof BrushOffAttackAction) {<br/>
            BrushOffAttackAction baa = (BrushOffAttackAction)aaa;<br/>
            int arm = baa.getArm();<br/>
            baa.setArm(BrushOffAttackAction.LEFT);<br/>
            toHit = BrushOffAttackAction.toHit(game, aaa.getEntityId(), aaa.getTarget(game), BrushOffAttackAction.LEFT);<br/>
            baa.setArm(BrushOffAttackAction.RIGHT);<br/>
            pr.toHitRight = BrushOffAttackAction.toHit(game, aaa.getEntityId(), aaa.getTarget(game), BrushOffAttackAction.RIGHT);<br/>
            damage = BrushOffAttackAction.getDamageFor(ae, BrushOffAttackAction.LEFT);<br/>
            pr.damageRight = BrushOffAttackAction.getDamageFor(ae, BrushOffAttackAction.RIGHT);<br/>
            baa.setArm(arm);<br/>
            pr.rollRight = Compute.d6(2);<br/>
        } else if (aaa instanceof ChargeAttackAction) {<br/>
            ChargeAttackAction caa = (ChargeAttackAction)aaa;<br/>
            toHit = caa.toHit(game);<br/>
            damage = ChargeAttackAction.getDamageFor(ae);<br/>
        } else if (aaa instanceof ClubAttackAction) {<br/>
            ClubAttackAction caa = (ClubAttackAction)aaa;<br/>
            toHit = caa.toHit(game);<br/>
            damage = ClubAttackAction.getDamageFor(ae, caa.getClub());<br/>
        } else if (aaa instanceof DfaAttackAction) {<br/>
            DfaAttackAction daa = (DfaAttackAction)aaa;<br/>
            toHit = daa.toHit(game);<br/>
            damage = DfaAttackAction.getDamageFor(ae);<br/>
        } else if (aaa instanceof KickAttackAction) {<br/>
            KickAttackAction kaa = (KickAttackAction)aaa;<br/>
            toHit = kaa.toHit(game);<br/>
            damage = KickAttackAction.getDamageFor(ae, kaa.getLeg());<br/>
        } else if (aaa instanceof ProtomechPhysicalAttackAction) {<br/>
            ProtomechPhysicalAttackAction paa = (ProtomechPhysicalAttackAction)aaa;<br/>
            toHit = paa.toHit(game);<br/>
            damage = ProtomechPhysicalAttackAction.getDamageFor(ae);<br/>
        } else if (aaa instanceof PunchAttackAction) {<br/>
            PunchAttackAction paa = (PunchAttackAction)aaa;<br/>
            int arm = paa.getArm();<br/>
            int damageRight = 0;<br/>
            paa.setArm(PunchAttackAction.LEFT);<br/>
            toHit = paa.toHit(game);<br/>
            paa.setArm(PunchAttackAction.RIGHT);<br/>
            ToHitData toHitRight = paa.toHit(game);<br/>
            damage = PunchAttackAction.getDamageFor(ae, PunchAttackAction.LEFT);<br/>
            damageRight = PunchAttackAction.getDamageFor(ae, PunchAttackAction.RIGHT);<br/>
            paa.setArm(arm);<br/>
            // If we're punching while prone (at a Tank,<br/>
            // duh), then we can only use one arm.<br/>
            if ( ae.isProne() ) {<br/>
                double oddsLeft = Compute.oddsAbove(toHit.getValue());<br/>
                double oddsRight = Compute.oddsAbove(toHitRight.getValue());<br/>
                // Use the best attack.<br/>
                if (  oddsLeft*damage &gt; oddsRight*damageRight ) {<br/>
                    paa.setArm(PunchAttackAction.LEFT);<br/>
                } else paa.setArm(PunchAttackAction.RIGHT);<br/>
            }<br/>
            pr.damageRight = damageRight;<br/>
            pr.toHitRight = toHitRight;<br/>
            pr.rollRight = Compute.d6(2);<br/>
        } else if (aaa instanceof PushAttackAction) {<br/>
            PushAttackAction paa = (PushAttackAction)aaa;<br/>
            toHit = paa.toHit(game);<br/>
        } else if (aaa instanceof LayExplosivesAttackAction) {<br/>
            LayExplosivesAttackAction leaa = (LayExplosivesAttackAction)aaa;<br/>
            toHit = leaa.toHit(game);<br/>
            damage = LayExplosivesAttackAction.getDamageFor(ae);<br/>
        } else if (aaa instanceof ThrashAttackAction) {<br/>
            ThrashAttackAction taa = (ThrashAttackAction)aaa;<br/>
            toHit = taa.toHit(game);<br/>
            damage = ThrashAttackAction.getDamageFor(ae);<br/>
        }<br/>
        pr.toHit = toHit;<br/>
        pr.damage = damage;<br/>
        return pr;<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolve a Physical Attack<br/>
     *<br/>
     * @param pr  The &lt;code&gt;PhysicalResult&lt;/code&gt; of the physical attack<br/>
     * @param cen The &lt;code&gt;int&lt;/code&gt; Entity Id of the entit's whose<br/>
     *            physical attack was last resolved<br/>
     */<br/>
    private void resolvePhysicalAttack(PhysicalResult pr, int cen) {<br/>
        AbstractAttackAction aaa = pr.aaa;<br/>
        if (aaa instanceof PunchAttackAction) {<br/>
            PunchAttackAction paa = (PunchAttackAction)aaa;<br/>
            if (paa.getArm() == PunchAttackAction.BOTH) {<br/>
                paa.setArm(PunchAttackAction.LEFT);<br/>
                pr.aaa = paa;<br/>
                resolvePunchAttack(pr, cen);<br/>
                cen = paa.getEntityId();<br/>
                paa.setArm(PunchAttackAction.RIGHT);<br/>
                pr.aaa = paa;<br/>
                resolvePunchAttack(pr, cen);<br/>
            } else {<br/>
                resolvePunchAttack(pr, cen);<br/>
                cen = paa.getEntityId();<br/>
            }<br/>
        } else if (aaa instanceof KickAttackAction) {<br/>
            resolveKickAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        } else if (aaa instanceof BrushOffAttackAction) {<br/>
            BrushOffAttackAction baa = (BrushOffAttackAction)aaa;<br/>
            if (baa.getArm() == BrushOffAttackAction.BOTH) {<br/>
                baa.setArm(BrushOffAttackAction.LEFT);<br/>
                pr.aaa = baa;<br/>
                resolveBrushOffAttack(pr, cen);<br/>
                cen = baa.getEntityId();<br/>
                baa.setArm(BrushOffAttackAction.RIGHT);<br/>
                pr.aaa = baa;<br/>
                resolveBrushOffAttack(pr, cen);<br/>
            } else {<br/>
                resolveBrushOffAttack(pr, cen);<br/>
                cen = baa.getEntityId();<br/>
            }<br/>
        } else if (aaa instanceof ThrashAttackAction) {<br/>
            resolveThrashAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        } else if (aaa instanceof ProtomechPhysicalAttackAction) {<br/>
            resolveProtoAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        } else if (aaa instanceof ClubAttackAction) {<br/>
            resolveClubAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        } else if (aaa instanceof PushAttackAction) {<br/>
            resolvePushAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        }  else if (aaa instanceof ChargeAttackAction) {<br/>
            resolveChargeAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        }  else if (aaa instanceof DfaAttackAction) {<br/>
            resolveDfaAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        }  else if (aaa instanceof LayExplosivesAttackAction) {<br/>
            resolveLayExplosivesAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        } else {<br/>
            // hmm, error.<br/>
        }<br/>
        // Not all targets are Entities.<br/>
        Targetable target = game.getTarget( aaa.getTargetType(),<br/>
                                        aaa.getTargetId() );<br/>
        if ( target instanceof Entity ) {<br/>
            creditKill( (Entity) target, game.getEntity(cen) );<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Add any extreme gravity PSRs the entity gets due to its movement<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; to check.<br/>
     * @param step   The last &lt;code&gt;MoveStep&lt;/code&gt; of this entity<br/>
     * @param curPos The current &lt;code&gt;Coords&lt;/code&gt; of this entity<br/>
     * @param cachedMaxMPExpenditure Server checks run/jump MP at start of move, as appropriate, caches to avoid mid-move change in MP causing erroneous grav check<br/>
     */<br/>
    private void checkExtremeGravityMovement(Entity entity, MoveStep step, Coords curPos, int cachedMaxMPExpenditure) {<br/>
        PilotingRollData rollTarget;<br/>
        if (game.getOptions().floatOption("gravity") != 1) {<br/>
            if (entity instanceof Mech) {<br/>
                if (step.getMovementType() == IEntityMovementType.MOVE_WALK<br/>
                        || (step.getMovementType() == IEntityMovementType.MOVE_VTOL_WALK)<br/>
                        || step.getMovementType() == IEntityMovementType.MOVE_RUN<br/>
                        || (step.getMovementType() == IEntityMovementType.MOVE_VTOL_RUN)) {<br/>
                    if (step.getMpUsed() &gt; cachedMaxMPExpenditure) {<br/>
                        // We moved too fast, let's make PSR to see if we get damage<br/>
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(step));<br/>
                    }<br/>
                } else if (step.getMovementType() == IEntityMovementType.MOVE_JUMP) {<br/>
                    if (step.getMpUsed() &gt; cachedMaxMPExpenditure) {<br/>
                        // We jumped too far, let's make PSR to see if we get damage<br/>
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(step));<br/>
                    } else if (game.getOptions().floatOption("gravity") &gt; 1) {<br/>
                        // jumping in high g is bad for your legs<br/>
                        rollTarget = entity.getBasePilotingRoll();<br/>
                        entity.addPilotingModifierForTerrain(rollTarget, step);<br/>
                        rollTarget.append(new PilotingRollData(entity.getId(), 0, "jumped in high gravity"));<br/>
                        game.addExtremeGravityPSR(rollTarget);<br/>
                    }<br/>
                }<br/>
            } else if (entity instanceof Tank) {<br/>
                if (step.getMovementType() == IEntityMovementType.MOVE_WALK<br/>
                        || (step.getMovementType() == IEntityMovementType.MOVE_VTOL_WALK)<br/>
                        || step.getMovementType() == IEntityMovementType.MOVE_RUN<br/>
                        || (step.getMovementType() == IEntityMovementType.MOVE_VTOL_RUN)) {<br/>
                    // For Tanks, we need to check if the tank had<br/>
                    // more MPs because it was moving along a road.<br/>
                    if ((step.getMpUsed() &gt; cachedMaxMPExpenditure) &amp;&amp; !step.isOnlyPavement()) {<br/>
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(step));<br/>
                    }<br/>
                    else if (step.getMpUsed() &gt; cachedMaxMPExpenditure + 1) {<br/>
                        // If the tank was moving on a road, he got a +1 bonus.<br/>
                        // N.B. The Ask Precentor Martial forum said that a 4/6<br/>
                        //      tank on a road can move 5/7, **not** 5/8.<br/>
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(step));<br/>
                    } // End tank-has-road-bonus<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Damage the inner structure of a mech's leg / a tank's front.<br/>
     * This only happens when the Entity fails an extreme Gravity PSR.<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; to damage.<br/>
     * @param damage The &lt;code&gt;int&lt;/code&gt; amount of damage.<br/>
     */<br/>
    private void doExtremeGravityDamage(Entity entity, int damage) {<br/>
        HitData hit;<br/>
        if (entity instanceof BipedMech) {<br/>
            for (int i = 6; i&lt;=7; i++) {<br/>
                hit = new HitData (i);<br/>
                addReport( damageEntity(entity, hit, damage, false, 0, true));<br/>
            }<br/>
        } if (entity instanceof QuadMech) {<br/>
            for (int i = 4; i&lt;=7; i++) {<br/>
                hit = new HitData (i);<br/>
                addReport( damageEntity(entity, hit, damage, false, 0, true));<br/>
            }<br/>
        } else if (entity instanceof Tank) {<br/>
            hit = new HitData (Tank.LOC_FRONT);<br/>
            addReport( damageEntity(entity, hit, damage, false, 0, true));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Eject an Entity.<br/>
     * @param entity    The &lt;code&gt;Entity&lt;/code&gt; to eject.<br/>
     * @param autoEject The &lt;code&gt;boolean&lt;/code&gt; state of the entity's auto-<br/>
     *                  ejection system<br/>
     * @return a &lt;code&gt;Vector&lt;/code&gt; of report objects for the gamelog.<br/>
     */<br/>
    public Vector ejectEntity(Entity entity, boolean autoEject) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // An entity can only eject it's crew once.<br/>
        if (entity.getCrew().isEjected())<br/>
            return vDesc;<br/>
        <br/>
        // If the crew are already dead, don't bother<br/>
        if(entity.getCrew().isDead() || entity.getCrew().isDoomed())<br/>
            return vDesc;<br/>
<br/>
        // Mek pilots may get hurt during ejection,<br/>
        // and run around the board afterwards.<br/>
        if (entity instanceof Mech) {<br/>
            PilotingRollData rollTarget = new PilotingRollData(entity.getId(), entity.getCrew().getPiloting(), "ejecting");<br/>
            if (entity.isProne()) {<br/>
                rollTarget.addModifier(5, "Mech is prone");<br/>
            }<br/>
            if (entity.getCrew().isUnconscious()) {<br/>
                rollTarget.addModifier(3, "pilot unconscious");<br/>
            }<br/>
            if (autoEject) {<br/>
                rollTarget.addModifier(1, "automatic ejection");<br/>
            }<br/>
            if (entity.getInternal(Mech.LOC_HEAD) &lt; 3) {<br/>
                rollTarget.addModifier(Math.min(3 - entity.getInternal(Mech.LOC_HEAD),2), "Head Internal Structure Damage");<br/>
            }<br/>
            int facing = entity.getFacing();<br/>
            Coords targetCoords = entity.getPosition().translated((facing + 3)%6);<br/>
            IHex targetHex = game.getBoard().getHex(targetCoords);<br/>
            if (targetHex != null) {<br/>
                if (targetHex.terrainLevel(Terrains.WATER) &gt; 0 &amp;&amp; !(targetHex.containsTerrain(Terrains.ICE))) {<br/>
                    rollTarget.addModifier(-1, "landing in water");<br/>
                } else if (targetHex.containsTerrain(Terrains.ROUGH)) {<br/>
                    rollTarget.addModifier(0, "landing in rough");<br/>
                } else if (targetHex.containsTerrain(Terrains.RUBBLE)) {<br/>
                    rollTarget.addModifier(0, "landing in rubble");<br/>
                } else if (targetHex.terrainLevel(Terrains.WOODS) == 1) {<br/>
                    rollTarget.addModifier(2, "landing in light woods");<br/>
                } else if (targetHex.terrainLevel(Terrains.WOODS) == 2) {<br/>
                    rollTarget.addModifier(3, "landing in heavy woods");<br/>
                } else if (targetHex.terrainLevel(Terrains.WOODS) == 3) {<br/>
                    rollTarget.addModifier(4, "landing in ultra heavy woods");<br/>
                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 1) {<br/>
                    rollTarget.addModifier(3, "landing in light jungle");<br/>
                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 2) {<br/>
                    rollTarget.addModifier(5, "landing in heavy jungle");<br/>
                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 3) {<br/>
                    rollTarget.addModifier(7, "landing in ultra heavy jungle");<br/>
                } else if (targetHex.terrainLevel(Terrains.BLDG_ELEV) &gt; 0) {<br/>
                    rollTarget.addModifier(targetHex.terrainLevel(Terrains.BLDG_ELEV), "landing in a building");<br/>
                } else rollTarget.addModifier(-2, "landing in clear terrain");<br/>
            } else {<br/>
                rollTarget.addModifier(-2, "landing off the board");<br/>
            }<br/>
            if (autoEject) {<br/>
                r = new Report(6395);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            // okay, print the info<br/>
            r = new Report(2180);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(rollTarget.getLastPlainDesc(), true);<br/>
            r.indent(3);<br/>
            vDesc.addElement(r);<br/>
            // roll<br/>
            final int diceRoll = Compute.d6(2);<br/>
            r = new Report(2190);<br/>
            r.subject = entity.getId();<br/>
            r.add(rollTarget.getValueAsString());<br/>
            r.add(rollTarget.getDesc());<br/>
            r.add(diceRoll);<br/>
            r.indent(4);<br/>
            r.newlines = 0;<br/>
            // create the MechWarrior in any case, for campaign tracking<br/>
            MechWarrior pilot = new MechWarrior(entity);<br/>
            pilot.setDeployed(true);<br/>
            pilot.setId(getFreeEntityId());<br/>
            game.addEntity(pilot.getId(), pilot);<br/>
            send(createAddEntityPacket(pilot.getId()));<br/>
            // make him not get a move this turn<br/>
            pilot.setDone(true);<br/>
            if (diceRoll &lt; rollTarget.getValue()) {<br/>
                r.choose(false);<br/>
                vDesc.addElement(r);<br/>
                Report.addNewline(vDesc);<br/>
                Vector v = damageCrew(pilot, 1);<br/>
                if(v.size() &gt; 0) {<br/>
                    r = (Report)v.firstElement();<br/>
                    r.indent(3);<br/>
                    vDesc.addElement(r);<br/>
                }<br/>
            } else {<br/>
                r.choose(true);<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            if (entity.getCrew().isDoomed()) {<br/>
                vDesc.addAll(<br/>
                        destroyEntity(pilot, "deadly ejection", false, false));<br/>
            }<br/>
            else {<br/>
                // Add the pilot as an infantry unit on the battlefield.<br/>
                if (game.getBoard().contains(targetCoords)) {<br/>
                    pilot.setPosition(targetCoords);<br/>
/* Can pilots eject into water???<br/>
   ASSUMPTION : They can (because they get a -1 mod to the PSR.<br/>
                    // Did the pilot land in water?<br/>
                    if ( game.getBoard().getHex( targetCoords).levelOf<br/>
                         ( Terrain.WATER ) &gt; 0 ) {<br/>
                         //report missing<br/>
                        desc.append("and the pilot ejects, but lands in water!!!\n");<br/>
                        //report missing<br/>
                        desc.append(destroyEntity( pilot, "a watery grave", false ));<br/>
                    } else {<br/>
                        //report missing<br/>
                        desc.append("and the pilot ejects safely!\n");<br/>
                    }<br/>
*/<br/>
                    //report safe ejection<br/>
                    r = new Report(6400);<br/>
                    r.subject = entity.getId();<br/>
                    r.indent(5);<br/>
                    vDesc.addElement(r);<br/>
                    if (game.getOptions().booleanOption("vacuum")) {<br/>
                        //ended up in a vacuum<br/>
                        r = new Report(6405);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent(3);<br/>
                        vDesc.addElement(r);<br/>
                        vDesc.addAll(<br/>
                            destroyEntity(pilot, "explosive decompression", false, false));<br/>
                    }<br/>
                    // Update the entity<br/>
                    this.entityUpdate(pilot.getId());<br/>
                    // check if the pilot lands in a minefield<br/>
                    doEntityDisplacementMinefieldCheck( pilot,<br/>
                            entity.getPosition(),<br/>
                            targetCoords );<br/>
                } else {<br/>
                    //ejects safely<br/>
                    r = new Report(6410);<br/>
                    r.subject = entity.getId();<br/>
                    r.indent(3);<br/>
                    vDesc.addElement(r);<br/>
                    if (game.getOptions().booleanOption("vacuum")) {<br/>
                        //landed in vacuum<br/>
                        r = new Report(6405);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent(3);<br/>
                        vDesc.addElement(r);<br/>
                        vDesc.addAll(<br/>
                            destroyEntity(pilot, "explosive decompression", false, false));<br/>
                    } else {<br/>
                        game.removeEntity( pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT );<br/>
                        send(createRemoveEntityPacket(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT) );<br/>
                    }<br/>
                }<br/>
                if (game.getOptions().booleanOption("ejected_pilots_flee")) {<br/>
                    game.removeEntity(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);<br/>
                    send(createRemoveEntityPacket(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));<br/>
                }<br/>
            } // Pilot safely ejects.<br/>
<br/>
        } // End entity-is-Mek<br/>
<br/>
        // Mark the entity's crew as "ejected".<br/>
        entity.getCrew().setEjected( true );<br/>
        vDesc.addAll(<br/>
            destroyEntity(entity, "ejection", true, true));<br/>
<br/>
        // only remove the unit that ejected manually<br/>
        if (!autoEject) {<br/>
            game.removeEntity( entity.getId(), IEntityRemovalConditions.REMOVE_EJECTED );<br/>
            send(createRemoveEntityPacket(entity.getId(), IEntityRemovalConditions.REMOVE_EJECTED));<br/>
        }<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Abandon an Entity.<br/>
     * @param entity    The &lt;code&gt;Entity&lt;/code&gt; to abandon.<br/>
     *<br/>
     * @return a &lt;code&gt;Vector&lt;/code&gt; of report objects for the gamelog.<br/>
     */<br/>
    public Vector abandonEntity(Entity entity) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // An entity can only eject it's crew once.<br/>
        if (entity.getCrew().isEjected())<br/>
            return vDesc;<br/>
<br/>
        if (entity.getCrew().isDoomed()) <br/>
            return vDesc;<br/>
        <br/>
        //Don't make them abandon into vacuum<br/>
        if (game.getOptions().booleanOption("vacuum")) <br/>
            return vDesc;<br/>
        <br/>
        Coords targetCoords = entity.getPosition();<br/>
        <br/>
        if (entity instanceof Mech) {<br/>
            // okay, print the info<br/>
            r = new Report(2027);<br/>
            r.subject = entity.getId();<br/>
            r.add(entity.getCrew().getName());<br/>
            r.addDesc(entity);<br/>
            r.indent(3);<br/>
            vDesc.addElement(r);<br/>
<br/>
            // create the MechWarrior in any case, for campaign tracking<br/>
            MechWarrior pilot = new MechWarrior(entity);<br/>
            pilot.getCrew().setUnconscious(entity.getCrew().isUnconscious());<br/>
            pilot.setDeployed(true);<br/>
            pilot.setId(getFreeEntityId());<br/>
            game.addEntity(pilot.getId(), pilot);<br/>
            send(createAddEntityPacket(pilot.getId()));<br/>
            // make him not get a move this turn<br/>
            pilot.setDone(true);<br/>
            // Add the pilot as an infantry unit on the battlefield.<br/>
            if (game.getBoard().contains(targetCoords))<br/>
                    pilot.setPosition(targetCoords);<br/>
            // Update the entity<br/>
            this.entityUpdate(pilot.getId());<br/>
            // check if the pilot lands in a minefield<br/>
            doEntityDisplacementMinefieldCheck( pilot,<br/>
                    entity.getPosition(),<br/>
                    targetCoords );<br/>
            if (game.getOptions().booleanOption("ejected_pilots_flee")) {<br/>
                game.removeEntity(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);<br/>
                send(createRemoveEntityPacket(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));<br/>
            }<br/>
        } // End entity-is-Mek<br/>
<br/>
        // Mark the entity's crew as "ejected".<br/>
        entity.getCrew().setEjected( true );<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks if ejected Mechwarriors are eligible to be picked up,<br/>
     * and if so, captures them or picks them up<br/>
     */<br/>
    private void resolveMechWarriorPickUp() {<br/>
        Report r;<br/>
<br/>
        // fetch all mechWarriors that are not picked up<br/>
        Enumeration mechWarriors =<br/>
            game.getSelectedEntities( new EntitySelector() {<br/>
                public boolean accept(Entity entity) {<br/>
                    if (entity instanceof MechWarrior) {<br/>
                        MechWarrior mw = (MechWarrior)entity;<br/>
                        if (mw.getPickedUpById() == Entity.NONE &amp;&amp;<br/>
                            !mw.isDoomed() &amp;&amp; (mw.getTransportId() == Entity.NONE) ) {<br/>
                            return true;<br/>
                        }<br/>
                    }<br/>
                    return false;<br/>
                }<br/>
            } );<br/>
        // loop through them, check if they are in a hex occupied by another<br/>
        // unit<br/>
        while ( mechWarriors.hasMoreElements() ) {<br/>
            boolean pickedUp = false;<br/>
            MechWarrior e = (MechWarrior) mechWarriors.nextElement();<br/>
            Enumeration pickupEntities = game.getEntities(e.getPosition());<br/>
            while (pickupEntities.hasMoreElements() ) {<br/>
                Entity pe = (Entity) pickupEntities.nextElement();<br/>
                if (pe.isDoomed() || pe.isShutDown() || pe.getCrew().isUnconscious()) {<br/>
                    continue;<br/>
                }<br/>
                if (!pickedUp &amp;&amp; pe.getOwnerId() == e.getOwnerId() &amp;&amp; pe.getId() != e.getId()) {<br/>
                    if (pe instanceof MechWarrior) {<br/>
                        //picked up by friendlies<br/>
                        r = new Report(6415, Report.PUBLIC); //no subject we can use...<br/>
                        r.add(pe.getDisplayName());<br/>
                        addReport(r);<br/>
                        continue;<br/>
                    }<br/>
                    // Pick up the unit.<br/>
                    pe.pickUp(e);<br/>
                    // The picked unit is being carried by the loader.<br/>
                    e.setPickedUpById(pe.getId());<br/>
                    e.setPickedUpByExternalId(pe.getExternalId());<br/>
                    pickedUp = true;<br/>
                    r = new Report(6420, Report.PUBLIC);<br/>
                    r.add(e.getDisplayName());<br/>
                    r.addDesc(pe);<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
            if (!pickedUp) {<br/>
                Enumeration pickupEnemyEntities = game.getEnemyEntities(e.getPosition(), e);<br/>
                while (pickupEnemyEntities.hasMoreElements() ) {<br/>
                    Entity pe = (Entity) pickupEnemyEntities.nextElement();<br/>
                    if (pe.isDoomed() || pe.isShutDown() ||<br/>
                        pe.getCrew().isUnconscious()) {<br/>
                        continue;<br/>
                    }<br/>
                    if (pe instanceof MechWarrior) {<br/>
                        //picked up by friendlies<br/>
                        r = new Report(6415, Report.PUBLIC); //no subject we can use...<br/>
                        r.add(pe.getDisplayName());<br/>
                        addReport(r);<br/>
                        continue;<br/>
                    }<br/>
                    // Capture the unit.<br/>
                    pe.pickUp(e);<br/>
                    // The captured unit is being carried by the loader.<br/>
                    e.setCaptured( true );<br/>
                    e.setPickedUpById(pe.getId());<br/>
                    e.setPickedUpByExternalId(pe.getExternalId());<br/>
                    pickedUp = true;<br/>
                    r = new Report(6420, Report.PUBLIC);<br/>
                    r.add(e.getDisplayName());<br/>
                    r.addDesc(pe);<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
            if (pickedUp) {<br/>
                // Remove the picked-up unit from the screen.<br/>
                e.setPosition( null );<br/>
                // Update the loaded unit.<br/>
                this.entityUpdate( e.getId() );<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * destroy all wheeled and tracked Tanks that got displaced into water<br/>
     */<br/>
    private void resolveSinkVees() {<br/>
        Enumeration sinkableTanks =<br/>
            game.getSelectedEntities( new EntitySelector() {<br/>
            public boolean accept(Entity entity) {<br/>
                if (entity.isOffBoard()) {<br/>
                    return false;<br/>
                }<br/>
                <br/>
                if (entity instanceof Tank<br/>
                        &amp;&amp; (entity.getPosition() != null)<br/>
                        &amp;&amp; (entity.getMovementMode() == IEntityMovementMode.TRACKED<br/>
                        || entity.getMovementMode() == IEntityMovementMode.WHEELED )<br/>
                        &amp;&amp; game.getBoard().getHex(entity.getPosition()).terrainLevel(Terrains.WATER) &gt; 0<br/>
                        &amp;&amp; entity.getElevation() &lt; 0) {<br/>
                        return true;<br/>
                }<br/>
                return false;<br/>
            }<br/>
        });<br/>
        while (sinkableTanks.hasMoreElements()) {<br/>
            Entity e = (Entity)sinkableTanks.nextElement();<br/>
            addReport(<br/>
                                  destroyEntity(e, "a watery grave", false));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * let all Entities make their "break-free-of-swamp-stickyness" PSR<br/>
     */<br/>
    private void doTryUnstuck() {<br/>
        if (game.getPhase() != IGame.PHASE_MOVEMENT)<br/>
            return;<br/>
<br/>
        Report r;<br/>
<br/>
        Enumeration stuckEntities =<br/>
            game.getSelectedEntities( new EntitySelector() {<br/>
            public boolean accept(Entity entity) {<br/>
                if (entity.isStuck()) {<br/>
                    return true;<br/>
                }<br/>
                return false;<br/>
            }<br/>
        });<br/>
        PilotingRollData rollTarget;<br/>
        while (stuckEntities.hasMoreElements()) {<br/>
            Entity entity = (Entity)stuckEntities.nextElement();<br/>
            rollTarget = entity.getBasePilotingRoll();<br/>
            entity.addPilotingModifierForTerrain(rollTarget);<br/>
            // apart from swamp &amp; liquid magma, -1 modifier<br/>
            IHex hex = game.getBoard().getHex(entity.getPosition());<br/>
            if(!(hex.containsTerrain(Terrains.SWAMP))<br/>
                &amp;&amp; !(hex.terrainLevel(Terrains.MAGMA) == 2)) {<br/>
                rollTarget.addModifier(-1, "bogged down");<br/>
            }<br/>
            // okay, print the info<br/>
            r = new Report(2340);<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
<br/>
            // roll<br/>
            final int diceRoll = Compute.d6(2);<br/>
            r = new Report(2190);<br/>
            r.add(rollTarget.getValueAsString());<br/>
            r.add(rollTarget.getDesc());<br/>
            r.add(diceRoll);<br/>
            if (diceRoll &lt; rollTarget.getValue()) {<br/>
                r.choose(false);<br/>
            } else {<br/>
                r.choose(true);<br/>
                entity.setStuck(false);<br/>
                entity.setCanUnstickByJumping(false);<br/>
            }<br/>
            addReport(r);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Remove all iNarc pods from all vehicles that did not<br/>
     * move and shoot this round<br/>
     * NOTE: this is not quite what the rules say, the player<br/>
     * should be able to choose whether or not to remove all iNarc Pods<br/>
     * that are attached.<br/>
     */<br/>
    private void resolveVeeINarcPodRemoval() {<br/>
        Enumeration vees =<br/>
            game.getSelectedEntities( new EntitySelector() {<br/>
            public boolean accept(Entity entity) {<br/>
                if (entity instanceof Tank &amp;&amp;<br/>
                    entity.mpUsed == 0) {<br/>
                    return true;<br/>
                }<br/>
                return false;<br/>
            }<br/>
        });<br/>
        boolean canSwipePods;<br/>
        while (vees.hasMoreElements()) {<br/>
            canSwipePods = true;<br/>
            Entity entity = (Entity)vees.nextElement();<br/>
            for (int i=0;i&lt;=5;i++) {<br/>
                if ( entity.weaponFiredFrom(i) ) {<br/>
                    canSwipePods = false;<br/>
                }<br/>
            }<br/>
            if (canSwipePods &amp;&amp; entity.hasINarcPodsAttached() &amp;&amp;<br/>
                entity.getCrew().isActive()) {<br/>
                entity.removeAllINarcPods();<br/>
                Report r = new Report(2345);<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    private void deadEntitiesCleanup() {<br/>
        //See note above where knownDeadEntities variable is declared<br/>
        /*<br/>
        Entity en = null;<br/>
        for(Enumeration k = game.getGraveyardEntities(); k.hasMoreElements(); en = (Entity) k.nextElement()) {<br/>
            if (en != null) {<br/>
                if (!knownDeadEntities.contains(en)) {<br/>
                    knownDeadEntities.add(en);<br/>
                }<br/>
            }           <br/>
        }<br/>
        */<br/>
    }<br/>
    <br/>
    private void resolveIceBroken(Coords c) {<br/>
        game.getBoard().getHex(c).removeTerrain(Terrains.ICE);<br/>
        sendChangedHex(c);<br/>
        //drop entities on the surface into the water<br/>
        for(Enumeration entities = game.getEntities(c);entities.hasMoreElements();) {<br/>
            Entity e = (Entity)entities.nextElement();<br/>
            if(e.getElevation() == 0) {<br/>
                doEntityFall(e, new PilotingRollData(TargetRoll.AUTOMATIC_FAIL));<br/>
            }<br/>
        }<br/>
    }<br/>
        <br/>
    private void checkForVehicleFire(Tank tank, boolean inferno) {<br/>
        int boomroll = Compute.d6(2);<br/>
        int penalty = 0;<br/>
        switch(tank.getMovementMode()) {<br/>
        case IEntityMovementMode.HOVER:<br/>
            penalty = 4;<br/>
            break;<br/>
        case IEntityMovementMode.VTOL:<br/>
        case IEntityMovementMode.WHEELED:<br/>
            penalty = 2;<br/>
            break;<br/>
        }<br/>
        if(inferno) {<br/>
            boomroll = 12;<br/>
        }<br/>
        Report r = new Report(5250);<br/>
        r.subject = tank.getId();<br/>
        r.addDesc(tank);<br/>
        r.add(8-penalty);<br/>
        r.add(boomroll);<br/>
        if (boomroll + penalty &lt; 8) {<br/>
            //phew!<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
        } else {<br/>
            //eek<br/>
            if(!inferno) {<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
            }<br/>
            if(boomroll + penalty &lt; 10) {<br/>
                vehicleMotiveDamage(tank, penalty - 1);<br/>
            } else {<br/>
                resolveVehicleFire(tank, false);<br/>
                if(boomroll + penalty &gt;= 12) {<br/>
                    r = new Report(5255);<br/>
                    r.subject = tank.getId();<br/>
                    r.indent(3);<br/>
                    addReport(r);<br/>
                    tank.setOnFire();<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    private void resolveVehicleFire(Tank tank, boolean existingStatus) {<br/>
        if(existingStatus &amp;&amp; !tank.isOnFire())<br/>
            return;<br/>
        for(int i=0;i&lt;tank.locations();i++) {<br/>
            if(i==Tank.LOC_BODY || (tank instanceof VTOL &amp;&amp; i==VTOL.LOC_ROTOR))<br/>
                continue;<br/>
            if(existingStatus &amp;&amp; !(tank.isLocationBurning(i)))<br/>
                continue;<br/>
            HitData hit = new HitData(i);<br/>
            int damage =Compute.d6(1);<br/>
            addReport(damageEntity(tank, hit, damage));<br/>
            if(damage == 1 &amp;&amp; existingStatus) {<br/>
                tank.extinguishLocation(i);<br/>
            }<br/>
        }        <br/>
       addNewLines();<br/>
    }<br/>
    <br/>
    private void vehicleMotiveDamage(Tank te, int modifier) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
        int roll = Compute.d6(2) + modifier;<br/>
        r = new Report(6305);<br/>
        r.subject = te.getId();<br/>
        r.add("movement system");<br/>
        r.newlines = 0;<br/>
        r.indent(3);<br/>
        vDesc.addElement(r);<br/>
        r = new Report(6310);<br/>
        r.subject = te.getId();<br/>
        r.add(roll);<br/>
        r.newlines = 0;<br/>
        vDesc.addElement(r);<br/>
        if(roll &lt;= 7) {<br/>
            //no effect<br/>
            r = new Report(6005);<br/>
            r.subject = te.getId();<br/>
            r.add(roll);<br/>
            vDesc.addElement(r);<br/>
        } else if (roll &lt;=9) {<br/>
            //minor damage<br/>
            r = new Report(6470);<br/>
            r.subject = te.getId();<br/>
            r.add(roll);<br/>
            vDesc.addElement(r);<br/>
            te.addMovementDamage(1);<br/>
        } else if (roll &lt;12) {<br/>
            //major damage<br/>
            r = new Report(6135);<br/>
            r.subject = te.getId();<br/>
            vDesc.addElement(r);<br/>
            te.addMovementDamage(2);<br/>
            int nMP = te.getOriginalWalkMP();<br/>
            if (nMP &gt; 0) {<br/>
                te.setOriginalWalkMP(nMP - 1);<br/>
<br/>
                if (te.getOriginalWalkMP()==0) {<br/>
                    // Hovercraft reduced to 0MP over water sink<br/>
                    if ( te.getMovementMode() == IEntityMovementMode.HOVER &amp;&amp;<br/>
                         game.getBoard().getHex( te.getPosition() ).terrainLevel(Terrains.WATER) &gt; 0 &amp;&amp;<br/>
                         !(game.getBoard().getHex( te.getPosition() ).containsTerrain(Terrains.ICE))) {<br/>
                        vDesc.addAll( destroyEntity(te, "a watery grave", false) );<br/>
                    }<br/>
                }<br/>
            }<br/>
        } else  {<br/>
            r = new Report(6140);<br/>
            r.subject = te.getId();<br/>
            vDesc.addElement(r);<br/>
            te.immobilize();<br/>
            // Does the hovercraft sink?<br/>
            IHex te_hex = game.getBoard().getHex( te.getPosition() );<br/>
            if ( te.getMovementMode() == IEntityMovementMode.HOVER &amp;&amp;<br/>
                 te_hex.terrainLevel(Terrains.WATER) &gt; 0 &amp;&amp;<br/>
                 !(te_hex.containsTerrain(Terrains.ICE))) {<br/>
                vDesc.addAll( destroyEntity(te, "a watery grave", false) );<br/>
            }<br/>
            if(te instanceof VTOL) {<br/>
                Report.addNewline(vDesc);<br/>
                //report problem: add tab<br/>
                vDesc.addAll( crashVTOL((VTOL)te));<br/>
            }<br/>
        }<br/>
        addReport(vDesc);<br/>
    }<br/>
<br/>
    <br/>
    /**<br/>
     * Add a whole lotta Reports to the players report queues<br/>
     * as well as the Master report queue vPhaseReport.<br/>
     */<br/>
    private  void addReport(Vector reports){<br/>
        //Only bother with player reports if doing double blind.<br/>
        if ( doBlind())<br/>
            for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
                final Connection conn = (Connection)i.nextElement();<br/>
                Player p = game.getPlayer(conn.getId());<br/>
    <br/>
                p.getTurnReport().addAll(filterReportVector(reports,p));<br/>
            }<br/>
        vPhaseReport.addAll(reports);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Add a single report to the report queue of all players and the master<br/>
     * vPhaseReport queue<br/>
     */<br/>
    private void addReport(Report report){<br/>
        //Only bother with player reports if doing double blind.<br/>
        if ( doBlind())<br/>
            for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
                final Connection conn = (Connection)i.nextElement();<br/>
                Player p = game.getPlayer(conn.getId());<br/>
    <br/>
                p.getTurnReport().addElement(filterReport(report,p,false));<br/>
            }<br/>
        vPhaseReport.addElement(report);<br/>
    }<br/>
<br/>
    /**<br/>
     * New Round has started clear everyones report queue<br/>
     */<br/>
    private void clearReports(){<br/>
        //Only bother with player reports if doing double blind.<br/>
        if ( doBlind())<br/>
            for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
                final Connection conn = (Connection)i.nextElement();<br/>
                Player p = game.getPlayer(conn.getId());<br/>
    <br/>
                p.getTurnReport().removeAllElements();<br/>
            }<br/>
        vPhaseReport.removeAllElements();        <br/>
    }<br/>
    <br/>
    /**<br/>
     * make sure all teh new lines that where added to the old vPhaseReport<br/>
     * get added to all of the players filters<br/>
     */<br/>
    private void addNewLines(){<br/>
        //Only bother with player reports if doing double blind.<br/>
        if ( doBlind())<br/>
            for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
                final Connection conn = (Connection)i.nextElement();<br/>
                Player p = game.getPlayer(conn.getId());<br/>
    <br/>
                Report.addNewline(p.getTurnReport());<br/>
            }<br/>
        Report.addNewline(vPhaseReport);<br/>
    }<br/>
    <br/>
    public void doAssaultDrop(Entity entity) {<br/>
        PilotingRollData psr;<br/>
        if(entity instanceof Mech) {<br/>
            psr=entity.getBasePilotingRoll();<br/>
        } else {<br/>
            psr=new PilotingRollData(entity.getId(),4,"landing assault drop");<br/>
        }<br/>
        int roll = Compute.d6(2);<br/>
        //check for a safe landing<br/>
        Report r = new Report(2380);<br/>
        r.subject = entity.getId();<br/>
        r.add(entity.getDisplayName(), true);<br/>
        r.add(psr.getValueAsString());<br/>
        r.add(roll);<br/>
        r.choose(roll &gt;= psr.getValue());<br/>
        addReport(r);<br/>
        if(roll &lt; psr.getValue()) {<br/>
            int fallHeight = psr.getValue() - roll;<br/>
            //determine where we really land<br/>
            int distance = Compute.d6(fallHeight);<br/>
            Coords c = Compute.scatter(entity.getPosition(), distance);<br/>
            r = new Report(2385);<br/>
            r.subject = entity.getId();<br/>
            r.add(distance);<br/>
            r.indent(3);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if(fallHeight &gt;=5 || !game.getBoard().contains(c)) {<br/>
                r = new Report(2386);<br/>
                addReport(r);<br/>
                game.removeEntity(entity.getId(),IEntityRemovalConditions.REMOVE_NEVER_JOINED);<br/>
                return;<br/>
            }<br/>
            entity.setPosition(c);<br/>
            <br/>
            //do fall damage<br/>
            if(entity instanceof Mech || entity instanceof Protomech) {<br/>
                entity.setElevation(fallHeight);<br/>
                doEntityFallsInto(entity, c, c, psr, true);<br/>
            }<br/>
            else if(entity instanceof BattleArmor) {<br/>
                for(int i=1;i&lt;entity.locations();i++) {<br/>
                    HitData h = new HitData(i);<br/>
                    addReport(damageEntity(entity,h,Compute.d6(fallHeight)));<br/>
                    addNewLines();<br/>
                }<br/>
            }<br/>
            else if(entity instanceof Infantry) {<br/>
                HitData h = new HitData(Infantry.LOC_INFANTRY);<br/>
                addReport(damageEntity(entity,h, 1));<br/>
                addNewLines();<br/>
            }<br/>
        }<br/>
        //set entity to expected elevation<br/>
        IHex hex = game.getBoard().getHex(entity.getPosition());<br/>
        entity.setElevation(entity.elevationOccupied(hex) - hex.floor());<br/>
        //finally, check for any stacking violations<br/>
        Entity violated = Compute.stackingViolation(game, entity, entity.getPosition(), null);<br/>
        if(violated != null) {<br/>
            //handle this as accidental fall from above<br/>
            entity.setElevation(violated.getElevation() + 2);<br/>
            r = new Report(2390);<br/>
            r.subject = entity.getId();<br/>
            r.add(entity.getDisplayName(), true);<br/>
            r.add(violated.getDisplayName(), true);<br/>
            addReport(r);<br/>
            doEntityFallsInto(entity, entity.getPosition(), entity.getPosition(), psr);<br/>
        }<br/>
        return;<br/>
    }<br/>
    <br/>
    void doAllAssaultDrops() {<br/>
        for(Enumeration i = game.getEntities();i.hasMoreElements();) {<br/>
            Entity e = (Entity)(i.nextElement());<br/>
            if(e.isAssaultDropInProgress()) {<br/>
                doAssaultDrop(e);<br/>
                e.setLandedAssaultDrop();<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    void doMagmaDamage(Entity en, boolean eruption) {<br/>
        if((en.getMovementMode() == IEntityMovementMode.VTOL ||<br/>
           (en.getMovementMode() == IEntityMovementMode.HOVER &amp;&amp; en.getOriginalWalkMP() &gt; 0 &amp;&amp; !eruption))<br/>
           &amp;&amp; !(en.isImmobile())) {<br/>
           return;<br/>
        }<br/>
        Report r;<br/>
        boolean isMech = en instanceof Mech;<br/>
        if(isMech)<br/>
            r = new Report(2405);<br/>
        else<br/>
            r = new Report(2400);<br/>
        r.addDesc(en);<br/>
        r.subject = en.getId();<br/>
        addReport(r);<br/>
        if(isMech) {<br/>
            HitData h;<br/>
            for(int i=0;i&lt;en.locations();i++) {<br/>
                if(eruption || en.locationIsLeg(i) || en.isProne()) {<br/>
                    h = new HitData(i);<br/>
                    addReport(damageEntity(en, h, Compute.d6(2)));<br/>
                }<br/>
            }<br/>
        } else {<br/>
            addReport(destroyEntity(en, "fell into magma", false, false));<br/>
        }<br/>
        addNewLines();<br/>
    }<br/>
    <br/>
    /**<br/>
     * deal area saturation damage to an individual hex<br/>
     * @param coords         The hex being hit<br/>
     * @param attackSource   The location the attack came from.  For hit table resolution<br/>
     * @param damage         Amount of damage to deal to each entity<br/>
     * @param ammo           The ammo type being used<br/>
     * @param subjectId      Subject for reports<br/>
     * @param killer         Who should be credited with kills<br/>
     * @param exclude        Entity that should take no damage (used for homing splash)<br/>
     * @param flak           Flak, hits flying units only, instead of flyers being immune<br/>
     * @param altitude       Absolute altitude for flak attack<br/>
     */<br/>
    void artilleryDamageHex(Coords coords, Coords attackSource, int damage, AmmoType ammo, int subjectId, Entity killer, Entity exclude, boolean flak, int altitude) {<br/>
<br/>
        IHex hex = game.getBoard().getHex(coords);<br/>
        if(hex == null) return; //not on board.<br/>
<br/>
        int flakElevation = altitude - hex.surface();<br/>
<br/>
        Report r;<br/>
<br/>
        Building bldg = game.getBoard().getBuildingAt(coords);<br/>
        int bldgAbsorbs = 0;<br/>
        if(bldg != null<br/>
           &amp;&amp; !(flak &amp;&amp; flakElevation &gt; hex.terrainLevel(Terrains.BLDG_ELEV))) {<br/>
            bldgAbsorbs = bldg.getPhaseCF() / 10;<br/>
            if(!(ammo != null &amp;&amp; ammo.getMunitionType() == AmmoType.M_FLECHETTE)) {<br/>
                //damage the building<br/>
                r = damageBuilding( bldg, damage );<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                addNewLines();<br/>
            }<br/>
        }<br/>
<br/>
        if(flak<br/>
           &amp;&amp; (flakElevation &lt;= 0<br/>
               || flakElevation &lt;= hex.terrainLevel(Terrains.BLDG_ELEV)<br/>
               || flakElevation == hex.terrainLevel(Terrains.BRIDGE_ELEV))) {<br/>
            //Flak in this hex would only hit landed units<br/>
            return;<br/>
        }<br/>
<br/>
        // get units in hex<br/>
        for (Enumeration impactHexHits = game.getEntities(coords);impactHexHits.hasMoreElements();) {<br/>
            Entity entity = (Entity)impactHexHits.nextElement();<br/>
            int hits = damage;<br/>
            ToHitData toHit = new ToHitData();<br/>
            int cluster = 5;<br/>
            <br/>
            //Check: is entity excluded?<br/>
            if(entity == exclude)<br/>
                continue;<br/>
<br/>
            //Check: is entity inside building?<br/>
            if(bldg != null &amp;&amp;<br/>
               bldgAbsorbs &gt; 0 &amp;&amp;<br/>
               entity.getElevation() &lt; hex.terrainLevel(Terrains.BLDG_ELEV)) {<br/>
                cluster -= bldgAbsorbs;<br/>
                if(entity instanceof Infantry) {<br/>
                    continue; //took its damage already from building damage<br/>
                }<br/>
                else if(cluster &lt;= 0) {<br/>
                    //entity takes no damage<br/>
                    r = new Report(6426);<br/>
                    r.subject = subjectId;<br/>
                    r.addDesc(entity);<br/>
                    addReport(r);<br/>
                    continue;<br/>
                } else {<br/>
                    r = new Report(6425);<br/>
                    r.subject = subjectId;<br/>
                    r.add(bldgAbsorbs);<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            if(flak) {<br/>
                //Check: is entity not a VTOL in flight<br/>
                if (!(entity instanceof VTOL ||<br/>
                    entity.getMovementMode()==IEntityMovementMode.VTOL)) {<br/>
                    continue;<br/>
                }<br/>
                //Check: is entity at correct elevation?<br/>
                if(entity.getElevation() != flakElevation)<br/>
                    continue;<br/>
            } else {<br/>
                //Check: is entity a VTOL in flight?<br/>
                if (entity instanceof VTOL ||<br/>
                    entity.getMovementMode()==IEntityMovementMode.VTOL) {<br/>
                    // VTOLs take no damage from normal artillery unless landed<br/>
                    if (entity.getElevation()!=0<br/>
                        &amp;&amp; entity.getElevation()!=hex.terrainLevel(Terrains.BLDG_ELEV)<br/>
                        &amp;&amp; entity.getElevation()!=hex.terrainLevel(Terrains.BRIDGE_ELEV)) {<br/>
                        continue;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            //Work out hit table to use<br/>
            if (attackSource!=null) {<br/>
                toHit.setSideTable(entity.sideTable(attackSource));<br/>
                if(ammo != null <br/>
                   &amp;&amp; entity instanceof Mech<br/>
                   &amp;&amp; ammo.getMunitionType() == AmmoType.M_CLUSTER<br/>
                   &amp;&amp; attackSource.equals(coords)) {<br/>
                    toHit.setHitTable(ToHitData.HIT_ABOVE);<br/>
                }<br/>
            }<br/>
<br/>
            //Entity/ammo specific damage modifiers<br/>
            if(ammo != null) {<br/>
                if(ammo.getMunitionType() == AmmoType.M_CLUSTER) {<br/>
                    if(hex.containsTerrain(Terrains.FORTIFIED) <br/>
                            &amp;&amp; entity instanceof Infantry<br/>
                            &amp;&amp; !(entity instanceof BattleArmor)) {<br/>
                        hits *= 2;<br/>
                    }<br/>
                    if(hex.containsTerrain(Terrains.WOODS)<br/>
                            || hex.containsTerrain(Terrains.JUNGLE)) {<br/>
                        hits = (hits + 1) / 2;<br/>
                    }<br/>
                }<br/>
                else if(ammo.getMunitionType() == AmmoType.M_FLECHETTE) {<br/>
                    //wheeled and hover tanks take movement critical<br/>
                    if(entity instanceof Tank &amp;&amp;<br/>
                       (entity.getMovementMode() == IEntityMovementMode.WHEELED ||<br/>
                        entity.getMovementMode() == IEntityMovementMode.HOVER)) {<br/>
                        r = new Report(6480);<br/>
                        r.subject = entity.getId();<br/>
                        r.addDesc(entity);<br/>
                        r.add(toHit.getTableDesc());<br/>
                        r.add(0);<br/>
                        addReport(r);<br/>
                        vehicleMotiveDamage((Tank)entity, 0);<br/>
                        continue;<br/>
                    }<br/>
                    //non infantry are immune<br/>
                    if(entity instanceof BattleArmor ||<br/>
                       !(entity instanceof Infantry)) {<br/>
                        continue;<br/>
                    }<br/>
                    if(hex.containsTerrain(Terrains.WOODS)<br/>
                            || hex.containsTerrain(Terrains.JUNGLE)) {<br/>
                        hits = (hits + 1) / 2;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            //Do the damage<br/>
            addNewLines();<br/>
            r = new Report(6480);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(toHit.getTableDesc());<br/>
            r.add(hits);<br/>
            addReport(r);<br/>
            while(hits&gt;0) {<br/>
                HitData hit = entity.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
<br/>
                addReport( damageEntity(entity, hit, Math.min(cluster, hits), false, 0, false, true, false));<br/>
                hits -= Math.min(5,hits);<br/>
            }<br/>
            if(killer != null) {<br/>
                creditKill(entity, killer);<br/>
            }<br/>
            addNewLines();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * deal area saturation damage to the map, used for artillery<br/>
     * @param centre         The hex on which damage is centred<br/>
     * @param attackSource   The position the attack came from<br/>
     * @param ammo           The ammo type doing the damage<br/>
     * @param subjectId      Subject for reports<br/>
     * @param killer         Who should be credited with kills<br/>
     * @param flak           Flak, hits flying units only, instead of flyers being immune<br/>
     * @param altitude       Absolute altitude for flak attack<br/>
     */<br/>
    void artilleryDamageArea(Coords centre, Coords attackSource, AmmoType ammo, int subjectId, Entity killer, boolean flak, int altitude) {<br/>
        int damage; <br/>
        int falloff=5;<br/>
        if(ammo.getMunitionType() == AmmoType.M_FLECHETTE) {<br/>
            damage = ammo.getRackSize() + 10;<br/>
        } <br/>
        else if(ammo.getMunitionType() == AmmoType.M_CLUSTER) {<br/>
            if(ammo.getAmmoType() == AmmoType.T_SNIPER)<br/>
                damage = 15;<br/>
            else<br/>
                damage = ammo.getRackSize();<br/>
            attackSource = centre;<br/>
        }<br/>
        else if(game.getOptions().booleanOption("maxtech_artillery")) {<br/>
            //"standard" mutates into high explosive<br/>
            if(ammo.getAmmoType() == AmmoType.T_LONG_TOM)<br/>
                damage = 25;<br/>
            else<br/>
                damage = ammo.getRackSize() + 10;<br/>
            falloff = 10;<br/>
        }<br/>
        else {<br/>
            //level 2 ammo<br/>
            damage = ammo.getRackSize();<br/>
            falloff = (damage + 1) / 2;<br/>
        }<br/>
        artilleryDamageArea(centre, attackSource, ammo, subjectId, killer, damage, falloff, flak, altitude);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Deals area-saturation damage to an area of the board.<br/>
     * Used for artillery, bombs, or anything else with linear decreas in damage<br/>
     * @param centre         The hex on which damage is centred<br/>
     * @param attackSource   The position the attack came from<br/>
     * @param ammo           The ammo type doing the damage<br/>
     * @param subjectId      Subject for reports<br/>
     * @param killer         Who should be credited with kills<br/>
     * @param damage         Damage at ground zero<br/>
     * @param falloff        Reduction in damage for each hex of distance<br/>
     * @param flak           Flak, hits flying units only, instead of flyers being immune<br/>
     * @param altitude       Absolute altitude for flak attack<br/>
     */<br/>
    void artilleryDamageArea(Coords centre, Coords attackSource, AmmoType ammo, int subjectId, Entity killer, int damage, int falloff, boolean flak, int altitude) {<br/>
        for(int ring=0;damage &gt; 0;ring++,damage-=falloff) {<br/>
            ArrayList&lt;Coords&gt; hexes = Compute.coordsAtRange(centre, ring);<br/>
            for(Coords c : hexes) {<br/>
                artilleryDamageHex(c, attackSource, damage, ammo, subjectId, killer, null, flak, altitude);<br/>
            }<br/>
            attackSource = centre; // all splash comes from ground zero<br/>
        }<br/>
    }<br/>
}<br/>
<br/>
</div>
</div>
</div>
<div class="right">
<h1>right_Server_1.926.java</h1>
<div class="code">
<div class="id">
/*<br/>
 * MegaMek -<br/>
 * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)<br/>
 *<br/>
 *  This program is free software; you can redistribute it and/or modify it<br/>
 *  under the terms of the GNU General Public License as published by the Free<br/>
 *  Software Foundation; either version 2 of the License, or (at your option)<br/>
 *  any later version.<br/>
 *<br/>
 *  This program is distributed in the hope that it will be useful, but<br/>
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<br/>
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License<br/>
 *  for more details.<br/>
 */<br/>
<br/>
package megamek.server;<br/>
<br/>
import java.io.File;<br/>
import java.io.FileInputStream;<br/>
import java.io.FileOutputStream;<br/>
import java.io.IOException;<br/>
import java.io.ObjectInputStream;<br/>
import java.io.ObjectOutputStream;<br/>
import java.net.InetAddress;<br/>
import java.net.ServerSocket;<br/>
import java.net.Socket;<br/>
import java.net.UnknownHostException;<br/>
import java.text.SimpleDateFormat;<br/>
import java.util.ArrayList;<br/>
import java.util.Collections;<br/>
import java.util.Comparator;<br/>
import java.util.Date;<br/>
import java.util.Enumeration;<br/>
import java.util.Hashtable;<br/>
import java.util.Iterator;<br/>
import java.util.StringTokenizer;<br/>
import java.util.Vector;<br/>
<br/>
import megamek.*;<br/>
import megamek.common.*;<br/>
import megamek.common.actions.*;<br/>
import megamek.server.commands.*;<br/>
import megamek.common.net.*;<br/>
import megamek.common.options.*;<br/>
import megamek.common.util.BoardUtilities;<br/>
import megamek.common.util.StringUtil;<br/>
import megamek.common.verifier.EntityVerifier;<br/>
import megamek.common.verifier.TestEntity;<br/>
import megamek.common.verifier.TestMech;<br/>
import megamek.common.verifier.TestTank;<br/>
import megamek.common.TagInfo;<br/>
import megamek.common.preference.PreferenceManager;<br/>
<br/>
/**<br/>
 * @author Ben Mazur<br/>
 */<br/>
public class Server implements Runnable {<br/>
    //    public final static String  LEGAL_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-";<br/>
    public final static String  DEFAULT_BOARD = MapSettings.BOARD_SURPRISE;<br/>
    private final static String VERIFIER_CONFIG_FILENAME =<br/>
        "data/mechfiles/UnitVerifierOptions.xml";<br/>
<br/>
    // server setup<br/>
    private String              password;<br/>
    private ServerSocket        serverSocket;<br/>
    private String              motd;<br/>
<br/>
    // game info<br/>
    private Vector              connections = new Vector(4);<br/>
    private Vector              connectionsPending = new Vector(4);<br/>
    private Hashtable           connectionIds = new Hashtable();<br/>
<br/>
    private int                 connectionCounter = 0;<br/>
    private int                 entityCounter = 0;<br/>
<br/>
    private IGame               game = new Game();<br/>
<br/>
    private Vector              vPhaseReport = new Vector();<br/>
<br/>
    private MapSettings         mapSettings = new MapSettings();<br/>
<br/>
    // commands<br/>
    private Hashtable           commandsHash = new Hashtable();<br/>
<br/>
    // listens for and connects players<br/>
    private Thread              connector;<br/>
<br/>
    // Track buildings that are affected by an entity's movement.<br/>
    private Hashtable           affectedBldgs = new Hashtable();<br/>
<br/>
    // Track Physical Action results, HACK to deal with opposing pushes <br/>
    // canceling each other<br/>
    private Vector              physicalResults = new Vector();<br/>
    <br/>
    private Vector&lt;DynamicTerrainProcessor&gt; terrainProcessors = new Vector();<br/>
    <br/>
    /* Tracks entities which have been destroyed recently.  Allows refactoring of the<br/>
     * damage and kill logic from Server, where it is now, to the Entity subclasses eventually.  <br/>
     * This has not been implemented yet -- I am just starting to build the groundwork into Server.<br/>
     * It isn't in the execution path and shouldn't cause any bugs */<br/>
    //Note from another coder - I have commented out your groundwork<br/>
    //for now because it is using HashSet, which isn't available in<br/>
    //Java 1.1 unless you import the collections classes.  Since the<br/>
    //Server class isn't using any other collecitons classes, there<br/>
    //might be a reason we're avoiding them here...if not, feel free<br/>
    //to add the import.<br/>
    //private HashSet             knownDeadEntities = new HashSet();<br/>
<br/>
    private static EntityVerifier entityVerifier = null;<br/>
<br/>
    private ConnectionListenerAdapter connectionListener = new ConnectionListenerAdapter() {<br/>
<br/>
        /**<br/>
         * Called when it is sensed that a connection has terminated.<br/>
         */<br/>
        public void disconnected(DisconnectedEvent e) {<br/>
            Connection conn = e.getConnection();<br/>
            <br/>
            // write something in the log<br/>
            System.out.println("s: connection " + conn.getId()+ " disconnected");<br/>
<br/>
            connections.removeElement(conn);<br/>
            connectionsPending.removeElement(conn);<br/>
            connectionIds.remove(new Integer(conn.getId()));<br/>
<br/>
            // if there's a player for this connection, remove it too<br/>
            Player player = getPlayer(conn.getId());<br/>
            if (null != player) {<br/>
                Server.this.disconnected( player );<br/>
            }<br/>
            <br/>
        }<br/>
<br/>
        public void packetReceived(PacketReceivedEvent e) {<br/>
            Server.this.handle(e.getConnection().getId(),e.getPacket());<br/>
        }<br/>
<br/>
    };<br/>
    <br/>
    /**<br/>
     * Construct a new GameHost and begin listening for<br/>
     * incoming clients.<br/>
     * @param   password the &lt;code&gt;String&lt;/code&gt; that is set as a password<br/>
     * @param   port the &lt;code&gt;int&lt;/code&gt; value that specifies the port that<br/>
     *          is used<br/>
     */<br/>
    public Server(String password, int port) {<br/>
        this.password = password.length() &gt; 0 ? password : null;<br/>
        // initialize server socket<br/>
        try {<br/>
            serverSocket = new ServerSocket(port);<br/>
        } catch(IOException ex) {<br/>
            System.err.println("could not create server socket on port "+port);<br/>
        }<br/>
<br/>
        motd = createMotd();<br/>
<br/>
        game.getOptions().initialize();<br/>
<br/>
        changePhase(IGame.PHASE_LOUNGE);<br/>
<br/>
        // display server start text<br/>
        System.out.println("s: starting a new server...");<br/>
<br/>
        try {<br/>
            String host = InetAddress.getLocalHost().getHostName();<br/>
            System.out.print("s: hostname = '" );<br/>
            System.out.print( host );<br/>
            System.out.print( "' port = " );<br/>
            System.out.println( serverSocket.getLocalPort() );<br/>
            InetAddress[] addresses = InetAddress.getAllByName(host);<br/>
            for (int i = 0; i &lt; addresses.length; i++) {<br/>
                System.out.println("s: hosting on address = "<br/>
                                   + addresses[i].getHostAddress());<br/>
            }<br/>
        } catch (UnknownHostException  e) {<br/>
            // oh well.<br/>
        }<br/>
<br/>
        System.out.println("s: password = " + this.password);<br/>
<br/>
        connector = new Thread(this, "Connection Listener");<br/>
        connector.start();<br/>
<br/>
        // register commands<br/>
        registerCommand(new DefeatCommand(this));<br/>
        registerCommand(new HelpCommand(this));<br/>
        registerCommand(new KickCommand(this));<br/>
        registerCommand(new ResetCommand(this));<br/>
        registerCommand(new RollCommand(this));<br/>
        registerCommand(new SaveGameCommand(this));<br/>
        registerCommand(new SkipCommand(this));<br/>
        registerCommand(new VictoryCommand(this));<br/>
        registerCommand(new WhoCommand(this));<br/>
        registerCommand(new SeeAllCommand(this));<br/>
        registerCommand(new LocalSaveGameCommand(this));<br/>
        registerCommand(new FixElevationCommand(this));<br/>
        <br/>
        //register terrain processors<br/>
        terrainProcessors.add(new FireProcessor(this));<br/>
        terrainProcessors.add(new GeyserProcessor(this));<br/>
        terrainProcessors.add(new ElevatorProcessor(this));<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets the game for this server.  Restores any transient fields, and sets<br/>
     * all players as ghosts.<br/>
     * This should only be called during server initialization before any<br/>
     * players have connected.<br/>
     */<br/>
    public void setGame(IGame g) {<br/>
        this.game = g;<br/>
<br/>
        // reattach the transient fields and ghost the players<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements(); ) {<br/>
            Entity ent = (Entity)e.nextElement();<br/>
            ent.setGame(game);<br/>
        }<br/>
        game.setOutOfGameEntitiesVector(game.getOutOfGameEntitiesVector());<br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements(); ) {<br/>
            Player p = (Player)e.nextElement();<br/>
            p.setGame(game);<br/>
            p.setGhost(true);<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /** Returns the current game object */<br/>
    public IGame getGame() {<br/>
        return game;<br/>
    }<br/>
<br/>
    /**<br/>
     * Make a default message o' the day containing the version string, and<br/>
     * if it was found, the build timestamp<br/>
     */<br/>
    private String createMotd() {<br/>
        StringBuffer buf = new StringBuffer();<br/>
        buf.append("Welcome to MegaMek.  Server is running version ");<br/>
        buf.append(MegaMek.VERSION);<br/>
        buf.append(", build date ");<br/>
        if (MegaMek.TIMESTAMP &gt; 0L) {<br/>
            buf.append(new Date(MegaMek.TIMESTAMP).toString());<br/>
        } else {<br/>
            buf.append("unknown");<br/>
        }<br/>
        buf.append(".");<br/>
<br/>
        return buf.toString();<br/>
    }<br/>
<br/>
    /**<br/>
     * @return true if the server has a password<br/>
     */<br/>
    public boolean isPassworded() {<br/>
        return password != null;<br/>
    }<br/>
<br/>
    /**<br/>
     * @return true if the password matches<br/>
     */<br/>
    public boolean isPassword(Object guess) {<br/>
        return password.equals(guess);<br/>
    }<br/>
<br/>
    /**<br/>
     * Registers a new command in the server command table<br/>
     */<br/>
    private void registerCommand(ServerCommand command) {<br/>
        commandsHash.put(command.getName(), command);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the command associated with the specified name<br/>
     */<br/>
    public ServerCommand getCommand(String name) {<br/>
        return (ServerCommand)commandsHash.get(name);<br/>
    }<br/>
<br/>
    /**<br/>
     * Shuts down the server.<br/>
     */<br/>
    public void die() {<br/>
        // kill thread accepting new connections<br/>
        connector = null;<br/>
<br/>
        // close socket<br/>
        try {<br/>
            serverSocket.close();<br/>
        } catch(IOException ex) {}<br/>
<br/>
        // kill pending connnections<br/>
        for (Enumeration i=connectionsPending.elements();i.hasMoreElements();){<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.close();<br/>
        }<br/>
        connectionsPending.removeAllElements();<br/>
<br/>
        // Send "kill" commands to all connections<br/>
        // N.B. I may be starting a race here.<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            send(conn.getId(), new Packet(Packet.COMMAND_CLOSE_CONNECTION));<br/>
        }<br/>
<br/>
        // kill active connnections<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.close();<br/>
        }<br/>
        connections.removeAllElements();<br/>
        connectionIds.clear();<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns an enumeration of all the command names<br/>
     */<br/>
    public Enumeration getAllCommandNames() {<br/>
        return commandsHash.keys();<br/>
    }<br/>
<br/>
    /**<br/>
     * Sent when a client attempts to connect.<br/>
     */<br/>
    private void greeting(int cn) {<br/>
        // send server greeting -- client should reply with client info.<br/>
        sendToPending(cn, new Packet(Packet.COMMAND_SERVER_GREETING));<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a free connection id.<br/>
     */<br/>
    public int getFreeConnectionId() {<br/>
        while (getPendingConnection(connectionCounter) != null<br/>
        || getConnection(connectionCounter) != null<br/>
        || getPlayer(connectionCounter) != null) {<br/>
            connectionCounter++;<br/>
        }<br/>
        return connectionCounter;<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a free entity id.  Perhaps this should be in Game instead.<br/>
     */<br/>
    public int getFreeEntityId() {<br/>
        return game.getNextEntityId();<br/>
    }<br/>
<br/>
    /**<br/>
     * Allow the player to set whatever parameters he is able to<br/>
     */<br/>
    private void receivePlayerInfo(Packet packet, int connId) {<br/>
        Player player = (Player)packet.getObject(0);<br/>
        Player connPlayer = game.getPlayer( connId );<br/>
        if ( null != connPlayer ) {<br/>
            connPlayer.setColorIndex(player.getColorIndex());<br/>
            connPlayer.setStartingPos(player.getStartingPos());<br/>
            connPlayer.setTeam(player.getTeam());<br/>
            connPlayer.setCamoCategory(player.getCamoCategory());<br/>
            connPlayer.setCamoFileName(player.getCamoFileName());<br/>
            connPlayer.setNbrMFConventional(player.getNbrMFConventional());<br/>
            connPlayer.setNbrMFCommand(player.getNbrMFCommand());<br/>
            connPlayer.setNbrMFVibra(player.getNbrMFVibra());<br/>
        }<br/>
    }<br/>
<br/>
    private String correctDupeName(String oldName) {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            Player player = (Player)i.nextElement();<br/>
            if (player.getName().equals(oldName)) {<br/>
                // We need to correct it.<br/>
                String newName = oldName;<br/>
                int dupNum = 2;<br/>
                try {<br/>
                    dupNum = Integer.parseInt(oldName.substring(oldName.lastIndexOf(".")+1));<br/>
                    dupNum++;<br/>
                    newName = oldName.substring(0,oldName.lastIndexOf("."));<br/>
                } catch (Exception e) {<br/>
                    // If this fails, we don't care much.<br/>
                    // Just assume it's the first time for this name.<br/>
                    dupNum = 2;<br/>
                }<br/>
                newName = newName.concat(".").concat(Integer.toString(dupNum));<br/>
                return correctDupeName(newName);<br/>
            }<br/>
        }<br/>
        return oldName;<br/>
    }<br/>
<br/>
    /**<br/>
     * Recieves a player name, sent from a pending connection, and connects<br/>
     * that connection.<br/>
     */<br/>
    private void receivePlayerName(Packet packet, int connId) {<br/>
        final Connection conn = getPendingConnection(connId);<br/>
        String name = (String)packet.getObject(0);<br/>
        boolean returning = false;<br/>
<br/>
        // this had better be from a pending connection<br/>
        if (conn == null) {<br/>
            System.out.println("server: got a client name from a non-pending" +<br/>
                               " connection");<br/>
            return;<br/>
        }<br/>
<br/>
        // check if they're connecting with the same name as a ghost player<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            Player player = (Player)i.nextElement();<br/>
            if (player.getName().equals(name)) {<br/>
                if (player.isGhost()) {<br/>
                    returning = true;<br/>
                    player.setGhost(false);<br/>
                    // switch id<br/>
                    connId = player.getId();<br/>
                    conn.setId(connId);<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        if (!returning) {<br/>
            // Check to avoid duplicate names...<br/>
            name = correctDupeName(name);<br/>
            send(connId, new Packet(Packet.COMMAND_SERVER_CORRECT_NAME, name));<br/>
        }<br/>
<br/>
        // right, switch the connection into the "active" bin<br/>
        connectionsPending.removeElement(conn);<br/>
        connections.addElement(conn);<br/>
        connectionIds.put(new Integer(conn.getId()), conn);<br/>
<br/>
        // add and validate the player info<br/>
        if (!returning) {<br/>
            game.addPlayer(connId, new Player(connId, name));<br/>
            validatePlayerInfo(connId);<br/>
        }<br/>
<br/>
        // if it is not the lounge phase, this player becomes an observer<br/>
        Player player = getPlayer( connId );<br/>
        if ( game.getPhase() != IGame.PHASE_LOUNGE<br/>
             &amp;&amp; null != player<br/>
             &amp;&amp; game.getEntitiesOwnedBy(player) &lt; 1) {<br/>
            player.setObserver(true);<br/>
        }<br/>
<br/>
        // send the player the motd<br/>
        sendServerChat(connId, motd);<br/>
<br/>
        // send info that the player has connected<br/>
        send(createPlayerConnectPacket(connId));<br/>
<br/>
        // tell them their local playerId<br/>
        send(connId, new Packet(Packet.COMMAND_LOCAL_PN, new Integer(connId)));<br/>
<br/>
        // send current game info<br/>
        sendCurrentInfo(connId);<br/>
<br/>
        try {<br/>
            InetAddress[] addresses = InetAddress.getAllByName(InetAddress<br/>
                                                               .getLocalHost()<br/>
                                                               .getHostName());<br/>
            for (int i = 0; i &lt; addresses.length; i++) {<br/>
                sendServerChat(connId, "Machine IP is " +<br/>
                               addresses[i].getHostAddress());<br/>
            }<br/>
        } catch (UnknownHostException  e) {<br/>
            // oh well.<br/>
        }<br/>
<br/>
        // Send the port we're listening on. Only useful for the player<br/>
        // on the server machine to check.<br/>
        sendServerChat(connId, "Listening on port " + serverSocket<br/>
                                                      .getLocalPort());<br/>
<br/>
        // Get the player *again*, because they may have disconnected.<br/>
        player = getPlayer( connId );<br/>
        if ( null != player ) {<br/>
            StringBuffer buff = new StringBuffer();<br/>
            buff.append( player.getName() )<br/>
                .append( " connected from " )<br/>
                .append( getClient(connId).getInetAddress() );<br/>
            String who = buff.toString();<br/>
            System.out.print( "s: player #" );<br/>
            System.out.print( connId );<br/>
            System.out.print( ", " );<br/>
            System.out.println( who );<br/>
<br/>
            sendServerChat( who );<br/>
<br/>
        } // Found the player<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends a player the info they need to look at the current phase.<br/>
     * This is triggered when a player first connects to the server.<br/>
     */<br/>
    private void sendCurrentInfo(int connId) {<br/>
        //why are these two outside the player != null check below?<br/>
        transmitAllPlayerConnects(connId);<br/>
        send(connId, createGameSettingsPacket());<br/>
<br/>
        Player player = game.getPlayer(connId);<br/>
        if ( null != player ) {<br/>
            send(connId, new Packet(Packet.COMMAND_SENDING_MINEFIELDS,<br/>
                                    player.getMinefields()));<br/>
<br/>
            switch (game.getPhase()) {<br/>
            case IGame.PHASE_LOUNGE :<br/>
                send(connId, createMapSettingsPacket());<br/>
                // Send Entities *after* the Lounge Phase Change<br/>
                send(connId, new Packet(Packet.COMMAND_PHASE_CHANGE,<br/>
                                        new Integer(game.getPhase())));<br/>
                if (doBlind()) {<br/>
                    send(connId, createFilteredFullEntitiesPacket(player));<br/>
                }<br/>
                else {<br/>
                    send(connId, createFullEntitiesPacket());<br/>
                }<br/>
                break;<br/>
            default :<br/>
                send(connId, new Packet(Packet.COMMAND_ROUND_UPDATE, new Integer(game.getRoundCount())));<br/>
                //send(connId, createReportPacket(player));<br/>
                send(connId, createAllReportsPacket(player));<br/>
<br/>
                // Send Entites *before* other phase changes.<br/>
                if (doBlind()) {<br/>
                    send(connId, createFilteredFullEntitiesPacket(player));<br/>
                }<br/>
                else {<br/>
                    send(connId, createFullEntitiesPacket());<br/>
                }<br/>
                player.setDone( game.getEntitiesOwnedBy(player) &lt;= 0 );<br/>
                send(connId, createBoardPacket());<br/>
                send(connId, new Packet(Packet.COMMAND_PHASE_CHANGE,<br/>
                                        new Integer(game.getPhase())));<br/>
                break;<br/>
            }<br/>
            if (game.getPhase() == IGame.PHASE_FIRING ||<br/>
                game.getPhase() == IGame.PHASE_TARGETING ||<br/>
                game.getPhase() == IGame.PHASE_OFFBOARD ||<br/>
                game.getPhase() == IGame.PHASE_PHYSICAL) {<br/>
                // can't go above, need board to have been sent<br/>
                send(connId,createAttackPacket(game.getActionsVector(),0));<br/>
                send(connId,createAttackPacket(game.getChargesVector(),1));<br/>
                send(connId,createAttackPacket(game.getLayMinefieldActionsVector(),2));<br/>
            }<br/>
            if (game.phaseHasTurns(game.getPhase())) {<br/>
                send(connId, createTurnVectorPacket());<br/>
                send(connId, createTurnIndexPacket());<br/>
            }<br/>
            <br/>
            send(connId, createArtilleryPacket(player));<br/>
            send(connId, createFlarePacket());<br/>
<br/>
        } // Found the player.<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Validates the player info.<br/>
     */<br/>
    public void validatePlayerInfo(int playerId) {<br/>
        final Player player = getPlayer(playerId);<br/>
<br/>
        //        maybe this isn't actually useful<br/>
        //        // replace characters we don't like with "X"<br/>
        //        StringBuffer nameBuff = new StringBuffer(player.getName());<br/>
        //        for (int i = 0; i &lt; nameBuff.length(); i++) {<br/>
        //            int chr = nameBuff.charAt(i);<br/>
        //            if (LEGAL_CHARS.indexOf(chr) == -1) {<br/>
        //                nameBuff.setCharAt(i, 'X');<br/>
        //            }<br/>
        //        }<br/>
        //        player.setName(nameBuff.toString());<br/>
<br/>
        //TODO: check for duplicate or reserved names<br/>
<br/>
        // make sure colorIndex is unique<br/>
        boolean[] colorUsed = new boolean[Player.colorNames.length];<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player otherPlayer = (Player)i.nextElement();<br/>
            if (otherPlayer.getId() != playerId) {<br/>
                colorUsed[otherPlayer.getColorIndex()] = true;<br/>
            }<br/>
        }<br/>
        if (null != player &amp;&amp; colorUsed[player.getColorIndex()]) {<br/>
            // find a replacement color;<br/>
            for (int i = 0; i &lt; colorUsed.length; i++) {<br/>
                if (!colorUsed[i]) {<br/>
                    player.setColorIndex(i);<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Called when it's been determined that an actual player<br/>
     * disconnected.  Notifies the other players and does the appropriate<br/>
     * housekeeping.<br/>
     */<br/>
    void disconnected(Player player) {<br/>
        int phase = game.getPhase();<br/>
<br/>
        // in the lounge, just remove all entities for that player<br/>
        if (phase == IGame.PHASE_LOUNGE) {<br/>
            removeAllEntitesOwnedBy(player);<br/>
        }<br/>
<br/>
        // if a player has active entities, he becomes a ghost<br/>
        // except the VICTORY_PHASE when the dosconnected <br/>
        // player is most likely the Bot disconnected after receiving<br/>
        // the COMMAND_END_OF_GAME command <br/>
        // see the Bug 1225949.<br/>
        // TODO Perhaps there is a better solution to handle the Bot disconnect<br/>
        if (game.getEntitiesOwnedBy(player) &gt; 0 &amp;&amp; phase != IGame.PHASE_VICTORY) {<br/>
            player.setGhost(true);<br/>
            player.setDone(true);<br/>
            send(createPlayerUpdatePacket(player.getId()));<br/>
        } else {<br/>
            game.removePlayer(player.getId());<br/>
            send(new Packet(Packet.COMMAND_PLAYER_REMOVE,<br/>
                 new Integer(player.getId())));<br/>
        }<br/>
<br/>
        // make sure the game advances<br/>
        if ( game.phaseHasTurns(game.getPhase()) &amp;&amp; null != game.getTurn() ) {<br/>
            if ( game.getTurn().isValid( player.getId(), game ) ) {<br/>
                sendGhostSkipMessage( player );<br/>
            }<br/>
        } else {<br/>
            checkReady();<br/>
        }<br/>
<br/>
        // notify other players<br/>
        sendServerChat(player.getName() + " disconnected.");<br/>
<br/>
        // log it<br/>
        System.out.println("s: removed player " + player.getName());<br/>
<br/>
        // Reset the game after Elvis has left the building.<br/>
        if ( 0 == game.getNoOfPlayers() ) {<br/>
            resetGame();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks each player to see if he has no entities, and if true, sets the<br/>
     * observer flag for that player.  An exception is that there are no<br/>
     * observers during the lounge phase.<br/>
     */<br/>
    public void checkForObservers() {<br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements(); ) {<br/>
            Player p = (Player)e.nextElement();<br/>
            p.setObserver(game.getEntitiesOwnedBy(p) &lt; 1 &amp;&amp;<br/>
                          game.getPhase() != IGame.PHASE_LOUNGE);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Reset the game back to the lounge.<br/>
     *<br/>
     * TODO: couldn't this be a hazard if there are other things executing at<br/>
     *  the same time?<br/>
     */<br/>
    public void resetGame() {<br/>
        // remove all entities<br/>
        game.reset();<br/>
        send(createEntitiesPacket());<br/>
        send(new Packet(Packet.COMMAND_SENDING_MINEFIELDS, new Vector()));<br/>
<br/>
        //TODO: remove ghosts<br/>
<br/>
        // reset all players<br/>
        resetPlayersDone();<br/>
        transmitAllPlayerDones();<br/>
<br/>
        // Write end of game to stdout so controlling scripts can rotate logs.<br/>
        SimpleDateFormat format = new SimpleDateFormat<br/>
            ( "yyyy-MM-dd HH:mm:ss z" );<br/>
        System.out.print( format.format(new Date()) );<br/>
        System.out.println( " END OF GAME" );<br/>
<br/>
        changePhase(IGame.PHASE_LOUNGE);<br/>
    }<br/>
<br/>
    <br/>
    /**<br/>
     * automatically save the game <br/>
     */<br/>
    public void autoSave() {<br/>
        String fileName = "autosave";<br/>
        if (PreferenceManager.getClientPreferences().stampFilenames()) {<br/>
            fileName = StringUtil.addDateTimeStamp(fileName);<br/>
        }<br/>
        saveGame(fileName,game.getOptions().booleanOption("autosave_msg"));<br/>
    }<br/>
<br/>
    /**<br/>
     * save the game and send it to the sepecified connection<br/>
     * @param connId The &lt;code&gt;int&lt;/code&gt; connection id to send to<br/>
     * @param sFile  The &lt;code&gt;String&lt;/code&gt; filename to use<br/>
     */<br/>
    public void sendSaveGame (int connId, String sFile) {<br/>
        saveGame(sFile, false);<br/>
        String sFinalFile = sFile;<br/>
        if (!sFinalFile.endsWith(".sav")) {<br/>
            sFinalFile = sFile + ".sav";<br/>
        }<br/>
        sFinalFile = "savegames" + File.separator + sFinalFile;<br/>
        File f = new File(sFinalFile);<br/>
        try {<br/>
            ObjectInputStream ois = new ObjectInputStream(<br/>
                new FileInputStream(f));<br/>
            send(connId,new Packet(Packet.COMMAND_SEND_SAVEGAME, new Object[] {sFinalFile, ois.readObject()}));<br/>
            sendChat(connId,"***Server","Savegame has been sent to you.");<br/>
            ois.close();<br/>
        } catch (Exception e) {<br/>
            System.err.println("Unable to load file: " + f);<br/>
            e.printStackTrace();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * save the game<br/>
     * @param sFile   The &lt;code&gt;String&lt;/code&gt; filename to use<br/>
     * @param sendChat A &lt;code&gt;boolean&lt;/code&gt; value wether or not to announce<br/>
     *                 the saving to the server chat. <br/>
     */<br/>
    public void saveGame(String sFile, boolean sendChat) {<br/>
        String sFinalFile = sFile;<br/>
        if (!sFinalFile.endsWith(".sav")) {<br/>
            sFinalFile = sFile + ".sav";<br/>
        }<br/>
        try {<br/>
            File sDir = new File("savegames");<br/>
            if (!sDir.exists()) {<br/>
                sDir.mkdir();<br/>
            }<br/>
            sFinalFile = sDir + File.separator + sFinalFile;<br/>
            ObjectOutputStream oos = new ObjectOutputStream(<br/>
                    new FileOutputStream(sFinalFile));<br/>
            oos.writeObject(game);<br/>
            oos.flush();<br/>
            oos.close();<br/>
        } catch (Exception e) {<br/>
            System.err.println("Unable to save file: " + sFinalFile);<br/>
            e.printStackTrace();<br/>
        }<br/>
<br/>
        if (sendChat) sendChat("MegaMek", "Game saved to " + sFinalFile);<br/>
    }<br/>
<br/>
    /**<br/>
     * save the game<br/>
     * @param sFile   The &lt;code&gt;String&lt;/code&gt; filename to use<br/>
     */<br/>
    public void saveGame(String sFile) {<br/>
        saveGame(sFile,true);<br/>
    }<br/>
<br/>
    /**<br/>
     * load the game<br/>
     * @param f The &lt;code&gt;File&lt;/code&gt; to load<br/>
     * @return A &lt;code&gt;boolean&lt;/code&gt; value wether or not the loading was successfull<br/>
     */<br/>
    public boolean loadGame(File f) {<br/>
        System.out.println("s: loading saved game file '"+f+"'");<br/>
        try {<br/>
            ObjectInputStream ois = new ObjectInputStream(<br/>
                    new FileInputStream(f));<br/>
            game = (IGame)ois.readObject();<br/>
            ois.close();<br/>
        } catch (Exception e) {<br/>
            System.err.println("Unable to load file: " + f);<br/>
            e.printStackTrace();<br/>
            return false;<br/>
        }<br/>
<br/>
        // a bit redundant, but there's some initialization code there<br/>
        setGame(game);<br/>
<br/>
        return true;<br/>
    }<br/>
<br/>
    /**<br/>
     * Shortcut to game.getPlayer(id)<br/>
     */<br/>
    public Player getPlayer(int id) {<br/>
        return game.getPlayer(id);<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes all entities owned by a player.  Should only be called when it<br/>
     * won't cause trouble (the lounge, for instance, or between phases.)<br/>
     * @param the &lt;code&gt;Player&lt;/code&gt; whose entites are to be removed<br/>
     */<br/>
    private void removeAllEntitesOwnedBy(Player player) {<br/>
        Vector toRemove = new Vector();<br/>
<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            if (entity.getOwner().equals(player)) {<br/>
                toRemove.addElement(entity);<br/>
            }<br/>
        }<br/>
<br/>
        for (Enumeration e = toRemove.elements(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            int id = entity.getId();<br/>
            game.removeEntity(id, IEntityRemovalConditions.REMOVE_NEVER_JOINED);<br/>
            send(createRemoveEntityPacket(id, IEntityRemovalConditions.REMOVE_NEVER_JOINED));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * a shorter name for getConnection()<br/>
     */<br/>
    private Connection getClient(int connId) {<br/>
        return getConnection(connId);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a connection, indexed by id<br/>
     */<br/>
    public Enumeration getConnections() {<br/>
        return connections.elements();<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a connection, indexed by id<br/>
     */<br/>
    public Connection getConnection(int connId) {<br/>
        return (Connection)connectionIds.get(new Integer(connId));<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a pending connection<br/>
     */<br/>
    private Connection getPendingConnection(int connId) {<br/>
        for (Enumeration i=connectionsPending.elements();i.hasMoreElements();){<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
<br/>
            if (conn.getId() == connId) {<br/>
                return conn;<br/>
            }<br/>
        }<br/>
        return null;<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of each game round to reset values on this<br/>
     * entity that are reset every round<br/>
     */<br/>
    private void resetEntityRound() {<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            Entity entity = (Entity)e.nextElement();<br/>
<br/>
            entity.newRound(game.getRoundCount());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of each phase.  Sets and resets<br/>
     * any entity parameters that need to be reset.<br/>
     */<br/>
    private void resetEntityPhase(int phase) {<br/>
        // first, mark doomed entities as destroyed and flag them<br/>
        Vector toRemove = new Vector(0, 10);<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            if (entity.crew.isDoomed()) {<br/>
                entity.crew.setDead(true);<br/>
                entity.setDestroyed(true);<br/>
            }<br/>
<br/>
            if (entity.isDoomed()) {<br/>
                entity.setDestroyed(true);<br/>
<br/>
                // Is this unit swarming somebody?  Better let go before<br/>
                //  it's too late.<br/>
                final int swarmedId = entity.getSwarmTargetId();<br/>
                if ( Entity.NONE != swarmedId ) {<br/>
                    final Entity swarmed = game.getEntity( swarmedId );<br/>
                    swarmed.setSwarmAttackerId( Entity.NONE );<br/>
                    entity.setSwarmTargetId( Entity.NONE );<br/>
                    Report r = new Report(5165);<br/>
                    r.subject = swarmedId;<br/>
                    r.addDesc(swarmed);<br/>
                    addReport(r);<br/>
                    this.entityUpdate( swarmedId );<br/>
                }<br/>
            }<br/>
<br/>
            if (entity.isDestroyed() || entity.getCrew().isDead()) {<br/>
                toRemove.addElement(entity);<br/>
            }<br/>
        }<br/>
<br/>
        // actually remove all flagged entities<br/>
        for (Enumeration e = toRemove.elements(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
            int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;<br/>
            if ( !entity.isSalvage() ) {<br/>
                condition = IEntityRemovalConditions.REMOVE_DEVASTATED;<br/>
            }<br/>
<br/>
            this.entityUpdate(entity.getId());<br/>
            game.removeEntity(entity.getId(), condition);<br/>
            send( createRemoveEntityPacket(entity.getId(), condition) );<br/>
        }<br/>
<br/>
        // do some housekeeping on all the remaining<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            final Entity entity = (Entity)e.nextElement();<br/>
<br/>
            entity.applyDamage();<br/>
<br/>
            entity.reloadEmptyWeapons();<br/>
<br/>
            // reset damage this phase<br/>
            entity.damageThisPhase = 0;<br/>
            entity.engineHitsThisRound = 0;<br/>
            entity.rolledForEngineExplosion = false;<br/>
            entity.dodging = false;<br/>
<br/>
            // reset done to false<br/>
<br/>
            if ( phase == IGame.PHASE_DEPLOYMENT ) {<br/>
                entity.setDone(!entity.shouldDeploy(game.getRoundCount()));<br/>
            } else {<br/>
                entity.setDone(false);<br/>
            }<br/>
            <br/>
            // reset spotlights<br/>
            entity.setIlluminated(false);<br/>
            entity.setUsedSearchlight(false);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every player not ready.<br/>
     */<br/>
    private void resetPlayersDone() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            player.setDone(false);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called at the beginning of certain phases to make<br/>
     * every active player not ready.<br/>
     */<br/>
    private void resetActivePlayersDone() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            player.setDone(game.getEntitiesOwnedBy(player) &lt;= 0);<br/>
<br/>
        }<br/>
        transmitAllPlayerDones();<br/>
    }<br/>
<br/>
    /**<br/>
     * Writes the victory report<br/>
     */<br/>
    private void prepareVictoryReport() {<br/>
        Report r;<br/>
<br/>
        addReport(new Report(7000, Report.PUBLIC));<br/>
<br/>
        //Declare the victor<br/>
        r = new Report(1210);<br/>
        r.type = Report.PUBLIC;<br/>
        if (game.getVictoryTeam() == Player.TEAM_NONE) {<br/>
            Player player = getPlayer( game.getVictoryPlayerId() );<br/>
            if ( null == player ) {<br/>
                r.messageId = 7005;<br/>
            } else {<br/>
                r.messageId = 7010;<br/>
                r.add(player.getName());<br/>
            }<br/>
        } else {<br/>
            //Team victory<br/>
            r.messageId = 7015;<br/>
            r.add(game.getVictoryTeam());<br/>
        }<br/>
        addReport(r);<br/>
<br/>
        //List the survivors<br/>
        Enumeration survivors = game.getEntities();<br/>
        if ( survivors.hasMoreElements() ) {<br/>
            addReport(new Report(7020, Report.PUBLIC));<br/>
            while ( survivors.hasMoreElements() ) {<br/>
                Entity entity = (Entity) survivors.nextElement();<br/>
<br/>
                if ( !entity.isDeployed() )<br/>
                  continue;<br/>
<br/>
                addReport( entity.victoryReport());<br/>
            }<br/>
        }<br/>
        //List units that never deployed<br/>
        Enumeration undeployed = game.getEntities();<br/>
        if ( undeployed.hasMoreElements() ) {<br/>
            boolean wroteHeader = false;<br/>
<br/>
            while ( undeployed.hasMoreElements() ) {<br/>
                Entity entity = (Entity) undeployed.nextElement();<br/>
<br/>
                if ( entity.isDeployed() )<br/>
                  continue;<br/>
<br/>
                if ( !wroteHeader ) {<br/>
                  addReport(new Report(7075, Report.PUBLIC));<br/>
                  wroteHeader = true;<br/>
                }<br/>
<br/>
                addReport( entity.victoryReport());<br/>
            }<br/>
        }<br/>
        //List units that retreated<br/>
        Enumeration retreat = game.getRetreatedEntities();<br/>
        if ( retreat.hasMoreElements() ) {<br/>
            addReport(new Report(7080, Report.PUBLIC));<br/>
            while ( retreat.hasMoreElements() ) {<br/>
                Entity entity = (Entity) retreat.nextElement();<br/>
                addReport( entity.victoryReport());<br/>
            }<br/>
        }<br/>
        //List destroyed units<br/>
        Enumeration graveyard = game.getGraveyardEntities();<br/>
        if ( graveyard.hasMoreElements() ) {<br/>
            addReport(new Report(7085, Report.PUBLIC));<br/>
            while ( graveyard.hasMoreElements() ) {<br/>
                Entity entity = (Entity) graveyard.nextElement();<br/>
                addReport( entity.victoryReport());<br/>
            }<br/>
        }<br/>
        //List devastated units (not salvagable)<br/>
        Enumeration devastated = game.getDevastatedEntities();<br/>
        if ( devastated.hasMoreElements() ) {<br/>
            addReport(new Report(7090, Report.PUBLIC));<br/>
<br/>
            while ( devastated.hasMoreElements() ) {<br/>
                Entity entity = (Entity) devastated.nextElement();<br/>
                addReport( entity.victoryReport());<br/>
            }<br/>
        }<br/>
        //Let player know about entitystatus.txt file<br/>
        addReport(new Report(7095, Report.PUBLIC));<br/>
    }<br/>
<br/>
    /**<br/>
     * Generates a detailed report for campaign use<br/>
     */<br/>
    private String getDetailedVictoryReport() {<br/>
        StringBuffer sb = new StringBuffer();<br/>
<br/>
        Vector vAllUnits = new Vector();<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
<br/>
        for ( Enumeration i = game.getRetreatedEntities();<br/>
              i.hasMoreElements(); ) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
<br/>
        for ( Enumeration i = game.getGraveyardEntities();<br/>
              i.hasMoreElements(); ) {<br/>
            vAllUnits.addElement(i.nextElement());<br/>
        }<br/>
<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
<br/>
            // Record the player.<br/>
            Player p = (Player)i.nextElement();<br/>
            sb.append("++++++++++ " )<br/>
                .append( p.getName() )<br/>
                .append( " ++++++++++");<br/>
            sb.append( CommonConstants.NL );<br/>
<br/>
            // Record the player's alive, retreated, or salvageable units.<br/>
            for (int x = 0; x &lt; vAllUnits.size(); x++) {<br/>
                Entity e = (Entity)vAllUnits.elementAt(x);<br/>
                if (e.getOwner() == p) {<br/>
                    sb.append(UnitStatusFormatter.format(e));<br/>
                }<br/>
            }<br/>
<br/>
            // Record the player's devastated units.<br/>
            Enumeration devastated = game.getDevastatedEntities();<br/>
            if ( devastated.hasMoreElements() ) {<br/>
                sb.append("=============================================================");<br/>
                sb.append( CommonConstants.NL );<br/>
                sb.append("The following utterly destroyed units are not available for salvage:");<br/>
                sb.append( CommonConstants.NL );<br/>
                while ( devastated.hasMoreElements() ) {<br/>
                    Entity e = (Entity) devastated.nextElement();<br/>
                    if (e.getOwner() == p) {<br/>
                        sb.append( e.getShortName() )<br/>
                            .append( ", Pilot: " )<br/>
                            .append( e.getCrew().getName() )<br/>
                            .append( " (" )<br/>
                            .append( e.getCrew().getGunnery() )<br/>
                            .append( "/" )<br/>
                            .append( e.getCrew().getPiloting() )<br/>
                            .append( ")" );<br/>
                        sb.append( CommonConstants.NL );<br/>
                    }<br/>
                } // Handle the next unsalvageable unit for the player<br/>
                sb.append("=============================================================");<br/>
                sb.append( CommonConstants.NL );<br/>
            }<br/>
<br/>
        } // Handle the next player<br/>
<br/>
        return sb.toString();<br/>
    }<br/>
<br/>
    /**<br/>
     * Forces victory for the specified player, or his/her team at the end of<br/>
     * the round.<br/>
     */<br/>
    public void forceVictory(Player victor) {<br/>
        game.setForceVictory(true);<br/>
        if (victor.getTeam() == Player.TEAM_NONE) {<br/>
            game.setVictoryPlayerId(victor.getId());<br/>
            game.setVictoryTeam(Player.TEAM_NONE);<br/>
        } else {<br/>
            game.setVictoryPlayerId(Player.PLAYER_NONE);<br/>
            game.setVictoryTeam(victor.getTeam());<br/>
        }<br/>
<br/>
        Vector players = game.getPlayersVector();<br/>
        for (int i = 0; i &lt; players.size(); i++) {<br/>
            Player player = (Player) players.elementAt(i);<br/>
            player.setAdmitsDefeat(false);<br/>
        }<br/>
    }<br/>
<br/>
    /** Cancels the force victory */<br/>
    public void cancelVictory() {<br/>
        game.setForceVictory(false);<br/>
        game.setVictoryPlayerId(Player.PLAYER_NONE);<br/>
        game.setVictoryTeam(Player.TEAM_NONE);<br/>
    }<br/>
<br/>
    /**<br/>
     * Called when a player declares that he is "done."  Checks to see if all<br/>
     * players are done, and if so, moves on to the next phase.<br/>
     */<br/>
    private void checkReady() {<br/>
        // check if all active players are done<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if (!player.isGhost() &amp;&amp; !player.isObserver() &amp;&amp; !player.isDone()) {<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // Tactical Genius pilot special ability (lvl 3)<br/>
        if (game.getNoOfInitiativeRerollRequests() &gt; 0) {<br/>
            resetActivePlayersDone();<br/>
            game.rollInitAndResolveTies();<br/>
<br/>
            determineTurnOrder(IGame.PHASE_INITIATIVE);<br/>
            clearReports();<br/>
            writeInitiativeReport(true);<br/>
            sendReport(true);<br/>
            return;  // don't end the phase yet, players need to see new report<br/>
        }<br/>
<br/>
        // need at least one entity in the game for the lounge phase to end<br/>
        if (!game.phaseHasTurns(game.getPhase()) &amp;&amp;<br/>
                (game.getPhase() != IGame.PHASE_LOUNGE || game.getNoOfEntities() &gt; 0)) {<br/>
            endCurrentPhase();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called when the current player has done his current turn and the turn<br/>
     * counter needs to be advanced.<br/>
     * Also enforces the "protos_move_multi" and the "protos_move_multi"<br/>
     * option.  If the player has just moved infantry/protos with a "normal"<br/>
     * turn, adds up to Game.INF_AND_PROTOS_MOVE_MULTI - 1 more<br/>
     * infantry/proto-specific turns after the current turn.<br/>
     */<br/>
    private void endCurrentTurn(Entity entityUsed) {<br/>
<br/>
        // Enforce "inf_move_multi" and "protos_move_multi" options.<br/>
        // The "isNormalTurn" flag is checking to see if any non-Infantry<br/>
        // or non-Protomech units can move during the current turn.<br/>
        boolean turnsChanged = false;<br/>
        GameTurn turn = game.getTurn();<br/>
        final int playerId = (null == entityUsed) ?<br/>
            Player.PLAYER_NONE : entityUsed.getOwnerId();<br/>
        boolean infMoved = entityUsed instanceof Infantry;<br/>
        boolean infMoveMulti =<br/>
            game.getOptions().booleanOption("inf_move_multi")<br/>
            &amp;&amp; (game.getPhase() == IGame.PHASE_MOVEMENT<br/>
                || game.getPhase() == IGame.PHASE_INITIATIVE);<br/>
        boolean protosMoved = entityUsed instanceof Protomech;<br/>
        boolean protosMoveMulti =<br/>
            game.getOptions().booleanOption("protos_move_multi");<br/>
<br/>
        // If infantry or protos move multi see if any<br/>
        // other unit types can move in the current turn.<br/>
        int multiMask = 0;<br/>
        if ( infMoveMulti ) {<br/>
            multiMask += GameTurn.CLASS_INFANTRY;<br/>
        }<br/>
        if ( protosMoveMulti ) {<br/>
            multiMask += GameTurn.CLASS_PROTOMECH;<br/>
        }<br/>
<br/>
        // If a proto declared fire and protos don't move<br/>
        // multi, ignore whether infantry move or not.<br/>
        else if ( protosMoved &amp;&amp; game.getPhase() == IGame.PHASE_FIRING ) {<br/>
            multiMask = 0;<br/>
        }<br/>
<br/>
        // Is this a general move turn?<br/>
        boolean isGeneralMoveTurn =<br/>
            ( !(turn instanceof GameTurn.SpecificEntityTurn) &amp;&amp;<br/>
              !(turn instanceof GameTurn.UnitNumberTurn) &amp;&amp;<br/>
              !(turn instanceof GameTurn.UnloadStrandedTurn) &amp;&amp;<br/>
              ( !(turn instanceof GameTurn.EntityClassTurn) ||<br/>
                ( (turn instanceof GameTurn.EntityClassTurn) &amp;&amp;<br/>
                  ( (GameTurn.EntityClassTurn) turn ).isValidClass(~multiMask)<br/>
                  )<br/>
                )<br/>
              );<br/>
<br/>
        // Unless overridden by the "protos_move_multi" option, all Protomechs<br/>
        // in a unit declare fire, and they don't mix with infantry.<br/>
        if ( protosMoved &amp;&amp; !protosMoveMulti &amp;&amp; isGeneralMoveTurn &amp;&amp;<br/>
             game.getPhase() == IGame.PHASE_FIRING ) {<br/>
<br/>
            // What's the unit number and ID of the entity used?<br/>
            final char movingUnit = entityUsed.getUnitNumber();<br/>
            final int movingId = entityUsed.getId();<br/>
<br/>
            // How many other Protomechs are in the unit that can fire?<br/>
            int protoTurns = game.getSelectedEntityCount<br/>
                ( new EntitySelector() {<br/>
                        private final int ownerId = playerId;<br/>
                        private final int entityId = movingId;<br/>
                        private final char unitNum = movingUnit;<br/>
                        public boolean accept( Entity entity ) {<br/>
                            if ( entity instanceof Protomech &amp;&amp;<br/>
                                 entity.isSelectableThisTurn() &amp;&amp;<br/>
                                 ownerId == entity.getOwnerId() &amp;&amp;<br/>
                                 entityId != entity.getId() &amp;&amp;<br/>
                                 unitNum == entity.getUnitNumber() )<br/>
                                return true;<br/>
                            return false;<br/>
                        }<br/>
                    } );<br/>
<br/>
            // Add the correct number of turns for the Protomech unit number.<br/>
            for (int i = 0; i &lt; protoTurns; i++) {<br/>
                GameTurn newTurn = new GameTurn.UnitNumberTurn<br/>
                    ( playerId, movingUnit );<br/>
                game.insertNextTurn(newTurn);<br/>
                turnsChanged = true;<br/>
            }<br/>
        }<br/>
<br/>
        // Otherwise, we may need to add turns for the "*_move_multi" options.<br/>
        else if ( ( (infMoved &amp;&amp; infMoveMulti) ||<br/>
                    (protosMoved &amp;&amp; protosMoveMulti) ) &amp;&amp;<br/>
                  isGeneralMoveTurn ) {<br/>
            int remaining = 0;<br/>
<br/>
            // Calculate the number of EntityClassTurns need to be added.<br/>
            if ( infMoveMulti ) {<br/>
                remaining += game.getInfantryLeft(playerId);<br/>
            }<br/>
            if ( protosMoveMulti ) {<br/>
                remaining += game.getProtomechsLeft(playerId);<br/>
            }<br/>
            int moreInfAndProtoTurns =<br/>
                Math.min(game.getOptions().intOption("inf_proto_move_multi") - 1, remaining);<br/>
<br/>
            // Add the correct number of turns for the right unit classes.<br/>
            for (int i = 0; i &lt; moreInfAndProtoTurns; i++) {<br/>
                GameTurn newTurn =<br/>
                    new GameTurn.EntityClassTurn( playerId, multiMask );<br/>
                game.insertNextTurn(newTurn);<br/>
                turnsChanged = true;<br/>
            }<br/>
        }<br/>
        // brief everybody on the turn update, if they changed<br/>
        if (turnsChanged) {<br/>
            send(createTurnVectorPacket());<br/>
        }<br/>
<br/>
        // move along<br/>
        changeToNextTurn();<br/>
    }<br/>
<br/>
    /**<br/>
     * Changes the current phase, does some bookkeeping and<br/>
     * then tells the players.<br/>
     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase to change to<br/>
     */<br/>
    private void changePhase(int phase) {<br/>
        game.setLastPhase(game.getPhase());<br/>
        game.setPhase(phase);<br/>
<br/>
        // prepare for the phase<br/>
        prepareForPhase(phase);<br/>
<br/>
        if (isPhasePlayable(phase)) {<br/>
            // tell the players about the new phase<br/>
            send(new Packet(Packet.COMMAND_PHASE_CHANGE, new Integer(phase)));<br/>
<br/>
            // post phase change stuff<br/>
            executePhase(phase);<br/>
        } else {<br/>
            endCurrentPhase();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Prepares for, presumably, the next phase.  This typically involves<br/>
     * resetting the states of entities in the game and making sure the client<br/>
     * has the information it needs for the new phase.<br/>
     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase to prepare for<br/>
     */<br/>
    private void prepareForPhase(int phase) {<br/>
        switch (phase) {<br/>
            case IGame.PHASE_LOUNGE :<br/>
                clearReports();<br/>
                mapSettings.setBoardsAvailableVector<br/>
                    ( scanForBoards(mapSettings.getBoardWidth(),<br/>
                                    mapSettings.getBoardHeight()) );<br/>
                mapSettings.setNullBoards(DEFAULT_BOARD);<br/>
                send(createMapSettingsPacket());<br/>
                break;<br/>
            case IGame.PHASE_INITIATIVE :<br/>
                // remove the last traces of last round<br/>
                game.resetActions();<br/>
                game.resetTagInfo();<br/>
                clearReports();<br/>
                resetEntityRound();<br/>
                resetEntityPhase(phase);<br/>
                checkForObservers();<br/>
                // roll 'em<br/>
                resetActivePlayersDone();<br/>
                rollInitiative();<br/>
<br/>
                if ( !game.shouldDeployThisRound() )<br/>
                    incrementAndSendGameRound();<br/>
<br/>
                //setIneligible(phase);<br/>
                determineTurnOrder(phase);<br/>
                writeInitiativeReport(false);<br/>
                System.out.println("Round " + game.getRoundCount() + " memory usage: " + MegaMek.getMemoryUsed());<br/>
                break;<br/>
            case IGame.PHASE_DEPLOY_MINEFIELDS :<br/>
                checkForObservers();<br/>
                resetActivePlayersDone();<br/>
                setIneligible(phase);<br/>
<br/>
                Enumeration e = game.getPlayers();<br/>
                Vector turns = new Vector();<br/>
                while (e.hasMoreElements()) {<br/>
                    Player p = (Player) e.nextElement();<br/>
                    if (p.hasMinefields()) {<br/>
                        GameTurn gt = new GameTurn(p.getId());<br/>
                        turns.addElement(gt);<br/>
                    }<br/>
                }<br/>
                game.setTurnVector(turns);<br/>
                game.resetTurnIndex();<br/>
<br/>
                // send turns to all players<br/>
                send(createTurnVectorPacket());<br/>
                break;<br/>
            case IGame.PHASE_SET_ARTYAUTOHITHEXES :<br/>
                // place off board entities actually off-board<br/>
                Enumeration i = game.getEntities();<br/>
                while (i.hasMoreElements()) {<br/>
                    Entity en = (Entity) i.nextElement();<br/>
                    en.deployOffBoard();<br/>
                }<br/>
                checkForObservers();<br/>
                resetActivePlayersDone();<br/>
                setIneligible(phase);<br/>
<br/>
                i = game.getPlayers();<br/>
                Vector turn = new Vector();<br/>
<br/>
                // Walk through the players of the game, and add<br/>
                // a turn for all players with artillery weapons.<br/>
                while (i.hasMoreElements()) {<br/>
<br/>
                    // Get the next player.<br/>
                    final Player p = (Player) i.nextElement();<br/>
<br/>
                    // Does the player have any artillery-equipped units?<br/>
                    EntitySelector playerArtySelector = new EntitySelector() {<br/>
                            private Player owner = p;<br/>
                            public boolean accept (Entity entity) {<br/>
                                if ( owner.equals( entity.getOwner() ) &amp;&amp;<br/>
                                     entity.isEligibleForTargetingPhase() )<br/>
                                    return true;<br/>
                                return false;<br/>
                            }<br/>
                        };<br/>
                    if ( game.getSelectedEntities( playerArtySelector )<br/>
                         .hasMoreElements() ) {<br/>
<br/>
                        // Yes, the player has arty-equipped units.<br/>
                        GameTurn gt = new GameTurn(p.getId());<br/>
                        turn.addElement(gt);<br/>
                    }<br/>
                }<br/>
                game.setTurnVector(turn);<br/>
                game.resetTurnIndex();<br/>
<br/>
                // send turns to all players<br/>
                send(createTurnVectorPacket());<br/>
                break;<br/>
            case IGame.PHASE_MOVEMENT :<br/>
            case IGame.PHASE_DEPLOYMENT :<br/>
            case IGame.PHASE_FIRING :<br/>
            case IGame.PHASE_PHYSICAL :<br/>
            case IGame.PHASE_TARGETING:<br/>
            case IGame.PHASE_OFFBOARD:<br/>
                resetEntityPhase(phase);<br/>
                checkForObservers();<br/>
                setIneligible(phase);<br/>
                determineTurnOrder(phase);<br/>
                resetActivePlayersDone();<br/>
                //send(createEntitiesPacket());<br/>
                entityAllUpdate();<br/>
                clearReports();<br/>
                doTryUnstuck();<br/>
                break;<br/>
            case IGame.PHASE_END :<br/>
                resetEntityPhase(phase);<br/>
                clearReports();<br/>
                resolveHeat();<br/>
                //write End Phase header<br/>
                addReport(new Report(5005, Report.PUBLIC));<br/>
                checkForSuffocation();<br/>
                if (game.getOptions().booleanOption("vacuum")) {<br/>
                    checkForVacuumDeath();<br/>
                }<br/>
                for(Enumeration&lt;DynamicTerrainProcessor&gt; tps=terrainProcessors.elements();tps.hasMoreElements();) {<br/>
                    DynamicTerrainProcessor tp = tps.nextElement();<br/>
                    tp.DoEndPhaseChanges(vPhaseReport);<br/>
                }<br/>
                addReport( game.ageFlares());<br/>
                send(createFlarePacket());<br/>
                resolveExtremeTempInfantryDeath();<br/>
                resolveAmmoDumps();<br/>
                resolveCrewDamage();<br/>
                resolveCrewWakeUp();<br/>
                resolveMechWarriorPickUp();<br/>
                resolveVeeINarcPodRemoval();<br/>
                checkForObservers();<br/>
                entityAllUpdate();<br/>
                break;<br/>
            case IGame.PHASE_INITIATIVE_REPORT :<br/>
                autoSave();<br/>
            case IGame.PHASE_MOVEMENT_REPORT :<br/>
            case IGame.PHASE_OFFBOARD_REPORT :<br/>
            case IGame.PHASE_FIRING_REPORT :<br/>
            case IGame.PHASE_PHYSICAL_REPORT :<br/>
            case IGame.PHASE_END_REPORT :<br/>
                resetActivePlayersDone();<br/>
                sendReport();<br/>
                if (game.getOptions().booleanOption("paranoid_autosave")) autoSave();<br/>
                break;<br/>
            case IGame.PHASE_VICTORY :<br/>
                resetPlayersDone();<br/>
                clearReports();<br/>
                prepareVictoryReport();<br/>
                game.addReports(vPhaseReport);<br/>
                send(createFullEntitiesPacket());<br/>
                send(createReportPacket(null));<br/>
                send(createEndOfGamePacket());<br/>
                break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Should we play this phase or skip it?<br/>
     */<br/>
    private boolean isPhasePlayable(int phase) {<br/>
        switch (phase) {<br/>
            case IGame.PHASE_INITIATIVE :<br/>
            case IGame.PHASE_END :<br/>
                return false;<br/>
            case IGame.PHASE_SET_ARTYAUTOHITHEXES :<br/>
            case IGame.PHASE_DEPLOY_MINEFIELDS :<br/>
            case IGame.PHASE_DEPLOYMENT :<br/>
            case IGame.PHASE_MOVEMENT :<br/>
            case IGame.PHASE_FIRING :<br/>
            case IGame.PHASE_PHYSICAL :<br/>
            case IGame.PHASE_TARGETING:<br/>
            case IGame.PHASE_OFFBOARD :<br/>
                return game.hasMoreTurns();<br/>
            default :<br/>
                return true;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Do anything we seed to start the new phase, such as give a turn to<br/>
     * the first player to play.<br/>
     */<br/>
    private void executePhase(int phase) {<br/>
        switch (phase) {<br/>
            case IGame.PHASE_EXCHANGE :<br/>
                resetPlayersDone();<br/>
                // Build teams vector<br/>
                game.setupTeams();<br/>
                applyBoardSettings();<br/>
                game.setupRoundDeployment();<br/>
                game.determineWind();<br/>
                // If we add transporters for any Magnetic Clamp<br/>
                // equiped squads, then update the clients' entities.<br/>
                if ( game.checkForMagneticClamp() ) {<br/>
                    entityAllUpdate();<br/>
                }<br/>
                // transmit the board to everybody<br/>
                send(createBoardPacket());<br/>
                break;<br/>
            case IGame.PHASE_MOVEMENT :<br/>
                //write Movement Phase header to report<br/>
                addReport(new Report(2000, Report.PUBLIC));<br/>
            case IGame.PHASE_SET_ARTYAUTOHITHEXES :<br/>
            case IGame.PHASE_DEPLOY_MINEFIELDS :<br/>
            case IGame.PHASE_DEPLOYMENT :<br/>
            case IGame.PHASE_FIRING :<br/>
            case IGame.PHASE_PHYSICAL :<br/>
            case IGame.PHASE_TARGETING :<br/>
            case IGame.PHASE_OFFBOARD :<br/>
                changeToNextTurn();<br/>
                if (game.getOptions().booleanOption("paranoid_autosave")) autoSave();<br/>
                break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Ends this phase and moves on to the next.<br/>
     */<br/>
    private void endCurrentPhase() {<br/>
        switch (game.getPhase()) {<br/>
            case IGame.PHASE_LOUNGE :<br/>
                changePhase(IGame.PHASE_EXCHANGE);<br/>
                break;<br/>
            case IGame.PHASE_EXCHANGE :<br/>
                changePhase(IGame.PHASE_SET_ARTYAUTOHITHEXES);<br/>
                break;<br/>
            case IGame.PHASE_STARTING_SCENARIO :<br/>
                changePhase(IGame.PHASE_SET_ARTYAUTOHITHEXES);<br/>
                break;<br/>
            case IGame.PHASE_SET_ARTYAUTOHITHEXES :<br/>
                Enumeration e = game.getPlayers();<br/>
                boolean mines = false;<br/>
                while (e.hasMoreElements()) {<br/>
                    Player p = (Player) e.nextElement();<br/>
                    if (p.hasMinefields()) {<br/>
                         mines = true;<br/>
                    }<br/>
                }<br/>
                if (mines) {<br/>
                    changePhase(IGame.PHASE_DEPLOY_MINEFIELDS);<br/>
                } else {<br/>
                    changePhase(IGame.PHASE_INITIATIVE);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_DEPLOY_MINEFIELDS :<br/>
                changePhase(IGame.PHASE_INITIATIVE);<br/>
                break;<br/>
            case IGame.PHASE_DEPLOYMENT :<br/>
                game.clearDeploymentThisRound();<br/>
                game.checkForCompleteDeployment();<br/>
                Enumeration pls = game.getPlayers();<br/>
                while (pls.hasMoreElements()) {<br/>
                    Player p = (Player) pls.nextElement();<br/>
                    p.adjustStartingPosForReinforcements();<br/>
                }<br/>
<br/>
                changePhase(IGame.PHASE_INITIATIVE);<br/>
                break;<br/>
            case IGame.PHASE_INITIATIVE :<br/>
                game.addReports(vPhaseReport);<br/>
                changePhase(IGame.PHASE_INITIATIVE_REPORT);<br/>
                break;<br/>
            case IGame.PHASE_INITIATIVE_REPORT :<br/>
                //boolean doDeploy = game.shouldDeployThisRound() &amp;&amp; (game.getLastPhase() != IGame.PHASE_DEPLOYMENT);<br/>
                if ( game.shouldDeployThisRound() ) {<br/>
                    changePhase(IGame.PHASE_DEPLOYMENT);<br/>
                } else {<br/>
                    changePhase(IGame.PHASE_TARGETING);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_MOVEMENT :<br/>
                doAllAssaultDrops();<br/>
                addMovementHeat();<br/>
                applyBuildingDamage();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls(); // Skids cause damage in movement phase<br/>
                resolveCrewDamage(); // again, I guess<br/>
                checkForFlamingDeath();<br/>
                // check phase report<br/>
                if (vPhaseReport.size() &gt; 1) {<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_MOVEMENT_REPORT);<br/>
                } else {<br/>
                    //just the header, so we'll add the &lt;nothing&gt; label<br/>
                    addReport(new Report(1205, Report.PUBLIC));<br/>
                    game.addReports(vPhaseReport);<br/>
                    sendReport();<br/>
                    changePhase(IGame.PHASE_OFFBOARD);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_MOVEMENT_REPORT :<br/>
                changePhase(IGame.PHASE_OFFBOARD);<br/>
                break;<br/>
            case IGame.PHASE_FIRING :<br/>
                resolveAllButWeaponAttacks();<br/>
                assignAMS();<br/>
                resolveOnlyWeaponAttacks();<br/>
                applyBuildingDamage();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls();<br/>
                resolveCrewDamage(); // again, I guess<br/>
                // check phase report<br/>
                if (vPhaseReport.size() &gt; 1) {<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_FIRING_REPORT);<br/>
                } else {<br/>
                    //just the header, so we'll add the &lt;nothing&gt; label<br/>
                    addReport(new Report(1205, Report.PUBLIC));<br/>
                    sendReport();<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_PHYSICAL);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_FIRING_REPORT :<br/>
                changePhase(IGame.PHASE_PHYSICAL);<br/>
                break;<br/>
            case IGame.PHASE_PHYSICAL :<br/>
                resolvePhysicalAttacks();<br/>
                applyBuildingDamage();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls();<br/>
                resolveCrewDamage(); // again, I guess<br/>
                resolveSinkVees();<br/>
                // check phase report<br/>
                if (vPhaseReport.size() &gt; 1) {<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_PHYSICAL_REPORT);<br/>
                } else {<br/>
                    //just the header, so we'll add the &lt;nothing&gt; label<br/>
                    addReport(new Report(1205, Report.PUBLIC));<br/>
                    game.addReports(vPhaseReport);<br/>
                    sendReport();<br/>
                    changePhase(IGame.PHASE_END);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_PHYSICAL_REPORT :<br/>
                changePhase(IGame.PHASE_END);<br/>
                break;<br/>
            case IGame.PHASE_TARGETING :<br/>
                enqueueIndirectArtilleryAttacks();<br/>
                changePhase(IGame.PHASE_MOVEMENT);<br/>
                break;<br/>
            case IGame.PHASE_OFFBOARD :<br/>
                //write Offboard Attack Phase header<br/>
                addReport(new Report(1100, Report.PUBLIC));<br/>
                resolveAllButWeaponAttacks(); //torso twist or flip arms possible<br/>
                resolveOnlyWeaponAttacks(); //should only be TAG at this point<br/>
                resolveIndirectArtilleryAttacks();<br/>
                applyBuildingDamage();<br/>
                checkFor20Damage();<br/>
                resolveCrewDamage();<br/>
                resolvePilotingRolls();<br/>
                resolveCrewDamage(); // again, I guess<br/>
                //check reports<br/>
                if (vPhaseReport.size() &gt; 1) {<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_OFFBOARD_REPORT);<br/>
                } else {<br/>
                    //just the header, so we'll add the &lt;nothing&gt; label<br/>
                    addReport(new Report(1205, Report.PUBLIC));<br/>
                    game.addReports(vPhaseReport);<br/>
                    sendReport();<br/>
                    changePhase(IGame.PHASE_FIRING);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_OFFBOARD_REPORT:<br/>
                changePhase(IGame.PHASE_FIRING);<br/>
                break;<br/>
            case IGame.PHASE_END :<br/>
                // check phase report<br/>
                //HACK: hardcoded message ID check<br/>
                if (vPhaseReport.size() &gt; 3<br/>
                    || ((Report)vPhaseReport.elementAt(1)).messageId != 1205) {<br/>
                    game.addReports(vPhaseReport);<br/>
                    changePhase(IGame.PHASE_END_REPORT);<br/>
                } else {<br/>
                    //just the heat and end headers, so we'll add<br/>
                    // the &lt;nothing&gt; label<br/>
                    addReport(new Report(1205, Report.PUBLIC));<br/>
                    game.addReports(vPhaseReport);<br/>
                    sendReport();<br/>
                    if (victory()) {<br/>
                        changePhase(IGame.PHASE_VICTORY);<br/>
                    } else {<br/>
                        changePhase(IGame.PHASE_INITIATIVE);<br/>
                    }<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_END_REPORT :<br/>
                if (victory()) {<br/>
                    changePhase(IGame.PHASE_VICTORY);<br/>
                } else {<br/>
                    changePhase(IGame.PHASE_INITIATIVE);<br/>
                }<br/>
                break;<br/>
            case IGame.PHASE_VICTORY :<br/>
                resetGame();<br/>
                break;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Increment's the server's game round and send it to all the clients<br/>
     */<br/>
    private void incrementAndSendGameRound() {<br/>
        game.incrementRoundCount();<br/>
        send(new Packet(Packet.COMMAND_ROUND_UPDATE, new Integer(game.getRoundCount())));<br/>
    }<br/>
<br/>
    /**<br/>
     * Tries to change to the next turn.  If there are no more turns, ends the<br/>
     * current phase.  If the player whose turn it is next is not connected,<br/>
     * we allow the other players to skip that player.<br/>
     */<br/>
    private void changeToNextTurn() {<br/>
        // if there aren't any more turns, end the phase<br/>
        if (!game.hasMoreTurns()) {<br/>
            endCurrentPhase();<br/>
            return;<br/>
        }<br/>
<br/>
        // okay, well next turn then!<br/>
        GameTurn nextTurn = game.changeToNextTurn();<br/>
        send(createTurnIndexPacket());<br/>
<br/>
        Player player = getPlayer( nextTurn.getPlayerNum() );<br/>
        if ( null != player &amp;&amp; player.isGhost() ) {<br/>
            sendGhostSkipMessage( player );<br/>
        }<br/>
        else if ( null == game.getFirstEntity()<br/>
                  &amp;&amp; null != player<br/>
                  &amp;&amp; ((game.getPhase() != IGame.PHASE_DEPLOY_MINEFIELDS) &amp;&amp; (game.getPhase() != IGame.PHASE_SET_ARTYAUTOHITHEXES))) {<br/>
            sendTurnErrorSkipMessage( player );<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out a notification message indicating that a ghost player may<br/>
     * be skipped.<br/>
     *<br/>
     * @param   ghost - the &lt;code&gt;Player&lt;/code&gt; who is ghosted.<br/>
     *          This value must not be &lt;code&gt;null&lt;/code&gt;.<br/>
     */<br/>
    private void sendGhostSkipMessage( Player ghost ) {<br/>
        StringBuffer message = new StringBuffer();<br/>
        message.append( "Player '" )<br/>
            .append( ghost.getName() )<br/>
            .append( "' is disconnected.  You may skip his/her current turn with the /skip command." );<br/>
        sendServerChat( message.toString() );<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out a notification message indicating that the current turn is an<br/>
     * error and should be skipped.<br/>
     *<br/>
     * @param   skip - the &lt;code&gt;Player&lt;/code&gt; who is to be skipped.<br/>
     *          This value must not be &lt;code&gt;null&lt;/code&gt;.<br/>
     */<br/>
    private void sendTurnErrorSkipMessage( Player skip ) {<br/>
        StringBuffer message = new StringBuffer();<br/>
        message.append( "Player '" )<br/>
            .append( skip.getName() )<br/>
            .append( "' has no units to move.  You should skip his/her/your current turn with the /skip command. You may want to report this error.  See the MegaMek homepage (http://megamek.sf.net/) for details." );<br/>
        sendServerChat( message.toString() );<br/>
    }<br/>
<br/>
    /**<br/>
     * Skips the current turn.  This only makes sense in phases that have turns.<br/>
     * Operates by finding an entity to move and then doing nothing with it.<br/>
     */<br/>
    public void skipCurrentTurn() {<br/>
        // find an entity to skip...<br/>
        Entity toSkip = game.getFirstEntity();<br/>
<br/>
        switch (game.getPhase()) {<br/>
            case IGame.PHASE_DEPLOYMENT :<br/>
                sendServerChat("Turns cannot be skipped in the deployment phase.");<br/>
                break;<br/>
            case IGame.PHASE_MOVEMENT :<br/>
                if ( toSkip != null ) {<br/>
                    processMovement(toSkip, new MovePath(game, toSkip));<br/>
                }<br/>
                endCurrentTurn(toSkip);<br/>
                break;<br/>
            case IGame.PHASE_FIRING :<br/>
            case IGame.PHASE_PHYSICAL :<br/>
            case IGame.PHASE_TARGETING :<br/>
            case IGame.PHASE_OFFBOARD :<br/>
                if ( toSkip != null ) {<br/>
                    processAttack(toSkip, new Vector(0));<br/>
                }<br/>
                endCurrentTurn(toSkip);<br/>
                break;<br/>
            default :<br/>
<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the current turn may be skipped.  Ghost players' turns<br/>
     * are skippable, and a turn should be skipped if there's nothing to move.<br/>
     */<br/>
    public boolean isTurnSkippable() {<br/>
        GameTurn turn = game.getTurn();<br/>
        if (null == turn) return false;<br/>
        Player player = getPlayer( turn.getPlayerNum() );<br/>
        return ( null == player || player.isGhost()<br/>
                 || game.getFirstEntity() == null );<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if victory conditions have been met.  Victory conditions<br/>
     * are when there is only one player left with mechs or only one team.<br/>
     */<br/>
    public boolean victory() {<br/>
        if (game.isForceVictory()) {<br/>
            int victoryPlayerId = game.getVictoryPlayerId();<br/>
            int victoryTeam = game.getVictoryTeam();<br/>
            Vector players = game.getPlayersVector();<br/>
            boolean forceVictory = true;<br/>
<br/>
            // Individual victory.<br/>
            if (victoryPlayerId != Player.PLAYER_NONE) {<br/>
                for (int i = 0; i &lt; players.size(); i++) {<br/>
                    Player player = (Player) players.elementAt(i);<br/>
<br/>
                    if (player.getId() != victoryPlayerId &amp;&amp; !player.isObserver()) {<br/>
                        if (!player.admitsDefeat()) {<br/>
                            forceVictory = false;<br/>
                            break;<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
            // Team victory.<br/>
            if (victoryTeam != Player.TEAM_NONE) {<br/>
                for (int i = 0; i &lt; players.size(); i++) {<br/>
                    Player player = (Player) players.elementAt(i);<br/>
<br/>
                    if (player.getTeam() != victoryTeam &amp;&amp; !player.isObserver()) {<br/>
                        if (!player.admitsDefeat()) {<br/>
                            forceVictory = false;<br/>
                            break;<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            for (int i = 0; i &lt; players.size(); i++) {<br/>
                Player player = (Player) players.elementAt(i);<br/>
                player.setAdmitsDefeat(false);<br/>
            }<br/>
<br/>
            if (forceVictory) {<br/>
                return true;<br/>
            }<br/>
            cancelVictory();<br/>
        }<br/>
<br/>
        if (!game.getOptions().booleanOption("check_victory")) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // check all players/teams for aliveness<br/>
        int playersAlive = 0;<br/>
        Player lastPlayer = null;<br/>
        boolean oneTeamAlive = false;<br/>
        int lastTeam = Player.TEAM_NONE;<br/>
        boolean unteamedAlive = false;<br/>
        for (Enumeration e = game.getPlayers(); e.hasMoreElements();) {<br/>
            Player player = (Player)e.nextElement();<br/>
            int team = player.getTeam();<br/>
            if (game.getLiveDeployedEntitiesOwnedBy(player) &lt;= 0) {<br/>
                continue;<br/>
            }<br/>
            // we found a live one!<br/>
            playersAlive++;<br/>
            lastPlayer = player;<br/>
            // check team<br/>
            if (team == Player.TEAM_NONE) {<br/>
                unteamedAlive = true;<br/>
            } else if (lastTeam == Player.TEAM_NONE) {<br/>
                // possibly only one team alive<br/>
                oneTeamAlive = true;<br/>
                lastTeam = team;<br/>
            } else if (team != lastTeam) {<br/>
                // more than one team alive<br/>
                oneTeamAlive = false;<br/>
                lastTeam = team;<br/>
            }<br/>
        }<br/>
<br/>
        // check if there's one player alive<br/>
        if (playersAlive &lt; 1) {<br/>
            game.setVictoryPlayerId( Player.PLAYER_NONE );<br/>
            game.setVictoryTeam( Player.TEAM_NONE );<br/>
            return true;<br/>
        }<br/>
        else if ( playersAlive == 1 ) {<br/>
            if (lastPlayer.getTeam() == Player.TEAM_NONE) {<br/>
                // individual victory<br/>
                game.setVictoryPlayerId(lastPlayer.getId());<br/>
                game.setVictoryTeam(Player.TEAM_NONE);<br/>
                return true;<br/>
            }<br/>
        }<br/>
<br/>
        // did we only find one live team?<br/>
        if (oneTeamAlive &amp;&amp; !unteamedAlive) {<br/>
            // team victory<br/>
            game.setVictoryPlayerId(Player.PLAYER_NONE);<br/>
            game.setVictoryTeam(lastTeam);<br/>
            return true;<br/>
        }<br/>
<br/>
        return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Applies board settings.  This loads and combines all the boards that<br/>
     * were specified into one mega-board and sets that board as current.<br/>
     */<br/>
    public void applyBoardSettings() {<br/>
        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
        mapSettings.replaceBoardWithRandom(MapSettings.BOARD_SURPRISE);<br/>
        IBoard[] sheetBoards = new IBoard[mapSettings.getMapWidth() * mapSettings.getMapHeight()];<br/>
        for (int i = 0; i &lt; mapSettings.getMapWidth() * mapSettings.getMapHeight(); i++) {<br/>
            sheetBoards[i] = new Board();<br/>
            String name = (String)mapSettings.getBoardsSelectedVector().elementAt(i);<br/>
            boolean isRotated = false;<br/>
            if ( name.startsWith( Board.BOARD_REQUEST_ROTATION ) ) {<br/>
                isRotated = true;<br/>
                name = name.substring( Board.BOARD_REQUEST_ROTATION.length() );<br/>
            }<br/>
            if (name.startsWith(MapSettings.BOARD_GENERATED)) {<br/>
                sheetBoards[i] = BoardUtilities.generateRandom(mapSettings);<br/>
            } else {<br/>
                sheetBoards[i].load( name + ".board");<br/>
                BoardUtilities.flip(sheetBoards[i], isRotated, isRotated );<br/>
            }<br/>
        }<br/>
        IBoard newBoard = BoardUtilities.combine(mapSettings.getBoardWidth(), mapSettings.getBoardHeight(),<br/>
                mapSettings.getMapWidth(), mapSettings.getMapHeight(), sheetBoards);<br/>
        game.setBoard(newBoard);<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Rolls initiative for all the players.<br/>
     */<br/>
    private void rollInitiative() {<br/>
        if(game.getOptions().booleanOption("individual_initiative")) {<br/>
            TurnOrdered.rollInitiative(game.getEntitiesVector());<br/>
        } else {<br/>
            // Roll for initative on the teams.<br/>
            TurnOrdered.rollInitiative(game.getTeamsVector());<br/>
        }<br/>
<br/>
        transmitAllPlayerUpdates();<br/>
    }<br/>
<br/>
    /**<br/>
     * Determines the turn oder for a given phase (with individual init)<br/>
     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase<br/>
     */<br/>
    private void determineTurnOrderIUI(int phase) {<br/>
        for (Enumeration loop = game.getEntities(); loop.hasMoreElements();) {<br/>
            final Entity entity = (Entity)loop.nextElement();<br/>
            entity.resetOtherTurns();<br/>
            if (entity.isSelectableThisTurn()) {<br/>
                entity.incrementOtherTurns();<br/>
            }<br/>
        }<br/>
        // Now, generate the global order of all teams' turns.<br/>
        TurnVectors team_order = TurnOrdered.generateTurnOrder<br/>
            ( game.getEntitiesVector(), game );<br/>
<br/>
        // See if there are any loaded units stranded on immobile transports.<br/>
        Enumeration strandedUnits = game.getSelectedEntities<br/>
            ( new EntitySelector() {<br/>
                    public boolean accept( Entity entity ) {<br/>
                        if ( Server.this.game.isEntityStranded(entity) )<br/>
                            return true;<br/>
                        return false;<br/>
                    }<br/>
                } );<br/>
<br/>
        // Now, we collect everything into a single vector.<br/>
        Vector turns;<br/>
<br/>
        if ( strandedUnits.hasMoreElements() &amp;&amp;<br/>
             game.getPhase() == IGame.PHASE_MOVEMENT ) {<br/>
            // Add a game turn to unload stranded units, if this<br/>
            //  is the movement phase.<br/>
            turns = new Vector( team_order.getNormalTurns() +<br/>
                                team_order.getEvenTurns() + 1);<br/>
            turns.addElement( new GameTurn.UnloadStrandedTurn(strandedUnits) );<br/>
        } else {<br/>
            // No stranded units.<br/>
            turns = new Vector( team_order.getNormalTurns() +<br/>
                                team_order.getEvenTurns() );<br/>
        }<br/>
        <br/>
        //add the turns (this is easy)<br/>
        while(team_order.hasMoreElements()) {<br/>
            Entity e = (Entity)team_order.nextElement();<br/>
            if(e.isSelectableThisTurn())<br/>
                turns.addElement(new GameTurn.SpecificEntityTurn(e.getOwnerId(), e.getId()));<br/>
        }<br/>
        <br/>
        // set fields in game<br/>
        game.setTurnVector(turns);<br/>
        game.resetTurnIndex();<br/>
<br/>
        // send turns to all players<br/>
        send(createTurnVectorPacket());<br/>
    }<br/>
    /**<br/>
     * Determines the turn oder for a given phase<br/>
     * @param phase the &lt;code&gt;int&lt;/code&gt; id of the phase<br/>
     */<br/>
    private void determineTurnOrder(int phase) {<br/>
<br/>
        if(game.getOptions().booleanOption("individual_initiative")) {<br/>
            determineTurnOrderIUI(phase);<br/>
            return;<br/>
        }<br/>
        // and/or deploy even according to game options.<br/>
        boolean infMoveEven =<br/>
            ( game.getOptions().booleanOption("inf_move_even") &amp;&amp;<br/>
              (game.getPhase() == IGame.PHASE_INITIATIVE ||<br/>
               game.getPhase() == IGame.PHASE_MOVEMENT) ) ||<br/>
            ( game.getOptions().booleanOption("inf_deploy_even") &amp;&amp;<br/>
              game.getPhase() == IGame.PHASE_DEPLOYMENT );<br/>
        boolean infMoveMulti =<br/>
            ( game.getOptions().booleanOption("inf_move_multi") &amp;&amp;<br/>
              (game.getPhase() == IGame.PHASE_INITIATIVE ||<br/>
               game.getPhase() == IGame.PHASE_MOVEMENT) );<br/>
        boolean protosMoveEven =<br/>
            ( game.getOptions().booleanOption("protos_move_even") &amp;&amp;<br/>
              (game.getPhase() == IGame.PHASE_INITIATIVE ||<br/>
               game.getPhase() == IGame.PHASE_MOVEMENT) ) ||<br/>
            ( game.getOptions().booleanOption("protos_deploy_even") &amp;&amp;<br/>
              game.getPhase() == IGame.PHASE_DEPLOYMENT );<br/>
        boolean protosMoveMulti =<br/>
            game.getOptions().booleanOption("protos_move_multi");<br/>
        boolean protosFireMulti = !protosMoveMulti &amp;&amp;<br/>
            game.getPhase() == IGame.PHASE_FIRING;<br/>
        int evenMask = 0;<br/>
        if ( infMoveEven ) evenMask += GameTurn.CLASS_INFANTRY;<br/>
        if ( protosMoveEven ) evenMask += GameTurn.CLASS_PROTOMECH;<br/>
<br/>
        // Reset all of the Players' turn category counts<br/>
        for (Enumeration loop = game.getPlayers(); loop.hasMoreElements();) {<br/>
            final Player player = (Player) loop.nextElement();<br/>
            player.resetEvenTurns();<br/>
            player.resetMultiTurns();<br/>
            player.resetOtherTurns();<br/>
<br/>
            // Add turns for protomechs weapons declaration.<br/>
            if ( protosFireMulti ) {<br/>
<br/>
                // How many Protomechs does the player have?<br/>
                int numPlayerProtos = game.getSelectedEntityCount<br/>
                    ( new EntitySelector() {<br/>
                            private final int ownerId = player.getId();<br/>
                            public boolean accept( Entity entity ) {<br/>
                                if ( entity instanceof Protomech &amp;&amp;<br/>
                                     ownerId == entity.getOwnerId() )<br/>
                                    return true;<br/>
                                return false;<br/>
                            }<br/>
                        } );<br/>
                int numProtoUnits =<br/>
                    (int) Math.ceil( (numPlayerProtos) / 5.0 );<br/>
                for ( int unit = 0; unit &lt; numProtoUnits; unit++ ) {<br/>
                    if ( protosMoveEven ) player.incrementEvenTurns();<br/>
                    else player.incrementOtherTurns();<br/>
                }<br/>
<br/>
            } // End handle-proto-firing-turns<br/>
<br/>
        } // Handle the next player<br/>
<br/>
        // Go through all entities, and update the turn categories of the<br/>
        // entity's player.  The teams get their totals from their players.<br/>
        // N.B. protomechs declare weapons fire based on their point.<br/>
        for (Enumeration loop = game.getEntities(); loop.hasMoreElements();) {<br/>
            final Entity entity = (Entity)loop.nextElement();<br/>
            if (entity.isSelectableThisTurn()) {<br/>
                final Player player = entity.getOwner();<br/>
                if ( entity instanceof Infantry ) {<br/>
                    if ( infMoveEven ) player.incrementEvenTurns();<br/>
                    else if ( infMoveMulti ) player.incrementMultiTurns();<br/>
                    else player.incrementOtherTurns();<br/>
                }<br/>
                else if ( entity instanceof Protomech ) {<br/>
                    if ( !protosFireMulti ) {<br/>
                        if ( protosMoveEven ) player.incrementEvenTurns();<br/>
                        else if ( protosMoveMulti ) player.incrementMultiTurns();<br/>
                        else player.incrementOtherTurns();<br/>
                    }<br/>
                }<br/>
                else<br/>
                    player.incrementOtherTurns();<br/>
            }<br/>
        }<br/>
<br/>
        // Generate the turn order for the Players *within*<br/>
        // each Team.  Map the teams to their turn orders.<br/>
        // Count the number of teams moving this turn.<br/>
        int nTeams = game.getNoOfTeams();<br/>
        Hashtable allTeamTurns = new Hashtable( nTeams );<br/>
        Hashtable evenTrackers = new Hashtable( nTeams );<br/>
        int numTeamsMoving = 0;<br/>
        for (Enumeration loop = game.getTeams(); loop.hasMoreElements(); ) {<br/>
            final Team team = (Team) loop.nextElement();<br/>
            allTeamTurns.put( team, team.determineTeamOrder(game) );<br/>
<br/>
            // Track both the number of times we've checked the team for<br/>
            // "leftover" turns, and the number of "leftover" turns placed.<br/>
            int[] evenTracker = new int[2];<br/>
            evenTracker[0] = 0;<br/>
            evenTracker[1] = 0;<br/>
            evenTrackers.put (team, evenTracker);<br/>
<br/>
            // Count this team if it has any "normal" moves.<br/>
            if (team.getNormalTurns(game) &gt; 0)<br/>
                numTeamsMoving++;<br/>
        }<br/>
<br/>
        // Now, generate the global order of all teams' turns.<br/>
        TurnVectors team_order = TurnOrdered.generateTurnOrder<br/>
            ( game.getTeamsVector(), game );<br/>
<br/>
        // See if there are any loaded units stranded on immobile transports.<br/>
        Enumeration strandedUnits = game.getSelectedEntities<br/>
            ( new EntitySelector() {<br/>
                    public boolean accept( Entity entity ) {<br/>
                        if ( Server.this.game.isEntityStranded(entity) )<br/>
                            return true;<br/>
                        return false;<br/>
                    }<br/>
                } );<br/>
<br/>
        // Now, we collect everything into a single vector.<br/>
        Vector turns;<br/>
<br/>
        if ( strandedUnits.hasMoreElements() &amp;&amp;<br/>
             game.getPhase() == IGame.PHASE_MOVEMENT ) {<br/>
            // Add a game turn to unload stranded units, if this<br/>
            //  is the movement phase.<br/>
            turns = new Vector( team_order.getNormalTurns() +<br/>
                                team_order.getEvenTurns() + 1);<br/>
            turns.addElement( new GameTurn.UnloadStrandedTurn(strandedUnits) );<br/>
        } else {<br/>
            // No stranded units.<br/>
            turns = new Vector( team_order.getNormalTurns() +<br/>
                                team_order.getEvenTurns() );<br/>
        }<br/>
<br/>
        // Walk through the global order, assigning turns<br/>
        // for individual players to the single vector.<br/>
        // Keep track of how many turns we've added to the vector.<br/>
        Team prevTeam = null;<br/>
        int min = team_order.getMin();<br/>
        for ( int numTurn = 0; team_order.hasMoreElements(); numTurn++ ) {<br/>
            Team team = (Team) team_order.nextElement();<br/>
            TurnVectors withinTeamTurns = (TurnVectors) allTeamTurns.get(team);<br/>
<br/>
            int[] evenTracker = (int[]) evenTrackers.get (team);<br/>
            float teamEvenTurns = team.getEvenTurns();<br/>
<br/>
            // Calculate the number of "even" turns to add for this team.<br/>
            int numEven = 0;<br/>
            if (1 == numTeamsMoving) {<br/>
                // The only team moving should move all "even" units.<br/>
                numEven += teamEvenTurns;<br/>
            }<br/>
            else if (prevTeam == null) {<br/>
                // Increment the number of times we've checked for "leftovers".<br/>
                evenTracker[0]++;<br/>
<br/>
                // The first team to move just adds the "baseline" turns.<br/>
                numEven += teamEvenTurns / min;<br/>
            }<br/>
            else if (!team.equals(prevTeam)) {<br/>
                // Increment the number of times we've checked for "leftovers".<br/>
                evenTracker[0]++;<br/>
<br/>
                // This wierd equation attempts to spread the "leftover"<br/>
                // turns accross the turn's moves in a "fair" manner.<br/>
                // It's based on the number of times we've checked for<br/>
                // "leftovers" the number of "leftovers" we started with,<br/>
                // the number of times we've added a turn for a "leftover",<br/>
                // and the total number of times we're going to check.<br/>
                numEven += Math.ceil (evenTracker[0] * (teamEvenTurns % min)<br/>
                                       / min - 0.5) - evenTracker[1];<br/>
<br/>
                // Update the number of turns actually added for "leftovers".<br/>
                evenTracker[1] += numEven;<br/>
<br/>
                // Add the "baseline" number of turns.<br/>
                numEven += teamEvenTurns / min;<br/>
            }<br/>
<br/>
            // Record this team for the next move.<br/>
            prevTeam = team;<br/>
<br/>
            // This may be a "placeholder" for a team without "normal" turns.<br/>
            if (withinTeamTurns.hasMoreElements()) {<br/>
<br/>
                // Not a placeholder... get the player who moves next.<br/>
                Player player = (Player) withinTeamTurns.nextElement();<br/>
<br/>
                // If we've added all "normal" turns, allocate turns<br/>
                // for the infantry and/or protomechs moving even.<br/>
                GameTurn turn = null;<br/>
                if ( numTurn &gt;= team_order.getNormalTurns() ) {<br/>
                    turn = new GameTurn.EntityClassTurn<br/>
                        (player.getId(), evenMask);<br/>
                }<br/>
<br/>
                // If either Infantry or Protomechs move even, only allow<br/>
                // the other classes to move during the "normal" turn.<br/>
                else if ( infMoveEven || protosMoveEven ) {<br/>
                    turn = new GameTurn.EntityClassTurn<br/>
                        (player.getId(), ~evenMask);<br/>
                }<br/>
<br/>
                // Otherwise, let *anybody* move.<br/>
                else {<br/>
                    turn = new GameTurn( player.getId() );<br/>
                }<br/>
                turns.addElement(turn);<br/>
<br/>
            } // End team-has-"normal"-turns<br/>
<br/>
            // Add the calculated number of "even" turns.<br/>
            // Allow the player at least one "normal" turn before the<br/>
            // "even" turns to help with loading infantry in deployment.<br/>
            while (numEven &gt; 0 &amp;&amp; withinTeamTurns.hasMoreEvenElements()) {<br/>
                Player evenPlayer = (Player) withinTeamTurns.nextEvenElement();<br/>
                turns.addElement<br/>
                    (new GameTurn.EntityClassTurn (evenPlayer.getId(),<br/>
                                                   evenMask));<br/>
                numEven--;<br/>
            }<br/>
        }<br/>
<br/>
        // set fields in game<br/>
        game.setTurnVector(turns);<br/>
        game.resetTurnIndex();<br/>
<br/>
        // send turns to all players<br/>
        send(createTurnVectorPacket());<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Write the initiative results to the report<br/>
     */<br/>
    private void writeInitiativeReport(boolean abbreviatedReport) {<br/>
        // write to report<br/>
        Report r;<br/>
        boolean deployment = false;<br/>
        if (!abbreviatedReport) {<br/>
            r = new Report(1210);<br/>
            r.type = Report.PUBLIC;<br/>
            if ((game.getLastPhase() == IGame.PHASE_DEPLOYMENT) || game.isDeploymentComplete() || !game.shouldDeployThisRound()) {<br/>
                r.messageId = 1000;<br/>
                r.add(game.getRoundCount());<br/>
            } else {<br/>
                deployment = true;<br/>
                if ( game.getRoundCount() == 0 ) {<br/>
                    r.messageId = 1005;<br/>
                } else {<br/>
                    r.messageId = 1010;<br/>
                    r.add(game.getRoundCount());<br/>
                }<br/>
            }<br/>
            addReport(r);<br/>
<br/>
            //write seperator<br/>
            addReport(new Report(1200, Report.PUBLIC));<br/>
        } else {<br/>
            addReport(new Report(1210, Report.PUBLIC)); //newline<br/>
        }<br/>
<br/>
        if(game.getOptions().booleanOption("individual_initiative")) {<br/>
            r = new Report(1040, Report.PUBLIC);<br/>
            addReport(r);<br/>
            for(Enumeration&lt;GameTurn&gt; e = game.getTurns();e.hasMoreElements();) {<br/>
                GameTurn t = e.nextElement();<br/>
                if(t instanceof GameTurn.SpecificEntityTurn) {<br/>
                    Entity entity = game.getEntity(((GameTurn.SpecificEntityTurn)t).getEntityNum());<br/>
                    r = new Report(1045);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(entity.getInitiative().toString());<br/>
                    addReport(r);<br/>
                } else {<br/>
                    Player player = getPlayer( t.getPlayerNum() );<br/>
                    if ( null != player ) {<br/>
                        r = new Report(1050, Report.PUBLIC);<br/>
                        r.add(player.getName());<br/>
                        addReport(r);<br/>
                    }                    <br/>
                }<br/>
            }<br/>
        } else {<br/>
            for (Enumeration i = game.getTeams(); i.hasMoreElements();) {<br/>
                final Team team = (Team)i.nextElement();<br/>
    <br/>
                // If there is only one player, list them as the 'team', and<br/>
                // use the team iniative<br/>
                if (team.getSize() == 1) {<br/>
                    final Player player = (Player)team.getPlayers().nextElement();<br/>
                    r = new Report(1015, Report.PUBLIC);<br/>
                    r.add(player.getName());<br/>
                    r.add(team.getInitiative().toString());<br/>
                    addReport(r);<br/>
                } else {<br/>
                    // Multiple players.  List the team, then break it down.<br/>
                    r = new Report(1015, Report.PUBLIC);<br/>
                    r.add(Player.teamNames[team.getId()]);<br/>
                    r.add(team.getInitiative().toString());<br/>
                    addReport(r);<br/>
                    for( Enumeration j = team.getPlayers(); j.hasMoreElements();) {<br/>
                        final Player player = (Player)j.nextElement();<br/>
                        r = new Report(1015, Report.PUBLIC);<br/>
                        r.indent();<br/>
                        r.add(player.getName());<br/>
                        r.add(player.getInitiative().toString());<br/>
                        addReport(r);<br/>
                    }<br/>
                }<br/>
            }<br/>
    <br/>
            // The turn order is different in movement phase<br/>
            // if a player has any "even" moving units.<br/>
            r = new Report(1020, Report.PUBLIC);<br/>
    <br/>
            boolean firstTurn = true;<br/>
            boolean hasEven = false;<br/>
            for (Enumeration i = game.getTurns(); i.hasMoreElements();) {<br/>
                GameTurn turn = (GameTurn)i.nextElement();<br/>
                Player player = getPlayer( turn.getPlayerNum() );<br/>
                if ( null != player ) {<br/>
                    r.add(player.getName());<br/>
                    firstTurn = false;<br/>
                    if (player.getEvenTurns() &gt; 0)<br/>
                        hasEven = true;<br/>
                }<br/>
            }<br/>
            r.newlines = 2;<br/>
            addReport(r);<br/>
            if (hasEven) {<br/>
                r = new Report(1021, Report.PUBLIC);<br/>
                if ((game.getOptions().booleanOption("inf_deploy_even")<br/>
                    || game.getOptions().booleanOption("protos_deploy_even")) &amp;&amp;<br/>
                    !(game.getLastPhase() == IGame.PHASE_END_REPORT))<br/>
                    r.choose(true);<br/>
                else r.choose(false);<br/>
                r.indent();<br/>
                r.newlines = 2;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
        if (!abbreviatedReport) {<br/>
            //Wind direction and strength<br/>
            r = new Report(1025, Report.PUBLIC);<br/>
            r.add(game.getStringWindDirection());<br/>
            if (game.getWindStrength() != -1) {<br/>
                Report r2 = new Report(1030, Report.PUBLIC);<br/>
                r2.add(game.getStringWindStrength());<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
                addReport(r2);<br/>
            } else {<br/>
                addReport(r);<br/>
            }<br/>
<br/>
            if (deployment)<br/>
                addNewLines();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks ineligible entities as not ready for this phase<br/>
     */<br/>
    private void setIneligible(int phase) {<br/>
        Vector assistants = new Vector();<br/>
        boolean assistable = false;<br/>
        Entity entity = null;<br/>
        for (Enumeration e = game.getEntities(); e.hasMoreElements();) {<br/>
            entity = (Entity)e.nextElement();<br/>
            if (!entity.isEligibleFor(phase)) {<br/>
                assistants.addElement(entity);<br/>
            } else {<br/>
                assistable=true;<br/>
            }<br/>
        }<br/>
        for (int i=0;i&lt;assistants.size();i++) {<br/>
            entity = (Entity)assistants.elementAt(i);<br/>
            if(!assistable || !(entity.canAssist(phase))) {<br/>
                entity.setDone(true);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Have the loader load the indicated unit.<br/>
     * The unit being loaded loses its turn.<br/>
     *<br/>
     * @param   loader - the &lt;code&gt;Entity&lt;/code&gt; that is loading the unit.<br/>
     * @param   unit - the &lt;code&gt;Entity&lt;/code&gt; being loaded.<br/>
     */<br/>
    private void loadUnit( Entity loader, Entity unit ) {<br/>
<br/>
        // Remove the *last* friendly turn (removing the *first* penalizes<br/>
        // the opponent too much, and re-calculating moves is too hard).<br/>
        game.removeTurnFor(unit);<br/>
        send(createTurnVectorPacket());<br/>
<br/>
        // Load the unit.<br/>
        loader.load( unit );<br/>
<br/>
        // The loaded unit is being carried by the loader.<br/>
        unit.setTransportId( loader.getId() );<br/>
<br/>
        // Remove the loaded unit from the screen.<br/>
        unit.setPosition( null );<br/>
<br/>
        // Update the loaded unit.<br/>
        this.entityUpdate( unit.getId() );<br/>
    }<br/>
<br/>
    /**<br/>
     * Have the unloader unload the indicated unit.<br/>
     * The unit being unloaded does *not* gain a turn.<br/>
     *<br/>
     * @param   unloader - the &lt;code&gt;Entity&lt;/code&gt; that is unloading the unit.<br/>
     * @param   unloaded - the &lt;code&gt;Targetable&lt;/code&gt; unit being unloaded.<br/>
     * @param   pos - the &lt;code&gt;Coords&lt;/code&gt; for the unloaded unit.<br/>
     * @param   facing - the &lt;code&gt;int&lt;/code&gt; facing for the unloaded unit.<br/>
     * @param   elevation - the &lt;code&gt;int&lt;/code&gt; elevation at which to unload,<br/>
     *                      if both loader and loaded units use VTOL movement.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the unit was successfully unloaded,<br/>
     *          &lt;code&gt;false&lt;/code&gt; if the unit isn't carried in unloader.<br/>
     */<br/>
    private boolean unloadUnit( Entity unloader, Targetable unloaded,<br/>
                             Coords pos, int facing, int elevation ) {<br/>
<br/>
        // We can only unload Entities.<br/>
        Entity unit = null;<br/>
        if ( unloaded instanceof Entity ) {<br/>
            unit = (Entity) unloaded;<br/>
        } else {<br/>
            return false;<br/>
        }<br/>
<br/>
        // Unload the unit.<br/>
        if ( !unloader.unload( unit ) ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // The unloaded unit is no longer being carried.<br/>
        unit.setTransportId( Entity.NONE );<br/>
<br/>
        // Place the unloaded unit onto the screen.<br/>
        unit.setPosition( pos );<br/>
<br/>
        // Units unloaded onto the screen are deployed.<br/>
        if ( pos != null ) {<br/>
            unit.setDeployed( true );<br/>
        }<br/>
<br/>
        // Point the unloaded unit in the given direction.<br/>
        unit.setFacing( facing );<br/>
        unit.setSecondaryFacing( facing );<br/>
        <br/>
        IHex hex = game.getBoard().getHex(pos);<br/>
        boolean isBridge = hex.containsTerrain(Terrains.PAVEMENT);<br/>
<br/>
        if (unloader.getMovementMode() == IEntityMovementMode.VTOL) {<br/>
            if (unit.getMovementMode() == IEntityMovementMode.VTOL) {<br/>
                // Flying units onload to the same elevation as the flying transport<br/>
                unit.setElevation(elevation);<br/>
            } else if (game.getBoard().getBuildingAt(pos) != null) {<br/>
                // non-flying unit onloaded from a flying onto a building<br/>
                // -&gt; sit on the roff<br/>
                unit.setElevation(hex.terrainLevel(Terrains.BLDG_ELEV));<br/>
            }<br/>
        } else if (game.getBoard().getBuildingAt(pos) != null) {<br/>
            // non flying unit unloading units into a building<br/>
            // -&gt; sit in the building at the same elevation<br/>
            unit.setElevation(elevation);<br/>
        } else if (hex.terrainLevel(Terrains.WATER)&gt;0) {<br/>
            if (unit.getMovementMode() == IEntityMovementMode.HOVER ||<br/>
                unit.getMovementMode() == IEntityMovementMode.HYDROFOIL ||<br/>
                unit.getMovementMode() == IEntityMovementMode.NAVAL ||<br/>
                unit.getMovementMode() == IEntityMovementMode.SUBMARINE ||<br/>
                hex.containsTerrain(Terrains.ICE) ||<br/>
                isBridge) {<br/>
                // units that can float stay on the surface, or we go on the bridge<br/>
                // this means elevation 0, because elevation is relative to the surface<br/>
                unit.setElevation(0);<br/>
            } <br/>
        } else {<br/>
            // default to the floor of the hex.<br/>
            // unit elevation is relative to the surface <br/>
            unit.setElevation(hex.floor() - hex.surface());<br/>
        }<br/>
        doSetLocationsExposure(unit, hex, false, unit.getElevation());<br/>
<br/>
        // Update the unloaded unit.<br/>
        this.entityUpdate( unit.getId() );<br/>
<br/>
        // Unloaded successfully.<br/>
        return true;<br/>
    }<br/>
<br/>
    /**<br/>
     * Record that the given building has been affected by the current<br/>
     * entity's movement.  At the end of the entity's movement, notify<br/>
     * the clients about the updates.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that has been affected.<br/>
     * @param   collapse - a &lt;code&gt;boolean&lt;/code&gt; value that specifies that<br/>
     *          the building collapsed (when &lt;code&gt;true&lt;/code&gt;).<br/>
     */<br/>
    private void addAffectedBldg( Building bldg, boolean collapse ) {<br/>
<br/>
        // If the building collapsed, then the clients have already<br/>
        // been notified, so remove it from the notification list.<br/>
        if ( collapse ) {<br/>
            System.err.print( "Removing building from a list of " + affectedBldgs.size() + "\n" );//killme<br/>
            this.affectedBldgs.remove( bldg );<br/>
            System.err.print( "... now list of " + affectedBldgs.size() + "\n" );//killme<br/>
        }<br/>
<br/>
        // Otherwise, make sure that this building is tracked.<br/>
        else {<br/>
            this.affectedBldgs.put( bldg, Boolean.FALSE );<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Walk through the building hexes that were affected by the recent<br/>
     * entity's movement.  Notify the clients about the updates to all<br/>
     * affected entities and uncollapsed buildings.  The affected hexes<br/>
     * is then cleared for the next entity's movement.<br/>
     */<br/>
    private void applyAffectedBldgs() {<br/>
<br/>
        // Build a list of Building updates.<br/>
        Vector bldgUpdates = new Vector();<br/>
<br/>
        // Only send a single turn update.<br/>
        boolean bTurnsChanged = false;<br/>
<br/>
        // Walk the set of buildings.<br/>
        Enumeration bldgs = this.affectedBldgs.keys();<br/>
        while ( bldgs.hasMoreElements() ) {<br/>
            final Building bldg = (Building) bldgs.nextElement();<br/>
<br/>
            // Walk through the building's coordinates.<br/>
            Enumeration bldgCoords = bldg.getCoords();<br/>
            while ( bldgCoords.hasMoreElements() ) {<br/>
                final Coords coords = (Coords) bldgCoords.nextElement();<br/>
<br/>
                // Walk through the entities at these coordinates.<br/>
                Enumeration entities = game.getEntities( coords );<br/>
                while( entities.hasMoreElements() ) {<br/>
                    final Entity entity = (Entity) entities.nextElement();<br/>
<br/>
                    // Is the entity infantry?<br/>
                    if ( entity instanceof Infantry ) {<br/>
<br/>
                        // Is the infantry dead?<br/>
                        if ( entity.isDoomed() || entity.isDestroyed() ) {<br/>
<br/>
                            // Has the entity taken a turn?<br/>
                            if ( !entity.isDone() ) {<br/>
<br/>
                                // Dead entities don't take turns.<br/>
                                game.removeTurnFor(entity);<br/>
                                bTurnsChanged = true;<br/>
<br/>
                            } // End entity-still-to-move<br/>
<br/>
                            // Clean out the dead entity.<br/>
                            entity.setDestroyed(true);<br/>
                            game.moveToGraveyard(entity.getId());<br/>
                            send(createRemoveEntityPacket(entity.getId()));<br/>
                        }<br/>
<br/>
                        // Infantry that aren't dead are damaged.<br/>
                        else {<br/>
                            this.entityUpdate( entity.getId() );<br/>
                        }<br/>
<br/>
                    } // End entity-is-infantry<br/>
<br/>
                } // Check the next entity.<br/>
<br/>
            } // Handle the next hex in this building.<br/>
<br/>
            // Add this building to the report.<br/>
            bldgUpdates.addElement( bldg );<br/>
<br/>
        } // Handle the next affected building.<br/>
<br/>
        // Did we update the turns?<br/>
        if ( bTurnsChanged ) {<br/>
            send(createTurnVectorPacket());<br/>
        }<br/>
<br/>
        // Are there any building updates?<br/>
        if ( !bldgUpdates.isEmpty() ) {<br/>
<br/>
            // Send the building updates to the clients.<br/>
            sendChangedCFBuildings( bldgUpdates );<br/>
<br/>
            // Clear the list of affected buildings.<br/>
            this.affectedBldgs.clear();<br/>
        }<br/>
<br/>
        // And we're done.<br/>
        return;<br/>
<br/>
    } // End private void applyAffectedBldgs()<br/>
<br/>
    /**<br/>
     * Receives an entity movement packet, and if valid, executes it and ends<br/>
     * the current turn.<br/>
     *<br/>
     */<br/>
    private void receiveMovement(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        MovePath md = (MovePath)packet.getObject(1);<br/>
<br/>
        // is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_MOVEMENT) {<br/>
            System.err.println("error: server got movement packet in wrong phase");<br/>
            return;<br/>
        }<br/>
<br/>
        // can this player/entity act right now?<br/>
        if (!game.getTurn().isValid(connId, entity, game)) {<br/>
            System.err.println("error: server got invalid movement packet");<br/>
            return;<br/>
        }<br/>
<br/>
        // looks like mostly everything's okay<br/>
        processMovement(entity, md);<br/>
<br/>
        // Notify the clients about any building updates.<br/>
        applyAffectedBldgs();<br/>
<br/>
        // Update visibility indications if using double blind.<br/>
        if (doBlind()) {<br/>
            updateVisibilityIndicator();<br/>
        }<br/>
<br/>
        // This entity's turn is over.<br/>
        // N.B. if the entity fell, a *new* turn has already been added.<br/>
        endCurrentTurn(entity);<br/>
    }<br/>
<br/>
    /**<br/>
     * Steps through an entity movement packet, executing it.<br/>
     */<br/>
    private void processMovement(Entity entity, MovePath md) {<br/>
        Report r;<br/>
        boolean sideslipped = false; // for VTOL sideslipping<br/>
        <br/>
        // check for fleeing<br/>
        if (md.contains(MovePath.STEP_FLEE)) {<br/>
            // Unit has fled the battlefield.<br/>
            r = new Report(2005, Report.PUBLIC);<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
<br/>
            // Is the unit carrying passengers?<br/>
            final Vector passengers = entity.getLoadedUnits();<br/>
            if ( !passengers.isEmpty() ) {<br/>
                final Enumeration iter = passengers.elements();<br/>
                while ( iter.hasMoreElements() ) {<br/>
                    final Entity passenger = (Entity) iter.nextElement();<br/>
                    // Unit has fled the battlefield.<br/>
                    r = new Report(2010, Report.PUBLIC);<br/>
                    r.indent();<br/>
                    r.addDesc(passenger);<br/>
                    addReport(r);<br/>
                    game.removeEntity( passenger.getId(),<br/>
                            IEntityRemovalConditions.REMOVE_IN_RETREAT );<br/>
                    send( createRemoveEntityPacket(passenger.getId(),<br/>
                            IEntityRemovalConditions.REMOVE_IN_RETREAT) );<br/>
                }<br/>
            }<br/>
<br/>
            // Handle any picked up MechWarriors<br/>
            Enumeration iter = entity.getPickedUpMechWarriors().elements();<br/>
            while (iter.hasMoreElements() ) {<br/>
                Integer mechWarriorId = (Integer)iter.nextElement();<br/>
                Entity mw = game.getEntity(mechWarriorId.intValue());<br/>
<br/>
                // Is the MechWarrior an enemy?<br/>
                int condition = IEntityRemovalConditions.REMOVE_IN_RETREAT;<br/>
                r = new Report(2010);<br/>
                if (mw.isCaptured()) {<br/>
                    r = new Report(2015);<br/>
                    condition = IEntityRemovalConditions.REMOVE_CAPTURED;<br/>
                }<br/>
                game.removeEntity( mw.getId(), condition );<br/>
                send( createRemoveEntityPacket(mw.getId(), condition) );<br/>
                r.addDesc(mw);<br/>
                r.indent();<br/>
                addReport(r);<br/>
            }<br/>
<br/>
            // Is the unit being swarmed?<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
<br/>
                // Has the swarmer taken a turn?<br/>
                if ( !swarmer.isDone() ) {<br/>
<br/>
                    // Dead entities don't take turns.<br/>
                    game.removeTurnFor(swarmer);<br/>
                    send(createTurnVectorPacket());<br/>
<br/>
                } // End swarmer-still-to-move<br/>
<br/>
                // Unit has fled the battlefield.<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                r = new Report(2015, Report.PUBLIC);<br/>
                r.indent();<br/>
                r.addDesc(swarmer);<br/>
                addReport(r);<br/>
                game.removeEntity( swarmerId, IEntityRemovalConditions.REMOVE_CAPTURED );<br/>
                send( createRemoveEntityPacket(swarmerId,<br/>
                        IEntityRemovalConditions.REMOVE_CAPTURED) );<br/>
            }<br/>
            game.removeEntity( entity.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT );<br/>
            send( createRemoveEntityPacket(entity.getId(),<br/>
                    IEntityRemovalConditions.REMOVE_IN_RETREAT) );<br/>
            return;<br/>
        }<br/>
<br/>
        if (md.contains(MovePath.STEP_EJECT)) {<br/>
            if (entity instanceof Mech) {<br/>
                r = new Report(2020);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getCrew().getName());<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
            } else if (entity instanceof Tank) {<br/>
                r = new Report(2025);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
            }<br/>
            addReport( ejectEntity(entity, false));<br/>
<br/>
            return;<br/>
        }<br/>
<br/>
        // okay, proceed with movement calculations<br/>
        Coords lastPos = entity.getPosition();<br/>
        Coords curPos = entity.getPosition();<br/>
        int curFacing = entity.getFacing();<br/>
        int curVTOLElevation = entity.getElevation();<br/>
        int distance = 0;<br/>
        int mpUsed = 0;<br/>
        int moveType = IEntityMovementType.MOVE_NONE;<br/>
        int overallMoveType = IEntityMovementType.MOVE_NONE;<br/>
        // if the entity already used some MPs,<br/>
        // it previously tried to get up and fell,<br/>
        // and then got another turn. set moveType<br/>
        // and overallMoveType accordingly<br/>
        if (entity.mpUsed &gt; 0) {<br/>
            moveType = IEntityMovementType.MOVE_WALK;<br/>
            overallMoveType = IEntityMovementType.MOVE_WALK;<br/>
            if (entity.mpUsed &gt; entity.getWalkMP()) {<br/>
                moveType = IEntityMovementType.MOVE_RUN;<br/>
                overallMoveType = IEntityMovementType.MOVE_RUN;<br/>
            }<br/>
        }<br/>
        boolean firstStep;<br/>
        boolean wasProne;<br/>
        boolean fellDuringMovement;<br/>
        int prevFacing = curFacing;<br/>
        IHex prevHex = null;<br/>
        final boolean isInfantry = (entity instanceof Infantry);<br/>
        AttackAction charge = null;<br/>
        PilotingRollData rollTarget;<br/>
        // cache this here, otherwise changing MP in the turn causes <br/>
        // errorneous gravity PSRs<br/>
        int cachedGravityLimit = (IEntityMovementType.MOVE_JUMP == moveType)?<br/>
            entity.getOriginalJumpMP() : entity.getRunMP(false); <br/>
<br/>
        // Compile the move<br/>
        md.compile(game, entity);<br/>
<br/>
        if (md.contains(MovePath.STEP_CLEAR_MINEFIELD)) {<br/>
            ClearMinefieldAction cma = new ClearMinefieldAction(entity.getId());<br/>
            entity.setClearingMinefield(true);<br/>
            game.addAction(cma);<br/>
        }<br/>
<br/>
        // check for MASC failure<br/>
        if (entity instanceof Mech) {<br/>
            Vector crits = new Vector();<br/>
            Vector vReport = new Vector();<br/>
            if (((Mech)entity).checkForMASCFailure(md, vReport, crits)) {<br/>
                addReport(vReport);<br/>
                CriticalSlot cs = null;<br/>
                int loc = Entity.LOC_NONE;<br/>
                for(Enumeration e = crits.elements();e.hasMoreElements();) {<br/>
                    Object o = e.nextElement();<br/>
                    if(o instanceof Integer)<br/>
                        loc = (Integer) o;<br/>
                    else if (o instanceof CriticalSlot) {<br/>
                        cs = (CriticalSlot) o;<br/>
                        applyCriticalHit(entity, loc, cs, true);<br/>
                    }<br/>
                }<br/>
                // no movement after that<br/>
                md.clear();<br/>
            }<br/>
        }<br/>
<br/>
        overallMoveType = md.getLastStepMovementType();<br/>
<br/>
        //check for starting in liquid magma<br/>
        if(game.getBoard().getHex(entity.getPosition()).terrainLevel(Terrains.MAGMA) == 2<br/>
            &amp;&amp; entity.getElevation() == 0) {<br/>
            doMagmaDamage(entity, false);<br/>
        }            <br/>
<br/>
        // iterate through steps<br/>
        firstStep = true;<br/>
        fellDuringMovement = false;<br/>
        /* Bug 754610: Revert fix for bug 702735. */<br/>
        MoveStep prevStep = null;<br/>
<br/>
        Vector movePath = new Vector();<br/>
<br/>
        for (final Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MoveStep step = (MoveStep)i.nextElement();<br/>
            wasProne = entity.isProne();<br/>
            boolean isPavementStep = step.isPavementStep();<br/>
            boolean entityFellWhileAttemptingToStand = false;<br/>
<br/>
            // stop for illegal movement<br/>
            if (step.getMovementType() == IEntityMovementType.MOVE_ILLEGAL) {<br/>
                break;<br/>
            }<br/>
            <br/>
            //stop if the entity already killed itself<br/>
            if(entity.isDestroyed() || entity.isDoomed()) {<br/>
                break;<br/>
            }<br/>
            <br/>
            // check piloting skill for getting up<br/>
            rollTarget = entity.checkGetUp(step);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                entity.heatBuildup += 1;<br/>
                entity.setProne(false);<br/>
                entity.setHullDown(false);<br/>
                wasProne = false;<br/>
                game.resetPSRs(entity);<br/>
                entityFellWhileAttemptingToStand = !doSkillCheckInPlace(entity, rollTarget);<br/>
            }<br/>
            // did the entity just fall?<br/>
            if (entityFellWhileAttemptingToStand) {<br/>
                moveType = step.getMovementType();<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                mpUsed = step.getMpUsed();<br/>
                fellDuringMovement = true;<br/>
                break;<br/>
            }<br/>
<br/>
            if (step.getType() == MovePath.STEP_UNJAM_RAC) {<br/>
                entity.setUnjammingRAC(true);<br/>
                game.addAction(new UnjamAction(entity.getId()));<br/>
<br/>
                break;<br/>
            }<br/>
            <br/>
            if (step.getType() == MovePath.STEP_LAY_MINE) {<br/>
                LayMinefieldAction lma = new LayMinefieldAction(entity.getId(), step.getMineToLay());<br/>
                game.addLayMinefieldAction(lma);<br/>
                entity.setLayingMines(true);<br/>
                break;<br/>
            }<br/>
<br/>
            if (step.getType() == MovePath.STEP_SEARCHLIGHT &amp;&amp; entity.hasSpotlight()) {<br/>
                final boolean SearchOn = !entity.isUsingSpotlight();<br/>
                entity.setSpotlightState(SearchOn);<br/>
                sendServerChat(entity.getDisplayName() + " switched searchlight "+(SearchOn?"on":"off")+".");<br/>
            }<br/>
<br/>
            // set most step parameters<br/>
            moveType = step.getMovementType();<br/>
            distance = step.getDistance();<br/>
            mpUsed = step.getMpUsed();<br/>
<br/>
            // check for charge<br/>
            if (step.getType() == MovePath.STEP_CHARGE) {<br/>
                if (entity.canCharge()) {<br/>
                    checkExtremeGravityMovement(entity, step, curPos, cachedGravityLimit);<br/>
                    Targetable target = step.getTarget( game );<br/>
                    ChargeAttackAction caa = new ChargeAttackAction(entity.getId(), target.getTargetType(), target.getTargetId(), target.getPosition());<br/>
                    entity.setDisplacementAttack(caa);<br/>
                    game.addCharge(caa);<br/>
                    charge = caa;<br/>
                } else {<br/>
                    sendServerChat("Illegal charge!! I don't think "+entity.getDisplayName() +" should be allowed to charge,"+<br/>
                                   " but the client of "+entity.getOwner().getName()+" disagrees.");<br/>
                    sendServerChat("Please make sure "+entity.getOwner().getName()+" is running MegaMek "+MegaMek.VERSION+<br/>
                                   ", or if that is already the case, submit a bug report at http://megamek.sf.net/");<br/>
                    return;<br/>
                }<br/>
                break;<br/>
            }<br/>
<br/>
            // check for dfa<br/>
            if (step.getType() == MovePath.STEP_DFA) {<br/>
                if (entity.canDFA()) {<br/>
                    checkExtremeGravityMovement(entity, step, curPos, cachedGravityLimit);<br/>
                    Targetable target = step.getTarget( game );<br/>
                    DfaAttackAction daa = new DfaAttackAction(entity.getId(), target.getTargetType(), target.getTargetId(), target.getPosition());<br/>
                    entity.setDisplacementAttack(daa);<br/>
                    game.addCharge(daa);<br/>
                    charge = daa;<br/>
                } else {<br/>
                    sendServerChat("Illegal DFA!! I don't think "+entity.getDisplayName() +" should be allowed to DFA,"+<br/>
                                   " but the client of "+entity.getOwner().getName()+" disagrees.");<br/>
                    sendServerChat("Please make sure "+entity.getOwner().getName()+" is running MegaMek "+MegaMek.VERSION+<br/>
                                   ", or if that is already the case, submit a bug report at http://megamek.sf.net/");<br/>
                    return;<br/>
                }<br/>
                break;<br/>
            }<br/>
<br/>
            // set last step parameters<br/>
            curPos = step.getPosition();<br/>
            if(moveType != IEntityMovementType.MOVE_JUMP || entity.getJumpType() != Mech.JUMP_BOOSTER)<br/>
                curFacing = step.getFacing();<br/>
            curVTOLElevation = step.getElevation();<br/>
            //set elevation in case of collapses<br/>
            entity.setElevation(step.getElevation());<br/>
<br/>
            final IHex curHex = game.getBoard().getHex(curPos);<br/>
<br/>
            // check for automatic unstick<br/>
            if(entity.canUnstickByJumping() &amp;&amp; entity.isStuck() &amp;&amp; moveType == IEntityMovementType.MOVE_JUMP) {<br/>
                entity.setStuck(false);<br/>
                entity.setCanUnstickByJumping(false);<br/>
            }<br/>
<br/>
            // Check for skid.<br/>
            rollTarget = entity.checkSkid(moveType, prevHex, overallMoveType,<br/>
                                          prevStep, prevFacing, curFacing,<br/>
                                          lastPos, curPos, isInfantry,<br/>
                                          distance);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                // Have an entity-meaningful PSR message.<br/>
                boolean psrPassed = true;<br/>
                if ( entity instanceof Mech ) {<br/>
                    psrPassed = doSkillCheckWhileMoving( entity, lastPos,<br/>
                                                          lastPos, rollTarget,<br/>
                                                          true );<br/>
                } else {<br/>
                    psrPassed = doSkillCheckWhileMoving( entity, lastPos,<br/>
                                                          lastPos, rollTarget,<br/>
                                                          false );<br/>
                }<br/>
                // Does the entity skid?<br/>
                if ( !psrPassed ){<br/>
<br/>
                    curPos = lastPos;<br/>
                    Coords nextPos = curPos;<br/>
                    IHex    nextHex = null;<br/>
                    int    skidDistance = 0;<br/>
                    Enumeration targets = null;<br/>
                    Entity target = null;<br/>
                    int    curElevation;<br/>
                    int    nextElevation;<br/>
                    int skidDirection = prevFacing;<br/>
<br/>
                    // All charge damage is based upon<br/>
                    // the pre-skid move distance.<br/>
                    entity.delta_distance = distance-1;<br/>
<br/>
                    // Attacks against a skidding target have additional +2.<br/>
                    moveType = IEntityMovementType.MOVE_SKID;<br/>
<br/>
                    // What is the first hex in the skid?<br/>
                    if(step.isThisStepBackwards()) {<br/>
                        skidDirection = (skidDirection + 3) % 6;<br/>
                    }<br/>
                    nextPos = curPos.translated( skidDirection );<br/>
                    nextHex = game.getBoard().getHex( nextPos );<br/>
<br/>
                    // Move the entity a number hexes from curPos in the<br/>
                    // skidDirection direction equal to half the distance moved<br/>
                    // this turn (rounded up), unless something intervenes.<br/>
                    for ( skidDistance = 0;<br/>
                          skidDistance &lt; (int) Math.ceil(entity.delta_distance / 2.0);<br/>
                          skidDistance++ ) {<br/>
<br/>
                        // Is the next hex off the board?<br/>
                        if ( !game.getBoard().contains(nextPos) ) {<br/>
<br/>
                            // Can the entity skid off the map?<br/>
                            if (game.getOptions().booleanOption("push_off_board")) {<br/>
                                // Yup.  One dead entity.<br/>
                                game.removeEntity(entity.getId(),<br/>
                                        IEntityRemovalConditions.REMOVE_PUSHED);<br/>
                                send(createRemoveEntityPacket(entity.getId(),<br/>
                                        IEntityRemovalConditions.REMOVE_PUSHED));<br/>
                                r = new Report(2030, Report.PUBLIC);<br/>
                                r.addDesc(entity);<br/>
                                addReport(r);<br/>
<br/>
                                // TODO: remove passengers and swarmers.<br/>
<br/>
                                // The entity's movement is completed.<br/>
                                return;<br/>
<br/>
                            } else {<br/>
                                // Nope.  Update the report.<br/>
                                r = new Report(2035);<br/>
                                r.subject = entity.getId();<br/>
                                r.indent();<br/>
                                addReport(r);<br/>
                            }<br/>
                            // Stay in the current hex and stop skidding.<br/>
                            break;<br/>
                        }<br/>
                        <br/>
                        // Can the skiding entity enter the next hex from this?<br/>
                        // N.B. can skid along roads.<br/>
                        if ( ( entity.isHexProhibited(curHex) ||<br/>
                               entity.isHexProhibited(nextHex) ) &amp;&amp;<br/>
                             !Compute.canMoveOnPavement(game, curPos, nextPos)<br/>
                             ) {<br/>
                            // Update report.<br/>
                            r = new Report(2040);<br/>
                            r.subject = entity.getId();<br/>
                            r.indent();<br/>
                            r.add(nextPos.getBoardNum(), true);<br/>
                            addReport(r);<br/>
<br/>
                            // N.B. the BMRr pg. 22 says that the unit<br/>
                            // "crashes" into the terrain but it doesn't<br/>
                            // mention any damage.<br/>
<br/>
                            // Stay in the current hex and stop skidding.<br/>
                            break;<br/>
                        }<br/>
<br/>
                        // Hovercraft can "skid" over water.<br/>
                        // all units can skid over ice.<br/>
                        // TODO: allow entities to occupy different levels of<br/>
                        //       buildings.<br/>
                        curElevation = curHex.floor();<br/>
                        nextElevation = nextHex.floor();<br/>
                        if ( entity instanceof Tank &amp;&amp;<br/>
                             entity.getMovementMode() ==<br/>
                             IEntityMovementMode.HOVER ) {<br/>
                            if ( curHex.containsTerrain(Terrains.WATER) ) {<br/>
                                curElevation = curHex.surface();<br/>
                            }<br/>
                            if ( nextHex.containsTerrain(Terrains.WATER) ) {<br/>
                                nextElevation += nextHex.surface();<br/>
                            }<br/>
                        } else {<br/>
                            if(curHex.containsTerrain(Terrains.ICE)) {<br/>
                                curElevation = curHex.surface();<br/>
                            }<br/>
                            if(nextHex.containsTerrain(Terrains.ICE)) {<br/>
                                nextElevation = nextHex.surface();<br/>
                            }<br/>
                        }<br/>
<br/>
                        // BMRr pg. 22 - Can't skid uphill,<br/>
                        //      but can skid downhill.<br/>
                        if ( curElevation &lt; nextElevation ) {<br/>
                            r = new Report(2045);<br/>
                            r.subject = entity.getId();<br/>
                            r.indent();<br/>
                            r.add(nextPos.getBoardNum(), true);<br/>
                            addReport(r);<br/>
<br/>
                            // Stay in the current hex and stop skidding.<br/>
                            break;<br/>
                        }<br/>
<br/>
                        // Have skidding units suffer falls.<br/>
                        else if ( curElevation &gt; nextElevation + 1 ) {<br/>
                            doEntityFallsInto( entity, curPos, nextPos,<br/>
                                               entity.getBasePilotingRoll() );<br/>
                            doEntityDisplacementMinefieldCheck(entity, curPos, nextPos);<br/>
                            // Stay in the current hex and stop skidding.<br/>
                            break;<br/>
                        }<br/>
<br/>
                        // Get any building in the hex.<br/>
                        Building bldg = game.getBoard().getBuildingAt(nextPos);<br/>
                        boolean bldgSuffered = false;<br/>
                        boolean stopTheSkid = false;<br/>
                        // Does the next hex contain an entities?<br/>
                        // ASSUMPTION: hurt EVERYONE in the hex.<br/>
                        // TODO: allow entities to occupy different levels of<br/>
                        //       buildings, and only skid into a single level.<br/>
                        targets = game.getEntities( nextPos );<br/>
                        if ( targets.hasMoreElements()) {<br/>
                            boolean skidChargeHit = false;<br/>
                            while ( targets.hasMoreElements() ) {<br/>
                                target = (Entity) targets.nextElement();<br/>
<br/>
                                // TODO : allow ready targets to move out of way<br/>
<br/>
                                // Mechs and vehicles get charged,<br/>
                                // but need to make a to-hit roll<br/>
                                if ( target instanceof Mech ||<br/>
                                     target instanceof Tank ) {<br/>
                                    ChargeAttackAction caa = new ChargeAttackAction(entity.getId(), target.getTargetType(), target.getTargetId(), target.getPosition());<br/>
                                    ToHitData toHit = caa.toHit(game, true);<br/>
<br/>
                                    // Calculate hit location.<br/>
                                    if ( entity instanceof Tank<br/>
                                         &amp;&amp; ((entity.getMovementMode() == IEntityMovementMode.HOVER)<br/>
                                         || (entity.getMovementMode() == IEntityMovementMode.NAVAL)<br/>
                                         || (entity.getMovementMode() == IEntityMovementMode.HYDROFOIL))<br/>
                                         &amp;&amp; 0 &lt; nextHex.terrainLevel(Terrains.WATER)<br/>
                                         &amp;&amp; target.getElevation() &lt; 0) {<br/>
                                        if ( 2 &lt;= nextHex.terrainLevel(Terrains.WATER) ||<br/>
                                             target.isProne() ) {<br/>
                                            // Hovercraft/Naval Craft can't hit the Mek.<br/>
                                            continue;<br/>
                                        }<br/>
                                        else {<br/>
                                            toHit.setHitTable(ToHitData.HIT_PUNCH);<br/>
                                        }<br/>
                                    } else if ( entity.getHeight() &lt;<br/>
                                                target.getHeight() ) {<br/>
                                        toHit.setHitTable(ToHitData.HIT_KICK);<br/>
                                    } else {<br/>
                                        toHit.setHitTable(ToHitData.HIT_NORMAL);<br/>
                                    }<br/>
                                    toHit.setSideTable<br/>
                                        (Compute.targetSideTable(entity, target));<br/>
<br/>
                                    // roll<br/>
                                    int roll = Compute.d6(2);<br/>
                                    // Update report.<br/>
                                    r = new Report(2050);<br/>
                                    r.subject = entity.getId();<br/>
                                    r.indent();<br/>
                                    r.add(target.getShortName(), true);<br/>
                                    r.add(nextPos.getBoardNum(), true);<br/>
                                    r.newlines = 0;<br/>
                                    addReport(r);<br/>
                                    if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
                                        roll = -12;<br/>
                                        r = new Report(2055);<br/>
                                        r.subject = entity.getId();<br/>
                                        r.add(toHit.getDesc());<br/>
                                        r.newlines = 0;<br/>
                                        addReport(r);<br/>
                                    } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
                                        r = new Report(2060);<br/>
                                        r.subject = entity.getId();<br/>
                                        r.add(toHit.getDesc());<br/>
                                        r.newlines = 0;<br/>
                                        addReport(r);<br/>
                                        roll = Integer.MAX_VALUE;<br/>
                                    } else {<br/>
                                        // report the roll<br/>
                                        r = new Report(2065);<br/>
                                        r.subject = entity.getId();<br/>
                                        r.add(toHit.getValue());<br/>
                                        r.add(roll);<br/>
                                        r.newlines = 0;<br/>
                                        addReport(r);<br/>
                                    }<br/>
<br/>
                                    // Resolve a charge against the target.<br/>
                                    // ASSUMPTION: buildings block damage for<br/>
                                    //             *EACH* entity charged.<br/>
                                    if (roll &lt; toHit.getValue()) {<br/>
                                        r = new Report(2070);<br/>
                                        r.subject = entity.getId();<br/>
                                        addReport(r);<br/>
                                    } else {<br/>
                                        // Resolve the charge.<br/>
                                        resolveChargeDamage<br/>
                                            (entity, target, toHit, skidDirection);<br/>
                                        // HACK: set the entity's location<br/>
                                        // to the original hex again, for the other targets<br/>
                                        if (targets.hasMoreElements()) {<br/>
                                            entity.setPosition(curPos);<br/>
                                        }<br/>
                                        bldgSuffered = true;<br/>
                                        skidChargeHit = true;<br/>
                                    }<br/>
                                    // The skid ends here if the target lives.<br/>
                                    if ( !target.isDoomed() &amp;&amp;<br/>
                                         !target.isDestroyed() &amp;&amp;<br/>
                                         !game.isOutOfGame(target) ) {<br/>
                                        stopTheSkid = true;<br/>
                                    }<br/>
<br/>
                                    // if we don't do this here,<br/>
                                    // we can have a mech without a leg<br/>
                                    // standing on the field and moving<br/>
                                    // as if it still had his leg after<br/>
                                    // getting skid-charged.<br/>
                                    if (!target.isDone()) {<br/>
                                        resolvePilotingRolls(target);<br/>
                                        game.resetPSRs(target);<br/>
                                        target.applyDamage();<br/>
                                        addNewLines();<br/>
                                    }<br/>
<br/>
                                }<br/>
<br/>
                                // Resolve "move-through" damage on infantry.<br/>
                                // Infantry inside of a building don't get a<br/>
                                // move-through, but suffer "bleed through"<br/>
                                // from the building.<br/>
                                else if ( target instanceof Infantry &amp;&amp;<br/>
                                          bldg != null ) {<br/>
                                    // Update report.<br/>
                                    r = new Report(2075);<br/>
                                    r.subject = entity.getId();<br/>
                                    r.indent();<br/>
                                    r.add(target.getShortName(), true);<br/>
                                    r.add(nextPos.getBoardNum(), true);<br/>
                                    r.newlines = 0;<br/>
                                    addReport(r);<br/>
<br/>
                                    // Infantry don't have different<br/>
                                    // tables for punches and kicks<br/>
                                    HitData hit = target.rollHitLocation( ToHitData.HIT_NORMAL, Compute.targetSideTable(entity, target) );<br/>
<br/>
                                    // Damage equals tonnage, divided by 5.<br/>
                                    // ASSUMPTION: damage is applied in one hit.<br/>
                                    addReport(<br/>
                                      damageEntity(target, hit,<br/>
                                      Math.round(entity.getWeight()/5)));<br/>
                                    addNewLines();<br/>
                                }<br/>
<br/>
                                // Has the target been destroyed?<br/>
                                if ( target.isDoomed() ) {<br/>
<br/>
                                    // Has the target taken a turn?<br/>
                                    if ( !target.isDone() ) {<br/>
<br/>
                                        // Dead entities don't take turns.<br/>
                                        game.removeTurnFor(target);<br/>
                                        send(createTurnVectorPacket());<br/>
<br/>
                                    } // End target-still-to-move<br/>
<br/>
                                    // Clean out the entity.<br/>
                                    target.setDestroyed(true);<br/>
                                    game.moveToGraveyard(target.getId());<br/>
                                    send(createRemoveEntityPacket(target.getId()));<br/>
                                }<br/>
<br/>
                                // Update the target's position,<br/>
                                // unless it is off the game map.<br/>
                                if ( !game.isOutOfGame(target) ) {<br/>
                                    entityUpdate( target.getId() );<br/>
                                }<br/>
<br/>
                            } // Check the next entity in the hex.<br/>
<br/>
                            // if we missed all the entities in the hex,<br/>
                            // move attacker to side hex<br/>
                            if (!skidChargeHit) {<br/>
                                Coords src = entity.getPosition();<br/>
                                Coords dest = Compute.getMissedChargeDisplacement<br/>
                                    (game, entity.getId(), src, skidDirection);<br/>
                                doEntityDisplacement(entity, src, dest, null);<br/>
                            } else {<br/>
                                // HACK: otherwise, set the entities position to that<br/>
                                // hex's coords, because we had to move the entity<br/>
                                // back earlier for the other targets<br/>
                                entity.setPosition(nextPos);<br/>
                            }<br/>
                        }<br/>
<br/>
                        // Handle the building in the hex.<br/>
                        // TODO : BMRr pg. 22, only count buildings that are<br/>
                        //      higher than our starting terrain height.<br/>
                        // TODO: allow units to skid on top of buildings.<br/>
                        if ( bldg != null ) {<br/>
<br/>
                            // Report that the entity has entered the bldg.<br/>
                            r = new Report(2080);<br/>
                            r.subject = entity.getId();<br/>
                            r.indent();<br/>
                            r.add(bldg.getName());<br/>
                            r.add(nextPos.getBoardNum(), true);<br/>
                            addReport(r);<br/>
<br/>
                            // If the building hasn't already suffered<br/>
                            // damage, then apply charge damage to the<br/>
                            // building and displace the entity inside.<br/>
                            // ASSUMPTION: you don't charge the building<br/>
                            //             if Tanks or Mechs were charged.<br/>
                            int chargeDamage = ChargeAttackAction.getDamageFor<br/>
                                ( entity );<br/>
                            if ( !bldgSuffered ) {<br/>
                                Report buildingReport = damageBuilding( bldg, chargeDamage );<br/>
                                buildingReport.indent(2);<br/>
                                buildingReport.subject = entity.getId();<br/>
                                addReport(buildingReport);<br/>
<br/>
                                // Apply damage to the attacker.<br/>
                                int toAttacker = ChargeAttackAction.getDamageTakenBy<br/>
                                    ( entity, bldg );<br/>
                                HitData hit = entity.rollHitLocation( ToHitData.HIT_NORMAL,<br/>
                                                                      entity.sideTable(nextPos)<br/>
                                                                      );<br/>
                                addReport(<br/>
                                                      damageEntity( entity, hit, toAttacker ));<br/>
                                addNewLines();<br/>
<br/>
                                entity.setPosition( nextPos );<br/>
                                doEntityDisplacementMinefieldCheck(entity, curPos, nextPos);<br/>
                                curPos = nextPos;<br/>
                            } // End buildings-suffer-too<br/>
<br/>
                            // Any infantry in the building take damage<br/>
                            // equal to the building being charged.<br/>
                            // ASSUMPTION: infantry take no damage from the<br/>
                            //             building absorbing damage from<br/>
                            //             Tanks and Mechs being charged.<br/>
                            damageInfantryIn( bldg, chargeDamage );<br/>
<br/>
                            // If a building still stands, then end the skid,<br/>
                            // and add it to the list of affected buildings.<br/>
                            if ( bldg.getCurrentCF() &gt; 0 ) {<br/>
                                stopTheSkid = true;<br/>
                                this.addAffectedBldg( bldg, false );<br/>
                            }<br/>
<br/>
                        } // End handle-building.<br/>
<br/>
                        // Do we stay in the current hex and stop skidding?<br/>
                        if ( stopTheSkid ) {<br/>
                            break;<br/>
                        }<br/>
                        // is the next hex a rubble hex?<br/>
                        rollTarget = entity.checkRubbleMove(step, nextHex,<br/>
                                                curPos, nextPos);<br/>
                        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                            doSkillCheckWhileMoving(entity, curPos, nextPos,<br/>
                                                        rollTarget, true);<br/>
                            if (entity.isProne()) {<br/>
                                // if we fell, stop the skid (see bug 1115608)<br/>
                                break;<br/>
                            }<br/>
                        }<br/>
                        <br/>
                        //check for breaking magma crust<br/>
                        if(curHex.terrainLevel(Terrains.MAGMA) == 1) {<br/>
                            int roll = Compute.d6(1);<br/>
                            r = new Report(2395);<br/>
                            r.addDesc(entity);<br/>
                            r.add(roll);<br/>
                            r.subject = entity.getId();<br/>
                            addReport(r);<br/>
                            if(roll == 6) {<br/>
                                curHex.removeTerrain(Terrains.MAGMA);<br/>
                                curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.MAGMA, 2));<br/>
                                sendChangedHex(curPos);<br/>
                                for(Enumeration e=game.getEntities(curPos);e.hasMoreElements();) {<br/>
                                    Entity en = (Entity)e.nextElement();<br/>
                                    if(en != entity)<br/>
                                        doMagmaDamage(en, false);<br/>
                                }<br/>
                            }<br/>
                        }<br/>
<br/>
                        //check for entering liquid magma<br/>
                        if(curHex.terrainLevel(Terrains.MAGMA) == 2) {<br/>
                            doMagmaDamage(entity, false);<br/>
                        }            <br/>
<br/>
                        // is the next hex a swamp?<br/>
                        rollTarget = entity.checkSwampMove(step, nextHex, <br/>
                                                              curPos, nextPos);<br/>
                        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                            if (!doSkillCheckWhileMoving(entity, curPos,<br/>
                                                   nextPos, rollTarget, false)){<br/>
                                entity.setStuck(true);<br/>
                                r = new Report(2081);<br/>
                                r.subject = entity.getId();<br/>
                                r.add(entity.getDisplayName(), true);<br/>
                                // stay here and stop skidding, see bug 1115608<br/>
                                break;<br/>
                            }<br/>
                        }<br/>
<br/>
                        // Update the position and keep skidding.<br/>
                        entity.setPosition( nextPos );<br/>
                        doEntityDisplacementMinefieldCheck(entity, curPos, nextPos);<br/>
                        curPos = nextPos;<br/>
                        r = new Report(2085);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent();<br/>
                        r.add(curPos.getBoardNum(), true);<br/>
                        addReport(r);<br/>
<br/>
                        // Get the next hex in the skid?<br/>
                        nextPos = nextPos.translated( skidDirection );<br/>
                        nextHex = game.getBoard().getHex( nextPos );<br/>
<br/>
                    } // Handle the next skid hex.<br/>
<br/>
                    // If the skidding entity violates stacking,<br/>
                    // displace targets until it doesn't.<br/>
                    curPos = entity.getPosition();<br/>
                    target = Compute.stackingViolation<br/>
                        (game, entity.getId(), curPos);<br/>
                    while (target != null) {<br/>
                        nextPos = Compute.getValidDisplacement<br/>
                            (game, target.getId(),<br/>
                             target.getPosition(), skidDirection);<br/>
                        // ASSUMPTION<br/>
                        // There should always be *somewhere* that<br/>
                        // the target can go... last skid hex if<br/>
                        // nothing else is available.<br/>
                        if ( null == nextPos ) {<br/>
                            // But I don't trust the assumption fully.<br/>
                            // Report the error and try to continue.<br/>
                            System.err.println( "The skid of " +<br/>
                                                entity.getShortName() +<br/>
                                                " should displace " +<br/>
                                                target.getShortName() +<br/>
                                                " in hex " +<br/>
                                                curPos.getBoardNum() +<br/>
                                                " but there is nowhere to go."<br/>
                                                );<br/>
                            break;<br/>
                        }<br/>
                        // indent displacement<br/>
                        r = new Report(1210, Report.PUBLIC);<br/>
                        r.indent();<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                        doEntityDisplacement(target, curPos, nextPos, null);<br/>
                        doEntityDisplacementMinefieldCheck(entity, curPos, nextPos);<br/>
                        target = Compute.stackingViolation( game,<br/>
                                                            entity.getId(),<br/>
                                                            curPos );<br/>
                    }<br/>
<br/>
                    // Mechs suffer damage for every hex skidded.<br/>
                    if ( entity instanceof Mech ) {<br/>
                        // Calculate one half falling damage times skid length.<br/>
                        int damage = skidDistance * (int) Math.ceil(Math.round(entity.getWeight() / 10.0) / 2.0);<br/>
<br/>
                        // report skid damage<br/>
                        r = new Report(2090);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent();<br/>
                        r.addDesc(entity);<br/>
                        r.add(damage);<br/>
                        addReport(r);<br/>
<br/>
                        // standard damage loop<br/>
                        // All skid damage is to the front.<br/>
                        while (damage &gt; 0) {<br/>
                            int cluster = Math.min(5, damage);<br/>
                            HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);<br/>
                            addReport(<br/>
                                damageEntity(entity, hit, cluster));<br/>
                            damage -= cluster;<br/>
                        }<br/>
                        addNewLines();<br/>
                    }<br/>
<br/>
                    // Clean up the entity if it has been destroyed.<br/>
                    if ( entity.isDoomed() ) {<br/>
                        entity.setDestroyed(true);<br/>
                        game.moveToGraveyard(entity.getId());<br/>
                        send(createRemoveEntityPacket(entity.getId()));<br/>
<br/>
                        // The entity's movement is completed.<br/>
                        return;<br/>
                    }<br/>
<br/>
                    // Let the player know the ordeal is over.<br/>
                    r = new Report(2095);<br/>
                    r.subject = entity.getId();<br/>
                    r.indent();<br/>
                    addReport(r);<br/>
<br/>
                    // set entity parameters<br/>
                    curFacing = entity.getFacing();<br/>
                    curPos = entity.getPosition();<br/>
                    entity.setSecondaryFacing( curFacing );<br/>
<br/>
                    // skid consumes all movement<br/>
                    if (md.hasActiveMASC()) {<br/>
                        mpUsed = entity.getRunMP();<br/>
                    } else {<br/>
                        mpUsed = entity.getRunMPwithoutMASC();<br/>
                    }<br/>
<br/>
                    entity.moved = moveType;<br/>
                    fellDuringMovement = true;<br/>
                    distance = entity.delta_distance;<br/>
                    break;<br/>
<br/>
                } // End failed-skid-psr<br/>
<br/>
            } // End need-skid-psr<br/>
            if(entity instanceof VTOL) {<br/>
                rollTarget = ((VTOL)entity).checkSideSlip(moveType, prevHex, overallMoveType,<br/>
                                          prevStep, prevFacing, curFacing,<br/>
                                          lastPos, curPos,<br/>
                                          distance);<br/>
                if(rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                    if(!doSkillCheckWhileMoving(entity,lastPos,curPos,rollTarget, false)) {<br/>
                        //report sideslip<br/>
                        sideslipped = true;<br/>
                        r = new Report(2100);<br/>
                        r.subject = entity.getId();<br/>
                        r.addDesc(entity);<br/>
                        addReport(r);<br/>
                        Coords newPos = lastPos.translated((prevFacing));//does this work for opposing hex?<br/>
                        // Is the next hex off the board?<br/>
                        if ( !game.getBoard().contains(newPos) ) {<br/>
                            // Can the entity skid off the map?<br/>
                            if (game.getOptions().booleanOption("push_off_board")) {<br/>
                                // Yup.  One dead entity.<br/>
                                game.removeEntity(entity.getId(),<br/>
                                        IEntityRemovalConditions.REMOVE_PUSHED);<br/>
                                send(createRemoveEntityPacket(entity.getId(),<br/>
                                        IEntityRemovalConditions.REMOVE_PUSHED));<br/>
                                r = new Report(2030);<br/>
                                r.subject = entity.getId();<br/>
                                r.addDesc(entity);<br/>
                                addReport(r);<br/>
<br/>
                                // TODO: remove passengers and swarmers.<br/>
                                // The entity's movement is completed.<br/>
                                return;<br/>
                            } else {<br/>
                                // Nope.  Update the report.<br/>
                                r = new Report(2035);<br/>
                                r.subject = entity.getId();<br/>
                                addReport(r);<br/>
                            }<br/>
                            // Stay in the current hex and stop skidding.<br/>
                            break;<br/>
                        }<br/>
                        IHex hex = game.getBoard().getHex(newPos);<br/>
                        int terrainLevel = hex.ceiling() - hex.surface();<br/>
                        int newElevation=(entity.calcElevation(game.getBoard().getHex(curPos),game.getBoard().getHex(newPos),curVTOLElevation,step.climbMode()));<br/>
                        if(newElevation&lt;=terrainLevel) {                            <br/>
                            r = new Report(2105);<br/>
                            r.subject = entity.getId();<br/>
                            r.add(newPos.getBoardNum(), true);<br/>
                            addReport(r);<br/>
<br/>
                            int hitSide=curFacing-prevFacing+6;<br/>
                            hitSide=hitSide % 6;<br/>
                            int table=0;<br/>
                            switch(hitSide) {//quite hackish...I think it ought to work, though.<br/>
                                case 0://can this happen?<br/>
                                    table=ToHitData.SIDE_FRONT;<br/>
                                    break;<br/>
                                case 1:<br/>
                                case 2:<br/>
                                    table=ToHitData.SIDE_LEFT;<br/>
                                    break;<br/>
                                case 3:<br/>
                                    table=ToHitData.SIDE_REAR;<br/>
                                    break;<br/>
                                case 4:<br/>
                                case 5:<br/>
                                    table=ToHitData.SIDE_RIGHT;<br/>
                                    break;<br/>
                            }<br/>
                            curPos=newPos;<br/>
                            curVTOLElevation=newElevation;<br/>
                            addReport(crashVTOL(((VTOL)entity),true,distance,curPos,curVTOLElevation,table));<br/>
                            <br/>
                            if((hex.containsTerrain(Terrains.WATER) &amp;&amp; !hex.containsTerrain(Terrains.ICE))<br/>
                                || hex.containsTerrain(Terrains.WOODS)<br/>
                                || hex.containsTerrain(Terrains.JUNGLE)) {<br/>
                                addReport(destroyEntity(entity,"could not land in crash site"));<br/>
                            } else if(newElevation &lt; hex.terrainLevel(Terrains.BLDG_ELEV)){<br/>
                                addReport(destroyEntity(entity, "crashed into building"));<br/>
                            }<br/>
                        } else {<br/>
                            r = new Report(2110);<br/>
                            r.subject = entity.getId();<br/>
                            r.add(newPos.getBoardNum(), true);<br/>
                            addReport(r);<br/>
                            entity.setElevation(entity.calcElevation(game.getBoard().getHex(curPos),game.getBoard().getHex(newPos),curVTOLElevation,step.climbMode()));<br/>
                            curPos=newPos;<br/>
                        }<br/>
<br/>
                        if(!entity.isDestroyed() &amp;&amp; !entity.isDoomed()) {<br/>
                            fellDuringMovement= true; //No, but it should work...<br/>
                        }<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // check if we've moved into rubble<br/>
            rollTarget = entity.checkRubbleMove(step, curHex, lastPos, curPos);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                doSkillCheckWhileMoving(entity, lastPos, curPos, rollTarget,<br/>
                                         true);<br/>
            }<br/>
<br/>
            //check for breaking magma crust<br/>
            if(curHex.terrainLevel(Terrains.MAGMA) == 1<br/>
                &amp;&amp; step.getElevation() == 0<br/>
                &amp;&amp; step.getMovementType() != IEntityMovementType.MOVE_JUMP) {<br/>
                int roll = Compute.d6(1);<br/>
                r = new Report(2395);<br/>
                r.addDesc(entity);<br/>
                r.add(roll);<br/>
                r.subject = entity.getId();<br/>
                addReport(r);<br/>
                if(roll == 6) {<br/>
                    curHex.removeTerrain(Terrains.MAGMA);<br/>
                    curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.MAGMA, 2));<br/>
                    sendChangedHex(curPos);<br/>
                    for(Enumeration e=game.getEntities(curPos);e.hasMoreElements();) {<br/>
                        Entity en = (Entity)e.nextElement();<br/>
                        if(en != entity)<br/>
                            doMagmaDamage(en, false);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            //check for entering liquid magma<br/>
            if(curHex.terrainLevel(Terrains.MAGMA) == 2<br/>
                &amp;&amp; step.getElevation() == 0<br/>
                &amp;&amp; step.getMovementType() != IEntityMovementType.MOVE_JUMP) {<br/>
                doMagmaDamage(entity, false);<br/>
            }            <br/>
<br/>
            // check if we've moved into a swamp<br/>
            rollTarget = entity.checkSwampMove(step, curHex, lastPos, curPos);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                if (!doSkillCheckWhileMoving(entity, lastPos, curPos, rollTarget,<br/>
                                         false)){<br/>
                    entity.setStuck(true);<br/>
                    entity.setCanUnstickByJumping(true);<br/>
                    r = new Report(2081);<br/>
                    r.add(entity.getDisplayName());<br/>
                    r.subject = entity.getId();<br/>
                    addReport(r);<br/>
                    break;<br/>
                }<br/>
            }<br/>
<br/>
            // check to see if we are a mech and we've moved OUT of fire<br/>
            IHex lastHex = game.getBoard().getHex(lastPos);<br/>
            if (entity instanceof Mech) {<br/>
                if ( !lastPos.equals(curPos)<br/>
                    &amp;&amp; (lastHex.containsTerrain(Terrains.FIRE)<br/>
                            || lastHex.containsTerrain(Terrains.MAGMA))<br/>
                    &amp;&amp; ( step.getMovementType() != IEntityMovementType.MOVE_JUMP<br/>
                         // Bug #828741 -- jumping bypasses fire, but not on the first step<br/>
                         //   getMpUsed -- total MP used to this step<br/>
                         //   getMp -- MP used in this step<br/>
                         //   the difference will always be 0 on the "first step" of a jump,<br/>
                         //   and &gt;0 on a step in the midst of a jump<br/>
                         || ( 0 == step.getMpUsed() - step.getMp() ) ) )<br/>
                {<br/>
                    int heat=0;<br/>
                    if(lastHex.containsTerrain(Terrains.FIRE))<br/>
                        heat+=2;<br/>
                    if(lastHex.terrainLevel(Terrains.MAGMA) == 1) {<br/>
                        heat+=2;<br/>
                    }<br/>
                    else if(lastHex.terrainLevel(Terrains.MAGMA) == 2) {<br/>
                        heat+=5;<br/>
                    }<br/>
                    entity.heatBuildup+=heat;<br/>
                    r = new Report(2115);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(heat);<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            // check to see if we are not a mech and we've moved INTO fire<br/>
            if (!(entity instanceof Mech)) {<br/>
                if ( game.getBoard().getHex(curPos).containsTerrain(Terrains.FIRE)<br/>
                    &amp;&amp; !lastPos.equals(curPos)<br/>
                    &amp;&amp; step.getMovementType() != IEntityMovementType.MOVE_JUMP<br/>
                    &amp;&amp; step.getElevation() &lt;= 1 ) {<br/>
                    if(game.getOptions().booleanOption("vehicle_fires")<br/>
                            &amp;&amp; entity instanceof Tank) {<br/>
                        checkForVehicleFire((Tank)entity, false);<br/>
                    } else {<br/>
                        doFlamingDeath(entity);<br/>
                    }<br/>
                }<br/>
            }<br/>
            // check for extreme gravity movement<br/>
            if (!i.hasMoreElements() &amp;&amp; !firstStep) {<br/>
                checkExtremeGravityMovement(entity, step, curPos, cachedGravityLimit);<br/>
            }<br/>
            // check for minefields.<br/>
            if ((!lastPos.equals(curPos) &amp;&amp; (step.getMovementType() != IEntityMovementType.MOVE_JUMP))<br/>
                || ((overallMoveType == IEntityMovementType.MOVE_JUMP) &amp;&amp; (!i.hasMoreElements()))) {<br/>
                checkVibrabombs(entity, curPos, false, lastPos, curPos);<br/>
                if (game.containsMinefield(curPos)) {<br/>
                    Enumeration minefields = game.getMinefields(curPos).elements();<br/>
                    while (minefields.hasMoreElements()) {<br/>
                        Minefield mf = (Minefield) minefields.nextElement();<br/>
<br/>
                        boolean isOnGround = (!i.hasMoreElements());<br/>
                        isOnGround |= (step.getMovementType() != IEntityMovementType.MOVE_JUMP);<br/>
                        isOnGround &amp;= step.getElevation() == 0;<br/>
                        if (isOnGround) {<br/>
                            enterMinefield(entity, mf, curPos, curPos, true);<br/>
                        } else if (mf.getType() == Minefield.TYPE_THUNDER_ACTIVE) {<br/>
                            enterMinefield(entity, mf, curPos, curPos, true, 2);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // infantry discovers minefields if they end their move<br/>
            // in a minefield.<br/>
<br/>
            if (!lastPos.equals(curPos) &amp;&amp;<br/>
                !i.hasMoreElements() &amp;&amp;<br/>
                isInfantry) {<br/>
                if (game.containsMinefield(curPos)) {<br/>
                    Player owner = entity.getOwner();<br/>
                    Enumeration minefields = game.getMinefields(curPos).elements();<br/>
                    while (minefields.hasMoreElements()) {<br/>
                        Minefield mf = (Minefield) minefields.nextElement();<br/>
                        if (!owner.containsMinefield(mf)) {<br/>
                            r = new Report(2120);<br/>
                            r.subject = entity.getId();<br/>
                            r.add(entity.getShortName(), true);<br/>
                            addReport(r);<br/>
                            revealMinefield(owner, mf);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // check if we've moved into water<br/>
            rollTarget = entity.checkWaterMove(step, curHex, lastPos, curPos,<br/>
                                               isPavementStep);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                // Swarmers need special handling.<br/>
                final int swarmerId = entity.getSwarmAttackerId();<br/>
                boolean swarmerDone = true;<br/>
                Entity swarmer = null;<br/>
                if (Entity.NONE != swarmerId) {<br/>
                    swarmer = game.getEntity( swarmerId );<br/>
                    swarmerDone = swarmer.isDone();<br/>
                }<br/>
<br/>
                // Now do the skill check.<br/>
                doSkillCheckWhileMoving(entity, lastPos, curPos, rollTarget,<br/>
                                         true);<br/>
<br/>
                // Swarming infantry platoons may drown.<br/>
                if (curHex.terrainLevel(Terrains.WATER) &gt; 1) {<br/>
                    drownSwarmer(entity, curPos);<br/>
                }<br/>
<br/>
                // Do we need to remove a game turn for the swarmer<br/>
                if (!swarmerDone &amp;&amp;<br/>
                    ( swarmer.isDoomed() || swarmer.isDestroyed() )) {<br/>
                    // We have to diddle with the swarmer's<br/>
                    // status to get its turn removed.<br/>
                    swarmer.setDone( false );<br/>
                    swarmer.setUnloaded( false );<br/>
<br/>
                    // Dead entities don't take turns.<br/>
                    game.removeTurnFor( swarmer );<br/>
                    send( createTurnVectorPacket() );<br/>
<br/>
                    // Return the original status.<br/>
                    swarmer.setDone( true );<br/>
                    swarmer.setUnloaded( true );<br/>
                }<br/>
<br/>
                // check for inferno wash-off<br/>
                checkForWashedInfernos(entity, curPos);<br/>
            }<br/>
            <br/>
            // In water, may or may not be a new hex, neccessary to<br/>
            // check during movement, for breach damage, and always<br/>
            // set dry if appropriate<br/>
            //TODO: possibly make the locations local and set later<br/>
            doSetLocationsExposure(entity, curHex, <br/>
                    step.getMovementType() == IEntityMovementType.MOVE_JUMP,<br/>
                    step.getElevation());<br/>
<br/>
            //check for breaking ice by breaking through from below<br/>
            if(prevHex != null &amp;&amp; prevStep != null<br/>
                    &amp;&amp; prevStep.getElevation() &lt; 0<br/>
                    &amp;&amp; step.getElevation() == 0<br/>
                    &amp;&amp; prevHex.containsTerrain(Terrains.ICE)<br/>
                    &amp;&amp; prevHex.containsTerrain(Terrains.WATER)<br/>
                    &amp;&amp; step.getMovementType() != IEntityMovementType.MOVE_JUMP<br/>
                    &amp;&amp; !(lastPos.equals(curPos))) {<br/>
                r = new Report(2410);<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                resolveIceBroken(lastPos);<br/>
            }<br/>
            //check for breaking ice by stepping on it<br/>
            if(curHex.containsTerrain(Terrains.ICE)<br/>
                    &amp;&amp; curHex.containsTerrain(Terrains.WATER)<br/>
                    &amp;&amp; step.getMovementType() != IEntityMovementType.MOVE_JUMP<br/>
                    &amp;&amp; !(lastPos.equals(curPos))) {<br/>
                if(step.getElevation() == 0<br/>
                        ) {<br/>
                    int roll = Compute.d6(1);<br/>
                    r = new Report(2118);<br/>
                    r.addDesc(entity);<br/>
                    r.add(roll);<br/>
                    r.subject = entity.getId();<br/>
                    addReport(r);<br/>
                    if(roll == 6) {<br/>
                        resolveIceBroken(curPos);<br/>
                        doEntityFallsInto(entity, lastPos, curPos, entity.getBasePilotingRoll(), false);<br/>
                    }<br/>
                }<br/>
                //or intersecting it<br/>
                else if(step.getElevation() + entity.height() == 0) {<br/>
                    r = new Report(2410);<br/>
                    r.addDesc(entity);<br/>
                    addReport(r);<br/>
                    resolveIceBroken(curPos);<br/>
                }<br/>
            }<br/>
            <br/>
            // Handle loading units.<br/>
            if ( step.getType() == MovePath.STEP_LOAD ) {<br/>
<br/>
                // Find the unit being loaded.<br/>
                Entity loaded = null;<br/>
                Enumeration entities = game.getEntities( curPos );<br/>
                while ( entities.hasMoreElements() ) {<br/>
<br/>
                    // Is the other unit friendly and not the current entity?<br/>
                    loaded = (Entity)entities.nextElement();<br/>
                    if ( entity.getOwner() == loaded.getOwner() &amp;&amp;<br/>
                         !entity.equals(loaded) ) {<br/>
<br/>
                        // The moving unit should be able to load the other<br/>
                        // unit and the other should be able to have a turn.<br/>
                        if ( !entity.canLoad(loaded) ||<br/>
                             !loaded.isSelectableThisTurn() ) {<br/>
                            // Something is fishy in Denmark.<br/>
                            System.err.println( entity.getShortName() +<br/>
                                                " can not load " +<br/>
                                                loaded.getShortName() );<br/>
                            loaded = null;<br/>
                        }<br/>
                        else {<br/>
                            // Have the deployed unit load the indicated unit.<br/>
                            this.loadUnit( entity, loaded );<br/>
<br/>
                            // Stop looking.<br/>
                            break;<br/>
                        }<br/>
<br/>
                    } else {<br/>
                        // Nope. Discard it.<br/>
                        loaded = null;<br/>
                    }<br/>
<br/>
                } // Handle the next entity in this hex.<br/>
<br/>
                // We were supposed to find someone to load.<br/>
                if ( loaded == null ) {<br/>
                    System.err.println( "Could not find unit for " +<br/>
                                        entity.getShortName() +<br/>
                                        " to load in " + curPos );<br/>
                }<br/>
<br/>
            } // End STEP_LOAD<br/>
<br/>
            // Handle unloading units.<br/>
            if ( step.getType() == MovePath.STEP_UNLOAD ) {<br/>
                Targetable unloaded = step.getTarget( game );<br/>
                if ( !this.unloadUnit( entity, unloaded,<br/>
                                       curPos, curFacing, step.getElevation() ) ) {<br/>
                    System.err.println( "Error! Server was told to unload " +<br/>
                                        unloaded.getDisplayName() +<br/>
                                        " from " + entity.getDisplayName() +<br/>
                                        " into " + curPos.getBoardNum() );<br/>
                }<br/>
            }<br/>
<br/>
            // Handle non-infantry moving into a building.<br/>
            int buildingMove = entity.checkMovementInBuilding(step, prevStep, curPos, lastPos);<br/>
            if (buildingMove &gt; 0) {<br/>
<br/>
                // Get the building being exited.<br/>
                Building bldgExited = null;<br/>
                if((buildingMove &amp; 1) == 1)<br/>
                    bldgExited = game.getBoard().getBuildingAt( lastPos );<br/>
<br/>
                // Get the building being entered.<br/>
                Building bldgEntered = null;<br/>
                if((buildingMove &amp; 2) == 2)<br/>
                    bldgEntered = game.getBoard().getBuildingAt( curPos );<br/>
                <br/>
                // Get the building being stepped on.<br/>
                Building bldgStepped = null;<br/>
                if((buildingMove &amp; 4) == 4)<br/>
                    bldgStepped = game.getBoard().getBuildingAt( curPos );<br/>
<br/>
                boolean collapsed = false;<br/>
                //are we passing through a building wall?<br/>
                if(bldgEntered != null || bldgExited != null) {<br/>
                    // If we're not leaving a building, just handle the "entered".<br/>
                    if ( bldgExited == null) {<br/>
                        collapsed = passBuildingWall( entity, bldgEntered,<br/>
                                                      lastPos, curPos,<br/>
                                                      distance, "entering" );<br/>
                        this.addAffectedBldg( bldgEntered, collapsed );<br/>
                    }<br/>
    <br/>
                    // If we're moving withing the same building, just handle<br/>
                    // the "within".<br/>
                    else if ( bldgExited.equals( bldgEntered ) ) {<br/>
                        collapsed = passBuildingWall( entity, bldgEntered,<br/>
                                                      lastPos, curPos,<br/>
                                                      distance, "moving in" );<br/>
                        this.addAffectedBldg( bldgEntered, collapsed );<br/>
                    }<br/>
    <br/>
                    // If we have different buildings, roll for each.<br/>
                    else if ( bldgExited != null &amp;&amp; bldgEntered != null ) {<br/>
                        collapsed = passBuildingWall( entity, bldgExited,<br/>
                                                      lastPos, curPos,<br/>
                                                      distance, "exiting" );<br/>
                        this.addAffectedBldg( bldgExited, collapsed );<br/>
                        collapsed = passBuildingWall( entity, bldgEntered,<br/>
                                                      lastPos, curPos,<br/>
                                                      distance, "entering" );<br/>
                        this.addAffectedBldg( bldgEntered, collapsed );<br/>
                    }<br/>
    <br/>
                    // Otherwise, just handle the "exited".<br/>
                    else if (bldgExited != null){<br/>
                        collapsed = passBuildingWall( entity, bldgExited,<br/>
                                                      lastPos, curPos,<br/>
                                                      distance, "exiting" );<br/>
                        this.addAffectedBldg( bldgExited, collapsed );<br/>
                    }<br/>
                }<br/>
                <br/>
                //stepping on roof, no PSR just check for over weight<br/>
                if(bldgStepped != null) {<br/>
                    collapsed = checkBuildingCollapseWhileMoving(bldgStepped, entity, curPos);<br/>
                    this.addAffectedBldg( bldgStepped, collapsed );<br/>
                }<br/>
<br/>
                // Clean up the entity if it has been destroyed.<br/>
                if ( entity.isDoomed() ) {<br/>
                    entity.setDestroyed(true);<br/>
                    game.moveToGraveyard(entity.getId());<br/>
                    send(createRemoveEntityPacket(entity.getId()));<br/>
<br/>
                    // The entity's movement is completed.<br/>
                    return;<br/>
                }<br/>
<br/>
                // TODO: what if a building collapses into rubble?<br/>
            }<br/>
<br/>
            // did the entity just fall?<br/>
            if (!wasProne &amp;&amp; entity.isProne()) {<br/>
                curFacing = entity.getFacing();<br/>
                curPos = entity.getPosition();<br/>
                mpUsed = step.getMpUsed();<br/>
                fellDuringMovement = true;<br/>
                break;<br/>
            }<br/>
<br/>
            // dropping prone intentionally?<br/>
            if (step.getType() == MovePath.STEP_GO_PRONE) {<br/>
                mpUsed = step.getMpUsed();<br/>
                rollTarget = entity.checkDislodgeSwarmers(step);<br/>
                if (rollTarget.getValue() == TargetRoll.CHECK_FALSE) {<br/>
                    // Not being swarmed<br/>
                    entity.setProne(true);<br/>
                    // check to see if we washed off infernos<br/>
                    checkForWashedInfernos(entity, curPos);<br/>
                    break;<br/>
                } else {<br/>
                    // Being swarmed<br/>
                    entity.setPosition(curPos);<br/>
                    if (doDislodgeSwarmerSkillCheck(entity,<br/>
                                                    rollTarget,<br/>
                                                    curPos)) {<br/>
                        // Entity falls<br/>
                        curFacing = entity.getFacing();<br/>
                        curPos = entity.getPosition();<br/>
                        fellDuringMovement = true;<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            }<br/>
            <br/>
            //going hull down<br/>
            if(step.getType() == MovePath.STEP_HULL_DOWN) {<br/>
                mpUsed = step.getMpUsed();<br/>
                entity.setHullDown(true);<br/>
            }<br/>
<br/>
            // Track this step's location.<br/>
            movePath.addElement( new UnitLocation( entity.getId(),<br/>
                                                   curPos,<br/>
                                                   curFacing ) );<br/>
<br/>
            // update lastPos, prevStep, prevFacing &amp; prevHex<br/>
            lastPos = new Coords(curPos);<br/>
            prevStep = step;<br/>
            /* Bug 754610: Revert fix for bug 702735.<br/>
            if (prevHex != null &amp;&amp; !curHex.equals(prevHex)) {<br/>
            */<br/>
            if (!curHex.equals(prevHex)) {<br/>
                prevFacing = curFacing;<br/>
            }<br/>
            prevHex = curHex;<br/>
<br/>
            firstStep = false;<br/>
        }<br/>
<br/>
        // set entity parameters<br/>
        entity.setPosition(curPos);<br/>
        entity.setFacing(curFacing);<br/>
        entity.setSecondaryFacing(curFacing);<br/>
        entity.delta_distance = distance;<br/>
        entity.moved = moveType;<br/>
        entity.mpUsed = mpUsed;<br/>
        if (!sideslipped &amp;&amp; !fellDuringMovement) {<br/>
            entity.setElevation(curVTOLElevation);<br/>
        }<br/>
        entity.setClimbMode(md.getFinalClimbMode());<br/>
        <br/>
        <br/>
<br/>
        // if we ran with destroyed hip or gyro, we need a psr<br/>
        rollTarget = entity.checkRunningWithDamage(overallMoveType);<br/>
        if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
            doSkillCheckInPlace(entity, rollTarget);<br/>
        }<br/>
<br/>
        // but the danger isn't over yet!  landing from a jump can be risky!<br/>
        if (overallMoveType == IEntityMovementType.MOVE_JUMP &amp;&amp; !entity.isMakingDfa()) {<br/>
            final IHex curHex = game.getBoard().getHex(curPos);<br/>
            // check for damaged criticals<br/>
            rollTarget = entity.checkLandingWithDamage();<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                doSkillCheckInPlace(entity, rollTarget);<br/>
            }<br/>
            // jumped into water?<br/>
            int waterLevel = curHex.terrainLevel(Terrains.WATER);<br/>
            if(curHex.containsTerrain(Terrains.ICE) &amp;&amp; waterLevel &gt; 0) {<br/>
                waterLevel = 0;<br/>
                //check for breaking ice<br/>
                int roll = Compute.d6(1);<br/>
                r = new Report(2122);<br/>
                r.add(entity.getDisplayName(), true);<br/>
                r.add(roll);<br/>
                r.subject = entity.getId();<br/>
                addReport(r);<br/>
                if(roll &gt;= 4) {<br/>
                    //oops!<br/>
                    resolveIceBroken(curPos);<br/>
                    doEntityFallsInto(entity, lastPos, curPos, entity.getBasePilotingRoll(), false);<br/>
                }<br/>
            }<br/>
            rollTarget = entity.checkWaterMove(waterLevel);<br/>
            if (rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
                doSkillCheckInPlace(entity, rollTarget);<br/>
            }<br/>
            if (waterLevel &gt; 1) {<br/>
                // Any swarming infantry will be destroyed.<br/>
                drownSwarmer(entity, curPos);<br/>
            }<br/>
<br/>
            //check for building collapse<br/>
            Building bldg = game.getBoard().getBuildingAt(curPos);<br/>
            if(bldg != null) {<br/>
                checkForCollapse( bldg, game.getPositionMap() );<br/>
            }<br/>
<br/>
            //check for breaking magma crust<br/>
            if(curHex.terrainLevel(Terrains.MAGMA) == 1) {<br/>
                int roll = Compute.d6(1);<br/>
                r = new Report(2395);<br/>
                r.addDesc(entity);<br/>
                r.add(roll);<br/>
                r.subject = entity.getId();<br/>
                addReport(r);<br/>
                if(roll == 6) {<br/>
                    curHex.removeTerrain(Terrains.MAGMA);<br/>
                    curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.MAGMA, 2));<br/>
                    sendChangedHex(curPos);<br/>
                    for(Enumeration e=game.getEntities(curPos);e.hasMoreElements();) {<br/>
                        Entity en = (Entity)e.nextElement();<br/>
                        if(en != entity)<br/>
                            doMagmaDamage(en, false);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            //check for entering liquid magma<br/>
            if(curHex.terrainLevel(Terrains.MAGMA) == 2) {<br/>
                doMagmaDamage(entity, false);<br/>
            }            <br/>
<br/>
            // jumped into swamp? maybe stuck!<br/>
            if (curHex.containsTerrain(Terrains.SWAMP)<br/>
                || curHex.containsTerrain(Terrains.MAGMA)<br/>
                || curHex.containsTerrain(Terrains.SNOW)<br/>
                || curHex.containsTerrain(Terrains.MUD)<br/>
                || curHex.containsTerrain(Terrains.TUNDRA)) {<br/>
                if (entity instanceof Mech) {<br/>
                    entity.setStuck(true);<br/>
                    r = new Report(2121);<br/>
                    r.add(entity.getDisplayName(), true);<br/>
                    r.subject = entity.getId();<br/>
                    addReport(r);<br/>
                } else if (entity instanceof Infantry) {<br/>
                    PilotingRollData roll = entity.getBasePilotingRoll();<br/>
                    roll.addModifier(5, "infantry jumping into swamp");<br/>
                    if (!doSkillCheckWhileMoving(entity, curPos, curPos, roll, false)) {<br/>
                        entity.setStuck(true);<br/>
                        r = new Report(2081);<br/>
                        r.add(entity.getDisplayName());<br/>
                        r.subject = entity.getId();<br/>
                        addReport(r);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // If the entity is being swarmed, jumping may dislodge the fleas.<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
                final PilotingRollData roll =<br/>
                    entity.getBasePilotingRoll();<br/>
<br/>
                entity.addPilotingModifierForTerrain(roll);<br/>
<br/>
                // Add a +4 modifier.<br/>
                roll.addModifier( 4, "dislodge swarming infantry" );<br/>
<br/>
                // If the swarmer has Assault claws, give a 1 modifier.<br/>
                // We can stop looking when we find our first match.<br/>
                for ( Enumeration iter = swarmer.getMisc();<br/>
                      iter.hasMoreElements(); ) {<br/>
                    Mounted mount = (Mounted) iter.nextElement();<br/>
                    EquipmentType equip = mount.getType();<br/>
                    if ( BattleArmor.ASSAULT_CLAW.equals<br/>
                         (equip.getInternalName()) ) {<br/>
                        roll.addModifier( 1, "swarmer has assault claws" );<br/>
                        break;<br/>
                    }<br/>
                }<br/>
<br/>
                // okay, print the info<br/>
                r = new Report(2125);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
<br/>
                // roll<br/>
                final int diceRoll = Compute.d6(2);<br/>
                r = new Report(2130);<br/>
                r.subject = entity.getId();<br/>
                r.add(roll.getValueAsString());<br/>
                r.add(roll.getDesc());<br/>
                r.add(diceRoll);<br/>
                if (diceRoll &lt; roll.getValue()) {<br/>
                    r.choose(false);<br/>
                    addReport(r);<br/>
                } else {<br/>
                    // Dislodged swarmers don't get turns.<br/>
                    game.removeTurnFor( swarmer );<br/>
                    send( createTurnVectorPacket() );<br/>
<br/>
                    // Update the report and the swarmer's status.<br/>
                    r.choose(true);<br/>
                    addReport(r);<br/>
                    entity.setSwarmAttackerId( Entity.NONE );<br/>
                    swarmer.setSwarmTargetId( Entity.NONE );<br/>
<br/>
                    // Did the infantry fall into water?<br/>
                    if ( curHex.terrainLevel(Terrains.WATER) &gt; 0 ) {<br/>
                        // Swarming infantry die.<br/>
                        swarmer.setPosition( curPos );<br/>
                        r = new Report(2135);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent();<br/>
                        r.addDesc(swarmer);<br/>
                        addReport(r);<br/>
                        addReport(<br/>
                            destroyEntity(swarmer, "a watery grave", false));<br/>
                    } else {<br/>
                        // Swarming infantry take an 11 point hit.<br/>
                        // ASSUMPTION : damage should not be doubled.<br/>
                        r = new Report(2140);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent();<br/>
                        r.addDesc(swarmer);<br/>
                        addReport(r);<br/>
                        addReport(damageEntity(swarmer, swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT), 11));<br/>
                        addNewLines();<br/>
                        swarmer.setPosition( curPos );<br/>
                    }<br/>
                    entityUpdate( swarmerId );<br/>
                } // End successful-PSR<br/>
<br/>
            } // End try-to-dislodge-swarmers<br/>
<br/>
            // one more check for inferno wash-off<br/>
            checkForWashedInfernos(entity, curPos);<br/>
<br/>
        } // End entity-is-jumping<br/>
        // update entity's locations' exposure<br/>
        doSetLocationsExposure(entity, game.getBoard().getHex(curPos), false, entity.getElevation());<br/>
<br/>
        // should we give another turn to the entity to keep moving?<br/>
        if (fellDuringMovement &amp;&amp; entity.mpUsed &lt; entity.getRunMP()<br/>
        &amp;&amp; entity.isSelectableThisTurn() &amp;&amp; !entity.isDoomed()) {<br/>
            entity.applyDamage();<br/>
            entity.setDone(false);<br/>
            GameTurn newTurn = new GameTurn.SpecificEntityTurn(entity.getOwner().getId(), entity.getId());<br/>
            game.insertNextTurn(newTurn);<br/>
            // brief everybody on the turn update<br/>
            send(createTurnVectorPacket());<br/>
            // let everyone know about what just happened<br/>
            send(entity.getOwner().getId(), createSpecialReportPacket());<br/>
        } else {<br/>
            entity.setDone(true);<br/>
        }<br/>
<br/>
        // If the entity is being swarmed, update the attacker's position.<br/>
        final int swarmerId = entity.getSwarmAttackerId();<br/>
        if ( Entity.NONE != swarmerId ) {<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            swarmer.setPosition( curPos );<br/>
            // If the hex is on fire, and the swarming infantry is<br/>
            // *not* Battle Armor, it drops off.<br/>
            if ( !(swarmer instanceof BattleArmor) &amp;&amp;<br/>
                 game.getBoard().getHex(curPos).containsTerrain(Terrains.FIRE) ) {<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                r = new Report(2145);<br/>
                r.subject = entity.getId();<br/>
                r.indent();<br/>
                r.add(swarmer.getShortName(), true);<br/>
                addReport(r);<br/>
            }<br/>
            entityUpdate( swarmerId );<br/>
        }<br/>
<br/>
        // Update the entitiy's position,<br/>
        // unless it is off the game map.<br/>
        if (!game.isOutOfGame(entity)) {<br/>
            entityUpdate( entity.getId(), movePath  );<br/>
            if (entity.isDoomed()) {<br/>
                send(createRemoveEntityPacket(entity.getId(), entity.getRemovalCondition()));<br/>
            }<br/>
        }<br/>
<br/>
        // if using double blind, update the player on new units he might see<br/>
        if (doBlind()) {<br/>
            send(entity.getOwner().getId(), createFilteredEntitiesPacket(entity.getOwner()));<br/>
        }<br/>
<br/>
        // if we generated a charge attack, report it now<br/>
        if (charge != null) {<br/>
            send(createAttackPacket(charge, 1));<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Delivers a thunder-aug shot to the targetted hex area.<br/>
     * Thunder-Augs are 7 hexes, though, so...<br/>
     */<br/>
    private void deliverThunderAugMinefield( Coords coords,<br/>
                                             int playerId, int damage ) {<br/>
        Coords mfCoord = null;<br/>
        for (int dir=0; dir &lt; 7; dir++) {<br/>
            switch (dir) {<br/>
            case 6:<br/>
                // The targeted hex.<br/>
                mfCoord = new Coords(coords);<br/>
                break;<br/>
            default:<br/>
                // The hex in the dir direction from the targeted hex.<br/>
                mfCoord = coords.translated(dir);<br/>
                break;<br/>
            }<br/>
<br/>
            // Only if this is on the board...<br/>
            if ( game.getBoard().contains(mfCoord) ) {<br/>
                Minefield minefield = null;<br/>
                Enumeration minefields = game.getMinefields(mfCoord).elements();<br/>
                // Check if there already are Thunder minefields in the hex.<br/>
                while (minefields.hasMoreElements()) {<br/>
                    Minefield mf = (Minefield) minefields.nextElement();<br/>
                    if (mf.getType() == Minefield.TYPE_THUNDER) {<br/>
                        minefield = mf;<br/>
                        break;<br/>
                    }<br/>
                }<br/>
<br/>
                // Did we find a Thunder minefield in the hex?<br/>
                // N.B. damage Thunder minefields equals the number of<br/>
                //      missiles, divided by two, rounded up.<br/>
                if (minefield == null) {<br/>
                    // Nope.  Create a new Thunder minefield<br/>
                    minefield = Minefield.createThunderMF<br/>
                        ( mfCoord, playerId, (damage/2 + damage%2) );<br/>
                    game.addMinefield(minefield);<br/>
                    revealMinefield(minefield);<br/>
                } else if (minefield.getDamage() &lt; Minefield.MAX_DAMAGE) {<br/>
                    // Yup.  Replace the old one.<br/>
                    removeMinefield(minefield);<br/>
                    int newDamage = (damage/2 + damage%2);<br/>
                    newDamage += minefield.getDamage();<br/>
<br/>
                    // Damage from Thunder minefields are capped.<br/>
                    if ( newDamage &gt; Minefield.MAX_DAMAGE ) {<br/>
                        newDamage = Minefield.MAX_DAMAGE;<br/>
                    }<br/>
                    minefield.setDamage(newDamage);<br/>
                    game.addMinefield(minefield);<br/>
                    revealMinefield(minefield);<br/>
                }<br/>
            } // End coords-on-board<br/>
<br/>
        } // Handle the next coords<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a Thunder minefield to the hex.<br/>
     * @param coords<br/>
     * @param playerId<br/>
     * @param damage<br/>
     */<br/>
    private void deliverThunderMinefield( Coords coords, int playerId,<br/>
                                          int damage ) {<br/>
        Minefield minefield = null;<br/>
        Enumeration minefields = game.getMinefields(coords).elements();<br/>
        // Check if there already are Thunder minefields in the hex.<br/>
        while (minefields.hasMoreElements()) {<br/>
            Minefield mf = (Minefield) minefields.nextElement();<br/>
            if (mf.getType() == Minefield.TYPE_THUNDER) {<br/>
                minefield = mf;<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
        // Create a new Thunder minefield<br/>
        if (minefield == null) {<br/>
            minefield = Minefield.createThunderMF(coords, playerId, damage);<br/>
            // Add to the old one<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
        } else if (minefield.getDamage() &lt; Minefield.MAX_DAMAGE) {<br/>
            removeMinefield(minefield);<br/>
            int oldDamage = minefield.getDamage();<br/>
            damage += oldDamage;<br/>
            damage = (damage &gt; Minefield.MAX_DAMAGE) ? Minefield.MAX_DAMAGE : damage;<br/>
            minefield.setDamage(damage);<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a Thunder Inferno minefield to the hex.<br/>
     * @param coords<br/>
     * @param playerId<br/>
     * @param damage<br/>
     */<br/>
    private void deliverThunderInfernoMinefield(Coords coords, int playerId, int damage) {<br/>
        Minefield minefield = null;<br/>
        Enumeration minefields = game.getMinefields(coords).elements();<br/>
        // Check if there already are Thunder minefields in the hex.<br/>
        while (minefields.hasMoreElements()) {<br/>
            Minefield mf = (Minefield) minefields.nextElement();<br/>
            if (mf.getType() == Minefield.TYPE_THUNDER_INFERNO) {<br/>
                minefield = mf;<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
        // Create a new Thunder Inferno minefield<br/>
        if (minefield == null) {<br/>
            minefield = Minefield.createThunderInfernoMF(coords, playerId, damage);<br/>
            // Add to the old one<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
       } else if (minefield.getDamage() &lt; Minefield.MAX_DAMAGE) {<br/>
            removeMinefield(minefield);<br/>
            int oldDamage = minefield.getDamage();<br/>
            damage += oldDamage;<br/>
            damage = (damage &gt; Minefield.MAX_DAMAGE) ? Minefield.MAX_DAMAGE : damage;<br/>
            minefield.setDamage(damage);<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
       }<br/>
    }<br/>
<br/>
    /**<br/>
     *Delivers a Arrow IV FASCAM shot to the targetted hex area.<br/>
     */<br/>
    private void deliverFASCAMMinefield( Coords coords, int playerId) {<br/>
        // Only if this is on the board...<br/>
        if ( game.getBoard().contains(coords) ) {<br/>
            Minefield minefield = null;<br/>
            Enumeration minefields = game.getMinefields(coords).elements();<br/>
            // Check if there already are Thunder minefields in the hex.<br/>
            while (minefields.hasMoreElements()) {<br/>
                Minefield mf = (Minefield) minefields.nextElement();<br/>
                if (mf.getType() == Minefield.TYPE_THUNDER) {<br/>
                    minefield = mf;<br/>
                    break;<br/>
                }<br/>
            }<br/>
            // Did we find a Thunder minefield in the hex?<br/>
            // N.B. damage of FASCAM minefields is 30<br/>
            if (minefield == null) minefield = Minefield.createThunderMF( coords, playerId, 30 );<br/>
            removeMinefield(minefield);<br/>
            minefield.setDamage(30);<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
        } // End coords-on-board<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a Thunder-Active minefield to the hex.<br/>
     */<br/>
    private void deliverThunderActiveMinefield(Coords coords, int playerId, int damage) {<br/>
        Minefield minefield = null;<br/>
        Enumeration minefields = game.getMinefields(coords).elements();<br/>
        // Check if there already are Thunder minefields in the hex.<br/>
        while (minefields.hasMoreElements()) {<br/>
            Minefield mf = (Minefield) minefields.nextElement();<br/>
            if (mf.getType() == Minefield.TYPE_THUNDER_ACTIVE) {<br/>
                minefield = mf;<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
        // Create a new Thunder-Active minefield<br/>
        if (minefield == null) {<br/>
            minefield = Minefield.createThunderActiveMF(coords, playerId, damage);<br/>
            // Add to the old one<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
        } else if (minefield.getDamage() &lt; Minefield.MAX_DAMAGE) {<br/>
            removeMinefield(minefield);<br/>
            int oldDamage = minefield.getDamage();<br/>
            damage += oldDamage;<br/>
            damage = (damage &gt; Minefield.MAX_DAMAGE) ? Minefield.MAX_DAMAGE : damage;<br/>
            minefield.setDamage(damage);<br/>
            game.addMinefield(minefield);<br/>
            revealMinefield(minefield);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a Thunder-Vibrabomb minefield to the hex.<br/>
     */<br/>
    private void deliverThunderVibraMinefield(Coords coords, int playerId, int damage, int sensitivity) {<br/>
        Minefield minefield = null;<br/>
        Enumeration minefields = game.getMinefields(coords).elements();<br/>
        // Check if there already are Thunder minefields in the hex.<br/>
        while (minefields.hasMoreElements()) {<br/>
            Minefield mf = (Minefield) minefields.nextElement();<br/>
            if (mf.getType() == Minefield.TYPE_THUNDER_VIBRABOMB) {<br/>
                minefield = mf;<br/>
                break;<br/>
            }<br/>
        }<br/>
<br/>
        // Create a new Thunder-Vibra minefield<br/>
        if (minefield == null) {<br/>
            minefield = Minefield.createThunderVibrabombMF(coords, playerId, damage, sensitivity);<br/>
            // Add to the old one<br/>
            game.addVibrabomb(minefield);<br/>
            revealMinefield(minefield);<br/>
        } else if (minefield.getDamage() &lt; Minefield.MAX_DAMAGE) {<br/>
            removeMinefield(minefield);<br/>
            int oldDamage = minefield.getDamage();<br/>
            damage += oldDamage;<br/>
            damage = (damage &gt; Minefield.MAX_DAMAGE) ? Minefield.MAX_DAMAGE : damage;<br/>
            minefield.setDamage(damage);<br/>
            game.addVibrabomb(minefield);<br/>
            revealMinefield(minefield);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a flare above the target<br/>
     */<br/>
    private void deliverFlare(Coords coords, int rackSize) {<br/>
        Flare flare = new Flare(coords, Math.max(1, rackSize / 5), 3, 0);<br/>
        game.addFlare(flare);<br/>
    }<br/>
    <br/>
    private void deliverArtilleryFlare(Coords coords, int radius) {<br/>
        Flare flare = new Flare(coords, 12, radius, Flare.F_DRIFTING);<br/>
        game.addFlare(flare);<br/>
    }<br/>
<br/>
    private void deliverArtillerySmoke(Coords coords) {<br/>
        if(game.getOptions().booleanOption("maxtech_fire")) {<br/>
            IHex h = game.getBoard().getHex(coords);<br/>
            //Unless there is a heavy smoke in the hex already, add one.<br/>
            if ( h.terrainLevel( Terrains.SMOKE ) &lt; 2 ) {<br/>
                Report r = new Report(5185, Report.PUBLIC);<br/>
                r.indent(2);<br/>
                r.add(coords.getBoardNum());<br/>
                addReport(r);<br/>
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.SMOKE, 2));<br/>
                sendChangedHex(coords);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    private void deliverArtilleryInferno(Coords coords, int subjectId) {<br/>
        IHex h = game.getBoard().getHex(coords);<br/>
        Report r;<br/>
        //Unless there is a fire in the hex already, start one.<br/>
        if ( !h.containsTerrain( Terrains.FIRE ) ) {<br/>
            r = new Report(3005);<br/>
            r.subject = subjectId;<br/>
            r.indent(2);<br/>
            r.add(coords.getBoardNum());<br/>
            addReport(r);<br/>
            h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
        }<br/>
        game.getBoard().addInfernoTo( coords, InfernoTracker.INFERNO_IV_ROUND, 1 );<br/>
        sendChangedHex(coords);<br/>
        for(Enumeration impactHexHits = game.getEntities(coords);impactHexHits.hasMoreElements();) {<br/>
            Entity entity = (Entity)impactHexHits.nextElement();<br/>
            entity.infernos.add( InfernoTracker.INFERNO_IV_ROUND, 1 );<br/>
            //entity on fire now<br/>
            r = new Report(3205);<br/>
            r.indent(2);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(entity.infernos.getTurnsLeftToBurn());<br/>
            addReport(r);<br/>
        }<br/>
        for(int dir=0;dir&lt;=5;dir++) {<br/>
            Coords tempcoords=coords.translated(dir);<br/>
            if(!game.getBoard().contains(tempcoords)) {<br/>
                continue;<br/>
            }<br/>
            if(coords.equals(tempcoords)) {<br/>
                continue;<br/>
            }<br/>
            h = game.getBoard().getHex(tempcoords);<br/>
            // Unless there is a fire in the hex already, start one.<br/>
            if ( !h.containsTerrain( Terrains.FIRE ) ) {<br/>
                r = new Report(3005);<br/>
                r.subject = subjectId;<br/>
                r.indent(2);<br/>
                r.add(tempcoords.getBoardNum());<br/>
                addReport(r);<br/>
                h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
            }<br/>
            game.getBoard().addInfernoTo( tempcoords, InfernoTracker.INFERNO_IV_ROUND, 1 );<br/>
            sendChangedHex(tempcoords);<br/>
            for (Enumeration splashHexHits = game.getEntities(tempcoords);splashHexHits.hasMoreElements();) {<br/>
                Entity entity = (Entity)splashHexHits.nextElement();<br/>
                entity.infernos.add( InfernoTracker.INFERNO_IV_ROUND, 1 );<br/>
                //entity on fire<br/>
                r = new Report(3205);<br/>
                r.indent(2);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(entity.infernos.getTurnsLeftToBurn());<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * When an entity enters a conventional or Thunder minefield.<br/>
     */<br/>
    private void enterMinefield(Entity entity, Minefield mf, Coords src, Coords dest, boolean resolvePSRNow) {<br/>
        enterMinefield(entity, mf, src, dest, resolvePSRNow, 0);<br/>
    }<br/>
<br/>
    /**<br/>
     * When an entity enters a conventional or Thunder minefield.<br/>
     * @param entity<br/>
     *<br/>
     * @param mf<br/>
     * @param src<br/>
     * @param dest<br/>
     * @param resolvePSRNow<br/>
     * @param hitMod<br/>
     */<br/>
    private void enterMinefield(Entity entity, Minefield mf, Coords src, Coords dest, boolean resolvePSRNow, int hitMod) {<br/>
        Report r;<br/>
        // Bug 954272: Mines shouldn't work underwater<br/>
        if (!game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.WATER)<br/>
                || game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.PAVEMENT)<br/>
                || game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.ICE)) {<br/>
        switch (mf.getType()) {<br/>
            case (Minefield.TYPE_CONVENTIONAL) :<br/>
            case (Minefield.TYPE_THUNDER) :<br/>
            case (Minefield.TYPE_THUNDER_ACTIVE) :<br/>
                if (mf.getTrigger() != Minefield.TRIGGER_NONE &amp;&amp;<br/>
                    Compute.d6(2) &lt; (mf.getTrigger()+hitMod)) {<br/>
                    return;<br/>
                }<br/>
<br/>
                r = new Report(2150);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getShortName(), true);<br/>
                r.add(mf.getCoords().getBoardNum(), true);<br/>
                addReport(r);<br/>
                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);<br/>
                addReport( damageEntity(entity, hit, mf.getDamage()));<br/>
                addNewLines();<br/>
<br/>
                if (resolvePSRNow) {<br/>
                    resolvePilotingRolls(entity, true, src, dest);<br/>
                }<br/>
<br/>
                if (!mf.isOneUse()) {<br/>
                    revealMinefield(mf);<br/>
                } else {<br/>
                    removeMinefield(mf);<br/>
                }<br/>
                break;<br/>
<br/>
            case (Minefield.TYPE_THUNDER_INFERNO) :<br/>
                if (mf.getTrigger() != Minefield.TRIGGER_NONE &amp;&amp;<br/>
                    Compute.d6(2) &lt; (mf.getTrigger()+hitMod)) {<br/>
                    return;<br/>
                }<br/>
                entity.infernos.add( InfernoTracker.STANDARD_ROUND, mf.getDamage() );<br/>
                //report hitting an inferno mine<br/>
                r = new Report(2155);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getShortName(), true);<br/>
                r.add(mf.getCoords().getBoardNum(), true);<br/>
                r.addDesc(entity);<br/>
                r.add(entity.infernos.getTurnsLeftToBurn());<br/>
                addReport(r);<br/>
<br/>
                // start a fire in the targets hex<br/>
                IHex h = game.getBoard().getHex(dest);<br/>
<br/>
                // Unless there a fire in the hex already, start one.<br/>
                if ( !h.containsTerrain( Terrains.FIRE ) ) {<br/>
                    r = new Report(3005);<br/>
                    r.subject = entity.getId();<br/>
                    r.add(dest.getBoardNum(), true);<br/>
                    addReport(r);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                }<br/>
                game.getBoard().addInfernoTo(dest, InfernoTracker.STANDARD_ROUND, 1);<br/>
                sendChangedHex(dest);<br/>
                break;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if an entity sets off any vibrabombs.<br/>
     */<br/>
    private void checkVibrabombs(Entity entity, Coords coords, boolean displaced) {<br/>
        checkVibrabombs(entity, coords, displaced, null, null);<br/>
    }<br/>
<br/>
    private void checkVibrabombs(Entity entity, Coords coords, boolean displaced, Coords lastPos, Coords curPos) {<br/>
        // Only mechs can set off vibrabombs.<br/>
        if (!(entity instanceof Mech)) {<br/>
            return;<br/>
        }<br/>
<br/>
        int mass = (int) entity.getWeight();<br/>
<br/>
        Enumeration e = game.getVibrabombs().elements();<br/>
<br/>
        while (e.hasMoreElements()) {<br/>
            Minefield mf = (Minefield) e.nextElement();<br/>
<br/>
            // Bug 954272: Mines shouldn't work underwater, and BMRr says Vibrabombs are mines<br/>
            if (game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.WATER)<br/>
                    &amp;&amp; !game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.PAVEMENT)<br/>
                    &amp;&amp; !game.getBoard().getHex(mf.getCoords()).containsTerrain(Terrains.ICE)) {<br/>
                continue;<br/>
            }<br/>
<br/>
            // Mech weighing 10 tons or less can't set off the bomb<br/>
            if (mass &lt;= mf.getSetting() - 10) {<br/>
                continue;<br/>
            }<br/>
<br/>
            int effectiveDistance = (mass - mf.getSetting()) / 10;<br/>
            int actualDistance = coords.distance(mf.getCoords());<br/>
<br/>
            if (actualDistance &lt;= effectiveDistance) {<br/>
                Report r = new Report(2156);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getShortName(), true);<br/>
                r.add(mf.getCoords().getBoardNum(), true);<br/>
                addReport(r);<br/>
                explodeVibrabomb(mf);<br/>
            }<br/>
<br/>
            // Hack; when moving, the Mech isn't in the hex during<br/>
            // the movement.<br/>
            if (!displaced &amp;&amp; actualDistance == 0) {<br/>
                //report getting hit by vibrabomb<br/>
                Report r = new Report(2160);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getShortName(), true);<br/>
                addReport(r);<br/>
                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);<br/>
                addReport( damageEntity(entity, hit, mf.getDamage()));<br/>
                addNewLines();<br/>
                resolvePilotingRolls(entity, true, lastPos, curPos);<br/>
                // we need to apply Damage now, in case the entity lost a leg,<br/>
                // otherwise it won't get a leg missing mod if it hasn't yet<br/>
                // moved and lost a leg, see bug 1071434 for an example<br/>
                entity.applyDamage();<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Remove all minefields in the specified coords from the game<br/>
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; from which to remove minefields<br/>
     */<br/>
    private void removeMinefieldsFrom(Coords coords) {<br/>
        Vector v = game.getMinefields(coords);<br/>
        while (v.elements().hasMoreElements()) {<br/>
            Minefield mf = (Minefield)v.elements().nextElement();<br/>
            removeMinefield(mf);<br/>
        }<br/>
        <br/>
    }<br/>
<br/>
    /**<br/>
     * Removes the minefield from the game.<br/>
     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to remove<br/>
     */<br/>
    private void removeMinefield(Minefield mf) {<br/>
        if (game.containsVibrabomb(mf)) {<br/>
            game.removeVibrabomb(mf);<br/>
        }<br/>
        game.removeMinefield(mf);<br/>
<br/>
        Enumeration players = game.getPlayers();<br/>
        while (players.hasMoreElements()) {<br/>
            Player player = (Player) players.nextElement();<br/>
            removeMinefield(player, mf);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes the minfield from a player.<br/>
     * @param player The &lt;code&gt;Player&lt;/code&gt; who's minefield should be removed<br/>
     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to be removed<br/>
     */<br/>
    private void removeMinefield(Player player, Minefield mf) {<br/>
        if (player.containsMinefield(mf)) {<br/>
            player.removeMinefield(mf);<br/>
            send(player.getId(), new Packet(Packet.COMMAND_REMOVE_MINEFIELD, mf));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Reveals a minefield for all players.<br/>
     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to be revealed<br/>
     */<br/>
    private void revealMinefield(Minefield mf) {<br/>
        Enumeration players = game.getPlayers();<br/>
        while (players.hasMoreElements()) {<br/>
            Player player = (Player) players.nextElement();<br/>
            revealMinefield(player, mf);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Reveals a minefield for a player.<br/>
     * @param player The &lt;code&gt;Player&lt;/code&gt; who's minefiled should be revealed<br/>
     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to be revealed<br/>
     */<br/>
    private void revealMinefield(Player player, Minefield mf) {<br/>
        if (!player.containsMinefield(mf)) {<br/>
            player.addMinefield(mf);<br/>
            send(player.getId(), new Packet(Packet.COMMAND_REVEAL_MINEFIELD, mf));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Explodes a vibrabomb.<br/>
     * @param mf The &lt;code&gt;Minefield&lt;/code&gt; to explode<br/>
     */<br/>
    private void explodeVibrabomb(Minefield mf) {<br/>
        Enumeration targets = game.getEntities(mf.getCoords());<br/>
        Report r;<br/>
<br/>
        while (targets.hasMoreElements()) {<br/>
            Entity entity = (Entity) targets.nextElement();<br/>
<br/>
            // check for the "no_premove_vibra" option<br/>
            // If it's set, and the target has not yet moved,<br/>
            // it doesn't get damaged.<br/>
            if (!entity.isDone() &amp;&amp; game.getOptions().booleanOption("no_premove_vibra")) {<br/>
                r = new Report(2157);<br/>
                r.subject = entity.getId();<br/>
                r.add(entity.getShortName(), true);<br/>
                addReport(r);<br/>
                continue;<br/>
            }<br/>
            //report hitting vibrabomb<br/>
            r = new Report(2160);<br/>
            r.subject = entity.getId();<br/>
            r.add(entity.getShortName(), true);<br/>
            addReport(r);<br/>
<br/>
            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {<br/>
                // normal vibrabombs do all damage in one pack<br/>
                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);<br/>
                addReport( damageEntity(entity, hit, mf.getDamage()));<br/>
                addNewLines();<br/>
            } else if (mf.getType() == Minefield.TYPE_THUNDER_VIBRABOMB) {<br/>
                int damage = mf.getDamage();<br/>
                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);<br/>
                addReport( damageEntity(entity, hit, damage));<br/>
            }<br/>
<br/>
            resolvePilotingRolls(entity, true, entity.getPosition(), entity.getPosition());<br/>
            // we need to apply Damage now, in case the entity lost a leg,<br/>
            // otherwise it won't get a leg missing mod if it hasn't yet<br/>
            // moved and lost a leg, see bug 1071434 for an example<br/>
            game.resetPSRs(entity);<br/>
            entity.applyDamage();<br/>
            addNewLines();<br/>
            entityUpdate(entity.getId());<br/>
        }<br/>
<br/>
        if (!mf.isOneUse()) {<br/>
            revealMinefield(mf);<br/>
        } else {<br/>
            removeMinefield(mf);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * drowns any units swarming the entity<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is being swarmed<br/>
     * @param pos The &lt;code&gt;Coords&lt;/code&gt; the entity is at<br/>
     */<br/>
    private void drownSwarmer(Entity entity, Coords pos) {<br/>
        // Any swarming infantry will be destroyed.<br/>
        final int swarmerId = entity.getSwarmAttackerId();<br/>
        if ( Entity.NONE != swarmerId ) {<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            // Only *platoons* drown while swarming.<br/>
            if (!(swarmer instanceof BattleArmor)) {<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                swarmer.setPosition( pos );<br/>
                Report r = new Report(2165);<br/>
                r.subject = entity.getId();<br/>
                r.indent();<br/>
                r.add(entity.getShortName(), true);<br/>
                addReport(r);<br/>
                addReport( destroyEntity(swarmer, "a watery grave", false));<br/>
                entityUpdate( swarmerId );<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if we may have just washed off infernos.  Call after<br/>
     * a step which may have done this.<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is being checked<br/>
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; the entity is at<br/>
     */<br/>
    void checkForWashedInfernos(Entity entity, Coords coords) {<br/>
        IHex hex = game.getBoard().getHex(coords);<br/>
        int waterLevel = hex.terrainLevel(Terrains.WATER);<br/>
        // Mech on fire with infernos can wash them off.<br/>
        if (!(entity instanceof Mech) || !entity.infernos.isStillBurning()) {<br/>
            return;<br/>
        }<br/>
        // Check if entering depth 2 water or prone in depth 1.<br/>
        if (waterLevel &gt; 0 &amp;&amp; entity.absHeight() &lt; 0) {<br/>
            washInferno(entity, coords);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Washes off an inferno from a mech and adds it to the (water) hex.<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is taking a bath<br/>
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; the entity is at<br/>
     */<br/>
    void washInferno(Entity entity, Coords coords) {<br/>
        game.getBoard().addInfernoTo( coords, InfernoTracker.STANDARD_ROUND, 1 );<br/>
        entity.infernos.clear();<br/>
<br/>
        // Start a fire in the hex?<br/>
        IHex hex = game.getBoard().getHex(coords);<br/>
        Report r = new Report(2170);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        if ( hex.containsTerrain(Terrains.FIRE) ) {<br/>
        } else {<br/>
            r.messageId = 2175;<br/>
            hex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
        }<br/>
        addReport(r);<br/>
        sendChangedHex(coords);<br/>
    }<br/>
<br/>
    /**<br/>
     * Add heat from the movement phase<br/>
     */<br/>
    public void addMovementHeat() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            // build up heat from movement<br/>
            if (entity.moved == IEntityMovementType.MOVE_NONE) {<br/>
                entity.heatBuildup += entity.getStandingHeat();<br/>
            } else if (entity.moved == IEntityMovementType.MOVE_WALK<br/>
                       || entity.moved == IEntityMovementType.MOVE_VTOL_WALK) {<br/>
                entity.heatBuildup += entity.getWalkHeat();<br/>
            } else if (entity.moved == IEntityMovementType.MOVE_RUN<br/>
                       || entity.moved == IEntityMovementType.MOVE_VTOL_RUN<br/>
                       || entity.moved == IEntityMovementType.MOVE_SKID) {<br/>
                entity.heatBuildup += entity.getRunHeat();<br/>
            } else if (entity.moved == IEntityMovementType.MOVE_JUMP) {<br/>
                entity.heatBuildup += entity.getJumpHeat(entity.delta_distance);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Set the locationsexposure of an entity<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; who's exposure is being set<br/>
     * @param hex The &lt;code&gt;IHex&lt;/code&gt; the entity is in<br/>
     * @param isJump a &lt;code&gt;boolean&lt;/code&gt; value wether the entity is jumping<br/>
     * @param elevation the elevation the entity should be at.<br/>
     */<br/>
<br/>
    public void doSetLocationsExposure(Entity entity, IHex hex, boolean isJump, int elevation) {<br/>
        if ( hex.terrainLevel(Terrains.WATER) &gt; 0<br/>
                &amp;&amp; !isJump<br/>
                &amp;&amp; elevation &lt; 0) {<br/>
            if (entity instanceof Mech<br/>
                    &amp;&amp; !entity.isProne()<br/>
                    &amp;&amp; hex.terrainLevel(Terrains.WATER) == 1) {<br/>
                for (int loop = 0; loop &lt; entity.locations(); loop++) {<br/>
                    if (game.getOptions().booleanOption("vacuum"))<br/>
                        entity.setLocationStatus(loop, ILocationExposureStatus.VACUUM);<br/>
                    else entity.setLocationStatus(loop, ILocationExposureStatus.NORMAL);<br/>
                }<br/>
                entity.setLocationStatus(Mech.LOC_RLEG, ILocationExposureStatus.WET);<br/>
                entity.setLocationStatus(Mech.LOC_LLEG, ILocationExposureStatus.WET);<br/>
                addReport(<br/>
                                      breachCheck(entity, Mech.LOC_RLEG, hex));<br/>
                addReport(<br/>
                                      breachCheck(entity, Mech.LOC_LLEG, hex));<br/>
                if (entity instanceof QuadMech) {<br/>
                    entity.setLocationStatus(Mech.LOC_RARM, ILocationExposureStatus.WET);<br/>
                    entity.setLocationStatus(Mech.LOC_LARM, ILocationExposureStatus.WET);<br/>
                    addReport(<br/>
                               breachCheck(entity, Mech.LOC_RARM, hex));<br/>
                    addReport(<br/>
                               breachCheck(entity, Mech.LOC_LARM, hex));<br/>
                }<br/>
            } else {<br/>
                for (int loop = 0; loop &lt; entity.locations(); loop++) {<br/>
                    entity.setLocationStatus(loop, ILocationExposureStatus.WET);<br/>
                    addReport( breachCheck(entity, loop, hex));<br/>
                }<br/>
            }<br/>
        } else {<br/>
            for (int loop = 0; loop &lt; entity.locations(); loop++) {<br/>
                if (game.getOptions().booleanOption("vacuum"))<br/>
                    entity.setLocationStatus(loop, ILocationExposureStatus.VACUUM);<br/>
                else entity.setLocationStatus(loop, ILocationExposureStatus.NORMAL);<br/>
            }<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a piloting skill check while standing still (during the<br/>
     *  movement phase).<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that should make the PSR<br/>
     * @param roll   The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for this PSR.<br/>
     *<br/>
     *@param Returns true if check succeeds, false otherwise.<br/>
     *<br/>
     */<br/>
    private boolean doSkillCheckInPlace(Entity entity, PilotingRollData roll) {<br/>
        if (roll.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {<br/>
            return true;<br/>
        }<br/>
<br/>
        // non-mechs should never get here<br/>
        if (! (entity instanceof Mech) || entity.isProne()) {<br/>
            return true;<br/>
        }<br/>
<br/>
        // okay, print the info<br/>
        Report r = new Report(2180);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        r.add(roll.getLastPlainDesc(), true);<br/>
        addReport(r);<br/>
<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        r = new Report(2185);<br/>
        r.subject = entity.getId();<br/>
        r.add(roll.getValueAsString());<br/>
        r.add(roll.getDesc());<br/>
        r.add(diceRoll);<br/>
        boolean suc;<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            r.choose(false);<br/>
            addReport(r);<br/>
            doEntityFall(entity, roll);<br/>
            suc = false;<br/>
        } else {<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
            suc = true;<br/>
        }<br/>
<br/>
        return suc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a Piloting Skill check to dislogde swarming infantry.<br/>
     *<br/>
     * @param   entity The &lt;code&gt;Entity&lt;/code&gt; that is doing the dislodging.<br/>
     * @param   roll The &lt;code&gt;PilotingRollData&lt;/code&gt; for this PSR.<br/>
     * @param   curPos The &lt;code&gt;Coords&lt;/code&gt; the entity is at.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the dislodging is successful.<br/>
     */<br/>
    private boolean doDislodgeSwarmerSkillCheck<br/>
        (Entity entity, PilotingRollData roll, Coords curPos)<br/>
    {<br/>
        // okay, print the info<br/>
        Report r = new Report(2180);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        r.add(roll.getLastPlainDesc(), true);<br/>
        addReport(r);<br/>
<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        r = new Report(2190);<br/>
        r.subject = entity.getId();<br/>
        r.add(roll.getValueAsString());<br/>
        r.add(roll.getDesc());<br/>
        r.add(diceRoll);<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            r.choose(false);<br/>
            addReport(r);<br/>
            return false;<br/>
        } else {<br/>
            // Dislodged swarmers don't get turns.<br/>
            int swarmerId = entity.getSwarmAttackerId();<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            game.removeTurnFor( swarmer );<br/>
            send( createTurnVectorPacket() );<br/>
<br/>
            // Update the report and cause a fall.<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
            entity.setPosition( curPos );<br/>
            doEntityFallsInto(entity, curPos, curPos, roll, false);<br/>
            return true;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Do a piloting skill check while moving.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that must roll.<br/>
     * @param   src - the &lt;code&gt;Coords&lt;/code&gt; the entity is moving from.<br/>
     * @param   dest - the &lt;code&gt;Coords&lt;/code&gt; the entity is moving to.<br/>
     *          This value can be the same as src for in-place checks.<br/>
     * @param   reason - the &lt;code&gt;PilotingRollData&lt;/code&gt; that is causing<br/>
     *          this check.<br/>
     * @param   isFallRoll - a &lt;code&gt;boolean&lt;/code&gt; flag that indicates that<br/>
     *          failure will result in a fall or not.  Falls will be processed.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the pilot passes the skill check.<br/>
     */<br/>
    private boolean doSkillCheckWhileMoving( Entity entity,<br/>
                                             Coords src,<br/>
                                             Coords dest,<br/>
                                             PilotingRollData roll,<br/>
                                             boolean isFallRoll ) {<br/>
        boolean result = true;<br/>
        boolean fallsInPlace;<br/>
<br/>
        // Start the info for this roll.<br/>
        Report r = new Report(1210);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
<br/>
        // Will the entity fall in the source or destination hex?<br/>
        if ( src.equals(dest) ) {<br/>
            fallsInPlace = true;<br/>
            r.messageId = 2195;<br/>
            r.add(src.getBoardNum(), true);<br/>
        } else {<br/>
            fallsInPlace = false;<br/>
            r.messageId = 2200;<br/>
            r.add(src.getBoardNum(), true);<br/>
            r.add(dest.getBoardNum(), true);<br/>
        }<br/>
<br/>
        // Finish the info.<br/>
        r.add(roll.getLastPlainDesc(), true);<br/>
        addReport(r);<br/>
<br/>
        // roll<br/>
        final int diceRoll = Compute.d6(2);<br/>
        r = new Report(2185);<br/>
        r.subject = entity.getId();<br/>
        r.add(roll.getValueAsString());<br/>
        r.add(roll.getDesc());<br/>
        r.add(diceRoll);<br/>
        if (diceRoll &lt; roll.getValue()) {<br/>
            // Does failing the PSR result in a fall.<br/>
            if ( isFallRoll ) {<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
                doEntityFallsInto( entity,<br/>
                                   (fallsInPlace ? dest : src),<br/>
                                   (fallsInPlace ? src : dest),<br/>
                                   roll );<br/>
            } else {<br/>
                r.messageId = 2190;<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
                entity.setPosition( fallsInPlace ? src : dest );<br/>
            }<br/>
            result = false;<br/>
        } else {<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
        }<br/>
        return result;<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * The entity falls into the hex specified.  Check for any conflicts and<br/>
     * resolve them.  Deal damage to faller.<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is falling.<br/>
     * @param src The &lt;code&gt;Coords&lt;/code&gt; of the source hex.<br/>
     * @param dest The &lt;code&gt;Coords&lt;/code&gt; of the destination hex.<br/>
     * @param roll The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for PSRs induced<br/>
     * by the falling.<br/>
     */<br/>
    private void doEntityFallsInto(Entity entity, Coords src, Coords dest, PilotingRollData roll) {<br/>
        doEntityFallsInto(entity, src, dest, roll, true);<br/>
    }<br/>
<br/>
    /**<br/>
    * The entity falls into the hex specified.  Check for any conflicts and<br/>
    * resolve them.  Deal damage to faller.<br/>
    *<br/>
    * @param entity The &lt;code&gt;Entity&lt;/code&gt; that is falling.<br/>
    * @param src The &lt;code&gt;Coords&lt;/code&gt; of the source hex.<br/>
    * @param dest The &lt;code&gt;Coords&lt;/code&gt; of the destination hex.<br/>
    * @param roll The &lt;code&gt;PilotingRollData&lt;/code&gt; to be used for PSRs induced<br/>
    * by the falling.<br/>
    * @param causeAffa The &lt;code&gt;boolean&lt;/code&gt; value wether this fall should<br/>
    * be able to cause an accidental fall from above<br/>
    */<br/>
    private void doEntityFallsInto(Entity entity, Coords src, Coords dest, PilotingRollData roll, boolean causeAffa) {<br/>
        final IHex srcHex = game.getBoard().getHex(src);<br/>
        final IHex destHex = game.getBoard().getHex(dest);<br/>
        final int srcHeightAboveFloor = entity.getElevation() + srcHex.depth(); <br/>
        final int fallElevation = Math.max(0, srcHex.floor() + srcHeightAboveFloor - destHex.floor());<br/>
        int direction = src.direction(dest);<br/>
        Report r;<br/>
        // check entity in target hex<br/>
        Entity affaTarget = game.getAffaTarget(dest, entity);<br/>
        // falling mech falls<br/>
        r = new Report(2205);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        r.add(fallElevation);<br/>
        r.add(dest.getBoardNum(), true);<br/>
        addReport(r);<br/>
<br/>
        // if hex was empty, deal damage and we're done<br/>
        if (affaTarget == null) {<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            return;<br/>
        }<br/>
<br/>
        // hmmm... somebody there... problems.<br/>
        if (fallElevation &gt;= 2 &amp;&amp; causeAffa &amp;&amp; affaTarget != null) {<br/>
            // accidental fall from above: havoc!<br/>
            r = new Report(2210);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(affaTarget);<br/>
            addReport(r);<br/>
<br/>
            // determine to-hit number<br/>
            ToHitData toHit = new ToHitData(7, "base");<br/>
            if (affaTarget instanceof Tank ) {<br/>
                toHit = new ToHitData(TargetRoll.AUTOMATIC_FAIL, "Target is a Tank");<br/>
            } else {<br/>
                toHit.append(Compute.getTargetMovementModifier(game, affaTarget.getId()));<br/>
                toHit.append(Compute.getTargetTerrainModifier(game, affaTarget));<br/>
            }<br/>
<br/>
            if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL) {<br/>
                // collision roll<br/>
                final int diceRoll = Compute.d6(2);<br/>
                r = new Report(2215);<br/>
                r.subject = entity.getId();<br/>
                r.add(toHit.getValue());<br/>
                r.add(diceRoll);<br/>
                if (diceRoll &gt;= toHit.getValue()) {<br/>
                    r.choose(true);<br/>
                    addReport(r);<br/>
                    // deal damage to target<br/>
                    int damage = Compute.getAffaDamageFor(entity);<br/>
                    r = new Report(2220);<br/>
                    r.subject = affaTarget.getId();<br/>
                    r.addDesc(affaTarget);<br/>
                    r.add(damage);<br/>
                    addReport(r);<br/>
                    while (damage &gt; 0) {<br/>
                        int cluster = Math.min(5, damage);<br/>
                        HitData hit = affaTarget.rollHitLocation(ToHitData.HIT_PUNCH, ToHitData.SIDE_FRONT);<br/>
                        addReport(<br/>
                                              damageEntity(affaTarget, hit, cluster));<br/>
                        damage -= cluster;<br/>
                    }<br/>
                    addNewLines();<br/>
<br/>
                    // attacker falls as normal, on his back<br/>
                    // only given a modifier, so flesh out into a full piloting roll<br/>
                    PilotingRollData pilotRoll = entity.getBasePilotingRoll();<br/>
                    pilotRoll.append(roll);<br/>
                    entity.addPilotingModifierForTerrain(pilotRoll, dest);<br/>
                    doEntityFall(entity, dest, fallElevation, 3, pilotRoll);<br/>
                    doEntityDisplacementMinefieldCheck(entity, src, dest);<br/>
<br/>
                    // defender pushed away, or destroyed, if there is a stacking violation<br/>
                    Entity violation = Compute.stackingViolation(game, entity.getId(), dest);<br/>
                    if (violation != null) {<br/>
                        Coords targetDest = Compute.getValidDisplacement(game, violation.getId(), dest, direction);<br/>
                        if (targetDest != null) {<br/>
                            doEntityDisplacement(affaTarget, dest, targetDest, new PilotingRollData(violation.getId(), 2, "fallen on"));<br/>
                            // Update the violating entity's postion on the client.<br/>
                            entityUpdate( affaTarget.getId() );<br/>
                        } else {<br/>
                            // ack!  automatic death!  Tanks<br/>
                            // suffer an ammo/power plant hit.<br/>
                            // TODO : a Mech suffers a Head Blown Off crit.<br/>
                            addReport(<br/>
                                                  destroyEntity(affaTarget, "impossible displacement", (violation instanceof Mech), (violation instanceof Mech)));<br/>
                        }<br/>
                    }<br/>
                    return;<br/>
                } else {<br/>
                    r.choose(false);<br/>
                    addReport(r);<br/>
                }<br/>
            } else {<br/>
                //automatic miss<br/>
                r = new Report(2225);<br/>
                r.add(toHit.getDesc());<br/>
                addReport(r);<br/>
            }<br/>
            // ok, we missed, let's fall into a valid other hex and not cause an AFFA while doing so<br/>
            Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), dest, direction);<br/>
            if (targetDest != null) {<br/>
                doEntityFallsInto(entity, src, targetDest, new PilotingRollData(entity.getId(), PilotingRollData.IMPOSSIBLE, "pushed off a cliff"), false);<br/>
                // Update the entity's postion on the client.<br/>
                entityUpdate( entity.getId() );<br/>
            } else {<br/>
                // ack!  automatic death!  Tanks<br/>
                // suffer an ammo/power plant hit.<br/>
                // TODO : a Mech suffers a Head Blown Off crit.<br/>
                addReport( destroyEntity(entity, "impossible displacement", (entity instanceof Mech), (entity instanceof Mech)));<br/>
            }<br/>
        } else {<br/>
            // damage as normal<br/>
            doEntityFall(entity, dest, fallElevation, roll);<br/>
            Entity violation = Compute.stackingViolation(game, entity.getId(), dest);<br/>
            if(violation != null) {<br/>
                // target gets displaced, because of low elevation<br/>
                Coords targetDest = Compute.getValidDisplacement(game, entity.getId(), dest, direction);<br/>
                doEntityDisplacement(violation, dest, targetDest, new PilotingRollData(violation.getId(), 0, "domino effect"));<br/>
                // Update the violating entity's postion on the client.<br/>
                entityUpdate( violation.getId() );<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Displace a unit in the direction specified.  The unit moves in that<br/>
     * direction, and the piloting skill roll is used to determine if it<br/>
     * falls.  The roll may be unnecessary as certain situations indicate an<br/>
     * automatic fall.  Rolls are added to the piloting roll list.<br/>
     */<br/>
    private void doEntityDisplacement(Entity entity, Coords src, Coords dest,<br/>
                                      PilotingRollData roll) {<br/>
        Report r;<br/>
        if (!game.getBoard().contains(dest)) {<br/>
            // set position anyway, for pushes moving through and stuff like<br/>
            // that<br/>
            entity.setPosition(dest);<br/>
            if (!entity.isDoomed()) {<br/>
                game.removeEntity(entity.getId(),<br/>
                        IEntityRemovalConditions.REMOVE_PUSHED);<br/>
                send(createRemoveEntityPacket(entity.getId(),<br/>
                        IEntityRemovalConditions.REMOVE_PUSHED));<br/>
                //entity forced from the field<br/>
                r = new Report(2230);<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                // TODO: remove passengers and swarmers.<br/>
            }<br/>
            return;<br/>
        }<br/>
        final IHex srcHex = game.getBoard().getHex(src);<br/>
        final IHex destHex = game.getBoard().getHex(dest);<br/>
        final int direction = src.direction(dest);<br/>
<br/>
        // Handle null hexes.<br/>
        if ( srcHex == null || destHex == null ) {<br/>
            System.err.println( "Can not displace " + entity.getShortName() +<br/>
                                " from " + src +<br/>
                                " to " + dest + "." );<br/>
            return;<br/>
        }<br/>
        int fallElevation = entity.elevationOccupied(srcHex) - entity.elevationOccupied(destHex);<br/>
        if (fallElevation &gt; 1) {<br/>
            if(roll == null)<br/>
                roll = entity.getBasePilotingRoll();<br/>
            doEntityFallsInto(entity, src, dest, roll);<br/>
            return;<br/>
        } else {<br/>
            //move the entity into the new location gently<br/>
            entity.setPosition(dest);<br/>
            entity.setElevation(entity.elevationOccupied(destHex) - destHex.surface());<br/>
            Entity violation = Compute.stackingViolation(game, entity.getId(), dest);<br/>
            if (violation == null) {<br/>
                // move and roll normally<br/>
                r = new Report(2235);<br/>
                r.indent();<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(dest.getBoardNum(), true);<br/>
                addReport(r);<br/>
            } else {<br/>
                // domino effect: move &amp; displace target<br/>
                r = new Report(2240);<br/>
                r.indent();<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(dest.getBoardNum(), true);<br/>
                r.addDesc(violation);<br/>
                addReport(r);<br/>
            }<br/>
            // trigger any special things for moving to the new hex<br/>
            doEntityDisplacementMinefieldCheck(entity, src, dest);<br/>
            doSetLocationsExposure(entity, destHex, false, entity.getElevation());<br/>
            if (roll != null) {<br/>
                game.addPSR(roll);<br/>
            }<br/>
            // Update the entity's postion on the client.<br/>
            entityUpdate( entity.getId() );<br/>
            <br/>
            if(violation != null) {<br/>
                doEntityDisplacement(violation, dest, dest.translated(direction), new PilotingRollData(violation.getId(), 0, "domino effect"));<br/>
                // Update the violating entity's postion on the client,<br/>
                // if it didn't get displaced off the board.<br/>
                if ( !game.isOutOfGame(violation) ) {<br/>
                    entityUpdate( violation.getId() );<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    private void doEntityDisplacementMinefieldCheck(Entity entity, Coords src, Coords dest) {<br/>
        if (game.containsMinefield(dest)) {<br/>
            Enumeration minefields = game.getMinefields(dest).elements();<br/>
            while (minefields.hasMoreElements()) {<br/>
                Minefield mf = (Minefield) minefields.nextElement();<br/>
                enterMinefield(entity, mf, src, dest, false);<br/>
            }<br/>
        }<br/>
        checkVibrabombs(entity, dest, true);<br/>
    }<br/>
<br/>
    /**<br/>
     * Receive a deployment packet.  If valid, execute it and end the current<br/>
     * turn.<br/>
     */<br/>
    private void receiveDeployment(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        Coords coords = (Coords)packet.getObject(1);<br/>
        int nFacing = packet.getIntValue(2);<br/>
<br/>
        // Handle units that deploy loaded with other units.<br/>
        int loadedCount = packet.getIntValue(3);<br/>
        Vector loadVector = new Vector();<br/>
        for ( int i = 0; i &lt; loadedCount; i++ ){<br/>
            int loadedId = packet.getIntValue( 5 + i );<br/>
            loadVector.addElement(game.getEntity( loadedId ));<br/>
        }<br/>
<br/>
        // is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_DEPLOYMENT) {<br/>
            System.err.println("error: server got deployment packet in wrong phase");<br/>
            return;<br/>
        }<br/>
<br/>
        // can this player/entity act right now?<br/>
        final boolean assaultDrop = packet.getBooleanValue(4);<br/>
        if ( !game.getTurn().isValid(connId, entity, game)<br/>
             || !(game.getBoard().isLegalDeployment(coords, entity.getOwner()) <br/>
                     ||(assaultDrop &amp;&amp; game.getOptions().booleanOption("assault_drop") &amp;&amp; entity.canAssaultDrop()))) {<br/>
            System.err.println("error: server got invalid deployment packet");<br/>
            return;<br/>
        }<br/>
<br/>
        // looks like mostly everything's okay<br/>
        processDeployment(entity, coords, nFacing, loadVector, assaultDrop);<br/>
<br/>
        // Update visibility indications if using double blind.<br/>
        if (doBlind()) {<br/>
            updateVisibilityIndicator();<br/>
        }<br/>
<br/>
        endCurrentTurn(entity);<br/>
    }<br/>
<br/>
    /**<br/>
     * Process a deployment packet by... deploying the entity!  We load any<br/>
     * other specified entities inside of it too.  Also, check that the<br/>
     * deployment is valid.<br/>
     */<br/>
    private void processDeployment(Entity entity, Coords coords, int nFacing, Vector loadVector, boolean assaultDrop) {<br/>
        for (Enumeration i = loadVector.elements(); i.hasMoreElements();) {<br/>
            Entity loaded = (Entity)i.nextElement();<br/>
            if ( loaded == null || loaded.getPosition() != null ||<br/>
                 loaded.getTransportId() != Entity.NONE ) {<br/>
                // Something is fishy in Denmark.<br/>
                System.err.println("error: " + entity + " can not load entity #" + loaded );<br/>
                break;<br/>
            }<br/>
            else {<br/>
                // Have the deployed unit load the indicated unit.<br/>
                this.loadUnit( entity, loaded );<br/>
            }<br/>
        }<br/>
<br/>
        entity.setPosition(coords);<br/>
        entity.setFacing(nFacing);<br/>
        entity.setSecondaryFacing(nFacing);<br/>
        IHex hex = game.getBoard().getHex(coords);<br/>
        if(assaultDrop) {<br/>
            entity.setElevation(hex.ceiling() - hex.surface() + 100); //falling from the sky!<br/>
            entity.setAssaultDropInProgress(true);<br/>
        } else if (entity instanceof VTOL) {<br/>
            // We should let players pick, but this simplifies a lot.<br/>
            // Only do it for VTOLs, though; assume everything else is on the ground.<br/>
            entity.setElevation(hex.ceiling()-hex.surface()+1);<br/>
            while ((Compute.stackingViolation(game, entity, coords, null) != null) &amp;&amp; (entity.getElevation() &lt;= 50)) {<br/>
                entity.setElevation(entity.getElevation() + 1);<br/>
            }<br/>
            if (entity.getElevation() &gt; 50) {<br/>
                throw new IllegalStateException("Entity #" + entity.getId() + " appears to be in an infinite loop trying to get a legal elevation.");<br/>
            }<br/>
        } else if (entity.getMovementMode() == IEntityMovementMode.SUBMARINE) {<br/>
            // TODO: Submarines should have a selectable height.<br/>
            // For now, pretend they're regular naval.<br/>
            entity.setElevation(0);<br/>
        } else if ((entity.getMovementMode() == IEntityMovementMode.HOVER)<br/>
                || (entity.getMovementMode() == IEntityMovementMode.NAVAL)<br/>
                || (entity.getMovementMode() == IEntityMovementMode.HYDROFOIL)) {<br/>
            // For now, assume they're on the surface.<br/>
            // entity elevation is relative to hex surface<br/>
            entity.setElevation(0);<br/>
        } else if (hex.containsTerrain(Terrains.ICE)<br/>
                || hex.containsTerrain(Terrains.BRIDGE)) {<br/>
            entity.setElevation(0);<br/>
        } else {<br/>
            // For anything else, assume they're on the floor.<br/>
            // entity elevation is relative to hex surface<br/>
            entity.setElevation(hex.floor()-hex.surface());<br/>
        }<br/>
        entity.setDone(true);<br/>
        entity.setDeployed(true);<br/>
        entityUpdate(entity.getId());<br/>
    }<br/>
<br/>
    private void receiveArtyAutoHitHexes(Packet packet, int connId) {<br/>
        Vector artyAutoHitHexes = (Vector) packet.getObject(0);<br/>
<br/>
        Integer playerId = (Integer)artyAutoHitHexes.firstElement();<br/>
        artyAutoHitHexes.removeElementAt(0);<br/>
<br/>
        // is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_SET_ARTYAUTOHITHEXES) {<br/>
            System.err.println("error: server got set artyautohithexespacket in wrong phase");<br/>
            return;<br/>
        }<br/>
        game.getPlayer(playerId.intValue()).setArtyAutoHitHexes(artyAutoHitHexes);<br/>
        endCurrentTurn(null);<br/>
    }<br/>
<br/>
    private void receiveDeployMinefields(Packet packet, int connId) {<br/>
        Vector minefields = (Vector) packet.getObject(0);<br/>
<br/>
        // is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_DEPLOY_MINEFIELDS) {<br/>
            System.err.println("error: server got deploy minefields packet in wrong phase");<br/>
            return;<br/>
        }<br/>
<br/>
        // looks like mostly everything's okay<br/>
        processDeployMinefields(minefields);<br/>
        endCurrentTurn(null);<br/>
    }<br/>
<br/>
    private void processDeployMinefields(Vector minefields) {<br/>
        int playerId = Player.PLAYER_NONE;<br/>
        for (int i = 0; i &lt; minefields.size(); i++) {<br/>
            Minefield mf = (Minefield) minefields.elementAt(i);<br/>
            playerId = mf.getPlayerId();<br/>
<br/>
            game.addMinefield(mf);<br/>
            if (mf.getType() == Minefield.TYPE_VIBRABOMB) {<br/>
                game.addVibrabomb(mf);<br/>
            }<br/>
        }<br/>
<br/>
        Player player = game.getPlayer( playerId );<br/>
        if ( null != player ) {<br/>
            int teamId = player.getTeam();<br/>
<br/>
            if (teamId != Player.TEAM_NONE) {<br/>
                Enumeration teams = game.getTeams();<br/>
                while (teams.hasMoreElements()) {<br/>
                    Team team = (Team) teams.nextElement();<br/>
                    if (team.getId() == teamId) {<br/>
                        Enumeration players = team.getPlayers();<br/>
                        while (players.hasMoreElements()) {<br/>
                            Player teamPlayer = (Player) players.nextElement();<br/>
                            if (teamPlayer.getId() != player.getId()) {<br/>
                                send(teamPlayer.getId(), new Packet(Packet.COMMAND_DEPLOY_MINEFIELDS, minefields));<br/>
                            }<br/>
                            teamPlayer.addMinefields(minefields);<br/>
                        }<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            } else {<br/>
                player.addMinefields(minefields);<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Gets a bunch of entity attacks from the packet.  If valid, processess<br/>
     * them and ends the current turn.<br/>
     */<br/>
    private void receiveAttack(Packet packet, int connId) {<br/>
        Entity entity = game.getEntity(packet.getIntValue(0));<br/>
        Vector vector = (Vector)packet.getObject(1);<br/>
<br/>
        // is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_FIRING<br/>
        &amp;&amp; game.getPhase() != IGame.PHASE_PHYSICAL<br/>
        &amp;&amp; game.getPhase() != IGame.PHASE_TARGETING<br/>
        &amp;&amp; game.getPhase() != IGame.PHASE_OFFBOARD) {<br/>
            System.err.println("error: server got attack packet in wrong phase");<br/>
            return;<br/>
        }<br/>
<br/>
        // can this player/entity act right now?<br/>
        if (!game.getTurn().isValid(connId, entity, game)) {<br/>
            System.err.println("error: server got invalid attack packet");<br/>
            return;<br/>
        }<br/>
<br/>
        // looks like mostly everything's okay<br/>
        processAttack(entity, vector);<br/>
<br/>
        // Update visibility indications if using double blind.<br/>
        if (doBlind()) {<br/>
            updateVisibilityIndicator();<br/>
        }<br/>
<br/>
        endCurrentTurn(entity);<br/>
    }<br/>
<br/>
    /**<br/>
     * Process a batch of entity attack (or twist) actions by adding them to<br/>
     * the proper list to be processed later.<br/>
     */<br/>
    private void processAttack(Entity entity, Vector vector) {<br/>
<br/>
        // Not **all** actions take up the entity's turn.<br/>
        boolean setDone =<br/>
            !(game.getTurn() instanceof GameTurn.TriggerAPPodTurn);<br/>
        for (Enumeration i = vector.elements(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
<br/>
            // is this the right entity?<br/>
            if (ea.getEntityId() != entity.getId()) {<br/>
                System.err.println("error: attack packet has wrong attacker");<br/>
                continue;<br/>
            }<br/>
<br/>
            // Anti-mech and pointblank attacks from<br/>
            // hiding may allow the target to respond.<br/>
            if ( ea instanceof WeaponAttackAction ) {<br/>
                final WeaponAttackAction waa = (WeaponAttackAction) ea;<br/>
                final String weaponName = entity.getEquipment<br/>
                    ( waa.getWeaponId() ).getType().getInternalName();<br/>
<br/>
                if ( Infantry.SWARM_MEK.equals(weaponName) ||<br/>
                     Infantry.LEG_ATTACK.equals(weaponName) ) {<br/>
<br/>
                    // Does the target have any AP Pods available?<br/>
                    final Entity target = game.getEntity( waa.getTargetId() );<br/>
                    Enumeration misc = target.getMisc();<br/>
                    while ( misc.hasMoreElements() ) {<br/>
                        final Mounted equip = (Mounted) misc.nextElement();<br/>
                        if ( equip.getType().hasFlag(MiscType.F_AP_POD) &amp;&amp;<br/>
                             equip.canFire()) {<br/>
<br/>
                            // Yup.  Insert a game turn to handle AP pods.<br/>
                            // ASSUMPTION : AP pod declarations come<br/>
                            // immediately after the attack declaration.<br/>
                            game.insertNextTurn( new GameTurn.TriggerAPPodTurn<br/>
                                  ( target.getOwnerId(), target.getId() ) );<br/>
                            send(createTurnVectorPacket());<br/>
<br/>
                            // We can stop looking.<br/>
                            break;<br/>
<br/>
                        } // end found-available-ap-pod<br/>
<br/>
                    } // Check the next piece of equipment on the target.<br/>
<br/>
                } // End check-for-available-ap-pod<br/>
            }<br/>
<br/>
            // The equipment type of a club needs to be restored.<br/>
            if (ea instanceof ClubAttackAction) {<br/>
                ClubAttackAction caa = (ClubAttackAction) ea;<br/>
                Mounted club = caa.getClub();<br/>
                club.restore();<br/>
            }<br/>
<br/>
            if (ea instanceof PushAttackAction) {<br/>
                // push attacks go the end of the displacement attacks<br/>
                PushAttackAction paa = (PushAttackAction)ea;<br/>
                entity.setDisplacementAttack(paa);<br/>
                game.addCharge(paa);<br/>
            } else if (ea instanceof DodgeAction) {<br/>
                entity.dodging = true;<br/>
            } else if (ea instanceof SpotAction) {<br/>
                entity.setSpotting(true);<br/>
            } else {<br/>
                // add to the normal attack list.<br/>
                game.addAction(ea);<br/>
            }<br/>
<br/>
            // Mark any AP Pod as used in this turn.<br/>
            if ( ea instanceof TriggerAPPodAction ) {<br/>
                TriggerAPPodAction tapa = (TriggerAPPodAction) ea;<br/>
                Mounted pod = entity.getEquipment( tapa.getPodId() );<br/>
                pod.setUsedThisRound( true );<br/>
            }<br/>
        }<br/>
<br/>
        // Unless otherwise stated,<br/>
        // this entity is done for the round.<br/>
        if ( setDone ) {<br/>
            entity.setDone(true);<br/>
        }<br/>
        entityUpdate(entity.getId());<br/>
<br/>
        // update all players on the attacks.  Don't worry about pushes being a<br/>
        // "charge" attack.  It doesn't matter to the client.<br/>
        send(createAttackPacket(vector, 0));<br/>
    }<br/>
<br/>
    /**<br/>
     * Auto-target active AMS systems<br/>
     */<br/>
    private void assignAMS() {<br/>
<br/>
        // sort all missile-based attacks by the target<br/>
        Hashtable htAttacks = new Hashtable();<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements(); ) {<br/>
            Object o = i.nextElement();<br/>
            if (o instanceof WeaponAttackAction) {<br/>
                WeaponAttackAction waa = (WeaponAttackAction)o;<br/>
                Mounted weapon = game.getEntity(waa.getEntityId()).getEquipment(waa.getWeaponId());<br/>
<br/>
                // Only entities can have AMS.<br/>
                if ( Targetable.TYPE_ENTITY != waa.getTargetType() ) {<br/>
                    continue;<br/>
                }<br/>
<br/>
                // Can only use AMS versus missles.<br/>
                if (((WeaponType)weapon.getType()).getDamage() == WeaponType.DAMAGE_MISSILE) {<br/>
                    Entity target = game.getEntity(waa.getTargetId());<br/>
                    Vector v = (Vector)htAttacks.get(target);<br/>
                    if (v == null) {<br/>
                        v = new Vector();<br/>
                        htAttacks.put(target, v);<br/>
                    }<br/>
                    v.addElement(waa);<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        // let each target assign its AMS<br/>
        for (Enumeration i = htAttacks.keys(); i.hasMoreElements(); ) {<br/>
            Entity e = (Entity)i.nextElement();<br/>
            Vector vAttacks = (Vector)htAttacks.get(e);<br/>
            e.assignAMS(vAttacks);<br/>
        }<br/>
    }<br/>
<br/>
    /** <br/>
     * Called during the weapons fire phase.  Resolves anything other than<br/>
     * weapons fire that happens.  Torso twists, for example.<br/>
     */<br/>
    private void resolveAllButWeaponAttacks() {<br/>
        if (game.getPhase()==IGame.PHASE_FIRING) {<br/>
            //Phase report header<br/>
            addReport(new Report(3000, Report.PUBLIC));<br/>
            Report r;<br/>
            for (Enumeration e = game.getLayMinefieldActions(); e.hasMoreElements();) {<br/>
                LayMinefieldAction lma = (LayMinefieldAction)e.nextElement();<br/>
                Entity ent = game.getEntity(lma.getEntityId());<br/>
                Mounted mine = ent.getEquipment(lma.getMineId());<br/>
                if (!mine.isMissing()) {<br/>
                    switch (mine.getMineType()) {<br/>
                        case 0:<br/>
                            deliverThunderMinefield(ent.getPosition(), ent.getOwnerId(), 10);<br/>
                            mine.setMissing(true);<br/>
                            r = new Report(3500);<br/>
                            r.subject = ent.getId();<br/>
                            r.addDesc(ent);<br/>
                            r.add(ent.getPosition().getBoardNum());<br/>
                            addReport(r);<br/>
                            break;<br/>
                        case 1:<br/>
                            deliverThunderVibraMinefield(ent.getPosition(), ent.getOwnerId(), 10, mine.getVibraSetting());<br/>
                            mine.setMissing(true);<br/>
                            r = new Report(3505);<br/>
                            r.subject = ent.getId();<br/>
                            r.addDesc(ent);<br/>
                            r.add(ent.getPosition().getBoardNum());<br/>
                            addReport(r);<br/>
                            break;<br/>
                        //TODO: command-detonated mines<br/>
                        // case 2:<br/>
                    }<br/>
                }<br/>
            }<br/>
            game.resetLayMinefieldActions();<br/>
        }<br/>
<br/>
        Vector clearAttempts = new Vector();<br/>
        Vector triggerPodActions = new Vector();<br/>
        // loop thru actions and handle everything we expect except attacks<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
            Entity entity = game.getEntity(ea.getEntityId());<br/>
            if (ea instanceof TorsoTwistAction) {<br/>
                TorsoTwistAction tta = (TorsoTwistAction)ea;<br/>
                if ( entity.canChangeSecondaryFacing() ) {<br/>
                    entity.setSecondaryFacing(tta.getFacing());<br/>
                }<br/>
            }<br/>
            else if (ea instanceof FlipArmsAction) {<br/>
                FlipArmsAction faa = (FlipArmsAction)ea;<br/>
                entity.setArmsFlipped(faa.getIsFlipped());<br/>
            }<br/>
            else if (ea instanceof FindClubAction) {<br/>
                resolveFindClub(entity);<br/>
            }<br/>
            else if (ea instanceof UnjamAction) {<br/>
                resolveUnjam(entity);<br/>
            }<br/>
            else if (ea instanceof ClearMinefieldAction) {<br/>
                clearAttempts.addElement(entity);<br/>
            }<br/>
            else if (ea instanceof TriggerAPPodAction) {<br/>
                TriggerAPPodAction tapa = (TriggerAPPodAction) ea;<br/>
<br/>
                // Don't trigger the same pod twice.<br/>
                if ( !triggerPodActions.contains( tapa ) ) {<br/>
                    triggerAPPod(entity, tapa.getPodId());<br/>
                    triggerPodActions.addElement( tapa );<br/>
                } else {<br/>
                    System.err.print( "AP Pod #" );<br/>
                    System.err.print( tapa.getPodId() );<br/>
                    System.err.print( " on " );<br/>
                    System.err.print( entity.getDisplayName() );<br/>
                    System.err.println(" was already triggered this round!!");<br/>
                }<br/>
            }<br/>
            else if (ea instanceof SearchlightAttackAction) {<br/>
                SearchlightAttackAction saa = (SearchlightAttackAction)ea;<br/>
                addReport(<br/>
                                      saa.resolveAction(game));<br/>
            }<br/>
        }<br/>
<br/>
        resolveClearMinefieldAttempts(clearAttempts);<br/>
    }<br/>
<br/>
    private void resolveClearMinefieldAttempts(Vector clearAttempts) {<br/>
<br/>
        for (int i = 0; i &lt; clearAttempts.size(); i++) {<br/>
            Vector temp = new Vector();<br/>
            Entity e = (Entity) clearAttempts.elementAt(i);<br/>
            Coords pos = e.getPosition();<br/>
            temp.addElement(e);<br/>
<br/>
            for (int j = i + 1; j &lt; clearAttempts.size(); j++) {<br/>
                Entity ent = (Entity) clearAttempts.elementAt(j);<br/>
                if (ent.getPosition().equals(pos)) {<br/>
                    temp.addElement(ent);<br/>
                    clearAttempts.removeElement(ent);<br/>
                }<br/>
            }<br/>
<br/>
            boolean accident = false;<br/>
            boolean cleared = false;<br/>
            for (int j = 0; j &lt; temp.size(); j++) {<br/>
                Entity ent = (Entity) temp.elementAt(j);<br/>
                int roll = Compute.d6(2);<br/>
                int clear = Minefield.CLEAR_NUMBER_INFANTRY;<br/>
                int boom = Minefield.CLEAR_NUMBER_INFANTRY_ACCIDENT;<br/>
<br/>
                // Does the entity has a minesweeper?<br/>
                Enumeration equip = ent.getMisc();<br/>
                while ( equip.hasMoreElements() ) {<br/>
                    Mounted mounted = (Mounted) equip.nextElement();<br/>
                    if ( mounted.getType().hasFlag(MiscType.F_TOOLS)<br/>
                     &amp;&amp; mounted.getType().hasSubType(MiscType.S_MINESWEEPER) ) {<br/>
                        int sweeperType = mounted.getType().getToHitModifier();<br/>
                        clear = Minefield.CLEAR_NUMBER_SWEEPER[sweeperType];<br/>
                        boom = Minefield.CLEAR_NUMBER_SWEEPER_ACCIDENT[sweeperType];<br/>
                        break;<br/>
                    }<br/>
                }<br/>
                //mine clearing roll<br/>
                Report r = new Report(2245);<br/>
                r.subject = ent.getId();<br/>
                r.add(ent.getShortName(), true);<br/>
                r.add(pos.getBoardNum(), true);<br/>
                r.add(clear);<br/>
                r.add(roll);<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
<br/>
                if (roll &gt;= clear) {<br/>
                    //success<br/>
                    r = new Report(2250);<br/>
                    r.subject = ent.getId();<br/>
                    addReport(r);<br/>
                    cleared = true;<br/>
                } else if (roll &lt;= boom) {<br/>
                    //"click"...oops!<br/>
                    r = new Report(2255);<br/>
                    r.subject = ent.getId();<br/>
                    addReport(r);<br/>
                    accident = true;<br/>
                } else {<br/>
                    //failure<br/>
                    r = new Report(2260);<br/>
                    r.subject = ent.getId();<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
            if (accident) {<br/>
                Enumeration minefields = game.getMinefields(pos).elements();<br/>
                while (minefields.hasMoreElements()) {<br/>
                    Minefield mf = (Minefield) minefields.nextElement();<br/>
                    switch (mf.getType()) {<br/>
                        case (Minefield.TYPE_CONVENTIONAL) :<br/>
                        case (Minefield.TYPE_THUNDER) :<br/>
                            for (int j = 0; j &lt; temp.size(); j++) {<br/>
                                Entity entity = (Entity) temp.elementAt(j);<br/>
                                Report r = new Report(2265);<br/>
                                r.subject = entity.getId();<br/>
                                r.add(entity.getShortName(), true);<br/>
                                addReport(r);<br/>
                                HitData hit = entity.rollHitLocation(Minefield.TO_HIT_TABLE, Minefield.TO_HIT_SIDE);<br/>
                                addReport( damageEntity(entity, hit, mf.getDamage()));<br/>
                                addNewLines();<br/>
                            }<br/>
                            break;<br/>
                        case (Minefield.TYPE_VIBRABOMB) :<br/>
                            explodeVibrabomb(mf);<br/>
                            break;<br/>
                    }<br/>
                }<br/>
            }<br/>
            if (cleared) {<br/>
                removeMinefieldsFrom(pos);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Called during the fire phase to resolve all (and only) weapon attacks<br/>
     */<br/>
    private void resolveOnlyWeaponAttacks() {<br/>
        Vector results = new Vector(game.actionsSize());<br/>
<br/>
        // loop thru received attack actions, getting weapon results<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
            if (o instanceof WeaponAttackAction) {<br/>
                WeaponAttackAction waa = (WeaponAttackAction)o;<br/>
                results.addElement(preTreatWeaponAttack(waa));<br/>
            }<br/>
        }<br/>
<br/>
        // loop through weapon results and resolve<br/>
        int cen = Entity.NONE;<br/>
        for (Enumeration i = results.elements(); i.hasMoreElements();) {<br/>
            WeaponResult wr = (WeaponResult)i.nextElement();<br/>
            resolveWeaponAttack(wr, cen);<br/>
            cen = wr.waa.getEntityId();<br/>
        }<br/>
<br/>
        // and clear the attacks Vector<br/>
        game.resetActions();<br/>
    }<br/>
<br/>
    /**<br/>
     * Trigger the indicated AP Pod of the entity.<br/>
     *<br/>
     * @param   entity the &lt;code&gt;Entity&lt;/code&gt; triggering the AP Pod.<br/>
     * @param   podId the &lt;code&gt;int&lt;/code&gt; ID of the AP Pod.<br/>
     */<br/>
    private void triggerAPPod( Entity entity, int podId ) {<br/>
<br/>
        // Get the mount for this pod.<br/>
        Mounted mount = entity.getEquipment( podId );<br/>
<br/>
        // Confirm that this is, indeed, an AP Pod.<br/>
        if ( null == mount ) {<br/>
            System.err.print( "Expecting to find an AP Pod at " );<br/>
            System.err.print( podId );<br/>
            System.err.print( " on the unit, " );<br/>
            System.err.print( entity.getDisplayName() );<br/>
            System.err.println( " but found NO equipment at all!!!" );<br/>
            return;<br/>
        }<br/>
        EquipmentType equip = mount.getType();<br/>
        if ( !(equip instanceof MiscType) ||<br/>
             !equip.hasFlag(MiscType.F_AP_POD) ) {<br/>
            System.err.print( "Expecting to find an AP Pod at " );<br/>
            System.err.print( podId );<br/>
            System.err.print( " on the unit, " );<br/>
            System.err.print( entity.getDisplayName() );<br/>
            System.err.print( " but found " );<br/>
            System.err.print( equip.getName() );<br/>
            System.err.println( " instead!!!" );<br/>
            return;<br/>
        }<br/>
<br/>
        // Now confirm that the entity can trigger the pod.<br/>
        // Ignore the "used this round" flag.<br/>
        boolean oldFired = mount.isUsedThisRound();<br/>
        mount.setUsedThisRound( false );<br/>
        boolean canFire = mount.canFire();<br/>
        mount.setUsedThisRound( oldFired );<br/>
        if ( !canFire ) {<br/>
            System.err.print( "Can not trigger the AP Pod at " );<br/>
            System.err.print( podId );<br/>
            System.err.print( " on the unit, " );<br/>
            System.err.print( entity.getDisplayName() );<br/>
            System.err.println( "!!!" );<br/>
            return;<br/>
        }<br/>
<br/>
        Report r;<br/>
<br/>
        // Mark the pod as fired and log the action.<br/>
        mount.setFired( true );<br/>
        r = new Report(3010);<br/>
        r.newlines = 0;<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        addReport(r);<br/>
<br/>
        // Walk through ALL entities in the triggering entity's hex.<br/>
        Enumeration targets = game.getEntities( entity.getPosition() );<br/>
        while ( targets.hasMoreElements() ) {<br/>
            final Entity target = (Entity) targets.nextElement();<br/>
<br/>
            // Is this an unarmored infantry platoon?<br/>
            if ( target instanceof Infantry &amp;&amp;<br/>
                 !(target instanceof BattleArmor) ) {<br/>
<br/>
                // Roll d6-1 for damage.<br/>
                final int damage = Compute.d6() - 1;<br/>
<br/>
                // If the platoon took no damage, log it and go no further<br/>
                if ( 0 == damage ) {<br/>
                    r = new Report(3015);<br/>
                    r.indent(2);<br/>
                    r.subject = target.getId();<br/>
                    r.addDesc(target);<br/>
                    addReport(r);<br/>
                }<br/>
                else {<br/>
                    // Damage the platoon.<br/>
                    addReport( damageEntity( target, new HitData(Infantry.LOC_INFANTRY),damage ));<br/>
<br/>
                    // Damage from AP Pods is applied immediately.<br/>
                    target.applyDamage();<br/>
                }<br/>
<br/>
            } // End target-is-unarmored<br/>
<br/>
            // Nope, the target is immune.<br/>
            // Don't make a log entry for the triggering entity.<br/>
            else if ( !entity.equals( target ) ) {<br/>
                r = new Report(3020);<br/>
                r.indent(2);<br/>
                r.subject = target.getId();<br/>
                r.addDesc(target);<br/>
                addReport(r);<br/>
            }<br/>
<br/>
        } // Check the next entity in the triggering entity's hex.<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolve an Unjam Action object<br/>
     */<br/>
    private void resolveUnjam(Entity entity) {<br/>
        Report r;<br/>
        final int TN = entity.getCrew().getGunnery() + 3;<br/>
        r = new Report(3025);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        addReport(r);<br/>
        for (Enumeration i = entity.getWeapons(); i.hasMoreElements();) {<br/>
            Mounted mounted = (Mounted)i.nextElement();<br/>
            if(mounted.isJammed()) {<br/>
                WeaponType wtype = (WeaponType)mounted.getType();<br/>
                if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
                    int roll = Compute.d6(2);<br/>
                    r = new Report(3030);<br/>
                    r.indent();<br/>
                    r.subject = entity.getId();<br/>
                    r.add(wtype.getName());<br/>
                    r.add(TN);<br/>
                    r.add(roll);<br/>
                    if(roll &gt;= TN) {<br/>
                        r.choose(true);<br/>
                        mounted.setJammed(false);<br/>
                    } else {<br/>
                        r.choose(false);<br/>
                    }<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    private void resolveFindClub(Entity entity) {<br/>
        EquipmentType clubType = null;<br/>
<br/>
        entity.setFindingClub(true);<br/>
<br/>
        // Get the entity's current hex.<br/>
        Coords coords = entity.getPosition();<br/>
        IHex curHex = game.getBoard().getHex( coords );<br/>
<br/>
        Report r;<br/>
<br/>
        // Is there a blown off arm in the hex?<br/>
        if (curHex.terrainLevel(Terrains.ARMS) &gt; 0) {<br/>
            clubType = EquipmentType.get("Limb Club");<br/>
            curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ARMS, curHex.terrainLevel(Terrains.ARMS)-1));<br/>
            sendChangedHex(entity.getPosition());<br/>
            r = new Report(3035);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
        }<br/>
        // Is there a blown off leg in the hex?<br/>
        else if (curHex.terrainLevel(Terrains.LEGS) &gt; 0) {<br/>
            clubType = EquipmentType.get("Limb Club");<br/>
            curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.LEGS, curHex.terrainLevel(Terrains.LEGS)-1));<br/>
            sendChangedHex(entity.getPosition());<br/>
            r = new Report(3040);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // Is there the rubble of a medium, heavy,<br/>
        // or hardened building in the hex?<br/>
        else if ( Building.LIGHT &lt; curHex.terrainLevel( Terrains.RUBBLE ) ) {<br/>
<br/>
            // Finding a club is not guaranteed.  The chances are<br/>
            // based on the type of building that produced the<br/>
            // rubble.<br/>
            boolean found = false;<br/>
            int roll = Compute.d6(2);<br/>
            switch ( curHex.terrainLevel( Terrains.RUBBLE ) ) {<br/>
            case Building.MEDIUM:<br/>
                if ( roll &gt;= 7 ) {<br/>
                    found = true;<br/>
                }<br/>
                break;<br/>
            case Building.HEAVY:<br/>
                if ( roll &gt;= 6 ) {<br/>
                    found = true;<br/>
                }<br/>
                break;<br/>
            case Building.HARDENED:<br/>
                if ( roll &gt;= 5 ) {<br/>
                    found = true;<br/>
                }<br/>
                break;<br/>
            }<br/>
<br/>
            // Let the player know if they found a club.<br/>
            if ( found ) {<br/>
                clubType = EquipmentType.get("Girder Club");<br/>
                r = new Report(3045);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
            } else {<br/>
                // Sorry, no club for you.<br/>
                clubType = null;<br/>
                r = new Report(3050);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        // Are there woods in the hex?<br/>
        else if ( curHex.containsTerrain( Terrains.WOODS )<br/>
                || curHex.containsTerrain( Terrains.JUNGLE ) ) {<br/>
            clubType = EquipmentType.get("Tree Club");<br/>
            r = new Report(3055);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // add the club<br/>
        try {<br/>
            if (clubType != null) {<br/>
                entity.addEquipment(clubType, Mech.LOC_NONE);<br/>
            }<br/>
        } catch (LocationFullException ex) {<br/>
            // unlikely...<br/>
            r = new Report(3060);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Generates a WeaponResult object for a WeaponAttackAction.  Adds heat,<br/>
     * depletes ammo, sets weapons used.<br/>
     */<br/>
    private WeaponResult preTreatWeaponAttack(WeaponAttackAction waa) {<br/>
        final Entity ae = game.getEntity(waa.getEntityId());<br/>
        final Mounted weapon = ae.getEquipment(waa.getWeaponId());<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        // 2003-01-02 BattleArmor MG and Small Lasers have unlimited ammo.<br/>
        final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
            !wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
<br/>
        Mounted ammo = null;<br/>
        if (usesAmmo) {<br/>
            if (waa.getAmmoId() &gt; -1) {<br/>
                ammo = ae.getEquipment(waa.getAmmoId());<br/>
                weapon.setLinked(ammo);<br/>
            } else {<br/>
                ammo = weapon.getLinked();<br/>
            }<br/>
        }<br/>
        boolean streakMiss;<br/>
<br/>
        WeaponResult wr = new WeaponResult();<br/>
        wr.waa = waa;<br/>
<br/>
        // has this weapon fired already?<br/>
        if (weapon.isUsedThisRound()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon has already been used this round");<br/>
            return wr;<br/>
        }<br/>
        // is the weapon functional?<br/>
        if (weapon.isDestroyed()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon was destroyed in a previous round");<br/>
            return wr;<br/>
        }<br/>
        // is it jammed?<br/>
        if (weapon.isJammed()) {<br/>
            wr.toHit = new ToHitData(TargetRoll.IMPOSSIBLE, "Weapon is jammed");<br/>
            return wr;<br/>
        }<br/>
        // make sure ammo is loaded<br/>
        if (usesAmmo &amp;&amp; (ammo == null || ammo.getShotsLeft() == 0 || ammo.isDumping())) {<br/>
            ae.loadWeaponWithSameAmmo(weapon);<br/>
            ammo = weapon.getLinked();<br/>
        }<br/>
<br/>
        // store the ammo type for later use (needed for artillery attacks)<br/>
        waa.setAmmoId(ae.getEquipmentNum(ammo));<br/>
<br/>
        // compute to-hit<br/>
        wr.toHit = waa.toHit(game);<br/>
        <br/>
        if (waa.isNemesisConfused()) {<br/>
            wr.toHit.addModifier(1, "iNarc Nemesis pod");<br/>
        }<br/>
        // roll dice<br/>
        wr.roll = Compute.d6(2);<br/>
<br/>
        // if the shot is possible and not a streak miss<br/>
        // and not a nemesis-confused shot, add heat and use ammo<br/>
        streakMiss = (((wtype.getAmmoType() == AmmoType.T_SRM_STREAK)<br/>
                || (wtype.getAmmoType() == AmmoType.T_LRM_STREAK))<br/>
                &amp;&amp; wr.roll &lt; wr.toHit.getValue());<br/>
        if (wr.toHit.getValue() != TargetRoll.IMPOSSIBLE<br/>
                &amp;&amp; (!streakMiss || Compute.isAffectedByAngelECM(ae, ae.getPosition(), waa.getTarget(game).getPosition()))<br/>
                &amp;&amp; !waa.isNemesisConfused()) {<br/>
            wr = addHeatUseAmmoFor(waa, wr);<br/>
        }<br/>
<br/>
        // set the weapon as having fired<br/>
        weapon.setUsedThisRound(true);<br/>
<br/>
        // if not streak miss, resolve any AMS attacks on this attack<br/>
        if (!streakMiss) {<br/>
            wr = resolveAmsFor(waa, wr);<br/>
        }<br/>
<br/>
        return wr;<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds heat and uses ammo appropriate for a single attack of this weapon.<br/>
     * Call only on a valid attack (and with a streak weapon, only on hits.)<br/>
     *<br/>
     * @returns modified WeaponResult<br/>
     */<br/>
    private WeaponResult addHeatUseAmmoFor(WeaponAttackAction waa, WeaponResult wr) {<br/>
        if (waa.isSwarmingMissiles()) return wr;<br/>
        <br/>
        final Entity ae = game.getEntity(waa.getEntityId());<br/>
        final Mounted weapon = ae.getEquipment(waa.getWeaponId());<br/>
        final WeaponType wtype = (WeaponType)weapon.getType();<br/>
        // 2003-01-02 BattleArmor MG and Small Lasers have unlimited ammo.<br/>
        final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
            wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
            !wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
<br/>
        Mounted ammo = weapon.getLinked();<br/>
<br/>
        // how many shots are we firing?<br/>
        int nShots = weapon.howManyShots();<br/>
<br/>
        // do we need to revert to single shot?<br/>
        if (usesAmmo &amp;&amp; nShots &gt; 1) {<br/>
            int nAvail = ae.getTotalAmmoOfType(ammo.getType());<br/>
            if (nAvail &lt; nShots) {<br/>
                wr.revertsToSingleShot = true;<br/>
                nShots = 1;<br/>
            }<br/>
        }<br/>
<br/>
        // use up ammo<br/>
        if (usesAmmo) {<br/>
            for (int i = 0; i &lt; nShots; i++) {<br/>
                if (ammo.getShotsLeft() &lt;= 0) {<br/>
                    ae.loadWeaponWithSameAmmo(weapon);<br/>
                    ammo = weapon.getLinked();<br/>
                }<br/>
                ammo.setShotsLeft(ammo.getShotsLeft() - 1);<br/>
            }<br/>
        }<br/>
<br/>
        // build up some heat<br/>
        ae.heatBuildup += (wtype.getHeat() * nShots);<br/>
<br/>
        return wr;<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolves any AMS fire for this weapon attack, adding AMS heat, depleting<br/>
     * AMS ammo.<br/>
     * @returns the appropriately modified WeaponResult<br/>
     */<br/>
    private WeaponResult resolveAmsFor(WeaponAttackAction waa, WeaponResult wr) {<br/>
        final Entity te = game.getEntity(waa.getTargetId());<br/>
<br/>
        // any AMS attacks by the target?<br/>
        Vector vCounters = waa.getCounterEquipment();<br/>
        if (null != vCounters) {<br/>
            // resolve AMS counter-fire<br/>
            wr.amsShotDown = new int[vCounters.size()];<br/>
            for (int x = 0; x &lt; vCounters.size(); x++) {<br/>
                wr.amsShotDown[x] = 0;<br/>
<br/>
                Mounted counter = (Mounted)vCounters.elementAt(x);<br/>
                Mounted mAmmo = counter.getLinked();<br/>
                if ((!(counter.getType() instanceof WeaponType))<br/>
                        || (!(counter.getType().hasFlag(WeaponType.F_AMS)))<br/>
                        || (!counter.isReady())<br/>
                        || (counter.isMissing())) {<br/>
                    continue;<br/>
                }<br/>
                // roll hits<br/>
                int amsHits = Compute.d6(((WeaponType)counter.getType()).getDamage());<br/>
<br/>
                // build up some heat (assume target is ams owner)<br/>
                if (counter.getType().hasFlag(WeaponType.F_HEATASDICE))<br/>
                    te.heatBuildup += Compute.d6(((WeaponType)counter.getType()).getHeat());<br/>
                else<br/>
                    te.heatBuildup += ((WeaponType)counter.getType()).getHeat();<br/>
<br/>
                // decrement the ammo<br/>
                if (mAmmo != null)<br/>
                    mAmmo.setShotsLeft(Math.max(0, mAmmo.getShotsLeft() - amsHits));<br/>
<br/>
                // set the ams as having fired<br/>
                counter.setUsedThisRound(true);<br/>
<br/>
                wr.amsShotDown[x]    = amsHits;<br/>
                wr.amsShotDownTotal += amsHits;<br/>
            }<br/>
        }<br/>
<br/>
        return wr;<br/>
    }<br/>
<br/>
    /**<br/>
     * Try to ignite the hex, taking into account exisiting fires and the<br/>
     * effects of Inferno rounds.<br/>
     *<br/>
     * @param   c - the &lt;code&gt;Coords&lt;/code&gt; of the hex being lit.<br/>
     * @param   bInferno - &lt;code&gt;true&lt;/code&gt; if the weapon igniting the<br/>
     *          hex is an Inferno round.  If some other weapon or ammo<br/>
     *          is causing the roll, this should be &lt;code&gt;false&lt;/code&gt;.<br/>
     * @param   nTargetRoll - the &lt;code&gt;int&lt;/code&gt; target number for the<br/>
     *          ignition roll.<br/>
     * @param   nTargetRoll - the &lt;code&gt;int&lt;/code&gt; roll target for the attempt.<br/>
     * @param   bReportAttempt - &lt;code&gt;true&lt;/code&gt; if the attempt roll should<br/>
     *          be added to the report.<br/>
     */<br/>
    private boolean tryIgniteHex( Coords c, int entityId, boolean bInferno,<br/>
                                  int nTargetRoll, boolean bReportAttempt ) {<br/>
<br/>
        IHex hex = game.getBoard().getHex(c);<br/>
        boolean bAnyTerrain = false;<br/>
        Report r;<br/>
<br/>
        // Ignore bad coordinates.<br/>
        if ( hex == null ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // inferno always ignites<br/>
        if (bInferno) {<br/>
            game.getBoard().addInfernoTo(c, InfernoTracker.STANDARD_ROUND, 1);<br/>
            nTargetRoll = 0;<br/>
            bAnyTerrain = true;<br/>
        }<br/>
<br/>
        // The hex may already be on fire.<br/>
        if ( hex.containsTerrain( Terrains.FIRE ) ) {<br/>
            if ( bReportAttempt ) {<br/>
                r = new Report(3065);<br/>
                r.indent(3);<br/>
                r.subject = entityId;<br/>
                addReport(r);<br/>
            }<br/>
            return true;<br/>
        }<br/>
        else if ( ignite(hex, nTargetRoll, bAnyTerrain, entityId) ) {<br/>
            //hex ignites<br/>
            r = new Report(3070);<br/>
            r.indent(3);<br/>
            r.subject = entityId;<br/>
            addReport(r);<br/>
            sendChangedHex(c);<br/>
            return true;<br/>
        }<br/>
        return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Try to ignite the hex, taking into account exisiting fires and the<br/>
     * effects of Inferno rounds.  This version of the method will not report<br/>
     * the attempt roll.<br/>
     *<br/>
     * @param   c - the &lt;code&gt;Coords&lt;/code&gt; of the hex being lit.<br/>
     * @param   bInferno - &lt;code&gt;true&lt;/code&gt; if the weapon igniting the<br/>
     *          hex is an Inferno round.  If some other weapon or ammo<br/>
     *          is causing the roll, this should be &lt;code&gt;false&lt;/code&gt;.<br/>
     * @param   nTargetRoll - the &lt;code&gt;int&lt;/code&gt; roll target for the attempt.<br/>
     */<br/>
   private boolean tryIgniteHex(Coords c, int entityId, boolean bInferno,<br/>
                                int nTargetRoll) {<br/>
       return tryIgniteHex(c, entityId, bInferno, nTargetRoll, false);<br/>
   }<br/>
<br/>
    private void tryClearHex(Coords c, int nTarget, int entityId) {<br/>
        IHex h = game.getBoard().getHex(c);<br/>
        int woods = h.terrainLevel(Terrains.WOODS);<br/>
        int jungle = h.terrainLevel(Terrains.JUNGLE);<br/>
        boolean ice = h.containsTerrain(Terrains.ICE);<br/>
        Report r;<br/>
        if (woods == ITerrain.LEVEL_NONE &amp;&amp; jungle == ITerrain.LEVEL_NONE &amp;&amp; !ice) {<br/>
            //woods already cleared<br/>
            r = new Report(3075);<br/>
            r.indent(3);<br/>
            r.subject = entityId;<br/>
            addReport(r);<br/>
        } else {<br/>
            int woodsRoll = Compute.d6(2);<br/>
            r = new Report(3080);<br/>
            r.indent(3);<br/>
            r.subject = entityId;<br/>
            r.add(nTarget);<br/>
            r.add(woodsRoll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if(woodsRoll &gt;= nTarget) {<br/>
                if(woods &gt; 2) {<br/>
                    h.removeTerrain(Terrains.WOODS);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.WOODS, woods - 1));<br/>
                    //ultra heavy converted to heavy<br/>
                    r = new Report(3082);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(woods == 2) {<br/>
                    h.removeTerrain(Terrains.WOODS);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.WOODS, woods - 1));<br/>
                    //heavy converted to light<br/>
                    r = new Report(3085);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(woods == 1) {<br/>
                    h.removeTerrain(Terrains.WOODS);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ROUGH, 1));<br/>
                    //light converted to rough<br/>
                    r = new Report(3090);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(jungle &gt; 2) {<br/>
                    h.removeTerrain(Terrains.JUNGLE);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.JUNGLE, jungle - 1));<br/>
                    //ultra heavy converted to heavy<br/>
                    r = new Report(3083);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(jungle == 2) {<br/>
                    h.removeTerrain(Terrains.JUNGLE);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.JUNGLE, jungle - 1));<br/>
                    //heavy converted to light<br/>
                    r = new Report(3086);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(jungle == 1) {<br/>
                    h.removeTerrain(Terrains.JUNGLE);<br/>
                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ROUGH, 1));<br/>
                    //light converted to rough<br/>
                    r = new Report(3091);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                }<br/>
                else if(ice) {<br/>
                    h.removeTerrain(Terrains.ICE);<br/>
                    r = new Report(3092);<br/>
                    r.subject = entityId;<br/>
                    addReport(r);<br/>
                    resolveIceBroken(c);<br/>
                }<br/>
                sendChangedHex(c);<br/>
            } else {<br/>
                //fails to clear woods<br/>
                r = new Report(3095);<br/>
                r.subject = entityId;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    private void resolveWeaponAttack(WeaponResult wr, int lastEntityId) {<br/>
        resolveWeaponAttack(wr, lastEntityId, false);<br/>
    }<br/>
    <br/>
    private boolean resolveWeaponAttack(WeaponResult wr, int lastEntityId, boolean isNemesisConfused) {<br/>
        return resolveWeaponAttack(wr, lastEntityId, isNemesisConfused, 0);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Resolve a single Weapon Attack object<br/>
     * @param wr The &lt;code&gt;WeaponResult&lt;/code&gt; to resolve<br/>
     * @param lastEntityId The &lt;code&gt;int&lt;/code&gt; ID of the last<br/>
     *        resolved weaponattack's attacking entity<br/>
     * @param isNemesisConfused The &lt;code&gt;boolean&lt;/code&gt; value of wether<br/>
     *        this attack is one caused by homing in on a iNarc Nemesis pod<br/>
     *        and so should not be further diverted<br/>
     * @param swarmMissilesLeft The &lt;code&gt;int&lt;/code&gt; number of remaining swarm<br/>
     *        missiles this attack has, 0 if this is not a remaining swarm<br/>
     *        missile attack <br/>
     * @return wether we hit or not, only needed for nemesis pod stuff<br/>
     */<br/>
    private boolean resolveWeaponAttack(WeaponResult wr, int lastEntityId, boolean isNemesisConfused, int swarmMissilesLeft) {<br/>
      // If it's an artillery shot, the shooting entity<br/>
      // might have died in the meantime<br/>
      Entity ae = game.getEntity( wr.waa.getEntityId() );<br/>
      if (ae == null) {<br/>
          ae = game.getOutOfGameEntity( wr.waa.getEntityId() );<br/>
      }<br/>
      final Targetable target = game.getTarget(wr.waa.getTargetType(),<br/>
                                               wr.waa.getTargetId());<br/>
      Report r;<br/>
      boolean throughFront;<br/>
      if (target instanceof Mech) {<br/>
          throughFront = Compute.isThroughFrontHex(game, wr.waa.getEntityId(), (Entity)target); <br/>
      } else {<br/>
          throughFront = true;<br/>
      }<br/>
       <br/>
      int subjectId = Entity.NONE;<br/>
      Entity entityTarget = null;<br/>
      if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
          entityTarget = (Entity) target;<br/>
          // The target of the attack should definately see the report.<br/>
          // The attacker usually will, but they might not if the attack<br/>
          // was indirect without a spotter.<br/>
          subjectId = entityTarget.getId();<br/>
      } else {<br/>
          //The target is not an entity, so we will show the report to<br/>
          // the attacker instead.<br/>
          subjectId = ae.getId();<br/>
      }<br/>
      final Mounted weapon = ae.getEquipment(wr.waa.getWeaponId());<br/>
      final WeaponType wtype = (WeaponType) weapon.getType();<br/>
      final boolean isWeaponInfantry = wtype.hasFlag(WeaponType.F_INFANTRY);<br/>
      // 2002-09-16 Infantry weapons have unlimited ammo.<br/>
      final boolean usesAmmo = wtype.getAmmoType() != AmmoType.T_NA &amp;&amp;<br/>
          wtype.getAmmoType() != AmmoType.T_BA_MG &amp;&amp;<br/>
          wtype.getAmmoType() != AmmoType.T_BA_SMALL_LASER &amp;&amp;<br/>
          !isWeaponInfantry;<br/>
      //retrieve ammo from the WeaponAttackAction rather than weapon.getLinked, because selected ammo may have changed<br/>
      //in the case of artillery attacks<br/>
      Mounted ammo = usesAmmo ? ae.getEquipment(wr.waa.getAmmoId()) : null;<br/>
      final AmmoType atype = ammo == null ? null : (AmmoType) ammo.getType();<br/>
      Infantry platoon = null;<br/>
      final boolean isBattleArmorAttack = wtype.hasFlag(WeaponType.F_BATTLEARMOR);<br/>
      ToHitData toHit = wr.toHit;<br/>
      boolean bInferno = (usesAmmo<br/>
                        &amp;&amp; ((atype.getAmmoType() == AmmoType.T_SRM)<br/>
                        || (atype.getAmmoType() == AmmoType.T_BA_INFERNO))<br/>
                        &amp;&amp; atype.getMunitionType() == AmmoType.M_INFERNO);<br/>
      boolean bFragmentation = (usesAmmo<br/>
                                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM) || (atype.getAmmoType() == AmmoType.T_SRM))<br/>
                                &amp;&amp; atype.getMunitionType() == AmmoType.M_FRAGMENTATION);<br/>
      boolean bAcidHead = (usesAmmo<br/>
                            &amp;&amp; atype.getAmmoType() == AmmoType.T_SRM<br/>
                            &amp;&amp; atype.getMunitionType() == AmmoType.M_AX_HEAD);<br/>
      boolean bFlechette = (usesAmmo &amp;&amp; (atype.getAmmoType() == AmmoType.T_AC)<br/>
                            &amp;&amp; atype.getMunitionType() == AmmoType.M_FLECHETTE);<br/>
      boolean bArtillery = target.getTargetType() == Targetable.TYPE_HEX_ARTILLERY;<br/>
      boolean bArtilleryFLAK = target.getTargetType() == Targetable.TYPE_ENTITY<br/>
                               &amp;&amp; wtype.hasFlag(WeaponType.F_ARTILLERY) <br/>
                               &amp;&amp; (usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_STANDARD)<br/>
                               &amp;&amp; entityTarget.getMovementMode() == IEntityMovementMode.VTOL<br/>
                               &amp;&amp; entityTarget.getElevation() &gt; 0;<br/>
      boolean bIncendiary = (usesAmmo &amp;&amp; atype.getAmmoType() == AmmoType.T_AC &amp;&amp;<br/>
              (atype.getMunitionType() == AmmoType.M_INCENDIARY_AC));<br/>
      boolean bTracer = (usesAmmo &amp;&amp; atype.getAmmoType() == AmmoType.T_AC &amp;&amp;<br/>
              (atype.getMunitionType() == AmmoType.M_TRACER));<br/>
      boolean bAntiTSM = (usesAmmo<br/>
                            &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM) || (atype.getAmmoType() == AmmoType.T_SRM))<br/>
                             &amp;&amp; atype.getMunitionType() == AmmoType.M_ANTI_TSM);<br/>
      boolean bSwarm = (usesAmmo<br/>
                            &amp;&amp; (atype.getAmmoType() == AmmoType.T_LRM)<br/>
                            &amp;&amp; atype.getMunitionType() == AmmoType.M_SWARM);<br/>
      boolean bSwarmI = (usesAmmo<br/>
                            &amp;&amp; (atype.getAmmoType() == AmmoType.T_LRM)<br/>
                            &amp;&amp; atype.getMunitionType() == AmmoType.M_SWARM_I);<br/>
      boolean isIndirect = ((wtype.getAmmoType() == AmmoType.T_LRM) || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO))<br/>
                               &amp;&amp; weapon.curMode().equals("Indirect");<br/>
      boolean isHotLoaded = ((wtype.getAmmoType() == AmmoType.T_LRM) ||                 <br/>
              (wtype.getAmmoType() == AmmoType.T_LRM_STREAK) ||<br/>
              (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO) ||<br/>
              (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO_COMBO))<br/>
               &amp;&amp; weapon.curMode().equals("Hot Load");<br/>
      boolean isAngelECMAffected = Compute.isAffectedByAngelECM(ae, ae.getPosition(), target.getPosition());<br/>
      if (isIndirect &amp;&amp; game.getOptions().booleanOption("indirect_fire") &amp;&amp;<br/>
          !game.getOptions().booleanOption("indirect_always_possible") &amp;&amp;<br/>
          LosEffects.calculateLos(game, ae.getId(), target).canSee()) {<br/>
          r = new Report(3470);<br/>
          r.subject = subjectId;<br/>
          r.addDesc(ae);<br/>
          addReport(r);<br/>
          return false;<br/>
      }<br/>
      boolean bGlancing = false; // For Glancing Hits Rule<br/>
      int swarmMissilesNowLeft = 0;<br/>
      int hits = 1, glancingMissileMod = 0;<br/>
      int glancingCritMod = 0;<br/>
<br/>
      if (!bInferno) {<br/>
        // also check for inferno infantry<br/>
        bInferno = (isWeaponInfantry &amp;&amp; wtype.hasFlag(WeaponType.F_INFERNO));<br/>
      }<br/>
      final boolean targetInBuilding =<br/>
          Compute.isInBuilding(game, entityTarget);<br/>
      if ((bArtillery||bArtilleryFLAK) &amp;&amp; game.getPhase()==IGame.PHASE_FIRING) { //if direct artillery<br/>
          wr.artyAttackerCoords=ae.getPosition();<br/>
      }<br/>
      if ( (bSwarm || bSwarmI) &amp;&amp; entityTarget != null) {<br/>
          entityTarget.addTargetedBySwarm(ae.getId(), wr.waa.getWeaponId());<br/>
      }<br/>
<br/>
      // Which building takes the damage?<br/>
      Building bldg = game.getBoard().getBuildingAt(target.getPosition());<br/>
      <br/>
      // Are we iNarc Nemesis Confusable?<br/>
      boolean isNemesisConfusable = false;<br/>
      Mounted mLinker = weapon.getLinkedBy();<br/>
      if ( wtype.getAmmoType() == AmmoType.T_ATM ||<br/>
           ( mLinker != null &amp;&amp;<br/>
             mLinker.getType() instanceof MiscType &amp;&amp;<br/>
             !mLinker.isDestroyed() &amp;&amp; !mLinker.isMissing() &amp;&amp; !mLinker.isBreached() &amp;&amp;<br/>
             mLinker.getType().hasFlag(MiscType.F_ARTEMIS) ) ) {<br/>
          if ((!weapon.getType().hasModes() ||<br/>
               !weapon.curMode().equals("Indirect")) &amp;&amp;<br/>
              ( ((atype.getAmmoType() == AmmoType.T_ATM) &amp;&amp;<br/>
                 (atype.getMunitionType() == AmmoType.M_STANDARD ||<br/>
                  atype.getMunitionType() == AmmoType.M_EXTENDED_RANGE ||<br/>
                  atype.getMunitionType() == AmmoType.M_HIGH_EXPLOSIVE) ) ||<br/>
                ((atype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 atype.getAmmoType() == AmmoType.T_SRM) &amp;&amp;<br/>
                atype.getMunitionType() == AmmoType.M_ARTEMIS_CAPABLE))) {<br/>
              isNemesisConfusable = true;<br/>
          }<br/>
      } else if (wtype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_SRM) {<br/>
          if (usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_NARC_CAPABLE) {<br/>
              isNemesisConfusable = true;<br/>
          }<br/>
      }<br/>
<br/>
      if (lastEntityId != ae.getId()) {<br/>
          //report who is firing<br/>
          r = new Report(3100);<br/>
          r.subject = subjectId;<br/>
          r.addDesc(ae);<br/>
          addReport(r);<br/>
      }<br/>
<br/>
      // Swarming infantry can stop during any weapons phase after start.<br/>
      if (Infantry.STOP_SWARM.equals(wtype.getInternalName())) {<br/>
          // ... but only as their *only* attack action.<br/>
          if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
              r = new Report(3105);<br/>
              r.subject = subjectId;<br/>
              r.add(toHit.getDesc());<br/>
              addReport(r);<br/>
              return true;<br/>
          } else {<br/>
              //swarming ended succesfully<br/>
              r = new Report(3110);<br/>
              r.subject = subjectId;<br/>
              addReport(r);<br/>
              // Only apply the "stop swarm 'attack'" to the swarmed Mek.<br/>
              if (ae.getSwarmTargetId() != target.getTargetId()) {<br/>
                  Entity other = game.getEntity(ae.getSwarmTargetId());<br/>
                  other.setSwarmAttackerId(Entity.NONE);<br/>
              }<br/>
              else {<br/>
                  entityTarget.setSwarmAttackerId(Entity.NONE);<br/>
              }<br/>
              ae.setSwarmTargetId(Entity.NONE);<br/>
              return true;<br/>
          }<br/>
      }<br/>
<br/>
      // Report weapon attack and its to-hit value.<br/>
      r = new Report(3115);<br/>
      r.indent();<br/>
      r.newlines = 0;<br/>
      r.subject = subjectId;<br/>
      r.add(wtype.getName());<br/>
      if (entityTarget != null) {<br/>
          r.addDesc(entityTarget);<br/>
      } else {<br/>
          r.messageId = 3120;<br/>
          r.add(target.getDisplayName(), true);<br/>
      }<br/>
      addReport(r);<br/>
<br/>
      boolean shotAtNemesisTarget = false;<br/>
      // check for nemesis<br/>
      if (isNemesisConfusable &amp;&amp; !isNemesisConfused) {<br/>
          // loop through nemesis targets<br/>
          for (Enumeration e = game.getNemesisTargets(ae, target.getPosition());e.hasMoreElements();) {<br/>
              Entity entity = (Entity)e.nextElement();<br/>
              //friendly unit with attached iNarc Nemesis pod standing in the way<br/>
              r = new Report(3125);<br/>
              r.subject = subjectId;<br/>
              addReport(r);<br/>
              weapon.setUsedThisRound(false);<br/>
              WeaponAttackAction newWaa = new WeaponAttackAction(ae.getId(),<br/>
                  entity.getTargetId(), wr.waa.getWeaponId());<br/>
              newWaa.setNemesisConfused(true);<br/>
              WeaponResult newWr = preTreatWeaponAttack(newWaa);<br/>
              // attack the new target, and if we hit it, return;<br/>
              if (resolveWeaponAttack(newWr, ae.getId(), true)) return true;<br/>
              shotAtNemesisTarget = true;<br/>
          }<br/>
      }<br/>
      if (shotAtNemesisTarget) {<br/>
          //back to original target<br/>
          r = new Report(3130);<br/>
          r.subject = subjectId;<br/>
          r.newlines = 0;<br/>
          addReport(r);<br/>
      }<br/>
      if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
          r = new Report(3135);<br/>
          r.subject = subjectId;<br/>
          r.add(toHit.getDesc());<br/>
          addReport(r);<br/>
          return false;<br/>
      }<br/>
      else if (toHit.getValue() == ToHitData.AUTOMATIC_FAIL) {<br/>
          r = new Report(3140);<br/>
          r.newlines = 0;<br/>
          r.subject = subjectId;<br/>
          r.add(toHit.getDesc());<br/>
          addReport(r);<br/>
      }<br/>
      else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
          r = new Report(3145);<br/>
          r.newlines = 0;<br/>
          r.subject = subjectId;<br/>
          r.add(toHit.getDesc());<br/>
          addReport(r);<br/>
      }<br/>
      else {<br/>
          //roll to hit<br/>
          r = new Report(3150);<br/>
          r.newlines = 0;<br/>
          r.subject = subjectId;<br/>
          r.add(toHit.getValue());<br/>
          addReport(r);<br/>
      }<br/>
<br/>
      // if firing an HGR unbraced, schedule a PSR<br/>
      if (wtype.getAmmoType() == AmmoType.T_GAUSS_HEAVY &amp;&amp; ae.mpUsed &gt; 0) {<br/>
          // the mod is weight-based<br/>
          int nMod;<br/>
          switch (ae.getWeightClass()) {<br/>
          case EntityWeightClass.WEIGHT_LIGHT:<br/>
              nMod = 2;<br/>
              break;<br/>
          case EntityWeightClass.WEIGHT_MEDIUM:<br/>
              nMod = 1;<br/>
              break;<br/>
          case EntityWeightClass.WEIGHT_HEAVY:<br/>
              nMod = 0;<br/>
              break;<br/>
          default:<br/>
              nMod = -1;<br/>
          }<br/>
          PilotingRollData psr = new PilotingRollData(ae.getId(), nMod,<br/>
                                          "fired HeavyGauss unbraced");<br/>
          psr.setCumulative(false);<br/>
          game.addPSR(psr);<br/>
      }<br/>
<br/>
      // dice have been rolled, thanks<br/>
      r = new Report(3155);<br/>
      r.newlines = 0;<br/>
      r.subject = subjectId;<br/>
      r.add(wr.roll);<br/>
      addReport(r);<br/>
<br/>
      // check for AC or Prototype jams<br/>
      int nShots = weapon.howManyShots();<br/>
      if (nShots &gt; 1 || <br/>
          (wtype.hasFlag(WeaponType.F_PROTOTYPE) &amp;&amp;<br/>
           wtype.getAmmoType() != AmmoType.T_NA) ) {<br/>
          int jamCheck = 0;<br/>
          if ((((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)<br/>
                || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB))<br/>
                &amp;&amp; weapon.curMode().equals("Ultra")) ||<br/>
              wtype.hasFlag(WeaponType.F_PROTOTYPE)) {<br/>
              jamCheck = 2;<br/>
              if (weapon.getType().hasModes() &amp;&amp;<br/>
                      weapon.curMode().equals("Ultra") &amp;&amp;<br/>
                      wtype.hasFlag(WeaponType.F_PROTOTYPE)) {<br/>
                  jamCheck = 4;<br/>
              }<br/>
          } else if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
              if (nShots == 2) {<br/>
                  jamCheck = 2;<br/>
              } else if (nShots == 4) {<br/>
                  jamCheck = 3;<br/>
              } else if (nShots == 6) {<br/>
                  jamCheck = 4;<br/>
              }<br/>
          }<br/>
<br/>
          if (jamCheck &gt; 0 &amp;&amp; wr.roll &lt;= jamCheck) {<br/>
              r = new Report(1210);<br/>
              // ultras and prototypes are destroyed by jamming<br/>
              if ((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)<br/>
                    || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)) {<br/>
                  r.messageId = 3160;<br/>
                  weapon.setJammed(true);<br/>
                  weapon.setHit(true);<br/>
              } else if (wtype.hasFlag(WeaponType.F_PROTOTYPE)) {<br/>
                  r.messageId = 3165;<br/>
                  weapon.setJammed(true);<br/>
                  weapon.setHit(true);<br/>
              } else {<br/>
                  r.messageId = 3170;<br/>
                  weapon.setJammed(true);<br/>
              }<br/>
              r.subject = subjectId;<br/>
              addReport(r);<br/>
              return true;<br/>
          }<br/>
      }<br/>
<br/>
      // Resolve roll for disengaged field inhibitors on PPCs, if needed<br/>
      if (game.getOptions().booleanOption("maxtech_ppc_inhibitors")<br/>
          &amp;&amp; wtype.hasModes()<br/>
          &amp;&amp; weapon.curMode().equals("Field Inhibitor OFF") ) {<br/>
          int rollTarget = 0;<br/>
          int dieRoll = Compute.d6(2);<br/>
          int distance = Compute.effectiveDistance(game, ae, target);<br/>
<br/>
          if (distance&gt;=3) {<br/>
              rollTarget = 3;<br/>
          } else if (distance == 2) {<br/>
              rollTarget = 6;<br/>
          } else if (distance == 1) {<br/>
              rollTarget = 10;<br/>
          }<br/>
          //roll to avoid damage<br/>
          r = new Report(3175);<br/>
          r.subject = ae.getId();<br/>
          r.indent();<br/>
          addReport(r);<br/>
          r = new Report(3180);<br/>
          r.subject = ae.getId();<br/>
          r.indent();<br/>
          r.add(rollTarget);<br/>
          r.add(dieRoll);<br/>
          if (dieRoll&lt;rollTarget) {<br/>
              // Oops, we ruined our day...<br/>
              int wlocation = weapon.getLocation();<br/>
              int wid = ae.getEquipmentNum(weapon);<br/>
              int slot = 0;<br/>
              weapon.setDestroyed (true);<br/>
              for (int i=0; i&lt;ae.getNumberOfCriticals(wlocation); i++) {<br/>
                  CriticalSlot slot1 = ae.getCritical (wlocation, i);<br/>
                  if (slot1 == null || slot1.getType() != CriticalSlot.TYPE_SYSTEM) {<br/>
                      continue;<br/>
                  }<br/>
                  Mounted mounted = ae.getEquipment(slot1.getIndex());<br/>
                  if (mounted.equals(weapon)) {<br/>
                      ae.hitAllCriticals(wlocation,i);<br/>
                  }<br/>
              }<br/>
              // Bug 1066147 : damage is *not* like an ammo explosion,<br/>
              //        but it *does* get applied directly to the IS.<br/>
              r.choose(false);<br/>
              addReport(r);<br/>
              addReport( damageEntity(ae, new HitData(wlocation), 10, false, 0, true));<br/>
              r = new Report(3185);<br/>
              r.subject = ae.getId();<br/>
              addReport(r);<br/>
          } else {<br/>
              r.choose(true);<br/>
              addReport(r);<br/>
          }<br/>
      }<br/>
<br/>
      // do we hit?<br/>
      boolean bMissed = wr.roll &lt; toHit.getValue();<br/>
      if (game.getOptions().booleanOption("maxtech_glancing_blows")) {<br/>
          if (wr.roll == toHit.getValue()) {<br/>
              bGlancing = true;<br/>
              glancingMissileMod = -4;<br/>
              glancingCritMod = -2;<br/>
              r = new  Report(3186);<br/>
              r.subject = ae.getId();<br/>
              r.newlines = 0;<br/>
              addReport(r);<br/>
          } else {<br/>
              bGlancing = false;<br/>
              glancingMissileMod = 0;<br/>
              glancingCritMod = 0;<br/>
          }<br/>
      } else {<br/>
          bGlancing = false;<br/>
          glancingMissileMod = 0;<br/>
          glancingCritMod = 0;<br/>
      }<br/>
<br/>
      // special case TAG.  No damage, but target is tagged until end of turn<br/>
      if (wtype.hasFlag(WeaponType.F_TAG)) {<br/>
          if (entityTarget == null) {<br/>
              r = new Report(3187);<br/>
              r.subject = ae.getId();<br/>
              addReport(r);<br/>
          } else {<br/>
              int priority = 1;<br/>
              EquipmentMode mode = (weapon.curMode());<br/>
              if (mode != null) {<br/>
                  if(mode.getName() == "1-shot") {<br/>
                      priority=1;<br/>
                  } else if(mode.getName() == "2-shot") {<br/>
                      priority=2;<br/>
                  } else if(mode.getName() == "3-shot") {<br/>
                      priority=3;<br/>
                  } else if(mode.getName() == "4-shot") {<br/>
                      priority=4;<br/>
                  }<br/>
              }<br/>
              if (priority &lt; 1) priority = 1;<br/>
              //add even misses, as they waste homing missiles.<br/>
              //it is possible for 2 or more tags to hit the same entity, <br/>
              //but this only matters in the offboard phase<br/>
              TagInfo info = new TagInfo(ae.getId(), entityTarget.getId(), priority, bMissed);<br/>
              game.addTagInfo(info);<br/>
              if (!bMissed) {<br/>
                  entityTarget.setTaggedBy(ae.getId());<br/>
                  r = new Report(3188);<br/>
                  r.subject = ae.getId();<br/>
                  addReport(r);<br/>
              } else {<br/>
                  r = new Report(3220);<br/>
                  r.subject = ae.getId();<br/>
                  addReport(r);<br/>
              }<br/>
          }<br/>
          return !bMissed;<br/>
      }<br/>
      // special case Artillery FLAK<br/>
      if (bArtilleryFLAK) {<br/>
          Coords coords = target.getPosition();<br/>
          int targEl = target.getElevation();<br/>
          // absolute height of target, so we can check units in adjacent hexes<br/>
          int absEl = targEl + game.getBoard().getHex(coords).surface();<br/>
          if (!bMissed) {<br/>
              r = new Report(3191);<br/>
              r.subject = subjectId;<br/>
              r.add(coords.getBoardNum());<br/>
              addReport(r);<br/>
          } else {<br/>
              coords = Compute.scatter(coords, game.getOptions().booleanOption("margin_scatter_distance")?toHit.getValue()-wr.roll:-1);<br/>
              if (game.getBoard().contains(coords)) {<br/>
                  r = new Report(3192);<br/>
                  r.subject = subjectId;<br/>
                  r.add(coords.getBoardNum());<br/>
                  addReport(r);<br/>
              }<br/>
              else {<br/>
                  r = new Report(3193);<br/>
                  r.subject = subjectId;<br/>
                  addReport(r);<br/>
                  return !bMissed;<br/>
              }<br/>
          }<br/>
          artilleryDamageArea(coords, wr.artyAttackerCoords, atype, subjectId, ae, true, absEl);<br/>
          return !bMissed;<br/>
      } // End artillery FLAK<br/>
      // special case BA micro bombs<br/>
      if (target.getTargetType() == Targetable.TYPE_HEX_BOMB) {<br/>
          Coords coords = target.getPosition();<br/>
          if (!bMissed) {<br/>
              r = new Report(3190);<br/>
              r.subject = subjectId;<br/>
              r.add(coords.getBoardNum());<br/>
              addReport(r);<br/>
          } else {<br/>
              coords = Compute.scatter(coords, 1);<br/>
              if (game.getBoard().contains(coords)) {<br/>
                  r = new Report(3195);<br/>
                  r.subject = subjectId;<br/>
                  r.add(coords.getBoardNum());<br/>
                  addReport(r);<br/>
              }<br/>
              else {<br/>
                  r = new Report(3200);<br/>
                  r.subject = subjectId;<br/>
                  addReport(r);<br/>
                  return !bMissed;<br/>
              }<br/>
          }<br/>
          int nCluster = 5;<br/>
          Infantry ba = (Infantry)ae;<br/>
          int ratedDamage = ba.getShootingStrength();<br/>
          artilleryDamageArea(coords, wr.artyAttackerCoords, atype, subjectId, ae, ratedDamage*2, ratedDamage, false, 0);<br/>
          return !bMissed;          <br/>
      } //end ba-micro-bombs<br/>
<br/>
      // special case minefield delivery, no damage and scatters if misses.<br/>
      if (target.getTargetType() == Targetable.TYPE_MINEFIELD_DELIVER<br/>
          || target.getTargetType() == Targetable.TYPE_FLARE_DELIVER) {<br/>
          Coords coords = target.getPosition();<br/>
          if (!bMissed) {<br/>
              r = new Report(3190);<br/>
              r.subject = subjectId;<br/>
              r.add(coords.getBoardNum());<br/>
              addReport(r);<br/>
          }<br/>
          else {<br/>
              coords = Compute.scatter(coords, game.getOptions().booleanOption("margin_scatter_distance")?toHit.getValue()-wr.roll:-1);<br/>
              if (game.getBoard().contains(coords)) {<br/>
                  //misses and scatters to another hex<br/>
                  r = new Report(3195);<br/>
                  r.subject = subjectId;<br/>
                  r.add(coords.getBoardNum());<br/>
                  addReport(r);<br/>
              }<br/>
              else {<br/>
                  //misses and scatters off-board<br/>
                  r = new Report(3200);<br/>
                  r.subject = subjectId;<br/>
                  addReport(r);<br/>
                  return !bMissed;<br/>
              }<br/>
          }<br/>
<br/>
          // Handle the thunder munitions.<br/>
          if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                &amp;&amp; atype.getMunitionType() == AmmoType.M_THUNDER_AUGMENTED) {<br/>
              deliverThunderAugMinefield(coords, ae.getOwner().getId(),<br/>
                                         atype.getRackSize());<br/>
          }<br/>
          else if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                    &amp;&amp; atype.getMunitionType() == AmmoType.M_THUNDER) {<br/>
              deliverThunderMinefield(coords, ae.getOwner().getId(),<br/>
                                      atype.getRackSize());<br/>
          }<br/>
          else if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                    &amp;&amp; atype.getMunitionType() == AmmoType.M_THUNDER_INFERNO)<br/>
              deliverThunderInfernoMinefield(coords, ae.getOwner().getId(),<br/>
                                             atype.getRackSize());<br/>
          else if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                    &amp;&amp; atype.getMunitionType() == AmmoType.M_THUNDER_VIBRABOMB)<br/>
              deliverThunderVibraMinefield(coords, ae.getOwner().getId(),<br/>
                                           atype.getRackSize(),<br/>
                                           wr.waa.getOtherAttackInfo());<br/>
          else if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                    &amp;&amp; atype.getMunitionType() == AmmoType.M_THUNDER_ACTIVE)<br/>
              deliverThunderActiveMinefield(coords, ae.getOwner().getId(),<br/>
                                        atype.getRackSize());<br/>
          else if ((atype.getAmmoType() == AmmoType.T_LRM)<br/>
                    &amp;&amp; atype.getMunitionType() == AmmoType.M_FLARE)<br/>
              deliverFlare(coords, atype.getRackSize());<br/>
          //else<br/>
          //{<br/>
          //...This is an error, but I'll just ignore it for now.<br/>
          //}<br/>
          return !bMissed;<br/>
      }<br/>
      //special case artillery<br/>
      if ((target.getTargetType() == Targetable.TYPE_HEX_ARTILLERY)<br/>
          &amp;&amp; !(usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_HOMING)) { <br/>
          Coords coords = target.getPosition();<br/>
          if (!bMissed) {<br/>
              r = new Report(3190);<br/>
              r.subject = subjectId;<br/>
              r.add(coords.getBoardNum());<br/>
              addReport(r);<br/>
          }<br/>
          else {<br/>
              coords = Compute.scatter(coords, (game.getOptions().booleanOption("margin_scatter_distance"))?(toHit.getValue()-wr.roll):-1);<br/>
              if (game.getBoard().contains(coords)) {<br/>
                  //misses and scatters to another hex<br/>
                  r = new Report(3195);<br/>
                  r.subject = subjectId;<br/>
                  r.add(coords.getBoardNum());<br/>
                  addReport(r);<br/>
              }<br/>
              else {<br/>
                  //misses and scatters off-board<br/>
                  r = new Report(3200);<br/>
                  r.subject = subjectId;<br/>
                  addReport(r);<br/>
                  return !bMissed;<br/>
              }<br/>
          }<br/>
<br/>
          if (usesAmmo) {<br/>
              //Check for various non-explosive types<br/>
              if(atype.getMunitionType() == AmmoType.M_FLARE) {<br/>
                  int radius;<br/>
                  if(atype.getAmmoType() == AmmoType.T_ARROW_IV)<br/>
                      radius = 4;<br/>
                  else if(atype.getAmmoType() == AmmoType.T_LONG_TOM)<br/>
                      radius = 3;<br/>
                  else radius = Math.max(1,atype.getRackSize() / 5);<br/>
                      deliverArtilleryFlare(coords,radius);<br/>
                  return !bMissed;<br/>
              }<br/>
              if(atype.getMunitionType() == AmmoType.M_INFERNO_IV) {<br/>
                  deliverArtilleryInferno(coords, subjectId);<br/>
                  return !bMissed;<br/>
              }<br/>
              if(atype.getMunitionType() == AmmoType.M_FASCAM) {<br/>
                  deliverFASCAMMinefield(coords, ae.getOwner().getId());<br/>
                  return !bMissed;<br/>
              }<br/>
              if(atype.getMunitionType() == AmmoType.M_VIBRABOMB_IV) {<br/>
                  deliverThunderVibraMinefield(coords, ae.getOwner().getId(), 20,<br/>
                                               wr.waa.getOtherAttackInfo());<br/>
                  return !bMissed;<br/>
              }<br/>
              if(atype.getMunitionType() == AmmoType.M_SMOKE) {<br/>
                  deliverArtillerySmoke(coords);<br/>
                  return !bMissed;<br/>
              }<br/>
          }<br/>
<br/>
          artilleryDamageArea(coords, wr.artyAttackerCoords, atype, subjectId, ae, false, 0);<br/>
<br/>
          return !bMissed;<br/>
      } // End artillery<br/>
      if(bMissed &amp;&amp; usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_HOMING) {<br/>
          //Arrow IV homing missed, splash the hex<br/>
          artilleryDamageHex(target.getPosition(), wr.artyAttackerCoords, 5, atype, subjectId, ae, null, false, 0);<br/>
      }<br/>
      <br/>
      int ammoUsage=0;<br/>
      int nDamPerHit = wtype.getDamage();<br/>
      if (bMissed) {<br/>
          // Report the miss.<br/>
          // MGs in rapidfire do heat even when they miss.<br/>
          if (weapon.isRapidfire() &amp;&amp;<br/>
              !(target instanceof Infantry &amp;&amp;<br/>
              !(target instanceof BattleArmor)) ){<br/>
                // Check for rapid fire Option. Only MGs can be rapidfire.<br/>
                nDamPerHit = Compute.d6();<br/>
                ammoUsage = 3*nDamPerHit;<br/>
                if (ae.getTotalAmmoOfType(ammo.getType())&gt;0) {<br/>
                    for (int i=0; i&lt;ammoUsage; i++) {<br/>
                        if (ammo.getShotsLeft() &lt;= 0) {<br/>
                            ae.loadWeapon(weapon);<br/>
                            ammo = weapon.getLinked();<br/>
                        }<br/>
                        ammo.setShotsLeft(ammo.getShotsLeft()-1);<br/>
                    }<br/>
                    if (ae instanceof Mech) {<br/>
                        // Apply heat<br/>
                        ae.heatBuildup += nDamPerHit;<br/>
                    }<br/>
                } else {<br/>
                    hits = 0;<br/>
                }<br/>
            }<br/>
            if ((( wtype.getAmmoType() == AmmoType.T_SRM_STREAK )<br/>
                    || ( wtype.getAmmoType() == AmmoType.T_LRM_STREAK ))<br/>
                    &amp;&amp; !isAngelECMAffected) {<br/>
                //no lock<br/>
                r = new Report(3215);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else {<br/>
                //miss<br/>
                r = new Report(3220);<br/>
                r.subject = subjectId;<br/>
                if (weapon.isRapidfire() &amp;&amp;<br/>
                    !(target instanceof Infantry &amp;&amp;<br/>
                    !(target instanceof BattleArmor)) ){<br/>
                  r.messageId = 3225;<br/>
                  r.add(ammoUsage);<br/>
              }<br/>
              addReport(r);<br/>
          }<br/>
<br/>
          // Report any AMS action.<br/>
          for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
              if (wr.amsShotDown[i] &gt; 0) {<br/>
                  r = new Report(3230);<br/>
                  r.indent();<br/>
                  r.subject = subjectId;<br/>
                  r.add(wr.amsShotDown[i]);<br/>
                  addReport(r);<br/>
              }<br/>
          }<br/>
<br/>
            // Figure out the maximum number of missile hits.<br/>
            // TODO: handle this in a different place.<br/>
            int maxMissiles = 0;<br/>
            if ( usesAmmo ) {<br/>
                maxMissiles = wtype.getRackSize();<br/>
                if ( wtype.hasFlag(WeaponType.F_DOUBLE_HITS) ) {<br/>
                    maxMissiles *= 2;<br/>
                }<br/>
                if ( ae instanceof BattleArmor ) {<br/>
                    platoon = (Infantry) ae;<br/>
                    maxMissiles *= platoon.getShootingStrength();<br/>
                }<br/>
            }<br/>
            if (bSwarm || bSwarmI) {<br/>
                swarmMissilesNowLeft = swarmMissilesLeft &gt; 0 ? swarmMissilesLeft : maxMissiles;<br/>
                maxMissiles = swarmMissilesLeft &gt; 0 ? swarmMissilesLeft : maxMissiles;<br/>
            }<br/>
<br/>
            // If the AMS shot down *all* incoming missiles, if<br/>
            // the shot is an automatic failure, or if it's from<br/>
            // a Streak rack, then Infernos can't ignite the hex<br/>
            // and any building is safe from damage.<br/>
            if ( (usesAmmo &amp;&amp; wr.amsShotDownTotal &gt;= maxMissiles)<br/>
                    || toHit.getValue() == TargetRoll.AUTOMATIC_FAIL<br/>
                    || ((wtype.getAmmoType() == AmmoType.T_SRM_STREAK <br/>
                    || wtype.getAmmoType() == AmmoType.T_LRM_STREAK)<br/>
                    &amp;&amp; !isAngelECMAffected)) {<br/>
                return !bMissed;<br/>
            }<br/>
            // If we're using swarm munition, set the number of missiles that<br/>
            // are left<br/>
            if ((bSwarm || bSwarmI) &amp;&amp; entityTarget != null) {<br/>
                swarmMissilesNowLeft -= wr.amsShotDownTotal;<br/>
                Entity swarmTarget = Compute.getSwarmTarget(game, ae.getId(), entityTarget, wr.waa.getWeaponId());<br/>
                if (swarmTarget != null) {<br/>
                    r = new Report(3420);<br/>
                    r.subject = ae.getId();<br/>
                    r.indent();<br/>
                    r.add(swarmMissilesNowLeft);<br/>
                    addReport(r);<br/>
                    weapon.setUsedThisRound(false);<br/>
                    WeaponAttackAction newWaa = new WeaponAttackAction(ae.getId(),<br/>
                        swarmTarget.getTargetId(), wr.waa.getWeaponId());<br/>
                    newWaa.setSwarmingMissiles(true);<br/>
                    newWaa.setOldTargetId(target.getTargetId());<br/>
                    newWaa.setAmmoId(wr.waa.getAmmoId());<br/>
                    WeaponResult newWr = preTreatWeaponAttack(newWaa);<br/>
                    resolveWeaponAttack(newWr, ae.getId(), false, swarmMissilesNowLeft);<br/>
                } else {<br/>
                    r = new Report(3425);<br/>
                    r.subject = ae.getId();<br/>
                    r.indent();<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            // Shots that miss an entity can set fires.<br/>
            // Infernos always set fires.  Otherwise<br/>
            // Buildings can't be accidentally ignited,<br/>
            // and some weapons can't ignite fires.<br/>
            if ( entityTarget != null &amp;&amp;<br/>
                 ( bInferno ||<br/>
                   ( bldg == null &amp;&amp;<br/>
                     wtype.getFireTN() != TargetRoll.IMPOSSIBLE ) ) ) {<br/>
                tryIgniteHex(target.getPosition(), ae.getId(), bInferno, 11);<br/>
            }<br/>
<br/>
            // BMRr, pg. 51: "All shots that were aimed at a target inside<br/>
            // a building and miss do full damage to the building instead."<br/>
            // BMRr, pg. 77: If the spotting unit successfully designates the target but<br/>
            // the missile misses, it still detonates in the hex and causes 5<br/>
            // points of artillery damage each to all units in the target hex<br/>
            if ( !targetInBuilding) {<br/>
                return !bMissed;<br/>
            }<br/>
        }<br/>
<br/>
        // special case NARC hits.  No damage, but a beacon is appended<br/>
        if (!bMissed &amp;&amp;<br/>
            wtype.getAmmoType() == AmmoType.T_NARC &amp;&amp;<br/>
            atype.getMunitionType() != AmmoType.M_NARC_EX) {<br/>
<br/>
            if (wr.amsShotDownTotal &gt; 0) {<br/>
                r = new Report(3235);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
                    r = new Report(3230);<br/>
                    r.indent(1);<br/>
                    r.subject = subjectId;<br/>
                    r.add(wr.amsShotDown[i]);<br/>
                    addReport(r);<br/>
                }<br/>
                r = new Report(3240);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else if (entityTarget == null) {<br/>
                r = new Report(3245);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else {<br/>
                entityTarget.setNarcedBy(ae.getOwner().getTeam());<br/>
                //narced<br/>
                r = new Report(3250);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            }<br/>
            return !bMissed;<br/>
        }<br/>
        <br/>
        // special case iNARC hits.  No damage, but a beacon is appended<br/>
        if (!bMissed &amp;&amp;<br/>
            wtype.getAmmoType() == AmmoType.T_INARC &amp;&amp;<br/>
            atype.getMunitionType() != AmmoType.M_EXPLOSIVE) {<br/>
<br/>
            if (wr.amsShotDownTotal &gt; 0) {<br/>
                r = new Report(3235);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
                    r = new Report(3230);<br/>
                    r.indent(1);<br/>
                    r.subject = subjectId;<br/>
                    r.add(wr.amsShotDown[i]);<br/>
                    addReport(r);<br/>
                }<br/>
                r = new Report(3240);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else if (entityTarget == null) {<br/>
                r = new Report(3245);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else {<br/>
                INarcPod pod = null;<br/>
                if (atype.getMunitionType() == AmmoType.M_ECM) {<br/>
                    pod = new INarcPod( ae.getOwner().getTeam(),<br/>
                                        INarcPod.ECM );<br/>
                    r = new Report(3251);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                } else if (atype.getMunitionType() == AmmoType.M_HAYWIRE) {<br/>
                    pod = new INarcPod( ae.getOwner().getTeam(),<br/>
                                        INarcPod.HAYWIRE );<br/>
                    r = new Report(3252);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                } else if (atype.getMunitionType() == AmmoType.M_NEMESIS) {<br/>
                    pod = new INarcPod( ae.getOwner().getTeam(),<br/>
                                        INarcPod.NEMESIS );<br/>
                    r = new Report(3253);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                } else {<br/>
                    pod = new INarcPod( ae.getOwner().getTeam(),<br/>
                                        INarcPod.HOMING );<br/>
                    r = new Report(3254);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                }<br/>
                entityTarget.attachINarcPod(pod);<br/>
            }<br/>
            return !bMissed;<br/>
        }<br/>
<br/>
        // attempt to clear minefield by LRM/MRM fire.<br/>
        if (!bMissed &amp;&amp; target.getTargetType() == Targetable.TYPE_MINEFIELD_CLEAR) {<br/>
            int clearAttempt = Compute.d6(2);<br/>
<br/>
            if (clearAttempt &gt;= Minefield.CLEAR_NUMBER_WEAPON) {<br/>
                //minefield cleared<br/>
                r = new Report(3255);<br/>
                r.indent(1);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                Coords coords = target.getPosition();<br/>
<br/>
                Enumeration minefields = game.getMinefields(coords).elements();<br/>
                while (minefields.hasMoreElements()) {<br/>
                    Minefield mf = (Minefield) minefields.nextElement();<br/>
<br/>
                    removeMinefield(mf);<br/>
                }<br/>
            } else {<br/>
                //fails to clear<br/>
                r = new Report(3260);<br/>
                r.indent(1);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            }<br/>
            return !bMissed;<br/>
        }<br/>
<br/>
        // yeech.  handle damage. . different weapons do this in very different ways<br/>
        int nCluster = 1, nSalvoBonus = 0;<br/>
        boolean bSalvo = false;<br/>
        // ecm check is heavy, so only do it once<br/>
        boolean bCheckedECM = false;<br/>
        boolean bECMAffected = false;<br/>
        boolean bMekStealthActive = false;<br/>
        String sSalvoType = " shot(s) ";<br/>
        boolean bAllShotsHit = false;<br/>
        int nRange = ae.getPosition().distance(target.getPosition());<br/>
        int nMissilesModifier = 0;<br/>
        boolean maxtechmissiles = game.getOptions().booleanOption("maxtech_mslhitpen");<br/>
        if (maxtechmissiles) {<br/>
            if (nRange&lt;=1) {<br/>
                nMissilesModifier = +1;<br/>
            } else if (nRange &lt;= wtype.getShortRange()) {<br/>
                nMissilesModifier = 0;<br/>
            } else if (nRange &lt;= wtype.getMediumRange()) {<br/>
                nMissilesModifier = -1;<br/>
            } else {<br/>
                nMissilesModifier = -2;<br/>
            }<br/>
       }<br/>
        // All shots fired by a Streak SRM weapon, during<br/>
        // a Mech Swarm hit, or at an adjacent building.<br/>
        if (((wtype.getAmmoType() == AmmoType.T_SRM_STREAK<br/>
                || wtype.getAmmoType() == AmmoType.T_LRM_STREAK)<br/>
                &amp;&amp; !isAngelECMAffected)<br/>
                || wtype.getAmmoType() == AmmoType.T_NARC<br/>
                || ae.getSwarmTargetId() == wr.waa.getTargetId()<br/>
                || ((target.getTargetType() == Targetable.TYPE_BLDG_IGNITE<br/>
                || target.getTargetType() == Targetable.TYPE_BUILDING)<br/>
                &amp;&amp; ae.getPosition().distance(target.getPosition()) &lt;= 1)) {<br/>
            bAllShotsHit = true;<br/>
        }<br/>
<br/>
        // Mek swarms attach the attacker to the target.<br/>
        if ( !bMissed &amp;&amp; Infantry.SWARM_MEK.equals( wtype.getInternalName() ) ) {<br/>
            // Is the target already swarmed?<br/>
            if ( Entity.NONE != entityTarget.getSwarmAttackerId() ) {<br/>
                r = new Report(3265);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            }<br/>
            // Did the target get destroyed by weapons fire?<br/>
            else if ( entityTarget.isDoomed() || entityTarget.isDestroyed() ||<br/>
                      entityTarget.getCrew().isDead() ) {<br/>
                r = new Report(3270);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
            } else {<br/>
                //success<br/>
                r = new Report(3275);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                ae.setSwarmTargetId( wr.waa.getTargetId() );<br/>
                entityTarget.setSwarmAttackerId( wr.waa.getEntityId() );<br/>
            }<br/>
            return !bMissed;<br/>
        }<br/>
<br/>
        // Magnetic Mine Launchers roll number of hits on battle armor<br/>
        // hits table but use # mines firing instead of men shooting.<br/>
        else if ( wtype.getInternalName().equals(BattleArmor.MINE_LAUNCHER) ) {<br/>
            hits = nShots;<br/>
            if ( !bAllShotsHit ) {<br/>
                hits = Compute.getBattleArmorHits( hits );<br/>
            }<br/>
            bSalvo = true;<br/>
            sSalvoType = " mine(s) ";<br/>
        }<br/>
<br/>
        // Other battle armor attacks use # of men firing to determine hits.<br/>
        // Each hit can be in a new location. The damage per shot comes from<br/>
        // the "racksize", or from the ammo, for ammo weapons<br/>
        else if ( isBattleArmorAttack ) {<br/>
            bSalvo = true;<br/>
            platoon = (Infantry) ae;<br/>
            nCluster = 1;<br/>
            if (usesAmmo) {<br/>
                nDamPerHit = atype.getDamagePerShot();<br/>
            }<br/>
            nDamPerHit = wtype.getRackSize();<br/>
            hits = platoon.getShootingStrength();<br/>
            // All attacks during Mek Swarms hit; all<br/>
            // others use the Battle Armor hits table.<br/>
            if ( !bAllShotsHit ) {<br/>
                hits = Compute.getBattleArmorHits( hits );<br/>
            }<br/>
<br/>
            // Handle Inferno SRM squads.<br/>
            if (bInferno) {<br/>
                nCluster = hits;<br/>
                nDamPerHit = 0;<br/>
                sSalvoType = " Inferno missle(s) ";<br/>
                bSalvo = false;<br/>
            }<br/>
            if (ae.getSwarmTargetId() == wr.waa.getTargetId())<br/>
                nDamPerHit += ((BattleArmor)ae).getVibroClawDamage();<br/>
        }<br/>
<br/>
        // Infantry damage depends on # men left in platoon.<br/>
        else if (isWeaponInfantry) {<br/>
            bSalvo = true;<br/>
            platoon = (Infantry)ae;<br/>
            nCluster = 5;<br/>
            nDamPerHit = 1;<br/>
            hits = platoon.getDamage(platoon.getShootingStrength());<br/>
            //TODO: Hmm, this should be localizable<br/>
            sSalvoType = " damage are inflicted by the shots that ";<br/>
<br/>
            // Handle Inferno SRM infantry.<br/>
            if (bInferno) {<br/>
                nCluster = hits;<br/>
                nDamPerHit = 0;<br/>
                sSalvoType = " Inferno missile(s) ";<br/>
                bSalvo = false;<br/>
            }<br/>
        } else if (wtype.getDamage() == WeaponType.DAMAGE_MISSILE ||<br/>
                   wtype.hasFlag(WeaponType.F_MISSILE_HITS) ) {<br/>
            bSalvo = true;<br/>
<br/>
            // Weapons with ammo type T_BA_MG or T_BA_SMALL_LASER<br/>
            // don't have an atype object.<br/>
            if ( wtype.getAmmoType() == AmmoType.T_BA_MG ||<br/>
                 wtype.getAmmoType() == AmmoType.T_BA_SMALL_LASER ) {<br/>
                nDamPerHit = Math.abs( wtype.getAmmoType() );<br/>
            } else {<br/>
                sSalvoType = " missile(s) ";<br/>
                // Get the damage from the linked ammo.<br/>
                nDamPerHit = atype.getDamagePerShot();<br/>
                if ((wtype.getAmmoType() == AmmoType.T_TBOLT5<br/>
                        || wtype.getAmmoType() == AmmoType.T_TBOLT10<br/>
                        || wtype.getAmmoType() == AmmoType.T_TBOLT15<br/>
                        || wtype.getAmmoType() == AmmoType.T_TBOLT20<br/>
                        ) &amp;&amp; nRange &lt;= wtype.getMinimumRange()) {<br/>
                    nDamPerHit /= 2;<br/>
                } <br/>
            }<br/>
<br/>
            if ( wtype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_LRM_STREAK ||<br/>
                 wtype.getAmmoType() == AmmoType.T_MRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_ATM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_EXLRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_ROCKET_LAUNCHER ) {<br/>
                nCluster = 5;<br/>
            }<br/>
<br/>
            // calculate # of missiles hitting<br/>
            if ( wtype.getAmmoType() == AmmoType.T_LRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_SRM ||<br/>
                 wtype.getAmmoType() == AmmoType.T_ATM ) {<br/>
<br/>
                // check for artemis, else check for narc and similar things<br/>
                mLinker = weapon.getLinkedBy();<br/>
                if ( wtype.getAmmoType() == AmmoType.T_ATM ||<br/>
                     ( mLinker != null &amp;&amp;<br/>
                       mLinker.getType() instanceof MiscType &amp;&amp;<br/>
                       !mLinker.isDestroyed() &amp;&amp; !mLinker.isMissing() &amp;&amp; !mLinker.isBreached() &amp;&amp;<br/>
                       mLinker.getType().hasFlag(MiscType.F_ARTEMIS) ) &amp;&amp;<br/>
                       atype.getMunitionType() == AmmoType.M_ARTEMIS_CAPABLE) {<br/>
<br/>
                    // check ECM interference<br/>
                    if (!bCheckedECM) {<br/>
                        // Attacking Meks using stealth suffer ECM effects.<br/>
                        if ( ae instanceof Mech ) {<br/>
                            bMekStealthActive = ae.isStealthActive();<br/>
                        }<br/>
                        //if the attacker is effected by ECM or the target is protected by ECM then<br/>
                        //act as if effected.<br/>
                        if (Compute.isAffectedByECM(ae, ae.getPosition(), target.getPosition()) || <br/>
                                Compute.isAffectedByAngelECM(ae, ae.getPosition(), target.getPosition()))<br/>
                            bECMAffected = true;<br/>
                        else if ( Compute.isProtectedByECM((Entity)target,target.getPosition(),ae.getPosition()) ||<br/>
                                Compute.isProtectedByAngelECM((Entity)target,target.getPosition(),ae.getPosition()))<br/>
                            bECMAffected = true;<br/>
                        else<br/>
                            bECMAffected = false;<br/>
                        bCheckedECM = true;<br/>
                    }<br/>
                    // also no artemis for IDF, and only use standard ammo (excepot for ATMs)<br/>
                    if (!bECMAffected &amp;&amp; !bMekStealthActive<br/>
                        &amp;&amp; (!weapon.getType().hasModes()<br/>
                            || !weapon.curMode().equals("Indirect"))<br/>
                        &amp;&amp; ( (atype.getAmmoType() == AmmoType.T_ATM &amp;&amp;<br/>
                              (atype.getMunitionType() == AmmoType.M_STANDARD||<br/>
                               atype.getMunitionType() == AmmoType.M_EXTENDED_RANGE ||<br/>
                               atype.getMunitionType() == AmmoType.M_HIGH_EXPLOSIVE)) ||<br/>
                             ( (atype.getAmmoType() == AmmoType.T_LRM ||<br/>
                                atype.getAmmoType() == AmmoType.T_SRM) &amp;&amp;<br/>
                               atype.getMunitionType() == AmmoType.M_ARTEMIS_CAPABLE))) {<br/>
                        nSalvoBonus += 2;<br/>
                    }<br/>
                } else if (entityTarget != null &amp;&amp; <br/>
                        (entityTarget.isNarcedBy(ae.getOwner().getTeam()) || <br/>
                         entityTarget.isINarcedBy(ae.getOwner().getTeam()))) {<br/>
                    // check ECM interference<br/>
                    if (!bCheckedECM) {<br/>
                        // Attacking Meks using stealth suffer ECM effects.<br/>
                        if ( ae instanceof Mech ) {<br/>
                            bMekStealthActive = ae.isStealthActive();<br/>
                        }<br/>
                        <br/>
                        //if the attacker is effected by ECM or the target is protected by ECM then<br/>
                        //act as if effected.<br/>
                        if (Compute.isAffectedByECM(ae, ae.getPosition(), target.getPosition()) || <br/>
                                Compute.isAffectedByAngelECM(ae, ae.getPosition(), target.getPosition()))<br/>
                            bECMAffected = true;<br/>
                        else if ( Compute.isProtectedByECM((Entity)target,target.getPosition(),ae.getPosition()) ||<br/>
                                Compute.isProtectedByAngelECM((Entity)target,target.getPosition(),ae.getPosition()))<br/>
                            bECMAffected = true;<br/>
                        else<br/>
                            bECMAffected = false;<br/>
                        bCheckedECM = true;<br/>
                    }<br/>
                    // only apply Narc bonus if we're not suffering ECM effect<br/>
                    // and we are using narc ammo.<br/>
                    if (!bECMAffected<br/>
                            &amp;&amp; !bMekStealthActive<br/>
                            &amp;&amp; ((atype.getAmmoType() == AmmoType.T_LRM) || (atype.getAmmoType() == AmmoType.T_SRM))<br/>
                            &amp;&amp; atype.getMunitionType() == AmmoType.M_NARC_CAPABLE) {<br/>
                        nSalvoBonus += 2;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // If dealing with Inferno rounds set damage to zero and reset<br/>
            // all salvo bonuses (cannot mix with other special munitions).<br/>
            if (bInferno) {<br/>
                    nDamPerHit = 0;<br/>
                    nSalvoBonus = 0;<br/>
                    sSalvoType = " inferno missile(s) ";<br/>
                    bSalvo = false;<br/>
            }<br/>
            if (bSwarm) {<br/>
                sSalvoType = " swarm missile(s) ";<br/>
            }<br/>
            if (bSwarmI) {<br/>
                sSalvoType = " swarm-I missile(s) ";<br/>
            }<br/>
            if (bAntiTSM) {<br/>
                sSalvoType = " anti-TSM missile(s) ";<br/>
            }<br/>
<br/>
            // If dealing with fragmentation missiles,<br/>
            // it does double damage to infantry...<br/>
            if (bFragmentation) {<br/>
                sSalvoType = " fragmentation missile(s) ";<br/>
            }<br/>
<br/>
            // Acid-heads, like infernos, can't mix with any other munitions type.<br/>
            if (bAcidHead) {<br/>
                nDamPerHit = 1;<br/>
                nSalvoBonus = -2;<br/>
                sSalvoType = " acid-head missile(s) ";<br/>
            }<br/>
<br/>
            // Large MRM missile racks roll twice.<br/>
            // MRM missiles never recieve hit bonuses.<br/>
            if ( wtype.getRackSize() == 30 || wtype.getRackSize() == 40 ) {<br/>
                hits = Compute.missilesHit(wtype.getRackSize() / 2, nMissilesModifier+glancingMissileMod, maxtechmissiles | bGlancing) +<br/>
                    Compute.missilesHit(wtype.getRackSize() / 2, nMissilesModifier+glancingMissileMod, maxtechmissiles | bGlancing);<br/>
            }<br/>
<br/>
            // Battle Armor units multiply their racksize by the number<br/>
            // of men shooting and they can't get missile hit bonuses.<br/>
            else if ( ae instanceof BattleArmor ) {<br/>
                platoon = (Infantry) ae;<br/>
                int temp = wtype.getRackSize() * platoon.getShootingStrength();<br/>
<br/>
                // Do all shots hit?<br/>
                if ( bAllShotsHit ) {<br/>
                    hits = temp;<br/>
                } else {<br/>
                    // Account for more than 20 missles hitting.<br/>
                    hits = 0;<br/>
                    while ( temp &gt; 20 ) {<br/>
                        hits += Compute.missilesHit( 20, nMissilesModifier+glancingMissileMod, maxtechmissiles | bGlancing );<br/>
                        temp -= 20;<br/>
                    }<br/>
                    hits += Compute.missilesHit( temp, nMissilesModifier+glancingMissileMod, maxtechmissiles | bGlancing );<br/>
                } // End not-all-shots-hit<br/>
            }<br/>
<br/>
            // If all shots hit, use the full racksize.<br/>
            else if ( bAllShotsHit ) {<br/>
                hits = wtype.getRackSize();<br/>
            }<br/>
            // In all other circumstances, roll for hits.<br/>
            else {<br/>
                hits = Compute.missilesHit(wtype.getRackSize(), nSalvoBonus + nMissilesModifier + glancingMissileMod, maxtechmissiles | bGlancing);<br/>
                // swarm missiles that didn't hit continue <br/>
                if ( (bSwarm || bSwarmI) &amp;&amp; swarmMissilesLeft == 0) {<br/>
                    swarmMissilesNowLeft = wtype.getRackSize() - hits;<br/>
                }<br/>
            }<br/>
            // anti TSM missiles hit with half the number, round up<br/>
            if (bAntiTSM) {<br/>
                hits = (int)Math.ceil((double)hits/2);<br/>
            }<br/>
            // swarm or swarm-I shots may just hit with the remaining missiles<br/>
            if ((bSwarm || bSwarmI) &amp;&amp; (swarmMissilesLeft &gt; 0)) {<br/>
                int swarmsForHitTable = 5;<br/>
                if (swarmMissilesLeft &gt; 5 &amp;&amp; swarmMissilesLeft &lt;= 10)<br/>
                    swarmsForHitTable = 10;<br/>
                else if (swarmMissilesLeft &gt; 10 &amp;&amp; swarmMissilesLeft &lt;= 15)<br/>
                    swarmsForHitTable = 15;<br/>
                else if (swarmMissilesLeft &gt; 15 &amp;&amp; swarmMissilesLeft &lt;= 20)<br/>
                    swarmsForHitTable = 20;<br/>
                hits = Compute.missilesHit(swarmsForHitTable, nSalvoBonus + nMissilesModifier + glancingMissileMod, maxtechmissiles | bGlancing);<br/>
                if (hits &gt; swarmMissilesLeft) {<br/>
                    hits = swarmMissilesLeft;<br/>
                }<br/>
                swarmMissilesNowLeft = swarmMissilesLeft - hits;<br/>
            }<br/>
<br/>
            // Advanced SRMs may get additional missiles<br/>
            if ( usesAmmo &amp;&amp;<br/>
                 atype.getAmmoType() == AmmoType.T_SRM_ADVANCED) {<br/>
                int tmp = wtype.getRackSize() * platoon.getShootingStrength();<br/>
                if (hits%2 == 1 &amp;&amp; hits &lt; tmp) {<br/>
                    hits++;<br/>
                }<br/>
            }<br/>
<br/>
        } else if (usesAmmo<br/>
                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC_LBX) <br/>
                || (atype.getAmmoType() == AmmoType.T_AC_LBX_THB))<br/>
                &amp;&amp; atype.getMunitionType() == AmmoType.M_CLUSTER) {<br/>
            // Cluster shots break into single point clusters.<br/>
            bSalvo = true;<br/>
            hits = wtype.getRackSize();<br/>
            // war of 3039 prototype LBXs get -1 mod on missile chart<br/>
            int nMod = wtype.hasFlag(WeaponType.F_PROTOTYPE) ? 0 : -1;<br/>
            if ( !bAllShotsHit ) {<br/>
                if (!bGlancing) {<br/>
                    hits = Compute.missilesHit( hits, nMod );<br/>
                } else {<br/>
                    // if glancing blow, half the number of missiles that hit,<br/>
                    // that halves damage. do this, and not adjust number of <br/>
                    // pellets, because maxtech only talks about missile weapons<br/>
                    hits = Compute.missilesHit(hits, nMod)/2;<br/>
                }<br/>
            }<br/>
            nDamPerHit = 1;<br/>
        } else if (nShots &gt; 1) {<br/>
            // this should handle multiple attacks from ultra and rotary ACs<br/>
            bSalvo = true;<br/>
            hits = nShots;<br/>
            if ( !bAllShotsHit ) {<br/>
                hits = Compute.missilesHit( hits );<br/>
            }<br/>
        }<br/>
        else if (wtype.getAmmoType() == AmmoType.T_GAUSS_HEAVY) {<br/>
            // HGR does range-dependent damage<br/>
            if (nRange &lt;= wtype.getShortRange()) {<br/>
                nDamPerHit = 25;<br/>
            } else if (nRange &lt;= wtype.getMediumRange()) {<br/>
                nDamPerHit = 20;<br/>
            } else {<br/>
                nDamPerHit = 10;<br/>
            }<br/>
        } else if (wtype.hasFlag(WeaponType.F_ENERGY)) {<br/>
            // Check for Altered Damage from Energy Weapons (MTR, pg.22)<br/>
            nDamPerHit = wtype.getDamage();<br/>
            if (game.getOptions().booleanOption("maxtech_altdmg")) {<br/>
                if (nRange&lt;=1) {<br/>
                    nDamPerHit++;<br/>
                } else if (nRange &lt;= wtype.getMediumRange()) {<br/>
                    // Do Nothing for Short and Medium Range<br/>
                } else if (nRange &lt;= wtype.getLongRange()) {<br/>
                    nDamPerHit--;<br/>
                } else if (nRange &lt;= wtype.getExtremeRange()) {<br/>
                    nDamPerHit = (int)Math.floor(nDamPerHit/2.0);<br/>
                }<br/>
            }<br/>
        } else if (weapon.isRapidfire() &amp;&amp;<br/>
                   !(target instanceof Infantry &amp;&amp;<br/>
                     !(target instanceof BattleArmor)) ){<br/>
            // Check for rapid fire Option. Only MGs can be rapidfire.<br/>
            nDamPerHit = Compute.d6();<br/>
            ammoUsage = 3*nDamPerHit;<br/>
            if (ae.getTotalAmmoOfType(ammo.getType())&gt;0) {<br/>
                for (int i=0; i&lt;ammoUsage; i++) {<br/>
                    if (ammo.getShotsLeft() &lt;= 0) {<br/>
                        ae.loadWeapon(weapon);<br/>
                        ammo = weapon.getLinked();<br/>
                    } <br/>
                    ammo.setShotsLeft(ammo.getShotsLeft()-1);<br/>
                }<br/>
                if (ae instanceof Mech) {<br/>
                    // Apply heat<br/>
                    ae.heatBuildup += nDamPerHit;<br/>
                }<br/>
            } else {<br/>
                hits = 0;<br/>
            }<br/>
        } <br/>
        // laser prototype weapons get 1d6 of extra heat<br/>
        if (wtype.hasFlag(WeaponType.F_LASER) &amp;&amp;<br/>
            wtype.hasFlag(WeaponType.F_PROTOTYPE)) {<br/>
            ae.heatBuildup += Compute.d6();<br/>
        }<br/>
<br/>
        // tracer rounds do -1 damage.<br/>
        if(bTracer) {<br/>
            nDamPerHit--;<br/>
        }<br/>
<br/>
        // only halve damage for non-missiles and non-cluster,<br/>
        // because cluster lbx gets handled above.<br/>
        if (bGlancing &amp;&amp; !wtype.hasFlag(WeaponType.F_MISSILE) &amp;&amp; !wtype.hasFlag(WeaponType.F_MISSILE_HITS)<br/>
                &amp;&amp; !(usesAmmo<br/>
                &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC_LBX) <br/>
                || (atype.getAmmoType() == AmmoType.T_AC_LBX_THB))<br/>
                &amp;&amp; atype.getMunitionType() == AmmoType.M_CLUSTER)) {<br/>
            nDamPerHit = (int)Math.floor(nDamPerHit/2.0);<br/>
        }<br/>
<br/>
        // Some weapons double the number of hits scored.<br/>
        if ( wtype.hasFlag(WeaponType.F_DOUBLE_HITS) ) {<br/>
            hits *= 2;<br/>
        }<br/>
<br/>
        //Arrow IV homing hits single location, like an AC20<br/>
        if(usesAmmo &amp;&amp; atype.getMunitionType() == AmmoType.M_HOMING) {<br/>
            nDamPerHit = wtype.getRackSize();<br/>
            if (entityTarget!=null &amp;&amp; entityTarget.getTaggedBy() != -1) {<br/>
                if(wr.artyAttackerCoords != null) {<br/>
                    toHit.setSideTable(entityTarget.sideTable(wr.artyAttackerCoords));<br/>
                } else {<br/>
                    Entity tagger = game.getEntity(entityTarget.getTaggedBy());<br/>
                    if(tagger != null) { <br/>
                        toHit.setSideTable(Compute.targetSideTable(tagger, entityTarget));<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        // We've calculated how many hits.  At this point, any missed<br/>
        // shots damage the building instead of the target.<br/>
        if ( bMissed ) {<br/>
            if ( targetInBuilding &amp;&amp; bldg != null &amp;&amp; !(bSwarm || bSwarmI)) {<br/>
<br/>
                // Reduce the number of hits by AMS hits.<br/>
                if (wr.amsShotDownTotal &gt; 0) {<br/>
                    for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
                        int shotDown = Math.min(wr.amsShotDown[i], hits);<br/>
                        r = new Report(3280);<br/>
                        r.indent(1);<br/>
                        r.subject = subjectId;<br/>
                        r.add(shotDown);<br/>
                        addReport(r);<br/>
                    }<br/>
                    hits -= wr.amsShotDownTotal;<br/>
                }<br/>
<br/>
                // Is the building hit by Inferno rounds?<br/>
                if ( bInferno &amp;&amp; hits &gt; 0 ) {<br/>
<br/>
                    // start a fire in the targets hex<br/>
                    Coords c = target.getPosition();<br/>
                    IHex h = game.getBoard().getHex(c);<br/>
<br/>
                    // Is there a fire in the hex already?<br/>
                    if ( h.containsTerrain( Terrains.FIRE ) ) {<br/>
                        r = new Report(3285);<br/>
                        r.indent(2);<br/>
                        r.subject = subjectId;<br/>
                        r.add(hits);<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        r = new Report(3290);<br/>
                        r.indent(2);<br/>
                        r.subject = subjectId;<br/>
                        r.add(hits);<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                        h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                    }<br/>
                    game.getBoard().addInfernoTo<br/>
                        ( c, InfernoTracker.STANDARD_ROUND, hits );<br/>
                    sendChangedHex(c);<br/>
<br/>
                }<br/>
<br/>
                // Damage the building in one big lump.<br/>
                else {<br/>
<br/>
                    // Only report if damage was done to the building.<br/>
                    int toBldg = hits * nDamPerHit;<br/>
                    if ( toBldg &gt; 0 ) {<br/>
                        Report buildingReport = damageBuilding( bldg, toBldg );<br/>
                        buildingReport.indent(2);<br/>
                        buildingReport.newlines = 1;<br/>
                        buildingReport.subject = subjectId;<br/>
                        addReport(buildingReport);<br/>
                    }<br/>
<br/>
                } // End rounds-hit<br/>
<br/>
            } // End missed-target-in-building<br/>
            return !bMissed;<br/>
<br/>
        } // End missed-target<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        int bldgAbsorbs = 0;<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
        }<br/>
<br/>
        // All attacks (except from infantry weapons)<br/>
        // during Mek Swarms hit the same location.<br/>
        if ( !isWeaponInfantry &amp;&amp;<br/>
             ae.getSwarmTargetId() == wr.waa.getTargetId() ) {<br/>
            nCluster = hits;<br/>
        }<br/>
<br/>
        // Battle Armor MGs do one die of damage per hit to PBI.<br/>
        if ( wtype.getAmmoType() == AmmoType.T_BA_MG &amp;&amp;<br/>
             (target instanceof Infantry) &amp;&amp;<br/>
             !(target instanceof BattleArmor) ) {<br/>
<br/>
            // ASSUMPTION: Building walls protect infantry from BA MGs.<br/>
            if ( bldgAbsorbs &gt; 0 ) {<br/>
                int toBldg = nDamPerHit * hits;<br/>
                r = new Report(3295);<br/>
                r.newlines = 0;<br/>
                r.subject = subjectId;<br/>
                r.add(hits);<br/>
                r.add(sSalvoType);<br/>
                addReport(r);<br/>
<br/>
                Report buildingReport =<br/>
                    damageBuilding( bldg,<br/>
                                    Math.min( toBldg, bldgAbsorbs ),<br/>
                                    " absorbs the shots, taking "  );<br/>
                buildingReport.newlines = 1;<br/>
                buildingReport.subject = subjectId;<br/>
                addReport(buildingReport);<br/>
                return !bMissed;<br/>
            }<br/>
            nDamPerHit = Compute.d6(hits);<br/>
            r = new Report(3300);<br/>
            r.newlines = 0;<br/>
            r.subject = subjectId;<br/>
            r.add(nDamPerHit);<br/>
            r.add(sSalvoType);<br/>
            addReport(r);<br/>
            hits = 1;<br/>
        }<br/>
<br/>
        // Mech and Vehicle MGs do *DICE* of damage to PBI.<br/>
        else if (usesAmmo &amp;&amp; atype.hasFlag(AmmoType.F_MG) &amp;&amp;<br/>
                  !isWeaponInfantry &amp;&amp; (target instanceof Infantry) &amp;&amp;<br/>
                  !(target instanceof BattleArmor) &amp;&amp; !weapon.isRapidfire()) {<br/>
<br/>
            int dice = wtype.getDamage();<br/>
<br/>
            // A building may absorb the entire shot.<br/>
            if ( nDamPerHit &lt;= bldgAbsorbs ) {<br/>
                int toBldg = nDamPerHit * hits;<br/>
                int curCF = bldg.getCurrentCF();<br/>
                curCF = Math.min( curCF, toBldg );<br/>
                bldg.setCurrentCF( curCF );<br/>
                if ( bSalvo ) {<br/>
                    r = new Report(3305);<br/>
                    r.subject = subjectId;<br/>
                    r.add(hits);<br/>
                    r.add(sSalvoType);<br/>
                    addReport(r);<br/>
                } else{<br/>
                    r = new Report(3310);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                }<br/>
                r = new Report(3315);<br/>
                r.indent(2);<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                Report buildingReport =<br/>
                    damageBuilding( bldg,<br/>
                                    Math.min( toBldg, bldgAbsorbs ),<br/>
                                    " absorbs the shots, taking "  );<br/>
                buildingReport.newlines = 1;<br/>
                buildingReport.subject = subjectId;<br/>
                addReport(buildingReport);<br/>
                return !bMissed;<br/>
            }<br/>
<br/>
            // If a building absorbs partial damage, reduce the dice of damage.<br/>
            else if ( bldgAbsorbs &gt; 0 ) {<br/>
                dice -= bldgAbsorbs;<br/>
            }<br/>
<br/>
            nDamPerHit = Compute.d6( dice );<br/>
            r = new Report(3320);<br/>
            r.subject = subjectId;<br/>
            r.add(nDamPerHit);<br/>
            r.add(sSalvoType);<br/>
            addReport(r);<br/>
            bSalvo = true;<br/>
<br/>
            // If a building absorbed partial damage, report it now<br/>
            // instead of later and then clear the variable.<br/>
            if ( bldgAbsorbs &gt; 0 ) {<br/>
                Report buildingReport = damageBuilding( bldg, bldgAbsorbs );<br/>
                buildingReport.indent(2);<br/>
                buildingReport.subject = subjectId;<br/>
                addReport(buildingReport);<br/>
                bldgAbsorbs = 0;<br/>
            }<br/>
<br/>
        }<br/>
<br/>
        // Report the number of hits.  Infernos have their own reporting<br/>
        else if (bSalvo &amp;&amp; !bInferno) {<br/>
            r = new Report(3325);<br/>
            r.subject = subjectId;<br/>
            r.add(hits);<br/>
            r.add(sSalvoType);<br/>
            r.add(toHit.getTableDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (bECMAffected) {<br/>
                //ECM prevents bonus<br/>
                r = new Report(3330);<br/>
                r.subject = subjectId;<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
            else if (bMekStealthActive) {<br/>
                //stealth prevents bonus<br/>
                r = new Report(3335);<br/>
                r.subject = subjectId;<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
            if (nSalvoBonus &gt; 0) {<br/>
                r = new Report(3340);<br/>
                r.subject = subjectId;<br/>
                r.add(nSalvoBonus);<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
            r = new Report(3345);<br/>
            r.subject = subjectId;<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
<br/>
            if (wr.amsShotDownTotal &gt; 0) {<br/>
                for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
                    int shotDown = Math.min(wr.amsShotDown[i], hits);<br/>
                    r = new Report(3350);<br/>
                    r.indent();<br/>
                    r.subject = subjectId;<br/>
                    r.add(wr.amsShotDown[i]);<br/>
                    r.add(shotDown);<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                }<br/>
                hits -= wr.amsShotDownTotal;<br/>
<br/>
                addNewLines();<br/>
                if (hits &lt; 1) {<br/>
                    //all missiles shot down<br/>
                    r = new Report(3355);<br/>
                    r.indent();<br/>
                    r.subject = subjectId;<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                } else {<br/>
                    r = new Report(3360);<br/>
                    r.indent();<br/>
                    r.subject = subjectId;<br/>
                    r.add(hits);<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        // convert the ATM missile damages to LRM type 5 point cluster damage<br/>
        // done here after AMS has been performed<br/>
        if (wtype.getAmmoType() == AmmoType.T_ATM) {<br/>
            hits = nDamPerHit * hits;<br/>
            nDamPerHit = 1;<br/>
        }<br/>
<br/>
        // Make sure the player knows when his attack causes no damage.<br/>
        if ( hits == 0 ) {<br/>
            r = new Report(3365);<br/>
            r.subject = subjectId;<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // for each cluster of hits, do a chunk of damage<br/>
        while (hits &gt; 0) {<br/>
            int nDamage;<br/>
<br/>
            // If the attack was with inferno rounds then<br/>
            // do heat and fire instead of damage.<br/>
            if ( bInferno ) {<br/>
                // AMS can shoot down infernos, too.<br/>
                if (wr.amsShotDownTotal &gt; 0) {<br/>
                    for (int i=0; i &lt; wr.amsShotDown.length; i++) {<br/>
                        int shotDown = Math.min(wr.amsShotDown[i], hits);<br/>
                        r = new Report(3350);<br/>
                        r.indent();<br/>
                        r.subject = subjectId;<br/>
                        r.add(wr.amsShotDown[i]);<br/>
                        r.add(shotDown);<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                    }<br/>
                    hits -= wr.amsShotDownTotal;<br/>
<br/>
                    addNewLines();<br/>
                    if (hits &lt; 1) {<br/>
                        //all missiles shot down<br/>
                        r = new Report(3355);<br/>
                        r.indent();<br/>
                        r.subject = subjectId;<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        r = new Report(3360);<br/>
                        r.indent();<br/>
                        r.subject = subjectId;<br/>
                        r.add(hits);<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                    }<br/>
                    if ( hits &lt;= 0 ) {<br/>
                        continue;<br/>
                    }<br/>
                }<br/>
<br/>
                // targeting a hex for ignition<br/>
                if( target.getTargetType() == Targetable.TYPE_HEX_IGNITE ||<br/>
                    target.getTargetType() == Targetable.TYPE_BLDG_IGNITE ) {<br/>
<br/>
                    //inferno missiles hit<br/>
                    r = new Report(3370);<br/>
                    r.subject = subjectId;<br/>
                    r.add(hits);<br/>
                    addReport(r);<br/>
<br/>
                    // Unless there a fire in the hex already, start one.<br/>
                    Coords c = target.getPosition();<br/>
                    IHex h = game.getBoard().getHex(c);<br/>
                    if ( !h.containsTerrain( Terrains.FIRE ) ) {<br/>
                        r = new Report(3005);<br/>
                        r.subject = subjectId;<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                        h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                    }<br/>
                    game.getBoard().addInfernoTo<br/>
                        ( c, InfernoTracker.STANDARD_ROUND, hits );<br/>
                    sendChangedHex(c);<br/>
<br/>
                    return !bMissed;<br/>
                }<br/>
<br/>
                // Targeting an entity<br/>
                if (entityTarget != null ) {<br/>
                    r = new Report(3375);<br/>
                    r.subject = subjectId;<br/>
                    r.add(hits);<br/>
                    addReport(r);<br/>
<br/>
                    if(game.getOptions().booleanOption("vehicle_fires")<br/>
                            &amp;&amp; entityTarget instanceof Tank) {<br/>
                        checkForVehicleFire((Tank)entityTarget, true);<br/>
                    } else {<br/>
                        entityTarget.infernos.add( InfernoTracker.STANDARD_ROUND,<br/>
                                hits );<br/>
                        r = new Report(3205);<br/>
                        r.indent(2);<br/>
                        r.subject = subjectId;<br/>
                        r.addDesc(entityTarget);<br/>
                        r.add(entityTarget.infernos.getTurnsLeftToBurn());<br/>
                        addReport(r);<br/>
                    }<br/>
<br/>
                    // Start a fire in the targets hex, unless already on fire.<br/>
                    Coords c = target.getPosition();<br/>
                    IHex h = game.getBoard().getHex(c);<br/>
<br/>
                    // Unless there a fire in the hex already, start one.<br/>
                    if ( !h.containsTerrain( Terrains.FIRE ) ) {<br/>
                        r = new Report(3005);<br/>
                        r.subject = subjectId;<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                        h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                    }<br/>
                    game.getBoard().addInfernoTo<br/>
                        ( c, InfernoTracker.STANDARD_ROUND, 1 );<br/>
                    sendChangedHex(c);<br/>
<br/>
                    return !bMissed;<br/>
                }<br/>
<br/>
            } // End is-inferno<br/>
<br/>
            // targeting a hex for igniting<br/>
            if( target.getTargetType() == Targetable.TYPE_HEX_IGNITE ||<br/>
                target.getTargetType() == Targetable.TYPE_BLDG_IGNITE ) {<br/>
                if ( !bSalvo ) {<br/>
                    //hits!<br/>
                    r = new Report(2270);<br/>
                    r.subject = subjectId;<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                }<br/>
                // We handle Inferno rounds above.<br/>
                int tn = wtype.getFireTN();<br/>
                if(bIncendiary) {<br/>
                    tn = 5; // Incendiary AC and LRM<br/>
                }<br/>
                if (tn != TargetRoll.IMPOSSIBLE) {<br/>
                    if ( bldg != null ) {<br/>
                        tn += bldg.getType() - 1;<br/>
                    }<br/>
                    addNewLines();<br/>
                    tryIgniteHex( target.getPosition(), ae.getId(), bInferno, tn, true );<br/>
                }<br/>
                return !bMissed;<br/>
            }<br/>
<br/>
            // targeting a hex for clearing<br/>
            if (target.getTargetType() == Targetable.TYPE_HEX_CLEAR) {<br/>
<br/>
                nDamage = nDamPerHit * hits;<br/>
                if ( !bSalvo ) {<br/>
                    //hits!<br/>
                    r = new Report(2270);<br/>
                    r.subject = subjectId;<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                }<br/>
                if (ae instanceof Infantry) {<br/>
                    //infantry cannot clear hexes<br/>
                    r = new Report(3380);<br/>
                    r.indent();<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                    return !bMissed;<br/>
                }<br/>
<br/>
<br/>
                //report that damge was "applied" to terrain<br/>
                r = new Report(3385);<br/>
                r.indent();<br/>
                r.subject = subjectId;<br/>
                r.add(nDamage);<br/>
                addReport(r);<br/>
<br/>
                // Any clear attempt can result in accidental ignition, even<br/>
                // weapons that can't normally start fires.  that's weird.<br/>
                // Buildings can't be accidentally ignited.<br/>
                if ( bldg == null) {<br/>
                    boolean alreadyIgnited = game.getBoard().getHex(target.getPosition()).containsTerrain(Terrains.FIRE);<br/>
                    boolean ignited = tryIgniteHex(target.getPosition(), subjectId, bInferno, 9);<br/>
                    if (!alreadyIgnited &amp;&amp; ignited) return !bMissed;<br/>
                }<br/>
<br/>
                int tn = 14 - nDamage;<br/>
                tryClearHex(target.getPosition(), tn, ae.getId());<br/>
<br/>
                return !bMissed;<br/>
            }<br/>
<br/>
            // Targeting a building.<br/>
            if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
                // Is the building hit by Inferno rounds?<br/>
                if ( bInferno ) {<br/>
<br/>
                    // start a fire in the targets hex<br/>
                    Coords c = target.getPosition();<br/>
                    IHex h = game.getBoard().getHex(c);<br/>
<br/>
                    // Is there a fire in the hex already?<br/>
                    if ( h.containsTerrain( Terrains.FIRE ) ) {<br/>
                        r = new Report(3285);<br/>
                        r.subject = subjectId;<br/>
                        r.add(hits);<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        r = new Report(3290);<br/>
                        r.subject = subjectId;<br/>
                        r.add(hits);<br/>
                        r.add(c.getBoardNum());<br/>
                        addReport(r);<br/>
                        h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                    }<br/>
                    game.getBoard().addInfernoTo<br/>
                        ( c, InfernoTracker.STANDARD_ROUND, hits );<br/>
                    sendChangedHex(c);<br/>
<br/>
                } else {<br/>
                    // The building takes the full brunt of the attack.<br/>
                    nDamage = nDamPerHit * hits;<br/>
                    if ( !bSalvo ) {<br/>
                        //hits!<br/>
                        r = new Report(3390);<br/>
                        r.subject = subjectId;<br/>
                        addReport(r);<br/>
                    }<br/>
                    addNewLines();<br/>
                    Report buildingReport = damageBuilding( bldg, nDamage );<br/>
                    buildingReport.indent(2);<br/>
                    buildingReport.newlines = 1;<br/>
                    buildingReport.subject = subjectId;<br/>
                    addReport(buildingReport);<br/>
    <br/>
                    // Damage any infantry in the hex.<br/>
                    this.damageInfantryIn( bldg, nDamage );<br/>
                }<br/>
<br/>
                // And we're done!<br/>
                return !bMissed;<br/>
            }<br/>
<br/>
            // Battle Armor squads equipped with fire protection<br/>
            // gear automatically avoid flaming death.<br/>
            if ( wtype.hasFlag(WeaponType.F_FLAMER) &amp;&amp;<br/>
                 target instanceof BattleArmor ) {<br/>
<br/>
                for ( Enumeration iter = entityTarget.getMisc();<br/>
                      iter.hasMoreElements(); ) {<br/>
                    Mounted mount = (Mounted) iter.nextElement();<br/>
                    EquipmentType equip = mount.getType();<br/>
                    if ( BattleArmor.FIRE_PROTECTION.equals<br/>
                         (equip.getInternalName()) ) {<br/>
                        if ( !bSalvo ) {<br/>
                            //hits<br/>
                            r = new Report(3390);<br/>
                            r.subject = subjectId;<br/>
                            addReport(r);<br/>
                        }<br/>
                        r = new Report(3395);<br/>
                        r.indent(2);<br/>
                        r.subject = subjectId;<br/>
                        r.addDesc(entityTarget);<br/>
                        addReport(r);<br/>
<br/>
                        // A building may be damaged, even if the squad is not.<br/>
                        if ( bldgAbsorbs &gt; 0 ) {<br/>
                            int toBldg = nDamPerHit * Math.min( bldgAbsorbs,<br/>
                                                                hits );<br/>
                            Report buildingReport = damageBuilding( bldg, toBldg );<br/>
                            buildingReport.indent(2);<br/>
                            buildingReport.newlines = 1;<br/>
                            buildingReport.subject = subjectId;<br/>
                            addReport(buildingReport);<br/>
                        }<br/>
<br/>
                     return !bMissed;<br/>
                    }<br/>
                }<br/>
            } // End target-may-be-immune<br/>
<br/>
            // Flamers do heat to mechs instead damage if the option is<br/>
            // available and the mode is set.<br/>
            if (entityTarget != null<br/>
                    &amp;&amp; (entityTarget instanceof Mech)<br/>
                    &amp;&amp; wtype.hasFlag(WeaponType.F_FLAMER)<br/>
                    &amp;&amp; game.getOptions().booleanOption("flamer_heat")<br/>
                    &amp;&amp; wtype.hasModes()<br/>
                    &amp;&amp; weapon.curMode().equals("Heat")) {<br/>
                nDamage = nDamPerHit * hits;<br/>
                if ( !bSalvo ) {<br/>
                    //hits<br/>
                    r = new Report(3390);<br/>
                    r.subject = subjectId;<br/>
                    addReport(r);<br/>
                }<br/>
                r = new Report(3400);<br/>
                r.subject = subjectId;<br/>
                r.indent(2);<br/>
                r.add(nDamage);<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
                entityTarget.heatBuildup += nDamage;<br/>
                hits = 0;<br/>
            } else if (entityTarget != null) {<br/>
                 HitData hit = entityTarget.rollHitLocation<br/>
                     ( toHit.getHitTable(),<br/>
                       toHit.getSideTable(),<br/>
                       wr.waa.getAimedLocation(),<br/>
                       wr.waa.getAimingMode() );<br/>
<br/>
                if (wtype.hasFlag(WeaponType.F_PLASMA_MFUK)<br/>
                        &amp;&amp; (entityTarget instanceof Mech)) {<br/>
                    nDamage = nDamPerHit * hits;<br/>
                    if (!bSalvo) {<br/>
                        //hits<br/>
                        r = new Report(3390);<br/>
                        r.subject = subjectId;<br/>
                        addReport(r);<br/>
                    }<br/>
                    r = new Report(3400);<br/>
                    r.subject = subjectId;<br/>
                    r.indent(2);<br/>
                    r.add(5);<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                    entityTarget.heatBuildup += 5;<br/>
                }<br/>
<br/>
                // If a leg attacks hit a leg that isn't<br/>
                // there, then hit the other leg.<br/>
                if ( wtype.getInternalName().equals("LegAttack") &amp;&amp;<br/>
                     entityTarget.getInternal(hit) &lt;= 0 ) {<br/>
                    if ( hit.getLocation() == Mech.LOC_RLEG ) {<br/>
                        hit = new HitData( Mech.LOC_LLEG );<br/>
                    }<br/>
                    else {<br/>
                        hit = new HitData( Mech.LOC_RLEG );<br/>
                    }<br/>
                }<br/>
<br/>
                // Mine Launchers automatically hit the<br/>
                // CT of a Mech or the front of a Tank.<br/>
                if ( wtype.getInternalName()<br/>
                     .equals(BattleArmor.MINE_LAUNCHER) ) {<br/>
                    if ( target instanceof Mech ) {<br/>
                        hit = new HitData( Mech.LOC_CT );<br/>
                    }<br/>
                    else { // te instanceof Tank<br/>
                        hit = new HitData( Tank.LOC_FRONT );<br/>
                    }<br/>
                }<br/>
<br/>
                // Each hit in the salvo get's its own hit location.<br/>
                if (!bSalvo) {<br/>
                    r = new Report(3405);<br/>
                    r.subject = subjectId;<br/>
                    r.add(toHit.getTableDesc());<br/>
                    r.add(entityTarget.getLocationAbbr(hit));<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                    if (hit.hitAimedLocation()) {<br/>
                        r = new Report(3410);<br/>
                        r.subject = subjectId;<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                    }<br/>
                }<br/>
<br/>
                // Special weapons do criticals instead of damage.<br/>
                if ( nDamPerHit == WeaponType.DAMAGE_SPECIAL ) {<br/>
                    // Do criticals.<br/>
                    //String specialDamage = criticalEntity( entityTarget, hit.getLocation() );<br/>
                    Vector specialDamageReport = criticalEntity( entityTarget, hit.getLocation() );<br/>
<br/>
                    // Replace "no effect" results with 4 points of damage.<br/>
                    //if ( specialDamage.endsWith(" no effect.") ) {<br/>
                    if (((Report)specialDamageReport.lastElement()).messageId == 6005) {<br/>
                        int damage = 4;<br/>
                        if (ae instanceof BattleArmor)<br/>
                            damage += ((BattleArmor)ae).getVibroClawDamage();<br/>
                        // ASSUMPTION: buildings CAN'T absorb *this* damage.<br/>
                        //specialDamage = damageEntity(entityTarget, hit, damage);<br/>
                        specialDamageReport = damageEntity(entityTarget, hit, damage, false, 0, false, false, throughFront);<br/>
                    }<br/>
                    else {<br/>
                        //add newline _before_ last report<br/>
                        try {<br/>
                            ((Report) specialDamageReport.elementAt(specialDamageReport.size() - 2)).newlines++;<br/>
                        } catch (ArrayIndexOutOfBoundsException aiobe) {<br/>
                            System.err.println("ERROR: no previous report when trying to add newline");<br/>
                        }<br/>
                    }<br/>
<br/>
                    // Report the result<br/>
                    addReport( specialDamageReport);<br/>
                }<br/>
                else if(game.getOptions().booleanOption("maxtech_partial_cover") &amp;&amp;<br/>
                  toHit.getHitTable() == ToHitData.HIT_PARTIAL_COVER &amp;&amp;<br/>
                  entityTarget.removePartialCoverHits(hit.getLocation(), toHit.getCover(), toHit.getSideTable())) {<br/>
                    r = new Report(3460);<br/>
                    r.subject = entityTarget.getId();<br/>
                    r.indent(2);<br/>
                    r.add(entityTarget.getDisplayName());<br/>
                    r.add(entityTarget.getLocationAbbr(hit));<br/>
                    r.newlines = 0;<br/>
                    addReport(r);<br/>
                }<br/>
                else {<br/>
                    // Resolve damage normally.<br/>
                    nDamage = nDamPerHit * Math.min(nCluster, hits);<br/>
<br/>
                    // A building may be damaged, even if the squad is not.<br/>
                    if ( bldgAbsorbs &gt; 0 ) {<br/>
                        int toBldg = Math.min( bldgAbsorbs, nDamage );<br/>
                        nDamage -= toBldg;<br/>
                        addNewLines();<br/>
                        Report buildingReport = damageBuilding( bldg, toBldg );<br/>
                        buildingReport.indent(2);<br/>
                        buildingReport.subject = subjectId;<br/>
                        addReport(buildingReport);<br/>
                    }<br/>
<br/>
                    // A building may absorb the entire shot.<br/>
                    if ( nDamage == 0 ) {<br/>
                        r = new Report(3415);<br/>
                        r.subject = subjectId;<br/>
                        r.indent(2);<br/>
                        r.addDesc(entityTarget);<br/>
                        r.newlines = 0;<br/>
                        addReport(r);<br/>
                    } else if (bFragmentation) {<br/>
                        // If it's a frag missile...<br/>
                        if (bGlancing) {<br/>
                            hit.makeGlancingBlow();<br/>
                        }<br/>
                        addReport(<br/>
                          damageEntity(entityTarget, hit, nDamage, false, 1, false, false, throughFront));<br/>
                    } else if (bFlechette) {<br/>
                        // If it's a frag missile...<br/>
                        if (bGlancing) {<br/>
                            hit.makeGlancingBlow();<br/>
                        }<br/>
                        addReport(<br/>
                          damageEntity(entityTarget, hit, nDamage, false, 2, false, false, throughFront));<br/>
                    } else if (bAcidHead) {<br/>
                        // If it's an acid-head warhead...<br/>
                        if (bGlancing) {<br/>
                            hit.makeGlancingBlow();<br/>
                        }<br/>
                        addReport(<br/>
                                              damageEntity(entityTarget, hit, nDamage, false, 3, false, false, throughFront) );<br/>
                    } else if(bIncendiary &amp;&amp; usesAmmo &amp;&amp; atype.getAmmoType() == AmmoType.T_AC) {<br/>
                        //incendiary AC ammo<br/>
                        if (bGlancing) {<br/>
                            hit.makeGlancingBlow();<br/>
                        }<br/>
                        addReport(<br/>
                                              damageEntity(entityTarget, hit, nDamage, false, 4, false, false, throughFront));<br/>
                    } else {<br/>
                        if (usesAmmo<br/>
                                &amp;&amp; (atype.getAmmoType() == AmmoType.T_AC)<br/>
                                &amp;&amp; (atype.getMunitionType() == AmmoType.M_ARMOR_PIERCING)<br/>
                                &amp;&amp; !(entityTarget.getArmorType() == EquipmentType.T_ARMOR_HARDENED))<br/>
                            hit.makeArmorPiercing(atype);<br/>
                        if (bGlancing) {<br/>
                            hit.makeGlancingBlow();<br/>
                        }<br/>
                        if (bAntiTSM) {<br/>
                            entityTarget.hitThisRoundByAntiTSM = true;<br/>
                        }<br/>
                        addReport(<br/>
                            damageEntity(entityTarget, hit, nDamage, false, 0, false, false, throughFront));<br/>
                    }<br/>
                }<br/>
                hits -= nCluster;<br/>
                creditKill(entityTarget, ae);<br/>
            } else {<br/>
                System.err.println("Unable to resolve hit against "+target.getDisplayName());<br/>
                if(entityTarget == null) {<br/>
                    System.err.println("   entityTarget is null");<br/>
                }<br/>
                hits = 0; //prevents server lock-up<br/>
            }<br/>
        } // Handle the next cluster.<br/>
<br/>
        //deal with splash damage from Arrow IV homing<br/>
        if(atype != null &amp;&amp; atype.getMunitionType() == AmmoType.M_HOMING) {<br/>
            artilleryDamageHex(target.getPosition(), wr.artyAttackerCoords, 5, atype, subjectId, ae, entityTarget, false, 0);<br/>
        }<br/>
<br/>
        addNewLines();<br/>
<br/>
        if (swarmMissilesNowLeft &gt; 0 &amp;&amp; entityTarget != null) {<br/>
            Entity swarmTarget = Compute.getSwarmTarget(game, ae.getId(), entityTarget, wr.waa.getWeaponId());<br/>
            if (swarmTarget != null) {<br/>
                //missiles keep swarming<br/>
                r = new Report(3420);<br/>
                r.subject = swarmTarget.getId();<br/>
                r.indent();<br/>
                r.add(swarmMissilesNowLeft);<br/>
                addReport(r);<br/>
                weapon.setUsedThisRound(false);<br/>
                WeaponAttackAction newWaa = new WeaponAttackAction(ae.getId(),<br/>
                    swarmTarget.getTargetId(), wr.waa.getWeaponId());<br/>
                newWaa.setSwarmingMissiles(true);<br/>
                newWaa.setOldTargetId(target.getTargetId());<br/>
                newWaa.setAmmoId(wr.waa.getAmmoId());<br/>
                WeaponResult newWr = preTreatWeaponAttack(newWaa);<br/>
                resolveWeaponAttack(newWr, ae.getId(), false, swarmMissilesNowLeft);<br/>
            } else {<br/>
                //missiles can't find another target<br/>
                r = new Report(3425);<br/>
                r.subject = ae.getId();<br/>
                r.indent();<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        return !bMissed;<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle all physical attacks for the round<br/>
     */<br/>
    private void resolvePhysicalAttacks() {<br/>
        //Physical phase header<br/>
        addReport(new Report(4000, Report.PUBLIC));<br/>
<br/>
        // add any pending charges<br/>
        for (Enumeration i = game.getCharges(); i.hasMoreElements();) {<br/>
            game.addAction((EntityAction)i.nextElement());<br/>
        }<br/>
        game.resetCharges();<br/>
<br/>
        // remove any duplicate attack declarations<br/>
        cleanupPhysicalAttacks();<br/>
<br/>
        // loop thru received attack actions<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            Object o = i.nextElement();<br/>
<br/>
            // verify that the attacker is still active<br/>
            AttackAction aa = (AttackAction)o;<br/>
            if (!(game.getEntity(aa.getEntityId()).isActive())<br/>
            &amp;&amp; !(o instanceof DfaAttackAction)) {<br/>
                continue;<br/>
            }<br/>
            AbstractAttackAction aaa = (AbstractAttackAction)o;<br/>
            // do searchlights immediately<br/>
            if (aaa instanceof SearchlightAttackAction) {<br/>
                SearchlightAttackAction saa = (SearchlightAttackAction)aaa;<br/>
                addReport(<br/>
                                      saa.resolveAction(game));<br/>
            } else {<br/>
                physicalResults.addElement(preTreatPhysicalAttack(aaa));<br/>
            }<br/>
        }<br/>
        int cen = Entity.NONE;<br/>
        for (Enumeration i = physicalResults.elements(); i.hasMoreElements();) {<br/>
            PhysicalResult pr = (PhysicalResult)i.nextElement();<br/>
            resolvePhysicalAttack(pr, cen);<br/>
            cen = pr.aaa.getEntityId();<br/>
        }<br/>
        physicalResults.removeAllElements();<br/>
    }<br/>
<br/>
    /**<br/>
     * Cleans up the attack declarations for the physical phase by removing<br/>
     * all attacks past the first for any one mech.  Also clears out attacks<br/>
     * by dead or disabled mechs.<br/>
     */<br/>
    private void cleanupPhysicalAttacks() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            removeDuplicateAttacks(entity.getId());<br/>
        }<br/>
        removeDeadAttacks();<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes any actions in the attack queue beyond the first by the<br/>
     * specified entity.<br/>
     */<br/>
    private void removeDuplicateAttacks(int entityId) {<br/>
        boolean attacked = false;<br/>
        Vector toKeep = new Vector(/*game.actionsSize()*/);<br/>
<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            EntityAction action = (EntityAction)i.nextElement();<br/>
            if (action.getEntityId() != entityId) {<br/>
                toKeep.addElement(action);<br/>
            } else if (!attacked) {<br/>
                toKeep.addElement(action);<br/>
                if(!(action instanceof SearchlightAttackAction)) {<br/>
                    attacked = true;<br/>
                }<br/>
            } else {<br/>
                System.err.println("server: removing duplicate phys attack for id#" + entityId);<br/>
                System.err.println("        action was "+ action.toString());<br/>
            }<br/>
        }<br/>
<br/>
        // reset actions and re-add valid elements<br/>
        game.resetActions();<br/>
        for (Enumeration i = toKeep.elements(); i.hasMoreElements();) {<br/>
            game.addAction((EntityAction)i.nextElement());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Removes all attacks by any dead entities.  It does this by going through<br/>
     * all the attacks and only keeping ones from active entities.  DFAs are<br/>
     * kept even if the pilot is unconscious, so that he can fail.<br/>
     */<br/>
    private void removeDeadAttacks() {<br/>
        Vector toKeep = new Vector(game.actionsSize());<br/>
<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            EntityAction action = (EntityAction)i.nextElement();<br/>
            Entity entity = game.getEntity(action.getEntityId());<br/>
            if (entity != null &amp;&amp; !entity.isDestroyed()<br/>
            &amp;&amp; (entity.isActive() || action instanceof DfaAttackAction)) {<br/>
                toKeep.addElement(action);<br/>
            }<br/>
        }<br/>
<br/>
        // reset actions and re-add valid elements<br/>
        game.resetActions();<br/>
        for (Enumeration i = toKeep.elements(); i.hasMoreElements();) {<br/>
            game.addAction((EntityAction)i.nextElement());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a punch attack<br/>
     */<br/>
    private void resolvePunchAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final PunchAttackAction paa = (PunchAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        final Targetable target = game.getTarget(paa.getTargetType(), paa.getTargetId());<br/>
        Entity te = null;<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = (Entity)target;<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, paa.getEntityId(), te);<br/>
        }<br/>
        final String armName = paa.getArm() == PunchAttackAction.LEFT<br/>
        ? "Left Arm" : "Right Arm";<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = paa.getArm() == PunchAttackAction.LEFT<br/>
        ? pr.damage : pr.damageRight;<br/>
        final ToHitData toHit = paa.getArm() == PunchAttackAction.LEFT<br/>
        ? pr.toHit : pr.toHitRight;<br/>
        int roll = paa.getArm() == PunchAttackAction.LEFT<br/>
        ? pr.roll : pr.rollRight;<br/>
        final boolean targetInBuilding = Compute.isInBuilding( game, te );<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
        Report r;<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( target.getPosition() );<br/>
<br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            //report who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4010);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(armName);<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4015);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            return;<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            r = new Report(4020);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            roll = Integer.MAX_VALUE;<br/>
        } else {<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            //nope<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
<br/>
            // If the target is in a building, the building absorbs the damage.<br/>
            if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
<br/>
                // Only report if damage was done to the building.<br/>
                if ( damage &gt; 0 ) {<br/>
                    Report buildingReport = damageBuilding( bldg, damage );<br/>
                    buildingReport.indent();<br/>
                    buildingReport.subject = ae.getId();<br/>
                    addReport(buildingReport);<br/>
                }<br/>
<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // Targeting a building.<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            r = new Report(4040);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
            // And we're done!<br/>
            return;<br/>
        }<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        r = new Report(4045);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getTableDesc());<br/>
        r.add(te.getLocationAbbr(hit));<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            int bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
            int toBldg = Math.min( bldgAbsorbs, damage );<br/>
            damage -= toBldg;<br/>
            addNewLines();<br/>
            Report buildingReport = damageBuilding( bldg, toBldg );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
        }<br/>
<br/>
        // A building may absorb the entire shot.<br/>
        if ( damage == 0 ) {<br/>
            r = new Report(4050);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getShortName());<br/>
            r.add(te.getOwner().getName());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        } else {<br/>
            if (glancing) {<br/>
                damage = (int)Math.floor(damage/2.0);<br/>
            }<br/>
            addReport(damageEntity(te, hit, damage, false, 0, false, false, throughFront));<br/>
        }<br/>
<br/>
        addNewLines();<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a kick attack<br/>
     */<br/>
    private void resolveKickAttack(PhysicalResult pr, int lastEntityId) {<br/>
        KickAttackAction kaa = (KickAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(kaa.getEntityId());<br/>
        final Targetable target = game.getTarget(kaa.getTargetType(), kaa.getTargetId());<br/>
        Entity te = null;<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = (Entity)target;<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, kaa.getEntityId(), te);<br/>
        }<br/>
        String legName = ( (kaa.getLeg() == KickAttackAction.LEFT) ||<br/>
                                 (kaa.getLeg() == KickAttackAction.LEFTMULE) )<br/>
        ? "Left "<br/>
        : "Right ";<br/>
        if (game.getOptions().booleanOption("maxtech_mulekicks")) {<br/>
            if ( (kaa.getLeg() == KickAttackAction.LEFTMULE) || <br/>
                 (kaa.getLeg() == KickAttackAction.RIGHTMULE) ) {<br/>
                legName.concat(" rear ");<br/>
            } else {<br/>
                legName.concat(" front ");<br/>
            }<br/>
        }<br/>
        legName.concat("leg");<br/>
        Report r;<br/>
<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        final boolean targetInBuilding = Compute.isInBuilding( game, te );<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( target.getPosition() );<br/>
<br/>
        if (lastEntityId != ae.getId()) {<br/>
            //who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4055);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(legName);<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4060);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a kick"));<br/>
            return;<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            r = new Report(4065);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            roll = Integer.MAX_VALUE;<br/>
        } else {<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a kick"));<br/>
<br/>
            // If the target is in a building, the building absorbs the damage.<br/>
            if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
<br/>
                // Only report if damage was done to the building.<br/>
                if ( damage &gt; 0 ) {<br/>
                    Report buildingReport = damageBuilding( bldg, damage );<br/>
                    buildingReport.indent();<br/>
                    buildingReport.subject = ae.getId();<br/>
                    addReport(buildingReport);<br/>
                }<br/>
<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // Targeting a building.<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            r = new Report(4040);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
            // And we're done!<br/>
            return;<br/>
        }<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        r = new Report(4045);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getTableDesc());<br/>
        r.add(te.getLocationAbbr(hit));<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            int bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
            int toBldg = Math.min( bldgAbsorbs, damage );<br/>
            damage -= toBldg;<br/>
            addNewLines();<br/>
            Report buildingReport = damageBuilding( bldg, toBldg );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
        }<br/>
<br/>
        // A building may absorb the entire shot.<br/>
        if ( damage == 0 ) {<br/>
            r = new Report(4050);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getShortName());<br/>
            r.add(te.getOwner().getName());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        } else {<br/>
            if (glancing) {<br/>
                damage = (int)Math.floor(damage/2.0);<br/>
            }<br/>
            addReport(damageEntity(te, hit, damage, false, 0, false, false, throughFront));<br/>
        }<br/>
<br/>
        if (te.getMovementMode() == IEntityMovementMode.BIPED || te.getMovementMode() == IEntityMovementMode.QUAD) {<br/>
            PilotingRollData kickPRD = new PilotingRollData(te.getId(), getKickPushPSRMod(ae, te, 0), "was kicked");<br/>
            kickPRD.setCumulative(false); // see Bug# 811987 for more info<br/>
            game.addPSR(kickPRD);<br/>
        }<br/>
<br/>
        addNewLines();<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a Protomech physicalattack<br/>
     */<br/>
<br/>
    private void resolveProtoAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final ProtomechPhysicalAttackAction ppaa = (ProtomechPhysicalAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(ppaa.getEntityId());<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        final Targetable target = game.getTarget(ppaa.getTargetType(), ppaa.getTargetId());<br/>
        Entity te = null;<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = (Entity)target;<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, ppaa.getEntityId(), te);<br/>
        }<br/>
        final boolean targetInBuilding = Compute.isInBuilding( game, te );<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
        Report r;<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( target.getPosition() );<br/>
<br/>
        if (lastEntityId != ae.getId()) {<br/>
            //who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4070);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4075);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            return;<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            r = new Report(4080);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            roll = Integer.MAX_VALUE;<br/>
        } else {<br/>
            // report the roll<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            // miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
<br/>
            // If the target is in a building, the building absorbs the damage.<br/>
            if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
<br/>
                // Only report if damage was done to the building.<br/>
                if ( damage &gt; 0 ) {<br/>
                    Report buildingReport = damageBuilding( bldg, damage );<br/>
                    buildingReport.indent();<br/>
                    buildingReport.subject = ae.getId();<br/>
                    addReport(buildingReport);<br/>
                }<br/>
<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // Targeting a building.<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            r = new Report(4040);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
            // And we're done!<br/>
            return;<br/>
        }<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        r = new Report(4045);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getTableDesc());<br/>
        r.add(te.getLocationAbbr(hit));<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            int bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
            int toBldg = Math.min( bldgAbsorbs, damage );<br/>
            damage -= toBldg;<br/>
            addNewLines();<br/>
            Report buildingReport = damageBuilding( bldg, toBldg );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
        }<br/>
<br/>
        // A building may absorb the entire shot.<br/>
        if ( damage == 0 ) {<br/>
            r = new Report(4050);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getShortName());<br/>
            r.add(te.getOwner().getName());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        } else {<br/>
            if (glancing) {<br/>
                damage = (int)Math.floor(damage/2.0);<br/>
            }<br/>
            addReport(damageEntity(te, hit, damage));<br/>
        }<br/>
<br/>
        addNewLines();<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Handle a brush off attack<br/>
     */<br/>
    private void resolveBrushOffAttack( PhysicalResult pr,<br/>
                                        int lastEntityId ) {<br/>
        final BrushOffAttackAction baa = (BrushOffAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(baa.getEntityId());<br/>
        // PLEASE NOTE: buildings are *never* the target<br/>
        // of a "brush off", but iNarc pods **are**.<br/>
        Targetable target = game.getTarget( baa.getTargetType(),<br/>
                                            baa.getTargetId() );<br/>
        Entity te = null;<br/>
        final String armName = baa.getArm() == BrushOffAttackAction.LEFT<br/>
            ? "Left Arm" : "Right Arm";<br/>
        Report r;<br/>
<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = game.getEntity(baa.getTargetId());<br/>
        }<br/>
<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        // ASSUMPTION: buildings can't absorb *this* damage.<br/>
        int damage = baa.getArm() == BrushOffAttackAction.LEFT<br/>
        ? pr.damage : pr.damageRight;<br/>
        final ToHitData toHit = baa.getArm() == BrushOffAttackAction.LEFT<br/>
        ? pr.toHit : pr.toHitRight;<br/>
        int roll = baa.getArm() == BrushOffAttackAction.LEFT<br/>
        ? pr.roll : pr.rollRight;<br/>
<br/>
        if (lastEntityId != baa.getEntityId()) {<br/>
            //who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4085);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4090);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        // report the roll<br/>
        r = new Report(4025);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getValue());<br/>
        r.add(roll);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            //miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
<br/>
            // Missed Brush Off attacks cause punch damage to the attacker.<br/>
            toHit.setHitTable( ToHitData.HIT_PUNCH );<br/>
            toHit.setSideTable( ToHitData.SIDE_FRONT );<br/>
            HitData hit = ae.rollHitLocation( toHit.getHitTable(),<br/>
                                              toHit.getSideTable() );<br/>
            r = new Report(4095);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            r.add(ae.getLocationAbbr(hit));<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            addReport(<br/>
                                  damageEntity(ae, hit, damage));<br/>
            addNewLines();<br/>
            return;<br/>
        }<br/>
<br/>
        // Different target types get different handling.<br/>
        switch ( target.getTargetType() ) {<br/>
        case Targetable.TYPE_ENTITY:<br/>
            // Handle Entity targets.<br/>
            HitData hit = te.rollHitLocation( toHit.getHitTable(),<br/>
                                              toHit.getSideTable() );<br/>
            r = new Report(4045);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getTableDesc());<br/>
            r.add(te.getLocationAbbr(hit));<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            addReport(<br/>
                                  damageEntity(te, hit, damage));<br/>
            addNewLines();<br/>
<br/>
            // Dislodge the swarming infantry.<br/>
            ae.setSwarmAttackerId( Entity.NONE );<br/>
            te.setSwarmTargetId( Entity.NONE );<br/>
            r = new Report(4100);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getDisplayName());<br/>
            addReport(r);<br/>
            break;<br/>
        case Targetable.TYPE_INARC_POD:<br/>
            // Handle iNarc pod targets.<br/>
            // TODO : check the return code and handle false appropriately.<br/>
            ae.removeINarcPod( (INarcPod) target );<br/>
//             // TODO : confirm that we don't need to update the attacker. //killme<br/>
//             entityUpdate( ae.getId() ); // killme<br/>
            r = new Report(4105);<br/>
            r.subject = ae.getId();<br/>
            r.add(target.getDisplayName());<br/>
            addReport(r);<br/>
            break;<br/>
            // TODO : add a default: case and handle it appropriately.<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a thrash attack<br/>
     */<br/>
    private void resolveThrashAttack( PhysicalResult pr,<br/>
                                        int lastEntityId ) {<br/>
        final ThrashAttackAction taa = (ThrashAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(taa.getEntityId());<br/>
<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int hits = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
<br/>
        // PLEASE NOTE: buildings are *never* the target of a "thrash".<br/>
        final Entity te = game.getEntity(taa.getTargetId());<br/>
        Report r;<br/>
<br/>
        if (lastEntityId != taa.getEntityId()) {<br/>
            //who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4110);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.addDesc(te);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4115);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        // Thrash attack may hit automatically<br/>
        if ( toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS ) {<br/>
            r = new Report(4120);<br/>
            r.subject = ae.getId();<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        } else {<br/>
            // report the roll<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
<br/>
            // do we hit?<br/>
            if (roll &lt; toHit.getValue()) {<br/>
                //miss<br/>
                r = new Report(4035);<br/>
                r.subject = ae.getId();<br/>
                addReport(r);<br/>
                return;<br/>
            }<br/>
            r = new Report(4125);<br/>
            r.subject = ae.getId();<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // Standard damage loop in 5 point clusters.<br/>
        if (glancing) {<br/>
            hits = (int)Math.floor(hits/2.0);<br/>
        }<br/>
<br/>
        r = new Report(4130);<br/>
        r.subject = ae.getId();<br/>
        r.add(hits);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
        if (glancing) {<br/>
            r = new Report(4030);<br/>
            r.subject = ae.getId();<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        }<br/>
        while ( hits &gt; 0 ) {<br/>
            int damage = Math.min(5, hits);<br/>
            hits -= damage;<br/>
            HitData hit = te.rollHitLocation( toHit.getHitTable(),<br/>
                                              toHit.getSideTable() );<br/>
            r = new Report(4135);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getLocationAbbr(hit));<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            addReport(<br/>
                                  damageEntity(te, hit, damage));<br/>
        }<br/>
<br/>
        addNewLines();<br/>
<br/>
        // Thrash attacks cause PSRs.  Failed PSRs cause falling damage.<br/>
        // This fall damage applies even though the Thrashing Mek is prone.<br/>
        PilotingRollData rollData = ae.getBasePilotingRoll();<br/>
        ae.addPilotingModifierForTerrain(rollData);<br/>
        rollData.addModifier( 0, "thrashing at infantry" );<br/>
        r = new Report(4140);<br/>
        r.subject = ae.getId();<br/>
        r.addDesc(ae);<br/>
        addReport(r);<br/>
        final int diceRoll = Compute.d6(2);<br/>
        r = new Report(2190);<br/>
        r.subject = ae.getId();<br/>
        r.addDesc(ae);<br/>
        r.add(rollData.getValueAsString());<br/>
        r.add(rollData.getDesc());<br/>
        r.add(diceRoll);<br/>
        if (diceRoll &lt; rollData.getValue()) {<br/>
            r.choose(false);<br/>
            addReport(r);<br/>
            doEntityFall( ae, rollData );<br/>
        } else {<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a club attack<br/>
     */<br/>
    private void resolveClubAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final ClubAttackAction caa = (ClubAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(caa.getEntityId());<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        final Targetable target = game.getTarget(caa.getTargetType(), caa.getTargetId());<br/>
        Entity te = null;<br/>
        if (target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = (Entity)target;<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, caa.getEntityId(), te);<br/>
        }<br/>
        final boolean targetInBuilding = Compute.isInBuilding( game, te );<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
        Report r;<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( target.getPosition() );<br/>
<br/>
        // restore club attack<br/>
        caa.getClub().restore();<br/>
<br/>
        if (lastEntityId != caa.getEntityId()) {<br/>
            //who is making the attacks<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4145);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(caa.getClub().getName());<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4075);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            if (((MiscType)(caa.getClub().getType())).hasSubType(MiscType.S_MACE_THB)) {<br/>
                game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a mace attack"));<br/>
            }<br/>
            if (((MiscType)(caa.getClub().getType())).hasSubType(MiscType.S_MACE)) {<br/>
                game.addPSR(new PilotingRollData(ae.getId(), 2, "missed a mace attack"));<br/>
            }<br/>
            return;<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            r = new Report(4080);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            roll = Integer.MAX_VALUE;<br/>
        } else {<br/>
            // report the roll<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
       }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            //miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            if (((MiscType)(caa.getClub().getType())).hasSubType(MiscType.S_MACE_THB)) {<br/>
                game.addPSR(new PilotingRollData(ae.getId(), 0, "missed a mace attack"));<br/>
            }<br/>
            if (((MiscType)(caa.getClub().getType())).hasSubType(MiscType.S_MACE)) {<br/>
                game.addPSR(new PilotingRollData(ae.getId(), 2, "missed a mace attack"));<br/>
            }<br/>
<br/>
            // If the target is in a building, the building absorbs the damage.<br/>
            if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
<br/>
                // Only report if damage was done to the building.<br/>
                if ( damage &gt; 0 ) {<br/>
                    Report buildingReport = damageBuilding( bldg, damage );<br/>
                    buildingReport.indent();<br/>
                    buildingReport.subject = ae.getId();<br/>
                    addReport(buildingReport);<br/>
                }<br/>
<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // Targeting a building.<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            r = new Report(4040);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
            // And we're done!<br/>
            return;<br/>
        }<br/>
<br/>
        HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
        r = new Report(4045);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getTableDesc());<br/>
        r.add(te.getLocationAbbr(hit));<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            int bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
            int toBldg = Math.min( bldgAbsorbs, damage );<br/>
            damage -= toBldg;<br/>
            addNewLines();<br/>
            Report buildingReport = damageBuilding( bldg, toBldg );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
        }<br/>
<br/>
        // A building may absorb the entire shot.<br/>
        if ( damage == 0 ) {<br/>
            r = new Report(4050);<br/>
            r.subject = ae.getId();<br/>
            r.add(te.getShortName());<br/>
            r.add(te.getOwner().getName());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
        } else {<br/>
            if (glancing) {<br/>
                damage = (int)Math.floor(damage/2.0);<br/>
            }<br/>
            addReport(damageEntity(te, hit, damage, false, 0, false, false, throughFront));<br/>
        }<br/>
<br/>
        addNewLines();<br/>
<br/>
        if (((MiscType)caa.getClub().getType()).hasSubType(MiscType.S_TREE_CLUB)) {<br/>
            //the club breaks<br/>
            r = new Report(4150);<br/>
            r.subject = ae.getId();<br/>
            r.add(caa.getClub().getName());<br/>
            addReport(r);<br/>
            ae.removeMisc(caa.getClub().getName());<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a push attack<br/>
     */<br/>
    private void resolvePushAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final PushAttackAction paa = (PushAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(paa.getEntityId());<br/>
        // PLEASE NOTE: buildings are *never* the target of a "push".<br/>
        final Entity te = game.getEntity(paa.getTargetId());<br/>
        // get roll and ToHitData from the PhysicalResult<br/>
        int roll = pr.roll;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        Report r;<br/>
<br/>
        // was this push resolved earlier?<br/>
        if (pr.pushBackResolved) {<br/>
            return;<br/>
        }<br/>
<br/>
        if (lastEntityId != paa.getEntityId()) {<br/>
            //who is making the attack<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        r = new Report(4155);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.addDesc(te);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            r = new Report(4160);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        // report the roll<br/>
        r = new Report(4025);<br/>
        r.subject = ae.getId();<br/>
        r.add(toHit.getValue());<br/>
        r.add(roll);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // check if our target has a push against us, too, and get it<br/>
        PhysicalResult targetPushResult = null;<br/>
        for (Enumeration i = physicalResults.elements(); i.hasMoreElements();) {<br/>
            PhysicalResult tpr = (PhysicalResult)i.nextElement();<br/>
            if (tpr.aaa.getEntityId() == te.getId() &amp;&amp;<br/>
                tpr.aaa instanceof PushAttackAction &amp;&amp;<br/>
                tpr.aaa.getTargetId() == ae.getId() ) {<br/>
                targetPushResult = tpr;<br/>
            }<br/>
        }<br/>
        // if our target has a push against us, we need to resolve both now<br/>
        if (targetPushResult != null) {<br/>
            // do both hit?<br/>
            if (targetPushResult.roll &gt;= targetPushResult.toHit.getValue() &amp;&amp;<br/>
                roll &gt;= toHit.getValue()) {<br/>
                r = new Report(4165);<br/>
                r.subject = ae.getId();<br/>
                r.addDesc(te);<br/>
                r.addDesc(te);<br/>
                r.addDesc(ae);<br/>
                r.add(toHit.getValue());<br/>
                r.add(roll);<br/>
                r.addDesc(ae);<br/>
                addReport(r);<br/>
                PilotingRollData targetPushPRD = new PilotingRollData(te.getId(), getKickPushPSRMod(ae, te, 0), "was pushed");<br/>
                targetPushPRD.setCumulative(false); // see Bug# 811987 for more info<br/>
                PilotingRollData pushPRD = new PilotingRollData(ae.getId(), getKickPushPSRMod(ae, te, 0), "was pushed");<br/>
                pushPRD.setCumulative(false); // see Bug# 811987 for more info<br/>
                game.addPSR(pushPRD);<br/>
                game.addPSR(targetPushPRD);<br/>
                targetPushResult.pushBackResolved = true;<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            //miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        // we hit...<br/>
        int direction = ae.getFacing();<br/>
<br/>
        Coords src = te.getPosition();<br/>
        Coords dest = src.translated(direction);<br/>
<br/>
        PilotingRollData pushPRD = new PilotingRollData(te.getId(), getKickPushPSRMod(ae, te, 0), "was pushed");<br/>
        pushPRD.setCumulative(false); // see Bug# 811987 for more info<br/>
<br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            r = new Report(4170);<br/>
            r.subject = ae.getId();<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (game.getBoard().contains(dest)) {<br/>
                r = new Report(4175);<br/>
                r.subject = ae.getId();<br/>
                r.add(dest.getBoardNum(), true);<br/>
                addReport(r);<br/>
            } else {<br/>
                //uh-oh, pushed off board<br/>
                r = new Report(4180);<br/>
                r.subject = ae.getId();<br/>
                addReport(r);<br/>
            }<br/>
<br/>
            doEntityDisplacement(te, src, dest, pushPRD);<br/>
<br/>
            // if push actually moved the target, attacker follows thru<br/>
            if (!te.getPosition().equals(src)) {<br/>
                ae.setPosition(src);<br/>
            }<br/>
        } else {<br/>
            //targe imovable<br/>
            r = new Report(4185);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            game.addPSR(pushPRD);<br/>
        }<br/>
<br/>
        addNewLines();<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a charge attack<br/>
     */<br/>
    private void resolveChargeAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final ChargeAttackAction caa = (ChargeAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(caa.getEntityId());<br/>
        final Targetable target = game.getTarget(caa.getTargetType(), caa.getTargetId());<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        Entity te = null;<br/>
        if (target != null &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            te = (Entity)target;<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, caa.getEntityId(), te);<br/>
        }<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
        Report r;<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( caa.getTargetPos() );<br/>
<br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
<br/>
        final int direction = ae.getFacing();<br/>
<br/>
        // entity isn't charging any more<br/>
        ae.setDisplacementAttack(null);<br/>
<br/>
        if (lastEntityId != caa.getEntityId()) {<br/>
            //who is making the attack<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // should we even bother?<br/>
        if (target == null || (target.getTargetType() == Targetable.TYPE_ENTITY<br/>
             &amp;&amp; (te.isDestroyed() || te.isDoomed() || te.crew.isDead()))) {<br/>
            r = new Report(4190);<br/>
            r.subject = ae.getId();<br/>
            r.indent();<br/>
            addReport(r);<br/>
            // doEntityDisplacement(ae, ae.getPosition(), caa.getTargetPos(), null);<br/>
            // Randall said that if a charge fails because of target destruction,<br/>
            // the attacker stays in the hex he was in at the end of the movement phase<br/>
            // See Bug 912094<br/>
            return;<br/>
        }<br/>
<br/>
        // attacker fell down?<br/>
        if (ae.isProne()) {<br/>
            r = new Report(4195);<br/>
            r.subject = ae.getId();<br/>
            r.indent();<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        // attacker immobile?<br/>
        if (ae.isImmobile()) {<br/>
            r = new Report(4200);<br/>
            r.subject = ae.getId();<br/>
            r.indent();<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        if (te.isProne()) {<br/>
            r = new Report(4205);<br/>
            r.subject = ae.getId();<br/>
            r.indent();<br/>
            addReport(r);<br/>
            return;<br/>
        }<br/>
<br/>
        r = new Report(4210);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // target still in the same position?<br/>
        if (!target.getPosition().equals(caa.getTargetPos())) {<br/>
            r = new Report(4215);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            doEntityDisplacement(ae, ae.getPosition(), caa.getTargetPos(), null);<br/>
            return;<br/>
        }<br/>
<br/>
        // if the attacker's prone, fudge the roll<br/>
        if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            roll = -12;<br/>
            r = new Report(4220);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            roll = Integer.MAX_VALUE;<br/>
            r = new Report(4225);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
        } else {<br/>
            // report the roll<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
       }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords src = ae.getPosition();<br/>
            Coords dest = Compute.getMissedChargeDisplacement(game, ae.getId(), src, direction);<br/>
<br/>
            // TODO: handle movement into/out of/through a building.  Do it here?<br/>
<br/>
            //miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            // move attacker to side hex<br/>
            doEntityDisplacement(ae, src, dest, null);<br/>
        }<br/>
<br/>
        // Targeting a building.<br/>
        else if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            r = new Report(4040);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
            // Apply damage to the attacker.<br/>
            int toAttacker = ChargeAttackAction.getDamageTakenBy( ae, bldg );<br/>
            HitData hit = ae.rollHitLocation( ToHitData.HIT_NORMAL,<br/>
                                              ae.sideTable(target.getPosition())<br/>
                                                  );<br/>
            addReport(<br/>
                                  damageEntity( ae, hit, toAttacker, false, 0, false, false, throughFront));<br/>
            addNewLines();<br/>
            entityUpdate( ae.getId() );<br/>
<br/>
            // TODO: Does the attacker enter the building?<br/>
            // TODO: What if the building collapses?<br/>
        }<br/>
        else {<br/>
            // Resolve the damage.<br/>
            resolveChargeDamage( ae, te, toHit, direction, glancing, throughFront );<br/>
        }<br/>
        return;<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a charge's damage<br/>
     */<br/>
    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit, int direction) {<br/>
        resolveChargeDamage (ae, te, toHit, direction, false, true);<br/>
    }<br/>
<br/>
    private void resolveChargeDamage(Entity ae, Entity te, ToHitData toHit, int direction, boolean glancing, boolean throughFront) {<br/>
<br/>
        // we hit...<br/>
        int damage = ChargeAttackAction.getDamageFor(ae);<br/>
        int damageTaken = ChargeAttackAction.getDamageTakenBy(ae, te, game.getOptions().booleanOption("maxtech_charge_damage"));<br/>
        PilotingRollData chargePSR = null;<br/>
        if (glancing) {<br/>
            // Glancing Blow rule doesn't state whether damage to attacker on charge<br/>
            // or DFA is halved as well, assume yes. TODO: Check with PM<br/>
            damage = (int)Math.floor(damage/2.0);<br/>
            damageTaken = (int)Math.floor(damageTaken/2.0);<br/>
        }<br/>
        // Is the target inside a building?<br/>
        final boolean targetInBuilding = Compute.isInBuilding( game, te );<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( te.getPosition() );<br/>
<br/>
        // The building shields all units from a certain amount of damage.<br/>
        // The amount is based upon the building's CF at the phase's start.<br/>
        int bldgAbsorbs = 0;<br/>
        if ( targetInBuilding &amp;&amp; bldg != null ) {<br/>
            bldgAbsorbs = (int) Math.ceil( bldg.getPhaseCF() / 10.0 );<br/>
        }<br/>
<br/>
        // If we're upright, we may fall down.<br/>
        if ( !ae.isProne() ) {<br/>
            chargePSR = new PilotingRollData(ae.getId(), 2, "charging");<br/>
        }<br/>
<br/>
        Report r;<br/>
<br/>
<br/>
        r = new Report(4230);<br/>
        r.subject = ae.getId();<br/>
        r.add(damage);<br/>
        r.add(toHit.getTableDesc());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            damage -= cluster;<br/>
            if ( bldgAbsorbs &gt; 0 ) {<br/>
                int toBldg = Math.min( bldgAbsorbs, cluster );<br/>
                cluster -= toBldg;<br/>
                addNewLines();<br/>
                Report buildingReport = damageBuilding( bldg, toBldg );<br/>
                buildingReport.indent();<br/>
                buildingReport.subject = ae.getId();<br/>
                addReport(buildingReport);<br/>
            }<br/>
<br/>
            // A building may absorb the entire shot.<br/>
            if ( cluster == 0 ) {<br/>
                r = new Report(4235);<br/>
                r.subject = ae.getId();<br/>
                r.addDesc(te);<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            } else {<br/>
                HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
                addReport(<br/>
                                      damageEntity(te, hit, cluster, false, 0, false, false, throughFront));<br/>
            }<br/>
        }<br/>
<br/>
        //damage to attacker<br/>
        r = new Report(4240);<br/>
        r.subject = ae.getId();<br/>
        r.add(damageTaken);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = ae.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT);<br/>
            addReport(<br/>
                                      damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
        // move attacker and target, if possible<br/>
        Coords src = te.getPosition();<br/>
        Coords dest = src.translated(direction);<br/>
<br/>
        if (Compute.isValidDisplacement(game, te.getId(), te.getPosition(), direction)) {<br/>
            addNewLines();<br/>
            doEntityDisplacement(te, src, dest, new PilotingRollData(te.getId(), 2, "was charged"));<br/>
            doEntityDisplacement(ae, ae.getPosition(), src, chargePSR);<br/>
        }<br/>
<br/>
        addNewLines();<br/>
<br/>
    } // End private void resolveChargeDamage( Entity, Entity, ToHitData )<br/>
<br/>
    private void resolveLayExplosivesAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final LayExplosivesAttackAction laa = (LayExplosivesAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(laa.getEntityId());<br/>
        final Targetable target = game.getTarget(laa.getTargetType(), laa.getTargetId());<br/>
        if(ae instanceof Infantry) {<br/>
            Infantry inf = (Infantry) ae;<br/>
            if(inf.turnsLayingExplosives &lt; 0) {<br/>
                inf.turnsLayingExplosives = 0;<br/>
                Report r = new Report(4270);<br/>
                r.subject = inf.getId();<br/>
                r.addDesc(inf);<br/>
                addReport(r);<br/>
            } else {<br/>
                Building building = game.getBoard().getBuildingAt(ae.getPosition());<br/>
                if(building != null) {<br/>
                    building.addDemolitionCharge(ae.getOwner().getId(), pr.damage);<br/>
                    Report r = new Report(4275);<br/>
                    r.subject = inf.getId();<br/>
                    r.addDesc(inf);<br/>
                    r.add(pr.damage);<br/>
                    addReport(r);<br/>
                }<br/>
                inf.turnsLayingExplosives = -1;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Handle a death from above attack<br/>
     */<br/>
    private void resolveDfaAttack(PhysicalResult pr, int lastEntityId) {<br/>
        final DfaAttackAction daa = (DfaAttackAction)pr.aaa;<br/>
        final Entity ae = game.getEntity(daa.getEntityId());<br/>
        final Targetable target = game.getTarget(daa.getTargetType(), daa.getTargetId());<br/>
        // get damage, ToHitData and roll from the PhysicalResult<br/>
        int damage = pr.damage;<br/>
        final ToHitData toHit = pr.toHit;<br/>
        int roll = pr.roll;<br/>
        Entity te = null;<br/>
        if (target != null &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY) {<br/>
            // Lets re-write around that horrible hack that was here before.<br/>
            // So instead of asking if a specific location is wet and praying<br/>
            // that it won't cause an NPE...<br/>
            // We'll check 1) if the hex has water, and 2) if it's deep enough<br/>
            // to cover the unit in question at its current elevation.<br/>
            // It's especially important to make sure it's done this way,<br/>
            // because some units (Sylph, submarines) can be at ANY elevation<br/>
            // underwater, and VTOLs can be well above the surface.<br/>
            te = (Entity)target;<br/>
            IHex hex = game.getBoard().getHex(te.getPosition());<br/>
            if (hex.containsTerrain(Terrains.WATER)) {<br/>
                if (te.absHeight() &lt; hex.getElevation())<br/>
                    damage = (int)Math.ceil(damage * 0.5f);<br/>
            }<br/>
        }<br/>
        boolean throughFront = true;<br/>
        if (te!=null) {<br/>
            throughFront = Compute.isThroughFrontHex(game, daa.getEntityId(), te);<br/>
        }<br/>
        final boolean glancing = (game.getOptions().booleanOption("maxtech_glancing_blows") &amp;&amp; (roll == toHit.getValue()));<br/>
        Report r;<br/>
<br/>
        // Which building takes the damage?<br/>
        Building bldg = game.getBoard().getBuildingAt( daa.getTargetPos() );<br/>
<br/>
        // is the attacker dead?  because that sure messes up the calculations<br/>
        if (ae == null) {<br/>
            return;<br/>
        }<br/>
<br/>
        final int direction = ae.getFacing();<br/>
<br/>
        if (lastEntityId != daa.getEntityId()) {<br/>
            //who is making the attack<br/>
            r = new Report(4005);<br/>
            r.subject = ae.getId();<br/>
            r.addDesc(ae);<br/>
            addReport(r);<br/>
        }<br/>
<br/>
        // entity isn't DFAing any more<br/>
        ae.setDisplacementAttack(null);<br/>
<br/>
        // should we even bother?<br/>
        if (target == null || (target.getTargetType() == Targetable.TYPE_ENTITY<br/>
             &amp;&amp; (te.isDestroyed() || te.isDoomed() || te.crew.isDead()))) {<br/>
            r = new Report(4245);<br/>
            r.subject = ae.getId();<br/>
            r.indent();<br/>
            addReport(r);<br/>
            if (ae.isProne()) {<br/>
                // attacker prone during weapons phase<br/>
                doEntityFall(ae, daa.getTargetPos(), 2, 3, ae.getBasePilotingRoll());<br/>
<br/>
            } else {<br/>
                // same effect as successful DFA<br/>
                doEntityDisplacement(ae, ae.getPosition(), daa.getTargetPos(), new PilotingRollData(ae.getId(), 4, "executed death from above"));<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        r = new Report(4246);<br/>
        r.subject = ae.getId();<br/>
        r.indent();<br/>
        r.add(target.getDisplayName());<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
<br/>
        // target still in the same position?<br/>
        if ( !target.getPosition().equals(daa.getTargetPos()) ) {<br/>
            r = new Report(4215);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            doEntityFallsInto(ae, ae.getPosition(), daa.getTargetPos(), ae.getBasePilotingRoll());<br/>
            return;<br/>
        }<br/>
<br/>
        // hack: if the attacker's prone, or incapacitated, fudge the roll<br/>
        if (ae.isProne() || !ae.isActive()) {<br/>
            roll = -12;<br/>
            r = new Report(4250);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
        } else if (toHit.getValue() == ToHitData.IMPOSSIBLE) {<br/>
            roll = -12;<br/>
            r = new Report(4255);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
        } else if (toHit.getValue() == ToHitData.AUTOMATIC_SUCCESS) {<br/>
            r = new Report(4260);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getDesc());<br/>
            addReport(r);<br/>
            roll = Integer.MAX_VALUE;<br/>
        } else {<br/>
            // report the roll<br/>
            r = new Report(4025);<br/>
            r.subject = ae.getId();<br/>
            r.add(toHit.getValue());<br/>
            r.add(roll);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if (glancing) {<br/>
                r = new Report(4030);<br/>
                r.subject = ae.getId();<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
<br/>
        // do we hit?<br/>
        if (roll &lt; toHit.getValue()) {<br/>
            Coords dest = te.getPosition();<br/>
            Coords targetDest = Compute.getPreferredDisplacement(game, te.getId(), dest, direction);<br/>
            //miss<br/>
            r = new Report(4035);<br/>
            r.subject = ae.getId();<br/>
            addReport(r);<br/>
            if (targetDest != null) {<br/>
                // attacker falls into destination hex<br/>
                r = new Report(4265);<br/>
                r.subject = ae.getId();<br/>
                r.addDesc(ae);<br/>
                r.add(dest.getBoardNum(), true);<br/>
                addReport(r);<br/>
                doEntityFall(ae, dest, 2, 3, ae.getBasePilotingRoll());<br/>
<br/>
                // move target to preferred hex<br/>
                doEntityDisplacement(te, dest, targetDest, null);<br/>
            } else {<br/>
                // attacker destroyed  Tanks<br/>
                // suffer an ammo/power plant hit.<br/>
                // TODO : a Mech suffers a Head Blown Off crit.<br/>
                addReport(<br/>
                                      destroyEntity(ae, "impossible displacement", (ae instanceof Mech), (ae instanceof Mech)));<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // we hit...<br/>
        // Can't DFA a target inside of a building.<br/>
        int damageTaken = DfaAttackAction.getDamageTakenBy(ae);<br/>
<br/>
        r = new Report(4040);<br/>
        r.subject = ae.getId();<br/>
        addReport(r);<br/>
<br/>
        // Targeting a building.<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
<br/>
            // The building takes the full brunt of the attack.<br/>
            Report buildingReport = damageBuilding( bldg, damage );<br/>
            buildingReport.indent();<br/>
            buildingReport.subject = ae.getId();<br/>
            addReport(buildingReport);<br/>
<br/>
            // Damage any infantry in the hex.<br/>
            this.damageInfantryIn( bldg, damage );<br/>
<br/>
        }<br/>
<br/>
        // Target isn't building.<br/>
        else {<br/>
            if (glancing) {<br/>
                damage = (int)Math.floor(damage/2.0);<br/>
            }<br/>
            //damage target<br/>
            r = new Report(4230);<br/>
            r.subject = ae.getId();<br/>
            r.add(damage);<br/>
            r.add(toHit.getTableDesc());<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            while (damage &gt; 0) {<br/>
                int cluster = Math.min(5, damage);<br/>
                HitData hit = te.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
                addReport(<br/>
                                      damageEntity(te, hit, cluster, false, 0, false, false, throughFront));<br/>
                damage -= cluster;<br/>
            }<br/>
        }<br/>
<br/>
        if (glancing) {<br/>
            // Glancing Blow rule doesn't state whether damage to attacker on charge<br/>
            // or DFA is halved as well, assume yes. TODO: Check with PM<br/>
            damageTaken = (int)Math.floor(damageTaken/2.0);<br/>
        }<br/>
<br/>
        //damage attacker<br/>
        r = new Report(4240);<br/>
        r.subject = ae.getId();<br/>
        r.add(damageTaken);<br/>
        r.newlines = 0;<br/>
        addReport(r);<br/>
        while (damageTaken &gt; 0) {<br/>
            int cluster = Math.min(5, damageTaken);<br/>
            HitData hit = ae.rollHitLocation(ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);<br/>
            addReport(<br/>
                                      damageEntity(ae, hit, cluster));<br/>
            damageTaken -= cluster;<br/>
        }<br/>
<br/>
        addNewLines();<br/>
<br/>
        // That's it for target buildings.<br/>
        // TODO: where do I put the attacker?!?<br/>
        if ( target.getTargetType() == Targetable.TYPE_BUILDING ) {<br/>
            return;<br/>
        }<br/>
<br/>
        // Target entities are pushed away or destroyed.<br/>
        Coords dest = te.getPosition();<br/>
        Coords targetDest = Compute.getValidDisplacement(game, te.getId(), dest, direction);<br/>
        if (targetDest != null) {<br/>
            doEntityDisplacement(te, dest, targetDest, new PilotingRollData(te.getId(), 2, "hit by death from above"));<br/>
        } else {<br/>
            // ack!  automatic death!  Tanks<br/>
            // suffer an ammo/power plant hit.<br/>
            // TODO : a Mech suffers a Head Blown Off crit.<br/>
            addReport(destroyEntity(te, "impossible displacement", (te instanceof Mech), (te instanceof Mech)));<br/>
        }<br/>
        // HACK: to avoid automatic falls, displace from dest to dest<br/>
        doEntityDisplacement(ae, dest, dest, new PilotingRollData(ae.getId(), 4, "executed death from above"));<br/>
    }<br/>
<br/>
    /**<br/>
     * Get the modifier for a Kick or Push PSR<br/>
     * @param attacker The attacking &lt;code&gt;Entity&gt;&lt;/code&gt;<br/>
     * @param target   The target &lt;code&gt;Entity&lt;/code&gt;<br/>
     * @param def      The &lt;code&gt;int&lt;/code&gt; default modifier <br/>
     * @return         The &lt;code&gt;int&lt;/code&gt; modifier to the PSR <br/>
     */<br/>
    private int getKickPushPSRMod(Entity attacker, Entity target, int def) {<br/>
        int mod = def;<br/>
        <br/>
        if ( game.getOptions().booleanOption("maxtech_physical_psr") ) {<br/>
            int attackerMod = 0;<br/>
            int targetMod = 0;<br/>
            <br/>
            switch ( attacker.getWeightClass() ) {<br/>
            case EntityWeightClass.WEIGHT_LIGHT:<br/>
                attackerMod = 1;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_MEDIUM:<br/>
                attackerMod = 2;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_HEAVY:<br/>
                attackerMod = 3;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_ASSAULT:<br/>
                attackerMod = 4;<br/>
                break;<br/>
            }<br/>
            switch ( target.getWeightClass() ) {<br/>
            case EntityWeightClass.WEIGHT_LIGHT:<br/>
                targetMod = 1;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_MEDIUM:<br/>
                targetMod = 2;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_HEAVY:<br/>
                targetMod = 3;<br/>
                break;<br/>
            case EntityWeightClass.WEIGHT_ASSAULT:<br/>
                targetMod = 4;<br/>
                break;<br/>
            }<br/>
            mod = attackerMod - targetMod;<br/>
        }<br/>
        return mod;<br/>
    }<br/>
<br/>
    /**<br/>
     * Each mech sinks the amount of heat appropriate to its current heat<br/>
     * capacity.<br/>
     */<br/>
    private void resolveHeat() {<br/>
        Report r;<br/>
        //Heat phase header<br/>
        addReport(new Report(5000, Report.PUBLIC));<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ) {<br/>
                continue;<br/>
            }<br/>
            IHex entityHex = game.getBoard().getHex(entity.getPosition());<br/>
<br/>
            // heat doesn't matter for non-mechs<br/>
            if (!(entity instanceof Mech)) {<br/>
                entity.heatBuildup = 0;<br/>
<br/>
                if(game.getOptions().booleanOption("vehicle_fires")<br/>
                        &amp;&amp; entity instanceof Tank) {<br/>
                    resolveVehicleFire((Tank)entity, true);<br/>
                }<br/>
                // If the unit is hit with an Inferno, do flaming death test.<br/>
                else if ( entity.infernos.isStillBurning()) {<br/>
                    doFlamingDeath(entity);<br/>
                }<br/>
                continue;<br/>
            }<br/>
            else {<br/>
                // Meks gain heat from inferno hits.<br/>
                if ( entity.infernos.isStillBurning() ) {<br/>
                    int infernoHeat = entity.infernos.getHeat();<br/>
                    entity.heatBuildup += infernoHeat;<br/>
                    r = new Report(5010);<br/>
                    r.subject = entity.getId();<br/>
                    r.add(infernoHeat);<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            // should we even bother?<br/>
            if ( entity.isDestroyed() || entity.isDoomed() ||<br/>
                 entity.crew.isDoomed() || entity.crew.isDead() ) {<br/>
                continue;<br/>
            }<br/>
<br/>
            // engine hits add a lot of heat, provided the engine is on<br/>
            entity.heatBuildup += entity.getEngineCritHeat();<br/>
<br/>
            // If a Mek had an active Stealth suite, add 10 heat.<br/>
            if ( entity instanceof Mech &amp;&amp; entity.isStealthActive() ) {<br/>
                entity.heatBuildup += 10;<br/>
                r = new Report(5015);<br/>
                r.subject = entity.getId();<br/>
                addReport(r);<br/>
            }<br/>
<br/>
            // If a Mek is in extreme Temperatures, add or subtract one<br/>
            // heat per 10 degrees (or fraction of 10 degrees) above or<br/>
            // below 50 or -30 degrees Celsius<br/>
            if ( entity instanceof Mech &amp;&amp; game.getTemperatureDifference() != 0<br/>
                 &amp;&amp; !((Mech)entity).hasLaserHeatSinks()) {<br/>
                if (game.getOptions().intOption("temperature") &gt; 50) {<br/>
                    entity.heatBuildup += game.getTemperatureDifference();<br/>
                    r = new Report(5020);<br/>
                    r.subject = entity.getId();<br/>
                    r.add(game.getTemperatureDifference());<br/>
                    addReport(r);<br/>
                }<br/>
                else {<br/>
                    entity.heatBuildup -= game.getTemperatureDifference();<br/>
                    r = new Report(5025);<br/>
                    r.subject = entity.getId();<br/>
                    r.add(game.getTemperatureDifference());<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            // Add +5 Heat if the hex you're in is on fire<br/>
            // and was on fire for the full round.<br/>
            if (entityHex != null) {<br/>
                if (entityHex.terrainLevel(Terrains.FIRE) == 2) {<br/>
                    entity.heatBuildup += 5;<br/>
                    r = new Report(5030);<br/>
                    r.subject = entity.getId();<br/>
                    addReport(r);<br/>
                }<br/>
                int magma = entityHex.terrainLevel(Terrains.MAGMA);<br/>
                if(magma &gt; 0) {<br/>
                    entity.heatBuildup += 5 * magma;<br/>
                    r = new Report(5032);<br/>
                    r.subject = entity.getId();<br/>
                    r.add(5 * magma);<br/>
                    addReport(r);                    <br/>
                }<br/>
            }<br/>
            <br/>
            // if heatbuildup is negative due to temperature, set it to 0<br/>
            // for prettier turnreports<br/>
            if (entity.heatBuildup &lt; 0) {<br/>
                entity.heatBuildup = 0;<br/>
            }<br/>
<br/>
            // add the heat we've built up so far.<br/>
            entity.heat += entity.heatBuildup;<br/>
<br/>
            // how much heat can we sink?<br/>
            int tosink = entity.getHeatCapacityWithWater();<br/>
<br/>
            // should we use a coolant pod?<br/>
            int safeHeat = entity.hasInfernoAmmo() ? 9 : 13;<br/>
            int possibleSinkage = ((Mech)entity).getNumberOfSinks();<br/>
            for(Enumeration equip=entity.getEquipment();equip.hasMoreElements();) {<br/>
                Mounted m = (Mounted)equip.nextElement();<br/>
                if(m.getType() instanceof AmmoType) {<br/>
                    AmmoType at = (AmmoType)(m.getType());<br/>
                    if(at.getAmmoType() == AmmoType.T_COOLANT_POD &amp;&amp; m.isAmmoUsable()) {<br/>
                        EquipmentMode mode = m.curMode();<br/>
                        if(mode.equals("dump")) {<br/>
                            r = new Report(5260);<br/>
                            r.subject = entity.getId();<br/>
                            addReport(r);<br/>
                            m.setShotsLeft(0);<br/>
                            tosink += possibleSinkage;<br/>
                            break;<br/>
                        }<br/>
                        if(mode.equals("safe") &amp;&amp; entity.heat - tosink &gt; safeHeat) {<br/>
                            r = new Report(5265);<br/>
                            r.subject = entity.getId();<br/>
                            addReport(r);<br/>
                            m.setShotsLeft(0);<br/>
                            tosink += possibleSinkage;<br/>
                            break;<br/>
                        }<br/>
                        if(mode.equals("efficient") &amp;&amp; entity.heat - tosink &gt;= possibleSinkage) {<br/>
                            r = new Report(5270);<br/>
                            r.subject = entity.getId();<br/>
                            addReport(r);<br/>
                            m.setShotsLeft(0);<br/>
                            tosink += possibleSinkage;<br/>
                            break;<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            tosink = Math.min( tosink, entity.heat );<br/>
            entity.heat -= tosink;<br/>
            r = new Report(5035);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(entity.heatBuildup);<br/>
            r.add(tosink);<br/>
            r.add(entity.heat);<br/>
            addReport(r);<br/>
            entity.heatBuildup = 0;<br/>
<br/>
            // Does the unit have inferno ammo?<br/>
            if( entity.hasInfernoAmmo() ) {<br/>
<br/>
                // Roll for possible inferno ammo explosion.<br/>
                if (entity.heat &gt;= 10) {<br/>
                    int boom = 4 + (entity.heat &gt;= 14 ? 2 : 0) +<br/>
                        (entity.heat &gt;= 19 ? 2 : 0) +<br/>
                        (entity.heat &gt;= 23 ? 2 : 0) +<br/>
                        (entity.heat &gt;= 28 ? 2 : 0);<br/>
                    int boomroll = Compute.d6(2);<br/>
                    r = new Report(5040);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(boom);<br/>
                    r.add(boomroll);<br/>
<br/>
                    if (boomroll &gt;= boom) {<br/>
                        //avoided<br/>
                        r.choose(true);<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        r.choose(false);<br/>
                        addReport(r);<br/>
                        addReport( explodeInfernoAmmoFromHeat(entity));<br/>
                    }<br/>
                }<br/>
            } // End avoid-inferno-explosion<br/>
            int autoShutDownHeat;<br/>
            boolean mtHeat;<br/>
            <br/>
            if (game.getOptions().booleanOption("maxtech_heat")) {<br/>
                autoShutDownHeat = 50;<br/>
                mtHeat = true;<br/>
            } else {<br/>
                autoShutDownHeat = 30;<br/>
                mtHeat = false;<br/>
            }<br/>
            // heat effects: start up<br/>
            if (entity.heat &lt; autoShutDownHeat &amp;&amp; entity.isShutDown()) {<br/>
                if (entity.heat &lt; 14) {<br/>
                    //automatically starts up again<br/>
                    entity.setShutDown(false);<br/>
                    r = new Report(5045);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    addReport(r);<br/>
                } else {<br/>
                    //roll for startup<br/>
                    int startup = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    if (mtHeat) {<br/>
                        startup = entity.crew.getPiloting() + startup - 8;<br/>
                    }<br/>
                    int suroll = Compute.d6(2);<br/>
                    r = new Report(5050);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(startup);<br/>
                    r.add(suroll);<br/>
                    if (suroll &gt;= startup) {<br/>
                        //start 'er back up<br/>
                        entity.setShutDown(false);<br/>
                        r.choose(true);<br/>
                    } else {<br/>
                        r.choose(false);<br/>
                    }<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: shutdown!<br/>
            // 2003-01-26 JAD - Don't shut down if you just restarted.<br/>
            else if (entity.heat &gt;= 14 &amp;&amp; !entity.isShutDown()) {<br/>
                if (entity.heat &gt;= autoShutDownHeat) {<br/>
                    r = new Report(5055);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    addReport(r);<br/>
                    // add a piloting roll and resolve immediately<br/>
                    game.addPSR(new PilotingRollData<br/>
                        ( entity.getId(), 3, "reactor shutdown" ));<br/>
                    resolvePilotingRolls();<br/>
                    // okay, now mark shut down<br/>
                    entity.setShutDown(true);<br/>
                } else if (entity.heat &gt;= 14) {<br/>
                    int shutdown = 4 + (((entity.heat - 14) / 4) * 2);<br/>
                    if (mtHeat) {<br/>
                        shutdown = entity.crew.getPiloting() + shutdown - 8;<br/>
                    }<br/>
                    int sdroll = Compute.d6(2);<br/>
                    r = new Report(5060);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(shutdown);<br/>
                    r.add(sdroll);<br/>
                    if (sdroll &gt;= shutdown) {<br/>
                        //avoided<br/>
                        r.choose(true);<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        //shutting down...<br/>
                        r.choose(false);<br/>
                        addReport(r);<br/>
                        // add a piloting roll and resolve immediately<br/>
                        game.addPSR(new PilotingRollData<br/>
                            ( entity.getId(), 3, "reactor shutdown" ));<br/>
                        resolvePilotingRolls();<br/>
                        // okay, now mark shut down<br/>
                        entity.setShutDown(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: ammo explosion!<br/>
            if (entity.heat &gt;= 19) {<br/>
                int boom = 4 + (entity.heat &gt;= 23 ? 2 : 0) +<br/>
                    (entity.heat &gt;= 28 ? 2 : 0);<br/>
                if (mtHeat) {<br/>
                    boom += <br/>
                        (entity.heat &gt;= 35 ? 2 : 0) +<br/>
                        (entity.heat &gt;= 40 ? 2 : 0) +<br/>
                        (entity.heat &gt;= 45 ? 2 : 0);<br/>
                    // Last line is a crutch; 45 heat should be no roll<br/>
                    // but automatic explosion.<br/>
                }<br/>
                if(entity instanceof Mech &amp;&amp; ((Mech)entity).hasLaserHeatSinks())<br/>
                    boom--;<br/>
                int boomroll = Compute.d6(2);<br/>
                r = new Report(5065);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(boom);<br/>
                r.add(boomroll);<br/>
                if (boomroll &gt;= boom) {<br/>
                    //mech is ok<br/>
                    r.choose(true);<br/>
                    addReport(r);<br/>
                } else {<br/>
                    //boom!<br/>
                    r.choose(false);<br/>
                    addReport(r);<br/>
                    addReport( explodeAmmoFromHeat(entity));<br/>
                }<br/>
            }<br/>
<br/>
            // heat effects: mechwarrior damage<br/>
            // N.B. The pilot may already be dead.<br/>
            int lifeSupportCritCount = 0;<br/>
            boolean torsoMountedCockpit = ((Mech)entity).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED;<br/>
            if ((entity instanceof Mech)<br/>
                    &amp;&amp; torsoMountedCockpit) {<br/>
                lifeSupportCritCount = entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                    Mech.SYSTEM_LIFE_SUPPORT,<br/>
                    Mech.LOC_RT);<br/>
                lifeSupportCritCount += entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                    Mech.SYSTEM_LIFE_SUPPORT,<br/>
                    Mech.LOC_LT);<br/>
            } else {<br/>
                lifeSupportCritCount = entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                        Mech.SYSTEM_LIFE_SUPPORT,<br/>
                        Mech.LOC_HEAD);<br/>
            }<br/>
            if (lifeSupportCritCount &gt; 0<br/>
                    &amp;&amp; ((entity.heat &gt;= 15) || (torsoMountedCockpit &amp;&amp; (entity.heat &gt;= 0)))<br/>
                    &amp;&amp; !entity.crew.isDead() &amp;&amp; !entity.crew.isDoomed()<br/>
                    &amp;&amp; !entity.crew.isEjected()) {<br/>
                int heatLimitDesc = 1;<br/>
                int damageToCrew = 0;<br/>
                if (entity.heat &gt;= 47 &amp;&amp; mtHeat) {<br/>
                    // mechwarrior takes 5 damage<br/>
                    heatLimitDesc = 47;<br/>
                    damageToCrew = 5;<br/>
                } else if (entity.heat &gt;= 39 &amp;&amp; mtHeat) {<br/>
                    // mechwarrior takes 4 damage<br/>
                    heatLimitDesc = 39;<br/>
                    damageToCrew = 4;<br/>
                } else if (entity.heat &gt;= 32 &amp;&amp; mtHeat) {<br/>
                    // mechwarrior takes 3 damage<br/>
                    heatLimitDesc = 32;<br/>
                    damageToCrew = 3;<br/>
                } else if (entity.heat &gt;= 25) {<br/>
                    // mechwarrior takes 2 damage<br/>
                    heatLimitDesc = 25;<br/>
                    damageToCrew = 2;<br/>
                } else if (entity.heat &gt;= 15) {<br/>
                    // mechwarrior takes 1 damage<br/>
                    heatLimitDesc = 15;<br/>
                    damageToCrew = 1;<br/>
                }<br/>
                if (entity.heat &gt; 0<br/>
                        &amp;&amp; (entity instanceof Mech)<br/>
                        &amp;&amp; ((Mech)entity).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED)<br/>
                    damageToCrew += 1;<br/>
                r = new Report(5070);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(heatLimitDesc);<br/>
                r.add(damageToCrew);<br/>
                addReport(r);<br/>
                damageCrew(entity, damageToCrew);<br/>
            } else if (mtHeat &amp;&amp; entity.heat &gt;= 32<br/>
                       &amp;&amp; !entity.crew.isDead() &amp;&amp; !entity.crew.isDoomed() ) {<br/>
                // Pilot may take damage from heat if MaxTech option is set<br/>
                int heatroll = Compute.d6(2);<br/>
                int avoidNumber = -1;<br/>
                if (entity.heat &gt;= 47) {<br/>
                    avoidNumber = 12;<br/>
                } else if (entity.heat &gt;= 39) {<br/>
                    avoidNumber = 10;<br/>
                } else if (entity.heat &gt;= 32) {<br/>
                    avoidNumber = 8;<br/>
                }<br/>
                r = new Report(5075);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.add(avoidNumber);<br/>
                r.add(heatroll);<br/>
                if (heatroll &gt;= avoidNumber) {<br/>
                    //damage avoided<br/>
                    r.choose(true);<br/>
                } else {<br/>
                    damageCrew(entity, 1);<br/>
                    r.choose(false);<br/>
                }<br/>
                addReport(r);<br/>
            }<br/>
<br/>
            // The pilot may have just expired.<br/>
            if ( (entity.crew.isDead() || entity.crew.isDoomed() )<br/>
                 &amp;&amp; !entity.crew.isEjected() ) {<br/>
                r = new Report(5080);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.newlines = 0;<br/>
                addReport(r);<br/>
                addReport( destroyEntity(entity, "crew death", true));<br/>
            }<br/>
<br/>
            // With MaxTech Heat Scale, there may occur critical damage<br/>
            if (mtHeat) {<br/>
                if (entity.heat &gt;= 36) {<br/>
                    int damageroll = Compute.d6(2);<br/>
                    int damageNumber = -1;<br/>
                    if (entity.heat &gt;= 44) {<br/>
                        damageNumber = 10;<br/>
                    } else if (entity.heat &gt;= 36) {<br/>
                        damageNumber = 8;<br/>
                    }<br/>
                    r = new Report(5085);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(damageNumber);<br/>
                    r.add(damageroll);<br/>
                    r.newlines = 0;<br/>
                    if (damageroll &gt;= damageNumber) {<br/>
                        r.choose(true);<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        r.choose(false);<br/>
                        addReport(r);<br/>
                        addReport(oneCriticalEntity(entity, Compute.d6(2)));<br/>
                        //add an empty report, for linebreaking<br/>
                        r = new Report(1210);<br/>
                        addReport(r);<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        if (vPhaseReport.size() == 1) {<br/>
            //I guess nothing happened...<br/>
            addReport(new Report(1205, Report.PUBLIC));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * check to see if unarmored infantry is outside in extreme temperatures<br/>
     * (crude fix because infantry shouldn't be able to be deployed<br/>
     * outside of vehicles or buildings, but we can't do that because<br/>
     * we don't know wether the map has buildings or not or wether the<br/>
     * player has an apc<br/>
     */<br/>
    private void resolveExtremeTempInfantryDeath() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ) {<br/>
                continue;<br/>
            }<br/>
            IHex entityHex = game.getBoard().getHex(entity.getPosition());<br/>
            if (entity instanceof Infantry &amp;&amp;<br/>
                    !(entity instanceof BattleArmor) &amp;&amp;<br/>
                    game.getTemperatureDifference() &gt; 0 &amp;&amp;<br/>
                    !(entityHex.containsTerrain(Terrains.BUILDING)) &amp;&amp; <br/>
                    (entity.getTransportId() == Entity.NONE) ) {<br/>
                Report r = new Report(5090);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                addReport(destroyEntity(entity, "heat/cold", false, false));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolve Flaming Death for the given Entity<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; that may experience flaming death.<br/>
     */<br/>
    private void doFlamingDeath(Entity entity) {<br/>
        Report r;<br/>
        int boomroll = Compute.d6(2);<br/>
        // Infantry are unaffected by fire while they're still swarming.<br/>
        if ( Entity.NONE != entity.getSwarmTargetId() ) {<br/>
            return;<br/>
        }<br/>
        if (entity.getMovementMode() == IEntityMovementMode.VTOL<br/>
                &amp;&amp; !(entity.infernos.isStillBurning())) {<br/>
            // VTOLs don't check as long as they are flying higher than<br/>
            // the burning terrain. TODO: Check for rules conformity (ATPM?)<br/>
            // according to maxtech, elevation 0 or 1 should be affected,<br/>
            // this makes sense for level 2 as well<br/>
            Coords c = entity.getPosition();<br/>
            IHex h = game.getBoard().getHex(c.x, c.y);<br/>
            if (entity.getElevation() &gt; 1) {<br/>
                return;<br/>
            }<br/>
        }<br/>
        // Battle Armor squads equipped with fire protection<br/>
        // gear automatically avoid flaming death.<br/>
        for ( Enumeration iter = entity.getMisc(); iter.hasMoreElements(); ) {<br/>
            Mounted mount = (Mounted) iter.nextElement();<br/>
            EquipmentType equip = mount.getType();<br/>
            if ( BattleArmor.FIRE_PROTECTION.equals(equip.getInternalName()) ) {<br/>
                r = new Report(5095);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        //Must roll 8+ to survive...<br/>
        r = new Report(5100);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        r.add(boomroll);<br/>
        if (boomroll &gt;= 8) {<br/>
            //phew!<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
        } else {<br/>
            //eek<br/>
            r.choose(false);<br/>
            addReport(r);<br/>
            addReport( destroyEntity(entity, "fire", false, false));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if any entity has takes 20 damage.  If so, they need a<br/>
     * piloting skill roll.<br/>
     */<br/>
    private void checkFor20Damage() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (entity instanceof Mech) {<br/>
                // if this mech has 20+ damage, add another roll to the list.<br/>
                if (entity.damageThisPhase &gt;= 20) {<br/>
                    if ( game.getOptions().booleanOption("maxtech_round_damage") ) {<br/>
                      int damMod = (entity.damageThisPhase / 20);<br/>
                      int weightMod = 0;<br/>
                      StringBuffer reportStr = new StringBuffer();<br/>
                      reportStr.append(entity.damageThisPhase)<br/>
                          .append(" damage +").append(damMod);<br/>
<br/>
                      switch ( entity.getWeightClass() ) {<br/>
                        case EntityWeightClass.WEIGHT_LIGHT:<br/>
                          weightMod = 1;<br/>
                          break;<br/>
<br/>
                        case EntityWeightClass.WEIGHT_MEDIUM:<br/>
                          weightMod = 0;<br/>
                          break;<br/>
<br/>
                        case EntityWeightClass.WEIGHT_HEAVY:<br/>
                          weightMod = -1;<br/>
                          break;<br/>
<br/>
                        case EntityWeightClass.WEIGHT_ASSAULT:<br/>
                          weightMod = -2;<br/>
                          break;<br/>
                      }<br/>
<br/>
                      PilotingRollData damPRD = new PilotingRollData(entity.getId(), damMod + weightMod, reportStr.toString());<br/>
                      damPRD.setCumulative(false);  // see Bug# 811987 for more info<br/>
                      game.addPSR(damPRD);<br/>
                    } else {<br/>
                      game.addPSR(new PilotingRollData(entity.getId(), 1, "20+ damage"));<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if any non-mech units are standing in fire.  Called at the<br/>
     * end of the movement phase<br/>
     */<br/>
    public void checkForFlamingDeath() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ||<br/>
                 entity instanceof Mech ||<br/>
                 entity.isDoomed() ||<br/>
                 entity.isDestroyed() ||<br/>
                 entity.isOffBoard()) {<br/>
                continue;<br/>
            }<br/>
            final IHex curHex = game.getBoard().getHex(entity.getPosition());<br/>
            if (curHex.containsTerrain(Terrains.FIRE)<br/>
                    &amp;&amp; entity.getElevation() &lt;= 1) {<br/>
                if(game.getOptions().booleanOption("vehicle_fires")<br/>
                        &amp;&amp; entity instanceof Tank) {<br/>
                    checkForVehicleFire((Tank)entity, false);<br/>
                } else {<br/>
                    doFlamingDeath(entity);<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Check to see if anyone dies due to being in a vacuum.<br/>
     */<br/>
    private void checkForVacuumDeath() {<br/>
        Report r;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (null == entity.getPosition() || entity.isOffBoard()) {<br/>
                // If it's not on the board - aboard something else, for example...<br/>
                continue;<br/>
            }<br/>
            if (entity.doomedInVacuum()) {<br/>
                r = new Report(6015);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                addReport(destroyEntity(entity, "being in a vacuum where it can't survive", true, true));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks to see if any entities are underwater with damaged life support.<br/>
     * Called during the end phase.<br/>
     */<br/>
    private void checkForSuffocation() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if ( null == entity.getPosition() ||<br/>
                 entity.isOffBoard()) {<br/>
                continue;<br/>
            }<br/>
            final IHex curHex = game.getBoard().getHex(entity.getPosition());<br/>
            if (entity.getElevation()&lt;0 &amp;&amp; (curHex.terrainLevel(Terrains.WATER) &gt; 1<br/>
            || (curHex.terrainLevel(Terrains.WATER) == 1 &amp;&amp; entity.isProne()))<br/>
            &amp;&amp; entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_LIFE_SUPPORT, Mech.LOC_HEAD) &gt; 0) {<br/>
                Report r = new Report(6020);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
                addReport(damageCrew(entity, 1));<br/>
<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolves all built up piloting skill rolls.<br/>
     * Used at end of weapons, physical phases.<br/>
     */<br/>
    private void resolvePilotingRolls() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            resolvePilotingRolls((Entity)i.nextElement());<br/>
        }<br/>
        game.resetPSRs();<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolves and reports all piloting skill rolls for a single mech.<br/>
     */<br/>
    void resolvePilotingRolls(Entity entity) {<br/>
        resolvePilotingRolls(entity, false, null, null);<br/>
    }<br/>
    void resolvePilotingRolls( Entity entity, boolean moving,<br/>
                               Coords src, Coords dest ) {<br/>
        // dead units don't need to.<br/>
        if ( entity.isDoomed() || entity.isDestroyed() ) {<br/>
            return;<br/>
        }<br/>
        Report r;<br/>
<br/>
        // first, do extreme gravity PSR, because non-mechs do these, too<br/>
        PilotingRollData rollTarget = null;<br/>
        for (Enumeration i = game.getExtremeGravityPSRs();i.hasMoreElements();) {<br/>
            final PilotingRollData roll = (PilotingRollData)i.nextElement();<br/>
            if (roll.getEntityId() != entity.getId()) {<br/>
                continue;<br/>
            }<br/>
            // found a roll, use it (there can be only 1 per entity)<br/>
            rollTarget = roll;<br/>
            game.resetExtremeGravityPSRs(entity);<br/>
        }<br/>
        if (rollTarget != null &amp;&amp;<br/>
            rollTarget.getValue() != TargetRoll.CHECK_FALSE) {<br/>
            // okay, print the info<br/>
            r = new Report(2180);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(rollTarget.getLastPlainDesc());<br/>
            addReport(r);<br/>
            // roll<br/>
            final int diceRoll = Compute.d6(2);<br/>
            r = new Report(2190);<br/>
            r.subject = entity.getId();<br/>
            r.add(rollTarget.getValueAsString());<br/>
            r.add(rollTarget.getDesc());<br/>
            r.add(diceRoll);<br/>
            if (diceRoll &lt; rollTarget.getValue()) {<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
                // walking and running, 1 damage per MP used more than we would<br/>
                // have normally<br/>
                if (entity.moved == IEntityMovementType.MOVE_WALK<br/>
                        || entity.moved == IEntityMovementType.MOVE_VTOL_WALK<br/>
                        || entity.moved == IEntityMovementType.MOVE_RUN<br/>
                        || entity.moved == IEntityMovementType.MOVE_VTOL_RUN) {<br/>
                    if (entity instanceof Mech) {<br/>
                        int j = entity.mpUsed;<br/>
                        int damage = 0;<br/>
                        while (j &gt; entity.getRunMP(false)) {<br/>
                            j--;<br/>
                            damage++;<br/>
                        }<br/>
                        // Wee, direct internal damage<br/>
                        doExtremeGravityDamage(entity, damage);<br/>
                    } else if (entity instanceof Tank) {<br/>
                        // if we got a pavement bonus, take care of it<br/>
                        int k = entity.gotPavementBonus ? 1 : 0;  <br/>
                        if (!entity.gotPavementBonus) {<br/>
                            int j = entity.mpUsed;<br/>
                            int damage = 0;<br/>
                            while (j &gt; entity.getRunMP(false) + k) {<br/>
                                j--;<br/>
                                damage++;<br/>
                            }<br/>
                            doExtremeGravityDamage(entity, damage);<br/>
                        }                      <br/>
                    }<br/>
                }<br/>
                // jumping<br/>
                if (entity.moved == IEntityMovementType.MOVE_JUMP &amp;&amp; entity instanceof Mech) {<br/>
                    // low g, 1 damage for each hex jumped further than<br/>
                    // possible normally<br/>
                    if (game.getOptions().floatOption("gravity") &lt; 1) {<br/>
                        int j = entity.mpUsed;<br/>
                        int damage = 0;<br/>
                        while (j &gt; entity.getOriginalJumpMP()) {<br/>
                            j--;<br/>
                            damage++;<br/>
                        }<br/>
                        // Wee, direct internal damage<br/>
                        doExtremeGravityDamage(entity, damage);<br/>
                    }<br/>
                    // high g, 1 damage for each MP we have less than normally<br/>
                    else if (game.getOptions().floatOption("gravity") &gt; 1) {<br/>
                            int damage = entity.getWalkMP(false) - entity.getWalkMP();<br/>
                            // Wee, direct internal damage<br/>
                            doExtremeGravityDamage(entity, damage);                    <br/>
                    }<br/>
                }                <br/>
            } else {<br/>
                r.choose(true);<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
        // non mechs and prone mechs can now return<br/>
        if ( !(entity instanceof Mech) || entity.isProne()) {<br/>
            return;<br/>
        }<br/>
        // add all cumulative rolls, count all rolls<br/>
        Vector rolls = new Vector();<br/>
        StringBuffer reasons = new StringBuffer();<br/>
        PilotingRollData base = entity.getBasePilotingRoll();<br/>
        entity.addPilotingModifierForTerrain(base);<br/>
        for (Enumeration i = game.getPSRs(); i.hasMoreElements();) {<br/>
            final PilotingRollData modifier = (PilotingRollData)i.nextElement();<br/>
            if (modifier.getEntityId() != entity.getId()) {<br/>
                continue;<br/>
            }<br/>
            // found a roll, add it<br/>
            rolls.addElement(modifier);<br/>
            if (reasons.length() &gt; 0) {<br/>
                reasons.append(", ");<br/>
            }<br/>
            reasons.append(modifier.getPlainDesc());<br/>
            // only cumulative rolls get added to the base roll<br/>
            if (modifier.isCumulative()) {<br/>
                base.append(modifier);<br/>
            }<br/>
        }<br/>
        // any rolls needed?<br/>
        if (rolls.size() == 0) {<br/>
            return;<br/>
        }<br/>
        // is our base roll impossible?<br/>
        if (base.getValue() == PilotingRollData.AUTOMATIC_FAIL || base.getValue() == PilotingRollData.IMPOSSIBLE) {<br/>
            r = new Report(2275);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(rolls.size());<br/>
            r.add(reasons.toString()); //international issue<br/>
            r.add(base.getDesc()); //international issue<br/>
            addReport(r);<br/>
            if (moving) {<br/>
                doEntityFallsInto( entity, src, dest, base );<br/>
            } else {<br/>
                doEntityFall(entity, base);<br/>
            }<br/>
            return;<br/>
        }<br/>
        // loop thru rolls we do have to make...<br/>
        r = new Report(2280);<br/>
        r.subject = entity.getId();<br/>
        r.addDesc(entity);<br/>
        r.add(rolls.size());<br/>
        r.add(reasons.toString()); //international issue<br/>
        addReport(r);<br/>
        r = new Report(2285);<br/>
        r.subject = entity.getId();<br/>
        r.add(base.getValueAsString());<br/>
        r.add(base.getDesc()); //international issue<br/>
        addReport(r);<br/>
        for (int i = 0; i &lt; rolls.size(); i++) {<br/>
            PilotingRollData modifier = (PilotingRollData)rolls.elementAt(i);<br/>
            PilotingRollData target = base;<br/>
            r = new Report(2290);<br/>
            r.subject = entity.getId();<br/>
            r.indent();<br/>
            r.newlines = 0;<br/>
            r.add(i+1);<br/>
            r.add(modifier.getPlainDesc()); //international issue<br/>
            addReport(r);<br/>
            if (!modifier.isCumulative()) {<br/>
                // non-cumulative rolls only happen due to weight class adj.<br/>
                r = new Report(2295);<br/>
                r.subject = entity.getId();<br/>
                r.newlines = 0;<br/>
                r.add(modifier.getValueAsString()); //international issue<br/>
                target = new PilotingRollData(entity.getId());<br/>
                target.append(base);<br/>
                target.append(modifier);<br/>
            }<br/>
            int diceRoll = Compute.d6(2);<br/>
            r = new Report(2300);<br/>
            r.subject = entity.getId();<br/>
            r.add(target.getValueAsString());<br/>
            r.add(diceRoll);<br/>
            if (diceRoll &lt; target.getValue()) {<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
                if (moving) {<br/>
                    doEntityFallsInto( entity, src, dest, base );<br/>
                } else {<br/>
                    doEntityFall(entity, base);<br/>
                }<br/>
                return;<br/>
            } else {<br/>
                r.choose(true);<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Inflict damage on a pilot<br/>
     *<br/>
     * @param en     The &lt;code&gt;Entity&lt;/code&gt; who's pilot gets damaged.<br/>
     * @param damage The &lt;code&gt;int&lt;/code&gt; amount of damage.<br/>
     */<br/>
    private Vector damageCrew(Entity en, int damage) {<br/>
        Vector vDesc = new Vector();<br/>
        Pilot crew = en.getCrew();<br/>
<br/>
        if (!crew.isDead() &amp;&amp; !crew.isEjected() &amp;&amp; !crew.isDoomed()) {<br/>
            crew.setHits( crew.getHits() + damage );<br/>
            Report r = new Report(6025);<br/>
            r.subject = en.getId();<br/>
            r.indent(2);<br/>
            r.addDesc(en);<br/>
            r.add(crew.getName());<br/>
            r.add(damage);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            if ( Pilot.DEATH &gt; crew.getHits() ) {<br/>
                crew.setRollsNeeded( crew.getRollsNeeded() + damage );<br/>
            } else if ( !crew.isDoomed() ) {<br/>
                crew.setDoomed(true);<br/>
                vDesc.addAll( destroyEntity(en, "pilot death", true));<br/>
            }<br/>
        }<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * This checks if the mech pilot goes unconscious from the damage he has<br/>
     * taken this phase.<br/>
     */<br/>
    private void resolveCrewDamage() {<br/>
        boolean anyRolls = false;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
            if (resolveCrewDamage(e, anyRolls)) {<br/>
                anyRolls = true;<br/>
            }<br/>
        }<br/>
        if (anyRolls) {<br/>
            addNewLines();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * resolves consciousness rolls for one entity<br/>
     */<br/>
    private boolean resolveCrewDamage(Entity e, boolean anyRolls) {<br/>
        final int totalHits = e.getCrew().getHits();<br/>
        final int rollsNeeded = e.getCrew().getRollsNeeded();<br/>
        e.crew.setRollsNeeded(0);<br/>
        if (!e.isTargetable() || !e.getCrew().isActive() || rollsNeeded == 0) {<br/>
            return false;<br/>
        }<br/>
        for (int hit = totalHits - rollsNeeded + 1; hit &lt;= totalHits; hit++) {<br/>
            int rollTarget = Compute.getConsciousnessNumber( hit );<br/>
            boolean edgeUsed = false;<br/>
            do {<br/>
                if (edgeUsed)<br/>
                    e.crew.decreaseEdge();<br/>
                int roll = Compute.d6(2);<br/>
                if ( e.getCrew().getOptions().booleanOption("pain_resistance") )<br/>
                  roll = Math.min(12, roll + 1);<br/>
                Report r = new Report(6030);<br/>
                r.subject = e.getId();<br/>
                r.addDesc(e);<br/>
                r.add(e.getCrew().getName());<br/>
                r.add(rollTarget);<br/>
                r.add(roll);<br/>
                if (roll &gt;= rollTarget) {<br/>
                    e.crew.setKoThisRound(false);<br/>
                    r.choose(true);<br/>
                } else {<br/>
                    e.crew.setKoThisRound(true);<br/>
                    r.choose(false);<br/>
                    if (e.crew.hasEdgeRemaining()<br/>
                            &amp;&amp; e.crew.getOptions().booleanOption("edge_when_ko")) {<br/>
                        edgeUsed = true;<br/>
                        vPhaseReport.addElement(r);<br/>
                        r = new Report(6520);<br/>
                        r.subject = e.getId();<br/>
                        r.addDesc(e);<br/>
                        r.add(e.getCrew().getName());<br/>
                        r.add(e.crew.getOptions().intOption("edge"));<br/>
                    } // if<br/>
                    //return true;<br/>
                } // else<br/>
                addReport(r);<br/>
            } while (e.crew.hasEdgeRemaining() &amp;&amp; e.crew.isKoThisRound()<br/>
                    &amp;&amp; e.crew.getOptions().booleanOption("edge_when_ko"));<br/>
            // end of do-while<br/>
            if (e.crew.isKoThisRound()) {<br/>
                e.crew.setUnconscious(true);  <br/>
                return true;<br/>
            }<br/>
        }<br/>
        return true;<br/>
    }<br/>
<br/>
    /**<br/>
     * Make the rolls indicating whether any unconscious crews wake up<br/>
     */<br/>
    private void resolveCrewWakeUp() {<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity e = (Entity)i.nextElement();<br/>
<br/>
            // only unconscious pilots of mechs and protos and MechWarrirs<br/>
            // can roll to wake up<br/>
            if ( !e.isTargetable() || !e.crew.isUnconscious() ||<br/>
                 e.crew.isKoThisRound() ||<br/>
                !(e instanceof Mech || e instanceof Protomech || e instanceof MechWarrior)) {<br/>
                continue;<br/>
            }<br/>
            int roll = Compute.d6(2);<br/>
<br/>
            if ( e.getCrew().getOptions().booleanOption("pain_resistance") )<br/>
              roll = Math.min(12, roll + 1);<br/>
<br/>
            int rollTarget = Compute.getConsciousnessNumber( e.crew.getHits() );<br/>
            Report r = new Report(6029);<br/>
            r.subject = e.getId();<br/>
            r.addDesc(e);<br/>
            r.add(e.getCrew().getName());<br/>
            r.add(rollTarget);<br/>
            r.add(roll);<br/>
            if (roll &gt;= rollTarget) {<br/>
                r.choose(true);<br/>
                e.crew.setUnconscious(false);<br/>
            } else {<br/>
                r.choose(false);<br/>
            }<br/>
            addReport(r);<br/>
        }<br/>
    }<br/>
<br/>
    public Vector damageEntity(Entity te, HitData hit, int damage, boolean ammoExplosion) {<br/>
        return damageEntity(te, hit, damage, ammoExplosion, 0, false, false);<br/>
    }<br/>
<br/>
    public Vector damageEntity(Entity te, HitData hit, int damage) {<br/>
        return damageEntity(te, hit, damage, false, 0, false, false);<br/>
    }<br/>
<br/>
    public Vector damageEntity(Entity te, HitData hit, int damage,<br/>
                               boolean ammoExplosion, int bFrag) {<br/>
        return damageEntity(te, hit, damage, ammoExplosion, bFrag,<br/>
                            false, false);<br/>
    }<br/>
<br/>
    public Vector damageEntity(Entity te, HitData hit, int damage,<br/>
                               boolean ammoExplosion, int bFrag,<br/>
                               boolean damageIS) {<br/>
        return damageEntity(te, hit, damage, ammoExplosion, bFrag,<br/>
                            damageIS, false);<br/>
    }<br/>
<br/>
    public Vector damageEntity(Entity te, HitData hit, int damage,<br/>
                               boolean ammoExplosion, int bFrag,<br/>
                               boolean damageIS, boolean areaSatArty) {<br/>
        return damageEntity (te, hit, damage, ammoExplosion, bFrag, damageIS,<br/>
                             false, true);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Deals the listed damage to an entity.  Returns a vector of Reports<br/>
     * for the phase report<br/>
     *<br/>
     * @param te the target entity<br/>
     * @param hit the hit data for the location hit<br/>
     * @param damage the damage to apply<br/>
     * @param ammoExplosion ammo explosion type damage is applied<br/>
     *          directly to the IS, hurts the pilot, causes auto-ejects,<br/>
     *          and can blow the unit to smithereens<br/>
     * @param bFrag If 0, nothing; if 1, Fragmentation; if 2, Flechette.<br/>
     * @param damageIS Should the target location's internal structure be<br/>
     *          damaged directly?<br/>
     * @param areaSatArty Is the damage from an area saturating artillery<br/>
     *          attack?<br/>
     * @param throughFront Is the damage coming through the hex the unit<br/>
     *          is facing?<br/>
     * @return a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt;s<br/>
     */<br/>
    private Vector damageEntity(Entity te, HitData hit, int damage,<br/>
                                boolean ammoExplosion, int bFrag,<br/>
                                boolean damageIS, boolean areaSatArty,<br/>
                                boolean throughFront) {<br/>
<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
        int te_n = te.getId();<br/>
        //This is good for shields if a shield absorps the hit it shouldn't<br/>
        //effect the pilot.<br/>
        boolean isHeadHit = (te instanceof Mech<br/>
            &amp;&amp; ((Mech)te).getCockpitType() != Mech.COCKPIT_TORSO_MOUNTED<br/>
            &amp;&amp; hit.getLocation() == Mech.LOC_HEAD);<br/>
        <br/>
        // show Locations which have rerolled with Edge<br/>
        HitData undoneLocation = hit.getUndoneLocation();<br/>
        while (undoneLocation != null) {<br/>
            r = new Report(6500);<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            r.addDesc(te);<br/>
            r.add(te.getLocationAbbr(undoneLocation));<br/>
            vDesc.addElement(r);            <br/>
            undoneLocation = undoneLocation.getUndoneLocation();<br/>
        } // while<br/>
        // if edge was uses, give at end overview of remainings<br/>
        if (hit.getUndoneLocation() != null) {<br/>
            r = new Report(6510);<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            r.addDesc(te);<br/>
            r.add(te.crew.getOptions().intOption("edge"));<br/>
            vDesc.addElement(r);            <br/>
        } // if<br/>
        <br/>
        boolean autoEject = false;<br/>
        if (ammoExplosion) {<br/>
            if (te instanceof Mech) {<br/>
                Mech mech = (Mech)te;<br/>
                if (mech.isAutoEject()) {<br/>
                    autoEject = true;<br/>
                    vDesc.addAll(ejectEntity(te, true));<br/>
                }<br/>
            }<br/>
        }<br/>
        boolean isBattleArmor = (te instanceof BattleArmor);<br/>
        boolean isPlatoon = !isBattleArmor &amp;&amp; (te instanceof Infantry);<br/>
        boolean isFerroFibrousTarget = false;<br/>
        boolean wasDamageIS = false;<br/>
        boolean tookInternalDamage = damageIS;<br/>
        IHex te_hex = null;<br/>
<br/>
        boolean hardenedArmor = false;<br/>
        if ((te instanceof Mech)<br/>
                &amp;&amp; (te.getArmorType() == EquipmentType.T_ARMOR_HARDENED))<br/>
            hardenedArmor = true;<br/>
        int crits = ((hit.getEffect() == HitData.EFFECT_CRITICAL) &amp;&amp; (!hardenedArmor)) ? 1 : 0;<br/>
        int specCrits = ((hit.getEffect() == HitData.EFFECT_CRITICAL) &amp;&amp; (hardenedArmor)) ? 1 : 0;<br/>
        HitData nextHit = null;<br/>
<br/>
        // Some "hits" on a Protomech are actually misses.<br/>
        if( te instanceof Protomech &amp;&amp;<br/>
            hit.getLocation() == Protomech.LOC_NMISS ) {<br/>
            r = new Report(6035);<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        // check for critical hit/miss vs. a BA<br/>
        if( crits &gt; 0 &amp;&amp; te instanceof BattleArmor) {<br/>
            //possible critical miss if the rerolled location isn't alive<br/>
            if(hit.getLocation() &gt;= te.locations()<br/>
            || te.getInternal(hit.getLocation()) &lt;= 0) {<br/>
                r = new Report(6037);<br/>
                r.add(hit.getLocation());<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
                return vDesc;<br/>
            }<br/>
            //otherwise critical hit<br/>
            r = new Report(6225);<br/>
            r.add(te.getLocationAbbr(hit));<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
<br/>
            crits = 0;<br/>
            damage = Math.max(te.getInternal(hit.getLocation()) + <br/>
                              te.getArmor(hit.getLocation()),<br/>
                              damage);<br/>
        }<br/>
<br/>
        if ((te != null) &amp;&amp;<br/>
            (te.getArmor(hit) &gt; 0) &amp;&amp;<br/>
            ((te.getArmorType() == EquipmentType.T_ARMOR_FERRO_FIBROUS) ||<br/>
             (te.getArmorType() == EquipmentType.T_ARMOR_LIGHT_FERRO) ||<br/>
             (te.getArmorType() == EquipmentType.T_ARMOR_HEAVY_FERRO))) {<br/>
            isFerroFibrousTarget = true;<br/>
        }<br/>
<br/>
        // Is the infantry in the open?<br/>
        if ( isPlatoon &amp;&amp; !te.isDestroyed() &amp;&amp; !te.isDoomed() ) {<br/>
            te_hex = game.getBoard().getHex( te.getPosition() );<br/>
            if ( te_hex != null &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.WOODS ) &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.JUNGLE ) &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.ROUGH ) &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.RUBBLE ) &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.SWAMP ) &amp;&amp;<br/>
                 !te_hex.containsTerrain( Terrains.BUILDING ) &amp;&amp;<br/>
                 !te_hex.containsTerrain(Terrains.FORTIFIED)) {<br/>
                // PBI.  Damage is doubled.<br/>
                damage = damage * 2;<br/>
                r = new Report(6040);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
        }<br/>
        // Is the infantry in vacuum?<br/>
        if ( (isPlatoon || isBattleArmor ) &amp;&amp; !te.isDestroyed()<br/>
                &amp;&amp; !te.isDoomed() &amp;&amp; game.getOptions().booleanOption("vacuum")) {<br/>
            // PBI. Double damage.<br/>
            damage = damage * 2;<br/>
            r = new Report(6041);<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
        }<br/>
        // If dealing with fragmentation missiles,<br/>
        // it does double damage to infantry...<br/>
        // We're actually going to abuse this for AX-head warheads, too, so as to not add another parameter.<br/>
        switch (bFrag)<br/>
        {<br/>
        case 1:<br/>
            if (isPlatoon) {<br/>
                damage *= 2;<br/>
                r = new Report(6045);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            else if (te != null) {<br/>
                damage = 0;<br/>
                r = new Report(6050);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            break;<br/>
        case 2:<br/>
            if (isPlatoon) {<br/>
                damage *= 2;<br/>
                r = new Report(6055);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            else if ((te != null) &amp;&amp; (!isBattleArmor)) {<br/>
                damage /= 2;<br/>
                r = new Report(6060);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            break;<br/>
        case 3:<br/>
            if (isFerroFibrousTarget) {<br/>
                damage = te.getArmor(hit) &gt;=3?3:te.getArmor(hit);<br/>
                r = new Report(6061);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                r.add(damage);<br/>
                vDesc.addElement(r);<br/>
            } else if (te != null) {<br/>
                r = new Report(6062);<br/>
                r.subject = te_n;<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            break;<br/>
        case 4:<br/>
            //Incendiary AC ammo does +2 damage to unarmoured infantry<br/>
            if(isPlatoon ) {<br/>
                damage += 2;<br/>
            }<br/>
            break;<br/>
<br/>
        default:<br/>
            // We can ignore this.<br/>
            break;<br/>
        }<br/>
<br/>
        //save EI status, in case sensors crit destroys it<br/>
        final boolean eiStatus = te.hasActiveEiCockpit();<br/>
        // BA using EI implants receive +1 damage from attacks<br/>
        if (!(te instanceof Mech) &amp;&amp; !(te instanceof Protomech) &amp;&amp; eiStatus) {<br/>
            damage += 1;<br/>
        }<br/>
<br/>
        // Allocate the damage<br/>
        while (damage &gt; 0) {<br/>
<br/>
            // let's resolve some damage!<br/>
            r = new Report(6065);<br/>
            r.subject = te_n;<br/>
            r.indent(2);<br/>
            r.newlines = 0;<br/>
            r.addDesc(te);<br/>
            r.add(damage);<br/>
            if (damageIS) r.messageId = 6070;<br/>
            r.add(te.getLocationAbbr(hit));<br/>
            vDesc.addElement(r);<br/>
<br/>
            // was the section destroyed earlier this phase?<br/>
            if (te.getInternal(hit) == IArmorState.ARMOR_DOOMED) {<br/>
                // cannot transfer a through armor crit if so<br/>
                crits = 0;<br/>
            }<br/>
<br/>
            //here goes the fun :)<br/>
            //Shields take damage first then cowls then armor whee<br/>
            //Shield does not protect from ammo explosions or falls.<br/>
            if ( !ammoExplosion &amp;&amp; !hit.isFallDamage() &amp;&amp; te.hasShield() ){<br/>
                Mech me = (Mech)te;<br/>
                int damageNew = me.shieldAbsorptionDamage(damage,hit.getLocation(),hit.isRear());<br/>
                //if a shield absorbed the damage then lets tell the world about it.<br/>
                if ( damageNew != damage){<br/>
                    int damageDiff = damage - damageNew;<br/>
                    damage = damageNew;<br/>
                    <br/>
                    r = new Report (3530);<br/>
                    r.subject = te_n;<br/>
                    r.indent(3);<br/>
                    r.newlines=0;<br/>
                    r.add(damageDiff);<br/>
                    vDesc.addElement(r);<br/>
                    <br/>
                    if ( damage &lt;= 0 ){<br/>
                        crits = 0;<br/>
                        specCrits = 0;<br/>
                        isHeadHit = false;<br/>
                    }<br/>
                        <br/>
                }<br/>
            }<br/>
            <br/>
            // Armored Cowl may absorb some damage from hit<br/>
            if (te instanceof Mech) {<br/>
                Mech me = (Mech)te;<br/>
                if (me.hasCowl() &amp;&amp; hit.getLocation()==Mech.LOC_HEAD &amp;&amp;<br/>
                    !throughFront ) {<br/>
                    int damageNew = me.damageCowl(damage);<br/>
                    int damageDiff = damage-damageNew;<br/>
                    damage = damageNew;<br/>
                    <br/>
                    r = new Report (3520);<br/>
                    r.subject = te_n;<br/>
                    r.indent(3);<br/>
                    r.newlines=0;<br/>
                    r.add(damageDiff);<br/>
                    vDesc.addElement(r);<br/>
                }<br/>
            }<br/>
            <br/>
            // Destroy searchlights on 7+ (torso hits on mechs)<br/>
            boolean spotlightHittable = false;<br/>
            if  (te.hasSpotlight()) {<br/>
                spotlightHittable = true;<br/>
                int loc = hit.getLocation();<br/>
                if (te instanceof Mech) {<br/>
                    if (loc != Mech.LOC_CT &amp;&amp; loc != Mech.LOC_LT &amp;&amp; loc != Mech.LOC_RT) {<br/>
                        spotlightHittable = false;<br/>
                    }<br/>
                } else if (te instanceof Tank) {<br/>
                    if (loc != Tank.LOC_FRONT &amp;&amp; loc != Tank.LOC_RIGHT &amp;&amp; loc != Tank.LOC_LEFT) {<br/>
                        spotlightHittable = false;<br/>
                    }<br/>
                }<br/>
                if (spotlightHittable) {<br/>
                    int spotroll = Compute.d6(2);<br/>
                    r = new Report(6072);<br/>
                    r.indent(2);<br/>
                    r.subject = te_n;<br/>
                    r.add(spotroll);<br/>
                    vDesc.addElement(r);<br/>
                    if (spotroll &gt;= 7) {<br/>
                        r = new Report(6071);<br/>
                        r.subject = te_n;<br/>
                        r.indent(2);<br/>
                        vDesc.addElement(r);<br/>
                        te.setSpotlightState(false);<br/>
                        te.setSpotlight(false);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // Does an exterior passenger absorb some of the damage?<br/>
            if (!damageIS) {<br/>
                int nLoc = hit.getLocation();<br/>
                Entity passenger = te.getExteriorUnitAt( nLoc, hit.isRear() );<br/>
                // Does an exterior passenger absorb some of the damage?<br/>
                if ( !ammoExplosion &amp;&amp; null != passenger<br/>
                        &amp;&amp; !passenger.isDoomed() ) {<br/>
                    // Yup.  Roll up some hit data for that passenger.<br/>
                    r = new Report(6075);<br/>
                    r.subject = passenger.getId();<br/>
                    r.indent(3);<br/>
                    r.addDesc(passenger);<br/>
                    vDesc.addElement(r);<br/>
<br/>
                    HitData passHit = passenger.getTrooperAtLocation<br/>
                        ( hit, te);<br/>
<br/>
                    // How much damage will the passenger absorb?<br/>
                    int absorb = 0;<br/>
                    HitData nextPassHit = passHit;<br/>
                    do {<br/>
                        if ( 0 &lt; passenger.getArmor( nextPassHit ) ) {<br/>
                            absorb += passenger.getArmor( nextPassHit );<br/>
                        }<br/>
                        if ( 0 &lt; passenger.getInternal( nextPassHit ) ) {<br/>
                            absorb += passenger.getInternal( nextPassHit );<br/>
                        }<br/>
                        nextPassHit = passenger.getTransferLocation( nextPassHit );<br/>
                    } while ( damage &gt; absorb &amp;&amp; nextPassHit.getLocation() &gt;= 0 );<br/>
<br/>
                    // Damage the passenger.<br/>
                    vDesc.addAll( damageEntity(passenger, passHit, damage));<br/>
<br/>
                    // Did some damage pass on?<br/>
                    if ( damage &gt; absorb ) {<br/>
                        // Yup.  Remove the absorbed damage.<br/>
                        damage -= absorb;<br/>
                        r = new Report(6080);<br/>
                        r.subject = te_n;<br/>
                        r.indent(1);<br/>
                        r.add(damage);<br/>
                        r.addDesc(te);<br/>
                        vDesc.addElement(r);<br/>
                    } else {<br/>
                        // Nope.  Return our description.<br/>
                        return vDesc;<br/>
                    }<br/>
<br/>
                } // End nLoc-has-exterior-passenger<br/>
<br/>
                // is this a mech dumping ammo being hit in the rear torso?<br/>
                boolean bTorso = (nLoc == Mech.LOC_CT || nLoc == Mech.LOC_RT ||<br/>
                                  nLoc == Mech.LOC_LT);<br/>
                if (te instanceof Mech &amp;&amp; hit.isRear() &amp;&amp; bTorso) {<br/>
                    for (Enumeration e = te.getAmmo(); e.hasMoreElements(); ) {<br/>
                        Mounted mAmmo = (Mounted)e.nextElement();<br/>
                        if (mAmmo.isDumping() &amp;&amp; !mAmmo.isDestroyed() &amp;&amp;<br/>
                            !mAmmo.isHit()) {<br/>
                            // doh.  explode it<br/>
                            vDesc.addAll( explodeEquipment(te, mAmmo.getLocation(), mAmmo) );<br/>
                            mAmmo.setHit(true);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // is there armor in the location hit?<br/>
            if (!ammoExplosion &amp;&amp; te.getArmor(hit) &gt; 0 &amp;&amp; !damageIS) {<br/>
                int tmpDamageHold = -1;<br/>
<br/>
                // If the target has hardened armor, we need to adjust damage.<br/>
                if (hardenedArmor) {<br/>
                    tmpDamageHold = damage;<br/>
                    damage /= 2;<br/>
                    damage += (tmpDamageHold%2);<br/>
                }<br/>
                <br/>
                if (te.getArmor(hit) &gt; damage) {<br/>
                    // armor absorbs all damage<br/>
                    te.setArmor(te.getArmor(hit) - damage, hit);<br/>
                    if (tmpDamageHold &gt;= 0)<br/>
                        te.damageThisPhase += tmpDamageHold;<br/>
                    else<br/>
                        te.damageThisPhase += damage;<br/>
                    damage = 0;<br/>
                    r = new Report(6085);<br/>
                    r.subject = te_n;<br/>
                    r.newlines = 0;<br/>
                    if(spotlightHittable)r.indent(3);<br/>
                    r.add(te.getArmor(hit));<br/>
                    vDesc.addElement(r);<br/>
                } else {<br/>
                    // damage goes on to internal<br/>
                    int absorbed = Math.max(te.getArmor(hit), 0);<br/>
                    te.setArmor(IArmorState.ARMOR_DESTROYED, hit);<br/>
                    if (tmpDamageHold &gt;= 0)<br/>
                        te.damageThisPhase += 2*absorbed;<br/>
                    else<br/>
                        te.damageThisPhase += absorbed;<br/>
                    damage -= absorbed;<br/>
                    r = new Report(6090);<br/>
                    r.subject = te_n;<br/>
                    r.newlines = 0;<br/>
                    if(spotlightHittable)r.indent(3);<br/>
                    vDesc.addElement(r);<br/>
                    if (te instanceof GunEmplacement) {<br/>
                        // gun emplacements have no internal,<br/>
                        // destroy the section<br/>
                        destroyLocation(te, hit.getLocation());<br/>
                        r = new Report(6115);<br/>
                        r.subject = te_n;<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
<br/>
                        if (te.getTransferLocation(hit).getLocation() ==<br/>
                            Entity.LOC_DESTROYED) {<br/>
                            vDesc.addAll(<br/>
                                                  destroyEntity(te,<br/>
                                                                "damage",<br/>
                                                                false));<br/>
                        }<br/>
                    }<br/>
                }<br/>
                <br/>
                // If it has hardened armor, now we need to "correct" any remaining damage.<br/>
                if (tmpDamageHold &gt; 0) {<br/>
                    if (hardenedArmor) {<br/>
                        damage *= 2;<br/>
                        damage -= (tmpDamageHold%2);<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            // is there damage remaining?<br/>
            if (damage &gt; 0) {<br/>
                tookInternalDamage = true;<br/>
                // is there internal structure in the location hit?<br/>
                if (te.getInternal(hit) &gt; 0) {<br/>
                    // Triggers a critical hit on Vehicles and Mechs.<br/>
                    if ( !isPlatoon &amp;&amp; !isBattleArmor ) {<br/>
                        crits++;<br/>
                    }<br/>
<br/>
                    // Now we need to consider alternate structure types!<br/>
                    int tmpDamageHold = -1;<br/>
                    if ((te instanceof Mech) &amp;&amp; (((Mech)te).hasCompositeStructure())) {<br/>
                        tmpDamageHold = damage;<br/>
                        damage *= 2;<br/>
                    }<br/>
                    if ((te instanceof Mech) &amp;&amp; (((Mech)te).hasReinforcedStructure())) {<br/>
                        tmpDamageHold = damage;<br/>
                        damage /= 2;<br/>
                        damage += (tmpDamageHold%2);<br/>
                    }<br/>
<br/>
                    if (te.getInternal(hit) &gt; damage) {<br/>
                        // internal structure absorbs all damage<br/>
                        te.setInternal(te.getInternal(hit) - damage, hit);<br/>
                        te.damageThisPhase += damage;<br/>
                        damage = 0;<br/>
                        r = new Report(1210);<br/>
                        r.subject = te_n;<br/>
                        r.newlines = 0;<br/>
                        // Infantry platoons have men not "Internals".<br/>
                        if ( isPlatoon ) {<br/>
                            r.messageId = 6095;<br/>
                        } else {<br/>
                            r.messageId = 6100;<br/>
                        }<br/>
                        r.add(te.getInternal(hit));<br/>
                        vDesc.addElement(r);<br/>
                    } else {<br/>
                        // damage transfers, maybe<br/>
                        int absorbed = Math.max(te.getInternal(hit), 0);<br/>
<br/>
                        // Handle Protomech pilot damage<br/>
                        // due to location destruction<br/>
                        if ( te instanceof Protomech ) {<br/>
                            int hits = Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()] -<br/>
                                ((Protomech)te).getPilotDamageTaken(hit.getLocation());<br/>
                            if ( hits &gt; 0 ) {<br/>
                                vDesc.addAll( damageCrew( te, hits ));<br/>
                                ((Protomech)te).setPilotDamageTaken<br/>
                                     (hit.getLocation(),<br/>
                                      Protomech.POSSIBLE_PILOT_DAMAGE[hit.getLocation()]);<br/>
                            }<br/>
                        }<br/>
<br/>
                        // Platoon, Trooper, or Section destroyed message<br/>
                        r = new Report(1210);<br/>
                        r.subject = te_n;<br/>
                        r.newlines = 0;<br/>
                        if ( isPlatoon ) {<br/>
                            // Infantry have only one section, and<br/>
                            //  are therefore destroyed.<br/>
                            r.messageId = 6105;<br/>
                        } else if ( isBattleArmor ) {<br/>
                            r.messageId = 6110;<br/>
                        } else {<br/>
                            r.messageId = 6115;<br/>
                        }<br/>
                        vDesc.addElement(r);<br/>
<br/>
                        // If a sidetorso got destroyed, and the<br/>
                        // corresponding arm is not yet destroyed, add<br/>
                        // it as a club to that hex (p.35 BMRr)<br/>
                        if (te instanceof Mech &amp;&amp;<br/>
                            ((hit.getLocation() == Mech.LOC_RT &amp;&amp;<br/>
                              te.getInternal(Mech.LOC_RARM) &gt; 0) ||<br/>
                             (hit.getLocation() == Mech.LOC_LT &amp;&amp;<br/>
                              te.getInternal(Mech.LOC_LARM) &gt; 0))) {<br/>
                            int blownOffLocation = -1; //good initial value?<br/>
                            if (hit.getLocation() == Mech.LOC_RT) {<br/>
                                blownOffLocation = Mech.LOC_RARM;<br/>
                            } else {<br/>
                                blownOffLocation = Mech.LOC_LARM;<br/>
                            }<br/>
                            r = new Report(6120);<br/>
                            r.subject = te_n;<br/>
                            r.add(te.getLocationName(blownOffLocation));<br/>
                            r.newlines = 0;<br/>
                            vDesc.addElement(r);<br/>
                            IHex h = game.getBoard().getHex(te.getPosition());<br/>
                            if (te instanceof BipedMech) {<br/>
                                if (!h.containsTerrain( Terrains.ARMS)) {<br/>
                                    h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ARMS, 1));<br/>
                                }<br/>
                                else h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.ARMS, h.terrainLevel(Terrains.ARMS)+1));<br/>
                            } else if (!h.containsTerrain( Terrains.LEGS)) {<br/>
                                h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.LEGS, 1));<br/>
                            } else h.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.LEGS, h.terrainLevel(Terrains.LEGS)+1));<br/>
                            sendChangedHex(te.getPosition());<br/>
                        }<br/>
<br/>
                        // Level 3 mechanized BA, troopers riding on a location <br/>
                        // all die when the location is destroyed.<br/>
                        if(game.getOptions().booleanOption("maxtech_mechanized_ba") &amp;&amp;<br/>
                           te instanceof Mech) {<br/>
                            Entity passenger = te.getExteriorUnitAt( hit.getLocation(), hit.isRear() );<br/>
                            if(null != passenger &amp;&amp; !passenger.isDoomed()) {<br/>
                                HitData passHit = passenger.getTrooperAtLocation( hit, te);<br/>
                                passHit.setEffect(HitData.EFFECT_CRITICAL); //ensures a kill<br/>
                                if(passenger.getInternal(passHit) &gt; 0) {<br/>
                                    vDesc.addAll(damageEntity(passenger, passHit, damage));<br/>
                                }<br/>
                                passHit = new HitData(hit.getLocation(), !(hit.isRear()));<br/>
                                passHit = passenger.getTrooperAtLocation( passHit, te);<br/>
                                passHit.setEffect(HitData.EFFECT_CRITICAL); //ensures a kill<br/>
                                if(passenger.getInternal(passHit) &gt; 0) {<br/>
                                    vDesc.addAll(damageEntity(passenger, passHit, damage));<br/>
                                }<br/>
                            }<br/>
                        }<br/>
<br/>
                        // Destroy the location.<br/>
                        destroyLocation(te, hit.getLocation());<br/>
                        te.damageThisPhase += absorbed;<br/>
                        damage -= absorbed;<br/>
<br/>
                        // Now we need to consider alternate structure types!<br/>
                        if (tmpDamageHold &gt; 0) {<br/>
                            if (((Mech)te).hasCompositeStructure()) {<br/>
                                // If there's a remainder, we can actually ignore it.<br/>
                                damage /= 2;<br/>
                            } else if (((Mech)te).hasReinforcedStructure()) {<br/>
                                damage *= 2;<br/>
                                damage -= (tmpDamageHold%2);<br/>
                            }<br/>
                        }<br/>
<br/>
                        if (te instanceof Mech &amp;&amp;<br/>
                            (hit.getLocation() == Mech.LOC_RT ||<br/>
                             hit.getLocation() == Mech.LOC_LT)) {<br/>
<br/>
                            boolean engineExploded = false;<br/>
<br/>
<br/>
                            int numEngineHits = 0;<br/>
                            numEngineHits +=<br/>
                                te.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                                                   Mech.SYSTEM_ENGINE,<br/>
                                                   Mech.LOC_CT);<br/>
                            numEngineHits +=<br/>
                                te.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                                                   Mech.SYSTEM_ENGINE,<br/>
                                                   Mech.LOC_RT);<br/>
                            numEngineHits +=<br/>
                                te.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                                                   Mech.SYSTEM_ENGINE,<br/>
                                                   Mech.LOC_LT);<br/>
<br/>
                            engineExploded = checkEngineExplosion(te, vDesc, numEngineHits);<br/>
                            if ( !engineExploded &amp;&amp; numEngineHits &gt; 2  ) {<br/>
                                // third engine hit<br/>
                                vDesc.addAll( destroyEntity(te, "engine destruction"));<br/>
                                if ( game.getOptions().booleanOption("auto_abandon_unit") )<br/>
                                    vDesc.addAll(abandonEntity(te));<br/>
<br/>
                            }<br/>
                        }<br/>
                        <br/>
                        if (te instanceof VTOL &amp;&amp; hit.getLocation() == VTOL.LOC_ROTOR) {<br/>
                            //if rotor is destroyed, movement goes bleh.<br/>
                            //I think this will work?<br/>
                            hit.setEffect(HitData.EFFECT_VEHICLE_MOVE_DESTROYED);<br/>
                            <br/>
                        }<br/>
                    }<br/>
                } if (te.getInternal(hit) &lt;= 0) {<br/>
                    // internal structure is gone, what are the transfer potentials?<br/>
                    nextHit = te.getTransferLocation(hit);<br/>
                    if (nextHit.getLocation() == Entity.LOC_DESTROYED) {<br/>
                        if (te instanceof Mech) {<br/>
                            // add all non-destroyed engine crits<br/>
                            te.engineHitsThisRound += te.getGoodCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, hit.getLocation());<br/>
                            // and substract those that where hit previously this round<br/>
                            // hackish, but works.<br/>
                            te.engineHitsThisRound -= te.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE, hit.getLocation());<br/>
                        }<br/>
<br/>
                        boolean engineExploded = false;<br/>
<br/>
                        engineExploded = checkEngineExplosion(te, vDesc, te.engineHitsThisRound);<br/>
<br/>
                        if ( !engineExploded &amp;&amp; !((te instanceof VTOL) &amp;&amp; hit.getLocation() == VTOL.LOC_ROTOR)) {<br/>
                            // Entity destroyed.  Ammo explosions are<br/>
                            // neither survivable nor salvagable.<br/>
                            // Only ammo explosions in the CT are devastating.<br/>
                            vDesc.addAll( destroyEntity( te, "damage",<br/>
                                                      !ammoExplosion,<br/>
                                                      !( (ammoExplosion || areaSatArty) &amp;&amp;<br/>
                                                         hit.getLocation() ==<br/>
                                                         Mech.LOC_CT ) ) );<br/>
                            // If the head is destroyed, kill the crew.<br/>
                            if (hit.getLocation() == Mech.LOC_HEAD ||<br/>
                                (hit.getLocation() == Mech.LOC_CT &amp;&amp; ((ammoExplosion &amp;&amp; !autoEject) || areaSatArty))) {<br/>
                                te.getCrew().setDoomed(true);<br/>
                            }<br/>
                            if (game.getOptions().booleanOption("auto_abandon_unit")) {<br/>
                                vDesc.addAll(abandonEntity(te));<br/>
                            }<br/>
                        }<br/>
<br/>
                        // nowhere for further damage to go<br/>
                        damage = 0;<br/>
                    } else if ( nextHit.getLocation() == Entity.LOC_NONE ) {<br/>
                        // Rest of the damage is wasted.<br/>
                        damage = 0;<br/>
                    } else if (ammoExplosion &amp;&amp; te.locationHasCase(hit.getLocation())) {<br/>
                        // Remaining damage prevented by CASE<br/>
                        r = new Report(6125);<br/>
                        r.subject = te_n;<br/>
                        r.add(damage);<br/>
                        r.indent(3);<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
<br/>
                        // ... but page 21 of the Ask The Precentor Martial FAQ<br/>
                        // www.classicbattletech.com/PDF/AskPMForumArchiveandFAQ.pdf<br/>
                        // says that the damage counts for making PSRs.<br/>
                        te.damageThisPhase += damage;<br/>
<br/>
                        // The target takes no more damage from the explosion.<br/>
                        damage = 0;<br/>
                    } else if (damage &gt; 0) {<br/>
                        // remaining damage transfers<br/>
                        r = new Report(6130);<br/>
                        r.subject = te_n;<br/>
                        r.indent(2);<br/>
                        r.newlines = 0;<br/>
                        r.add(damage);<br/>
                        r.add(te.getLocationAbbr(nextHit));<br/>
                        vDesc.addElement(r);<br/>
<br/>
                        // If there are split weapons in this location, mark it as<br/>
                        // destroyed, even if it took no criticals.<br/>
                        for (Enumeration weapons=te.getWeapons(); weapons.hasMoreElements(); ) {<br/>
                            Mounted m = (Mounted)weapons.nextElement();<br/>
                            if (m.isSplit()) {<br/>
                                if (m.getLocation() == hit.getLocation() ||<br/>
                                    m.getLocation() == nextHit.getLocation()) {<br/>
                                    te.setWeaponDestroyed(m);<br/>
                                }<br/>
                            }<br/>
                        }<br/>
                    }<br/>
                }<br/>
            } else if (hit.getSpecCritMod() &lt; 0) {<br/>
                // If there ISN'T any armor left but we did damage, then there's a chance of a crit, using Armor Piercing.<br/>
                specCrits++;<br/>
            }<br/>
            // check for breaching<br/>
            vDesc.addAll( breachCheck(te, hit.getLocation(), null));<br/>
<br/>
            // resolve special results<br/>
            if (hit.getEffect() == HitData.EFFECT_VEHICLE_MOVE_DAMAGED) {<br/>
                r = new Report(6135);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                int nMP = te.getOriginalWalkMP();<br/>
                if (nMP &gt; 0) {<br/>
                    te.setOriginalWalkMP(nMP - 1);<br/>
<br/>
                    if (te.getOriginalWalkMP()==0) {<br/>
                        // From http://www.classicbattletech.com/PDF/AskPMForumArchiveandFAQ.pdf<br/>
                        // page 19, tanks are only immobile if they take that critical hit.<br/>
                        // ((Tank)te).immobilize();<br/>
<br/>
                        // Hovercraft reduced to 0MP over water sink<br/>
                        if ( te.getMovementMode() == IEntityMovementMode.HOVER &amp;&amp;<br/>
                             game.getBoard().getHex( te.getPosition() ).terrainLevel(Terrains.WATER) &gt; 0 <br/>
                             &amp;&amp;!(game.getBoard().getHex( te.getPosition() ).containsTerrain(Terrains.ICE))) {<br/>
                            vDesc.addAll( destroyEntity(te, "a watery grave", false) );<br/>
                        }<br/>
                    }<br/>
                }<br/>
            } else if (hit.getEffect() == HitData.EFFECT_VEHICLE_MOVE_DESTROYED) {<br/>
                r = new Report(6140);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                ((Tank)te).immobilize();<br/>
                // Does the hovercraft sink?<br/>
                te_hex = game.getBoard().getHex( te.getPosition() );<br/>
                if ( te.getMovementMode() == IEntityMovementMode.HOVER &amp;&amp;<br/>
                     te_hex.terrainLevel(Terrains.WATER) &gt; 0 &amp;&amp;<br/>
                     !(te_hex.containsTerrain(Terrains.ICE))) {<br/>
                    vDesc.addAll( destroyEntity(te, "a watery grave", false) );<br/>
                }<br/>
                if(te instanceof VTOL) {<br/>
                    Report.addNewline(vDesc);<br/>
                    //report problem: add tab<br/>
                    vDesc.addAll( crashVTOL((VTOL)te));<br/>
                }<br/>
            } else if (hit.getEffect() == HitData.EFFECT_VEHICLE_TURRETLOCK) {<br/>
                r = new Report(6145);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                ((Tank)te).lockTurret();<br/>
            }<br/>
            else if (hit.getEffect() ==<br/>
                     HitData.EFFECT_GUN_EMPLACEMENT_WEAPONS) {<br/>
                r = new Report(6146);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                Enumeration weapons = te.getWeapons();<br/>
                while (weapons.hasMoreElements()) {<br/>
                    ((Mounted) weapons.nextElement()).setDestroyed(true);<br/>
                }<br/>
            }<br/>
            else if (hit.getEffect() == HitData.EFFECT_GUN_EMPLACEMENT_TURRET) {<br/>
                r = new Report(6147);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                ((GunEmplacement)te).setTurretLocked(true);<br/>
            }<br/>
            else if (hit.getEffect() == HitData.EFFECT_GUN_EMPLACEMENT_CREW) {<br/>
                r = new Report(6148);<br/>
                r.subject = te_n;<br/>
                r.indent(3);<br/>
                vDesc.addElement(r);<br/>
                ((GunEmplacement)te).getCrew().setDoomed(true);<br/>
            }<br/>
            // roll all critical hits against this location<br/>
            // unless the section destroyed in a previous phase?<br/>
            if (te.getInternal(hit) != IArmorState.ARMOR_DESTROYED) {<br/>
                for (int i = 0; i &lt; crits; i++) {<br/>
                    ((Report) vDesc.elementAt(vDesc.size() - 1)).newlines++;<br/>
                    vDesc.addAll( criticalEntity(te, hit.getLocation(), hit.glancingMod()) );<br/>
                }<br/>
                crits = 0;<br/>
<br/>
                for (int i = 0; i &lt; specCrits; i++) {<br/>
                    ((Report) vDesc.elementAt(vDesc.size() - 1)).newlines++;<br/>
                    vDesc.addAll( criticalEntity(te, hit.getLocation(), (hardenedArmor?-2:hit.getSpecCritMod())+hit.glancingMod()) );<br/>
                }<br/>
                specCrits = 0;<br/>
            }<br/>
<br/>
            if (isHeadHit) {<br/>
                Report.addNewline(vDesc);<br/>
                vDesc.addAll( damageCrew(te, 1) );<br/>
            }<br/>
<br/>
            // loop to next location<br/>
            hit = nextHit;<br/>
            if (damageIS) {<br/>
                wasDamageIS = true;<br/>
                damageIS = false;<br/>
            }<br/>
        }<br/>
        //Mechs using EI implants take pilot damage each time a hit <br/>
        //inflicts IS damage<br/>
        if (tookInternalDamage<br/>
                &amp;&amp; ((te instanceof Mech) || (te instanceof Protomech))<br/>
                &amp;&amp; te.hasActiveEiCockpit()) {<br/>
            Report.addNewline(vDesc);<br/>
            int roll = Compute.d6(2);<br/>
            r = new Report(5075);<br/>
            r.subject = te.getId();<br/>
            r.addDesc(te);<br/>
            r.add(7);<br/>
            r.add(roll);<br/>
            r.choose(roll&gt;=7);<br/>
            r.indent(2);<br/>
            vDesc.add(r);<br/>
            if(roll &lt; 7) {<br/>
                vDesc.addAll( damageCrew(te, 1) );<br/>
            }<br/>
        }<br/>
<br/>
        //damage field guns on infantry platoons if there arent enough men left to man it<br/>
        if(isPlatoon) {<br/>
            float tons = 0.0f;<br/>
            for(Enumeration&lt;Mounted&gt; weapons = te.getWeapons();weapons.hasMoreElements();) {<br/>
                Mounted weap = weapons.nextElement();<br/>
                WeaponType wtype = (WeaponType)weap.getType();<br/>
                if(!wtype.hasFlag(WeaponType.F_INFANTRY)) {<br/>
                    tons += wtype.getTonnage(te);<br/>
                    if(tons &gt; te.getInternal(Infantry.LOC_INFANTRY)) {<br/>
                        weap.setDestroyed(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        //This flag indicates the hit was directly to IS<br/>
        if (wasDamageIS) {<br/>
            Report.addNewline(vDesc);<br/>
        }<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Check to see if the entity's engine explodes.  <br/>
     * Rules for ICE explosions are different to fusion engines.<br/>
     * @param   en - the &lt;code&gt;Entity&lt;/code&gt; in question.<br/>
     *          This value must not be &lt;code&gt;null&lt;/code&gt;.<br/>
     * @param   vDesc - the &lt;code&gt;Vector&lt;/code&gt; that this function should<br/>
     *          add its &lt;code&gt;Report&lt;code&gt;s to.  It may be empty, but not<br/>
     *          &lt;code&gt;null&lt;/code&gt;.<br/>
     * @param   hits - the number of criticals on the engine<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the unit's engine exploded,<br/>
     *          &lt;code&gt;false&lt;/code&gt; if not.<br/>
     */<br/>
    private boolean checkEngineExplosion(Entity en, Vector vDesc, int hits) {<br/>
        if (!(en instanceof Mech)<br/>
                &amp;&amp; !(en instanceof QuadMech)<br/>
                &amp;&amp; !(en instanceof BipedMech)) {<br/>
            return false;<br/>
        }<br/>
        if(en.isDoomed() || en.isDestroyed())<br/>
            return false;<br/>
        Mech mech = (Mech)en;<br/>
<br/>
        //ICE can always explode and roll every time hit<br/>
        if (mech.getEngine().isFusion()<br/>
                &amp;&amp; (!game.getOptions().booleanOption("engine_explosions")<br/>
                    || en.rolledForEngineExplosion<br/>
                    || en.engineHitsThisRound &lt; 2) )<br/>
            return false;<br/>
        int explosionBTH = 12;<br/>
        if(!mech.getEngine().isFusion()) {<br/>
            switch (hits) {<br/>
                case 0: <br/>
                    return false;<br/>
                case 1:<br/>
                    explosionBTH = 10;<br/>
                    break;<br/>
                case 2:<br/>
                    explosionBTH = 7;<br/>
                    break;<br/>
                case 3:<br/>
                default:<br/>
                    explosionBTH = 4;<br/>
                    break;<br/>
            }<br/>
        }<br/>
        int explosionRoll = Compute.d6(2);<br/>
        boolean didExplode = explosionRoll &gt;= explosionBTH;<br/>
<br/>
        Report r;<br/>
        r = new Report(6150);<br/>
        r.subject = en.getId();<br/>
        r.indent(2);<br/>
        r.addDesc(en);<br/>
        r.add(en.engineHitsThisRound);<br/>
        vDesc.addElement(r);<br/>
        r = new Report(6155);<br/>
        r.subject = en.getId();<br/>
        r.indent(2);<br/>
        r.add(explosionBTH);<br/>
        r.add(explosionRoll);<br/>
        vDesc.addElement(r);<br/>
        en.rolledForEngineExplosion = true;<br/>
<br/>
        if ( !didExplode ) {<br/>
            //whew!<br/>
            r = new Report(6160);<br/>
            r.subject = en.getId();<br/>
            r.indent(2);<br/>
            vDesc.addElement(r);<br/>
        } else {<br/>
            r = new Report(6165, Report.PUBLIC);<br/>
            r.subject = en.getId();<br/>
            r.indent(2);<br/>
            vDesc.addElement(r);<br/>
            vDesc.addAll( destroyEntity(en, "engine explosion", false, false));<br/>
            //kill the crew<br/>
            en.getCrew().setDoomed(true);<br/>
<br/>
            //This is a hack so MM.NET marks the mech as not salvageable<br/>
            if ( en instanceof Mech )<br/>
                destroyLocation(en, Mech.LOC_CT);<br/>
<br/>
            //Light our hex on fire<br/>
            final IHex curHex = game.getBoard().getHex(en.getPosition());<br/>
<br/>
            if ((null != curHex)<br/>
                    &amp;&amp; !curHex.containsTerrain(Terrains.FIRE)<br/>
                    &amp;&amp; (curHex.containsTerrain(Terrains.WOODS)<br/>
                    || curHex.containsTerrain(Terrains.JUNGLE))) {<br/>
                curHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
                r = new Report(6170, Report.PUBLIC);<br/>
                r.subject = en.getId();<br/>
                r.indent(2);<br/>
                r.add(en.getPosition().getBoardNum());<br/>
                vDesc.addElement(r);<br/>
                sendChangedHex(en.getPosition());<br/>
            }<br/>
          <br/>
            //ICE explosions don't hurt anyone else, but fusion do<br/>
            if (mech.getEngine().isFusion()) {<br/>
                //Nuke anyone that is in our hex<br/>
                Enumeration entitesWithMe = game.getEntities(en.getPosition());<br/>
                Hashtable entitesHit = new Hashtable();<br/>
<br/>
                entitesHit.put(en, en);<br/>
    <br/>
                while (entitesWithMe.hasMoreElements()) {<br/>
                    Entity entity = (Entity)entitesWithMe.nextElement();<br/>
                    if ( entity.equals(en) )<br/>
                        continue;<br/>
                    vDesc.addAll( destroyEntity(entity, "engine explosion proximity", false, false));<br/>
                    // Kill the crew<br/>
                    entity.getCrew().setDoomed(true);<br/>
                    entitesHit.put(entity, entity);<br/>
                }<br/>
    <br/>
                //Now we damage people near us<br/>
                int engineRating = en.getEngine().getRating();<br/>
                int[] damages = { 999, (engineRating / 10), (engineRating / 20), (engineRating / 40) };<br/>
                Vector entites = game.getEntitiesVector();<br/>
                for (int i = 0; i &lt; entites.size(); i++) {<br/>
                    Entity entity = (Entity)entites.elementAt(i);<br/>
    <br/>
                    if (entitesHit.containsKey(entity))<br/>
                        continue;<br/>
    <br/>
                    if ( entity.isDoomed() || entity.isDestroyed() || !entity.isDeployed() )<br/>
                        continue;<br/>
<br/>
                    int range = en.getPosition().distance(entity.getPosition());<br/>
<br/>
                    if ( range &gt; 3 )<br/>
                        continue;<br/>
<br/>
                    int damage = damages[range];<br/>
<br/>
                    r = new Report(6175);<br/>
                    r.subject = entity.getId();<br/>
                    r.indent(2);<br/>
                    r.addDesc(entity);<br/>
                    r.add(damage);<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
<br/>
                    while (damage &gt; 0) {<br/>
                        int cluster = Math.min(5, damage);<br/>
                        HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, Compute.targetSideTable(en, entity));<br/>
                        vDesc.addAll( damageEntity(entity, hit, cluster));<br/>
                        damage -= cluster;<br/>
                    }<br/>
                    Report.addNewline(vDesc);<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        return didExplode;<br/>
    }<br/>
<br/>
    /**<br/>
     * Apply a single critical hit.<br/>
     *<br/>
     * The following private member of Server are accessed from this function,<br/>
     * preventing it from being factored out of the Server class:<br/>
     * destroyEntity()<br/>
     * destroyLocation()<br/>
     * checkEngineExplosion()<br/>
     * damageCrew()<br/>
     * explodeEquipment()<br/>
     * game<br/>
     *<br/>
     * @param   en the &lt;code&gt;Entity&lt;/code&gt; that is being damaged.<br/>
     *          This value may not be &lt;code&gt;null&lt;/code&gt;.<br/>
     * @param   loc the &lt;code&gt;int&lt;/code&gt; location of critical hit.<br/>
     *          This value may be &lt;code&gt;Entity.NONE&lt;/code&gt; for hits<br/>
     *          to &lt;code&gt;Tank&lt;/code&gt;s and for hits to a &lt;code&gt;Protomech&lt;/code&gt;<br/>
     *          torso weapon.<br/>
     * @param   cs the &lt;code&gt;CriticalSlot&lt;/code&gt; being damaged.<br/>
     *          This value may not be &lt;code&gt;null&lt;/code&gt;.<br/>
     *          For critical hits on a &lt;code&gt;Tank&lt;/code&gt;, the index of<br/>
     *          the slot should be the index of the critical hit table.<br/>
     * @param   secondaryEffects the &lt;code&gt;boolean&lt;/code&gt; flag that indicates<br/>
     *          whether to allow critical hits to cause secondary effects (such<br/>
     *          as triggering an ammo explosion, sending hovercraft to watery<br/>
     *          graves, or damaging Protomech torso weapons). This value is<br/>
     *          normally &lt;code&gt;true&lt;/code&gt;, but it will be &lt;code&gt;false&lt;/code&gt;<br/>
     *          when the hit is being applied from a saved game or scenario.<br/>
     */<br/>
    public Vector applyCriticalHit( Entity en, int loc, CriticalSlot cs,<br/>
                                     boolean secondaryEffects ) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // Handle hits on "critical slots" of tanks.<br/>
        if ( en instanceof Tank ) {<br/>
            Tank tank = (Tank)en;<br/>
            VTOL vtol = null;<br/>
            if (en instanceof VTOL)<br/>
                vtol = (VTOL)en;<br/>
            r = new Report(6180);<br/>
            r.subject = en.getId();<br/>
            r.indent(3);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            switch ( cs.getIndex() ) {<br/>
                case 1 : //crew stunned, or killed if VTOL<br/>
                    if (vtol == null) {<br/>
                        r = new Report(6185);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        // Carried units can't unload from a stunned transport.<br/>
                        // Units that escape a transport don't need to un-stun.<br/>
                        tank.stunCrew();<br/>
                    } else { //VTOL's suffer crew death instead<br/>
                        r = new Report(6190);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        vDesc.addAll(<br/>
                                              destroyEntity(vtol, "crew death", true));<br/>
                        en.getCrew().setDoomed(true);<br/>
                        vDesc.addAll( crashVTOL(vtol));<br/>
                    }<br/>
                    break;<br/>
                case 2 : //this one's ridiculous.  the 'main weapon' jams.<br/>
                    Mounted mWeap = tank.getMainWeapon();<br/>
                    if (mWeap == null) { //no main weapon, no crit<br/>
                        r = new Report(6195);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                    }<br/>
                    else {<br/>
                        r = new Report(6200);<br/>
                        r.subject = en.getId();<br/>
                        r.add(mWeap.getName());<br/>
                        int jamTurns = tank.getJammedTurns() + 1;<br/>
                        if ( jamTurns &gt; 1 ) {<br/>
                            r.messageId = 6205;<br/>
                            r.add(jamTurns);<br/>
                        }<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        tank.setJammedTurns( jamTurns );<br/>
                    }<br/>
                    break;<br/>
                case 3 : //engine destroyed<br/>
                    r = new Report(6210);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    tank.immobilize();<br/>
                    // Does the hovercraft sink?<br/>
                    // Sinking immobile hovercraft is a secondary effect<br/>
                    // and does not occur when loading from a scenario.<br/>
                    if ( secondaryEffects ) {<br/>
                        IHex te_hex = game.getBoard().getHex( en.getPosition() );<br/>
                        if (vtol == null) {<br/>
                            if ( en.getMovementMode() == IEntityMovementMode.HOVER<br/>
                                 &amp;&amp; te_hex.terrainLevel(Terrains.WATER) &gt; 0<br/>
                                 &amp;&amp; !(te_hex.containsTerrain(Terrains.ICE))) {<br/>
                                vDesc.addAll(<br/>
                                                      destroyEntity(en,"a watery grave", false));<br/>
                            }<br/>
                        } else { //VTOLs may land or crash<br/>
                            //TODO: Nothing if VTOL is landed.  If over clear,<br/>
                            // paved, rough, or building, VTOL must make PSR<br/>
                            // to land or crash.  Other terrain is automatic<br/>
                            // crash.<br/>
                            Report.addNewline(vDesc);<br/>
                            //report problem: add 3 tabs<br/>
                            vDesc.addAll( crashVTOL(vtol));<br/>
                        }<br/>
                    }<br/>
                    break;<br/>
                case 4 : //crew killed<br/>
                    r = new Report(6190);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    vDesc.addAll(<br/>
                        destroyEntity(en, "crew death", true));<br/>
                    en.getCrew().setDoomed(true);<br/>
                    if (vtol != null) { //VTOL's crash too<br/>
                        Report.addNewline(vDesc);<br/>
                        //report problem: add 3 tabs<br/>
                        vDesc.addAll( crashVTOL(vtol));<br/>
                    }<br/>
                    break;<br/>
                case 5 : //fuel tank/engine shielding, vehicle explodes<br/>
                    r = new Report(6215);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    if (vtol == null) {<br/>
                        vDesc.addAll(destroyEntity(en, "fuel tank explosion", false, false));<br/>
                    } else { //VTOL's explode and scatter burning fuel<br/>
                        Report.addNewline(vDesc);<br/>
                        //report problem: add 3 tabs<br/>
                        vDesc.addAll( explodeVTOL(vtol));<br/>
                    }<br/>
                    en.getCrew().setDoomed(true);<br/>
                    break;<br/>
                case 6 : //power plant hit, vehicle explodes<br/>
                    r = new Report(6220);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    boolean hasCASE = en.locationHasCase(Tank.LOC_BODY);<br/>
                    if (vtol == null) {<br/>
                        vDesc.addAll(destroyEntity(en, "power plant destruction", hasCASE, hasCASE));<br/>
                    } else { //VTOL's explode and scatter burning fuel<br/>
                        Report.addNewline(vDesc);<br/>
                        //report problem: add 3 tabs<br/>
                        vDesc.addAll( explodeVTOL(vtol));<br/>
                    }<br/>
                    en.getCrew().setDoomed(!hasCASE);<br/>
                    break;<br/>
            }<br/>
<br/>
        } // End entity-is-tank<br/>
<br/>
        // Handle critical hits on system slots.<br/>
        else if ( CriticalSlot.TYPE_SYSTEM == cs.getType() ) {<br/>
            cs.setHit(true);<br/>
            if (en instanceof Protomech) {<br/>
                int numHit=((Protomech)en).getCritsHit(loc);<br/>
                if ( cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_A &amp;&amp;<br/>
                     cs.getIndex() != Protomech.SYSTEM_TORSO_WEAPON_B ) {<br/>
                    r = new Report(6225);<br/>
                    r.subject = en.getId();<br/>
                    r.indent(3);<br/>
                    r.newlines = 0;<br/>
                    r.add(Protomech.systemNames[cs.getIndex()]);<br/>
                    vDesc.addElement(r);<br/>
                }<br/>
                switch (cs.getIndex()) {<br/>
                case Protomech.SYSTEM_HEADCRIT:<br/>
                    if (2==numHit) {<br/>
                        r = new Report(6230);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        destroyLocation(en, loc);<br/>
                    }<br/>
                    break;<br/>
                case Protomech.SYSTEM_ARMCRIT:<br/>
                    if (2==numHit) {<br/>
                        r = new Report(6235);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        destroyLocation(en,loc);<br/>
                    }<br/>
                    break;<br/>
                case Protomech.SYSTEM_LEGCRIT:<br/>
                    if (3==numHit) {<br/>
                        r = new Report(6240);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                        destroyLocation(en,loc);<br/>
                    }<br/>
                    break;<br/>
                case Protomech.SYSTEM_TORSOCRIT:<br/>
                    if (3==numHit) {<br/>
                        vDesc.addAll(<br/>
                            destroyEntity(en, "torso destruction"));<br/>
                    }<br/>
                    // Torso weapon hits are secondary effects and<br/>
                    // do not occur when loading from a scenario.<br/>
                    else if ( secondaryEffects ) {<br/>
                        int tweapRoll=Compute.d6(1);<br/>
                        CriticalSlot newSlot = null;<br/>
                        switch (tweapRoll) {<br/>
                        case 1:<br/>
                        case 2:<br/>
                            newSlot = new CriticalSlot<br/>
                                ( CriticalSlot.TYPE_SYSTEM,<br/>
                                  Protomech.SYSTEM_TORSO_WEAPON_A );<br/>
                            vDesc.addAll(<br/>
                                applyCriticalHit(en, Entity.NONE,<br/>
                                                  newSlot, secondaryEffects));<br/>
                            break;<br/>
                        case 3:<br/>
                        case 4:<br/>
                            newSlot = new CriticalSlot<br/>
                                ( CriticalSlot.TYPE_SYSTEM,<br/>
                                  Protomech.SYSTEM_TORSO_WEAPON_B );<br/>
                            vDesc.addAll(<br/>
                                applyCriticalHit(en, Entity.NONE,<br/>
                                                  newSlot, secondaryEffects));<br/>
                            break;<br/>
                        case 5:<br/>
                        case 6:<br/>
                            //no effect<br/>
                        }<br/>
                    }<br/>
                    break;<br/>
                case Protomech.SYSTEM_TORSO_WEAPON_A:<br/>
                    Mounted weaponA =( (Protomech) en ).getTorsoWeapon(true);<br/>
                    if ( null != weaponA ) {<br/>
                        weaponA.setHit(true);<br/>
                        r = new Report(6245);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                    }<br/>
                    break;<br/>
                case Protomech.SYSTEM_TORSO_WEAPON_B:<br/>
                    Mounted weaponB = ( (Protomech) en ).getTorsoWeapon(false);<br/>
                    if ( null != weaponB ) {<br/>
                        weaponB.setHit(true);<br/>
                        r = new Report(6250);<br/>
                        r.subject = en.getId();<br/>
                        r.newlines = 0;<br/>
                        vDesc.addElement(r);<br/>
                    }<br/>
                    break;<br/>
<br/>
<br/>
                } // End switch( cs.getType() )<br/>
<br/>
                // Shaded hits cause pilot damage.<br/>
                if ( ((Protomech)en).shaded(loc, numHit) ) {<br/>
                    // Destroyed Protomech sections have<br/>
                    // already damaged the pilot.<br/>
                    int pHits =<br/>
                        Protomech.POSSIBLE_PILOT_DAMAGE[ loc ] -<br/>
                        ((Protomech)en).getPilotDamageTaken( loc );<br/>
                    if (  Math.min(1, pHits) &gt; 0 ) {<br/>
                        Report.addNewline(vDesc);<br/>
                        vDesc.addAll(<br/>
                                              damageCrew(en, 1));<br/>
                        pHits = 1 + ((Protomech)en)<br/>
                            .getPilotDamageTaken( loc );<br/>
                        ((Protomech)en).setPilotDamageTaken<br/>
                            ( loc, pHits );<br/>
                    }<br/>
                } // End have-shaded-hit<br/>
<br/>
            } // End entity-is-protomech<br/>
            else {<br/>
                r = new Report(6225);<br/>
                r.subject = en.getId();<br/>
                r.indent(3);<br/>
                r.add(((Mech)en).getSystemName(cs.getIndex()));<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
                switch(cs.getIndex()) {<br/>
                case Mech.SYSTEM_COCKPIT :<br/>
                    // Don't kill a pilot multiple times.<br/>
                    if ( Pilot.DEATH &gt; en.getCrew().getHits() ) {<br/>
                        // boink!<br/>
                        en.getCrew().setDoomed(true);<br/>
                        Report.addNewline(vDesc);<br/>
                        vDesc.addAll(<br/>
                            destroyEntity(en, "pilot death", true));<br/>
                    }<br/>
                    break;<br/>
                case Mech.SYSTEM_ENGINE :<br/>
                    en.engineHitsThisRound++;<br/>
<br/>
                    boolean engineExploded = false;<br/>
<br/>
                    int numEngineHits = 0;<br/>
                    numEngineHits += en.getHitCriticals<br/>
                        (CriticalSlot.TYPE_SYSTEM,<br/>
                         Mech.SYSTEM_ENGINE, Mech.LOC_CT);<br/>
                    numEngineHits += en.getHitCriticals<br/>
                        (CriticalSlot.TYPE_SYSTEM,<br/>
                         Mech.SYSTEM_ENGINE, Mech.LOC_RT);<br/>
                    numEngineHits += en.getHitCriticals<br/>
                        (CriticalSlot.TYPE_SYSTEM,<br/>
                         Mech.SYSTEM_ENGINE, Mech.LOC_LT);<br/>
<br/>
                    engineExploded = checkEngineExplosion(en, vDesc, numEngineHits);<br/>
                    if ( !engineExploded &amp;&amp; numEngineHits &gt; 2 ) {<br/>
                        // third engine hit<br/>
                        vDesc.addAll(<br/>
                            destroyEntity(en, "engine destruction"));<br/>
                        if (game.getOptions().booleanOption("auto_abandon_unit")) {<br/>
                            vDesc.addAll(abandonEntity(en));<br/>
                        }<br/>
                    }<br/>
                    break;<br/>
                case Mech.SYSTEM_GYRO :<br/>
                    if (en.getHitCriticals(CriticalSlot.TYPE_SYSTEM,<br/>
                                           Mech.SYSTEM_GYRO, loc) &gt; 1) {<br/>
                                // gyro destroyed<br/>
                        game.addPSR( new PilotingRollData<br/>
                            (en.getId(), PilotingRollData.AUTOMATIC_FAIL,<br/>
                             3, "gyro destroyed") );<br/>
                    } else {<br/>
                                // first gyro hit<br/>
                        game.addPSR( new PilotingRollData<br/>
                            (en.getId(), 3, "gyro hit") );<br/>
                    }<br/>
                    break;<br/>
                case Mech.ACTUATOR_UPPER_LEG :<br/>
                case Mech.ACTUATOR_LOWER_LEG :<br/>
                case Mech.ACTUATOR_FOOT :<br/>
                    // leg/foot actuator piloting roll<br/>
                    game.addPSR( new PilotingRollData<br/>
                        (en.getId(), 1, "leg/foot actuator hit") );<br/>
                    break;<br/>
                case Mech.ACTUATOR_HIP :<br/>
                    // hip piloting roll<br/>
                    game.addPSR( new PilotingRollData<br/>
                        (en.getId(), 2, "hip actuator hit") );<br/>
                    break;<br/>
                }<br/>
<br/>
            } // End entity-is-mek<br/>
<br/>
        } // End crit-on-system-slot<br/>
<br/>
        // Handle critical hits on equipment slots.<br/>
        else if ( CriticalSlot.TYPE_EQUIPMENT == cs.getType() ) {<br/>
            cs.setHit(true);<br/>
            Mounted mounted = en.getEquipment(cs.getIndex());<br/>
            EquipmentType eqType = mounted.getType();<br/>
            boolean hitBefore = mounted.isHit();<br/>
<br/>
            r = new Report(6225);<br/>
            r.subject = en.getId();<br/>
            r.indent(3);<br/>
            r.add(mounted.getDesc());<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            <br/>
            //Shield objects are not useless when they take one crit.<br/>
            //Shields can be critted and still be usable.<br/>
            if (eqType instanceof MiscType &amp;&amp; ((MiscType)eqType).isShield())<br/>
                mounted.setHit(false);<br/>
            else<br/>
                mounted.setHit(true);<br/>
            <br/>
            if (eqType instanceof MiscType &amp;&amp; eqType.hasFlag(MiscType.F_HARJEL)) {<br/>
                r = new Report(6254);<br/>
                r.subject = en.getId();<br/>
                r.indent(2);<br/>
                breachLocation(en, loc, null, true);<br/>
            }<br/>
<br/>
            // If the item is the ECM suite of a Mek Stealth system<br/>
            // then it's destruction turns off the stealth.<br/>
            if ( !hitBefore &amp;&amp; eqType instanceof MiscType &amp;&amp;<br/>
                 eqType.hasFlag(MiscType.F_ECM) &amp;&amp;<br/>
                 mounted.getLinkedBy() != null ) {<br/>
                Mounted stealth = mounted.getLinkedBy();<br/>
                r = new Report(6255);<br/>
                r.subject = en.getId();<br/>
                r.indent(2);<br/>
                r.add(stealth.getType().getName());<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
                stealth.setMode( "Off" );<br/>
            }<br/>
<br/>
            // Handle equipment explosions.<br/>
            // Equipment explosions are secondary effects and<br/>
            // do not occur when loading from a scenario.<br/>
            if ( secondaryEffects &amp;&amp; eqType.isExplosive() &amp;&amp; !hitBefore ) {<br/>
                vDesc.addAll(explodeEquipment(en, loc, mounted));<br/>
            }<br/>
<br/>
            // Make sure that ammo in this slot is exhaused.<br/>
            if ( mounted.getShotsLeft() &gt; 0 ) {<br/>
                mounted.setShotsLeft(0);<br/>
            }<br/>
<br/>
        } // End crit-on-equipment-slot<br/>
        // mechs with TSM hit by anti-tsm missiles this round get another crit<br/>
        if (en instanceof Mech &amp;&amp; en.hitThisRoundByAntiTSM) {<br/>
            Mech mech = (Mech)en;<br/>
            if (mech.hasTSM()) {<br/>
                r = new Report(6430);<br/>
                r.subject = en.getId();<br/>
                r.indent(2);<br/>
                r.addDesc(en);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
                vDesc.addAll(oneCriticalEntity(en, Compute.d6(2)));<br/>
            }<br/>
            en.hitThisRoundByAntiTSM = false;<br/>
        }<br/>
<br/>
        // Return the results of the damage.<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Rolls and resolves critical hits with no die roll modifiers.<br/>
     */<br/>
    private Vector criticalEntity(Entity en, int loc) {<br/>
        return criticalEntity(en, loc, 0, true);<br/>
    }<br/>
<br/>
    private Vector criticalEntity(Entity en, int loc, int critMod) {<br/>
        return criticalEntity(en, loc, critMod, true);<br/>
    }<br/>
<br/>
    /**<br/>
     * Rolls one critical hit<br/>
     */<br/>
    private Vector oneCriticalEntity(Entity en, int loc) {<br/>
        return criticalEntity(en, loc, 0, false);<br/>
    }<br/>
<br/>
    private Vector crashVTOL(VTOL en,Coords crashPos,int curElevation) {<br/>
        return crashVTOL(en, false, 0,crashPos,curElevation,0);<br/>
    }<br/>
    private Vector crashVTOL(VTOL en) {<br/>
        return crashVTOL(en, false, 0 , en.getPosition(),en.getElevation(),0);<br/>
    }<br/>
<br/>
    /**<br/>
     * Crash a VTOL<br/>
     * @param en             The &lt;code&gt;VTOL&lt;/code&gt; to crash<br/>
     * @param sideSlipCrash  A &lt;code&gt;boolean&lt;/code&gt; value indicating wether this<br/>
     *                       is a sideslip crash or not.<br/>
     * @param hexesMoved     The &lt;code&gt;int&lt;/code&gt; number of hexes moved.<br/>
     * @param crashPos       The &lt;code&gt;Coords&lt;/code&gt; of the crash<br/>
     * @param crashElevation The &lt;code&gt;int&lt;/code&gt; elevation of the VTOL<br/>
     * @param impactSide     The &lt;code&gt;int&lt;/code&gt; describing the side on which<br/>
     *                       the VTOL falls<br/>
     * @return               a &lt;code&gt;Vector&lt;/code&gt; of Reports.<br/>
     */<br/>
    private Vector crashVTOL(VTOL en, boolean sideSlipCrash, int hexesMoved, Coords crashPos, int crashElevation,int impactSide) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        if(!sideSlipCrash) {<br/>
            //report lost movement and crashing<br/>
            r = new Report(6260);<br/>
            r.subject = en.getId();<br/>
            r.newlines = 0;<br/>
            r.addDesc(en);<br/>
            vDesc.addElement(r);<br/>
            int newElevation = 0;<br/>
            IHex fallHex = game.getBoard().getHex(crashPos);<br/>
<br/>
            //May land on roof of building or bridge<br/>
            if(fallHex.containsTerrain(Terrains.BLDG_ELEV))<br/>
                newElevation = fallHex.terrainLevel(Terrains.BLDG_ELEV);<br/>
            else if(fallHex.containsTerrain(Terrains.BRIDGE_ELEV)) {<br/>
                newElevation = fallHex.terrainLevel(Terrains.BRIDGE_ELEV);<br/>
                if(newElevation &gt; crashElevation)<br/>
                    newElevation = 0; //vtol was under bridge already<br/>
            }<br/>
<br/>
            int fall = crashElevation - newElevation;<br/>
            if(fall==0) {<br/>
                //already on ground, no harm done<br/>
                r = new Report(6265);<br/>
                r.subject = en.getId();<br/>
                vDesc.addElement(r);<br/>
            } else {<br/>
                //set elevation 1st to avoid multiple crashes<br/>
                en.setElevation(newElevation);<br/>
<br/>
                //plummets to ground<br/>
                r = new Report(6270);<br/>
                r.subject = en.getId();<br/>
                r.add(fall);<br/>
                vDesc.addElement(r);<br/>
<br/>
                // facing after fall<br/>
                String side;<br/>
                int table;<br/>
                int facing = Compute.d6();<br/>
                switch(facing) {<br/>
                    case 1:<br/>
                    case 2:<br/>
                        side = "right side";<br/>
                        table = ToHitData.SIDE_RIGHT;<br/>
                        break;<br/>
                    case 3:<br/>
                        side = "rear";<br/>
                        table = ToHitData.SIDE_REAR;<br/>
                        break;<br/>
                    case 4:<br/>
                    case 5:<br/>
                        side = "left side";<br/>
                        table = ToHitData.SIDE_LEFT;<br/>
                        break;<br/>
                    case 0:<br/>
                    default:<br/>
                        side = "front";<br/>
                        table = ToHitData.SIDE_FRONT;<br/>
                }<br/>
<br/>
                if(newElevation &lt;= 0) {<br/>
                    boolean waterFall= fallHex.containsTerrain(Terrains.WATER);<br/>
                    if(waterFall &amp;&amp; fallHex.containsTerrain(Terrains.ICE)) {<br/>
                        int roll = Compute.d6(1);<br/>
                        r = new Report(2118);<br/>
                        r.subject = en.getId();<br/>
                        r.add(en.getDisplayName(), true);<br/>
                        r.add(roll);<br/>
                        r.subject = en.getId();<br/>
                        addReport(r);<br/>
                        if(roll == 6) {<br/>
                            resolveIceBroken(crashPos);<br/>
                        } else {<br/>
                            waterFall = false; //saved by ice<br/>
                        }<br/>
                    }<br/>
                    if(waterFall) {<br/>
                        //falls into water and is destroyed<br/>
                        r = new Report(6275);<br/>
                        r.subject = en.getId();<br/>
                        vDesc.addElement(r);<br/>
                        en.destroy("Fell into water",false, false);//not sure, is this salvagable?<br/>
                    }<br/>
                }<br/>
<br/>
                // calculate damage for hitting the surface<br/>
                int damage = (int)Math.round(en.getWeight() / 10.0) * (fall + 1);<br/>
<br/>
                // adjust damage for gravity<br/>
                damage = Math.round(damage * game.getOptions().floatOption("gravity"));<br/>
                // report falling<br/>
                r = new Report(6280);<br/>
                r.subject = en.getId();<br/>
                r.indent();<br/>
                r.addDesc(en);<br/>
                r.add(side);<br/>
                r.add(damage);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
<br/>
                en.setFacing((en.getFacing() + (facing - 1)) % 6);<br/>
<br/>
                boolean exploded=false;<br/>
    <br/>
                // standard damage loop<br/>
                while (damage &gt; 0) {<br/>
                    int cluster = Math.min(5, damage);<br/>
                    HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, table);<br/>
                    int ISBefore[]={en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT), en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};//hack?<br/>
                    vDesc.addAll(<br/>
                                          damageEntity(en, hit, cluster));<br/>
                    int ISAfter[]={en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT), en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};<br/>
                    for(int x=0;x&lt;=3;x++) {<br/>
                        if(ISBefore[x]!=ISAfter[x]) {<br/>
                            exploded=true;<br/>
                        }<br/>
                    }<br/>
                    damage -= cluster;<br/>
                }<br/>
                if (exploded) {<br/>
                    r = new Report(6285);<br/>
                    r.subject = en.getId();<br/>
                    r.addDesc(en);<br/>
                    vDesc.addElement(r);<br/>
                    vDesc.addAll( explodeVTOL(en));<br/>
                }<br/>
<br/>
                //check for location exposure<br/>
                doSetLocationsExposure(en, fallHex, false, newElevation);<br/>
                <br/>
            }<br/>
        } else {<br/>
            en.setElevation(0);//considered landed in the hex.<br/>
            //crashes into ground thanks to sideslip<br/>
            r = new Report(6290);<br/>
            r.subject = en.getId();<br/>
            r.addDesc(en);<br/>
            vDesc.addElement(r);<br/>
            int damage = (int)Math.round(en.getWeight() / 10.0) * (hexesMoved + 1);<br/>
            boolean exploded=false;<br/>
<br/>
            // standard damage loop<br/>
            while (damage &gt; 0) {<br/>
                int cluster = Math.min(5, damage);<br/>
                HitData hit = en.rollHitLocation(ToHitData.HIT_NORMAL, impactSide);<br/>
                int ISBefore[]={en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT), en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};//hack?<br/>
                vDesc.addAll( damageEntity(en, hit, cluster));<br/>
                int ISAfter[]={en.getInternal(Tank.LOC_FRONT), en.getInternal(Tank.LOC_RIGHT), en.getInternal(Tank.LOC_LEFT), en.getInternal(Tank.LOC_REAR)};<br/>
                for(int x=0;x&lt;=3;x++) {<br/>
                    if(ISBefore[x]!=ISAfter[x]) {<br/>
                        exploded=true;<br/>
                    }<br/>
                }<br/>
                damage -= cluster;<br/>
            }<br/>
            if(exploded) {<br/>
                r = new Report(6295);<br/>
                r.subject = en.getId();<br/>
                r.addDesc(en);<br/>
                vDesc.addElement(r);<br/>
                vDesc.addAll( explodeVTOL(en));<br/>
            }<br/>
<br/>
        }<br/>
        return vDesc;<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Explode a VTOL<br/>
     * @param en  The &lt;code&gt;VTOL&lt;/code&gt; to explode.<br/>
     * @return a &lt;code&gt;Vector&lt;/code&gt; of reports<br/>
     */<br/>
    private Vector explodeVTOL(VTOL en) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        if(en.getEngine().isFusion()) {<br/>
            //fusion engine, no effect<br/>
            r = new Report(6300);<br/>
            r.subject = en.getId();<br/>
            vDesc.addElement(r);<br/>
        } else {<br/>
            Coords pos=en.getPosition();<br/>
            IHex hex = game.getBoard().getHex(pos);<br/>
            if(hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE)) {<br/>
                hex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
            } else {<br/>
                game.getBoard().addInfernoTo(pos, InfernoTracker.STANDARD_ROUND, 1);<br/>
                ((InfernoTracker)(game.getBoard().getInfernos().get(pos))).setTurnsLeftToBurn(game.getBoard().getInfernoBurnTurns(pos)-game.getBoard().getInfernoIVBurnTurns(pos)-2);  //massive hack<br/>
            }<br/>
        }<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Rolls and resolves critical hits on mechs or vehicles.<br/>
     * if rollNumber is false, a single hit is applied - needed for<br/>
     * MaxTech Heat Scale rule.<br/>
     */<br/>
    private Vector criticalEntity(Entity en, int loc, int critMod, boolean rollNumber) {<br/>
        CriticalSlot slot = null;<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
        Coords coords = en.getPosition();<br/>
        IHex hex = null;<br/>
        int hits;<br/>
        if (rollNumber) {<br/>
            if (null != coords) hex = game.getBoard().getHex(coords);<br/>
            r = new Report(6305);<br/>
            r.subject = en.getId();<br/>
            r.indent(2);<br/>
            r.add(en.getLocationAbbr(loc));<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            hits = 0;<br/>
            int roll = Compute.d6(2);<br/>
            r = new Report(6310);<br/>
            r.subject = en.getId();<br/>
            String rollString = new String();<br/>
            if ( critMod != 0 ) {<br/>
                rollString = "(" + roll;<br/>
                if ( critMod &gt; 0 ) {<br/>
                    rollString += "+";<br/>
                }<br/>
                rollString += critMod + ") = ";<br/>
                roll += critMod;<br/>
            }<br/>
            rollString += roll;<br/>
            r.add(rollString);<br/>
            r.newlines = 0;<br/>
            vDesc.addElement(r);<br/>
            if (roll &lt;= 7) {<br/>
                //no effect<br/>
                r = new Report(6005);<br/>
                r.subject = en.getId();<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
                return vDesc;<br/>
            } else if (roll &gt;= 8 &amp;&amp; roll &lt;= 9) {<br/>
                hits = 1;<br/>
                r = new Report(6315);<br/>
                r.subject = en.getId();<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            } else if (roll &gt;= 10 &amp;&amp; roll &lt;= 11) {<br/>
                hits = 2;<br/>
                r = new Report(6320);<br/>
                r.subject = en.getId();<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            } else if (roll == 12) {<br/>
                if (en instanceof Tank || en instanceof Protomech) {<br/>
                    hits = 3;<br/>
                    r = new Report(6325);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                } else if (en.locationIsLeg(loc)) {<br/>
                    //limb blown off<br/>
                    r = new Report(6120);<br/>
                    r.subject = en.getId();<br/>
                    r.add(en.getLocationName(loc));<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    if (en.getInternal(loc) &gt; 0) {<br/>
                        destroyLocation(en, loc);<br/>
                    }<br/>
                    if (null != hex) {<br/>
                        if (!hex.containsTerrain (Terrains.LEGS)) {<br/>
                            hex.addTerrain (Terrains.getTerrainFactory().createTerrain(Terrains.LEGS, 1));<br/>
                        }<br/>
                        else {<br/>
                            hex.addTerrain (Terrains.getTerrainFactory().createTerrain<br/>
                                            (Terrains.LEGS,<br/>
                                             hex.terrainLevel(Terrains.LEGS)+1));<br/>
                        }<br/>
                    }<br/>
                    sendChangedHex(en.getPosition());<br/>
                    return vDesc;<br/>
                } else if (loc == Mech.LOC_RARM || loc == Mech.LOC_LARM) {<br/>
                    //limb blown off<br/>
                    r = new Report(6120);<br/>
                    r.subject = en.getId();<br/>
                    r.add(en.getLocationName(loc));<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    destroyLocation(en, loc);<br/>
                    if (null != hex) {<br/>
                        if (!hex.containsTerrain( Terrains.ARMS)) {<br/>
                            hex.addTerrain (Terrains.getTerrainFactory().createTerrain(Terrains.ARMS, 1));<br/>
                        }<br/>
                        else {<br/>
                            hex.addTerrain (Terrains.getTerrainFactory().createTerrain<br/>
                                            (Terrains.ARMS,<br/>
                                             hex.terrainLevel(Terrains.ARMS)+1));<br/>
                        }<br/>
                    }<br/>
                    sendChangedHex(en.getPosition());<br/>
                    return vDesc;<br/>
                } else if (loc == Mech.LOC_HEAD) {<br/>
                    //head blown off<br/>
                    r = new Report(6330);<br/>
                    r.subject = en.getId();<br/>
                    r.add(en.getLocationName(loc));<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    destroyLocation(en, loc);<br/>
                    // Don't kill a pilot multiple times.<br/>
                    if ( Pilot.DEATH &gt; en.getCrew().getHits() ) {<br/>
                        en.crew.setDoomed(true);<br/>
                        Report.addNewline(vDesc);<br/>
                        vDesc.addAll( destroyEntity(en, "pilot death", true));<br/>
                    }<br/>
                    return vDesc;<br/>
                } else {<br/>
                    // torso hit<br/>
                    hits = 3;<br/>
                    r = new Report(6325);<br/>
                    r.subject = en.getId();<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                }<br/>
            }<br/>
        } else {<br/>
            hits = 1;<br/>
        }<br/>
<br/>
        // vehicle handle crits in their own 'special' way<br/>
        if (en instanceof Tank) {<br/>
            Tank tank = (Tank)en;<br/>
            for (int x = 0; x &lt; hits; x++) {<br/>
                slot = new CriticalSlot( CriticalSlot.TYPE_SYSTEM,<br/>
                                         Compute.d6(1) );<br/>
                vDesc.addAll( applyCriticalHit(en, Entity.NONE, slot, true));<br/>
            }<br/>
        }<br/>
        else {<br/>
            // transfer criticals, if needed<br/>
            while (hits &gt; 0 &amp;&amp; en.canTransferCriticals(loc)<br/>
                   &amp;&amp; en.getTransferLocation(loc) != Entity.LOC_DESTROYED<br/>
                   &amp;&amp; en.getTransferLocation(loc) != Entity.LOC_NONE) {<br/>
                loc = en.getTransferLocation(loc);<br/>
                r = new Report(6335);<br/>
                r.subject = en.getId();<br/>
                r.indent(3);<br/>
                r.add(en.getLocationAbbr(loc));<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
<br/>
            // Roll critical hits in this location.<br/>
            while (hits &gt; 0) {<br/>
<br/>
                // Have we hit all available slots in this location?<br/>
                if (en.getHittableCriticals(loc) &lt;= 0) {<br/>
                    r = new Report(6340);<br/>
                    r.subject = en.getId();<br/>
                    r.indent(3);<br/>
                    r.newlines = 0;<br/>
                    vDesc.addElement(r);<br/>
                    break;<br/>
                }<br/>
<br/>
                // Randomly pick a slot to be hit.<br/>
                int slotIndex = Compute.randomInt<br/>
                    ( en.getNumberOfCriticals(loc) );<br/>
                slot = en.getCritical(loc, slotIndex);<br/>
<br/>
                // Ignore empty or unhitable slots (this<br/>
                // includes all previously hit slots).<br/>
                <br/>
                if (slot != null &amp;&amp; slot.isHittable()) {<br/>
                    // if explosive use edge<br/>
                    if (<span class="add"><span class="mv">(en instanceof Mech) <br/>
                       &amp;&amp; ( en.crew.hasEdgeRemaining()<br/>
                            &amp;&amp; en.crew.getOptions().booleanOption("edge_when_explosion"))<br/>
                            &amp;&amp; <span class="add"><span class="add"><span class="add">slot</span>.<span class="add">getType</span>()</span> == <span class="add"><span class="add">CriticalSlot</span>.<span class="add">TYPE_EQUIPMENT</span></span></span></span> <br/>
                            &amp;&amp; <span class="mv">en.getEquipment(slot.getIndex()).getType().isExplosive()</span></span>) {<br/>
                       en.crew.decreaseEdge();<br/>
                       r = new Report(6530);<br/>
                       r.subject = en.getId();<br/>
                       r.indent(3);<br/>
                       r.newlines = 0;<br/>
                       r.add(en.crew.getOptions().intOption("edge"));<br/>
                       vDesc.addElement(r);<br/>
                       continue;<br/>
                    }<br/>
                    vDesc.addAll( applyCriticalHit(en, loc, slot, true));<br/>
                    hits--;<br/>
                }<br/>
<br/>
            } // Hit another slot in this location.<br/>
        }<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks for location breach and returns phase logging.<br/>
     * &lt;p/&gt;<br/>
     * Please note that dependent locations ARE NOT considered breached!<br/>
     *<br/>
     * @param   entity the &lt;code&gt;Entity&lt;/code&gt; that needs to be checked.<br/>
     * @param   loc the &lt;code&gt;int&lt;/code&gt; location on the entity that needs<br/>
     *          to be checked for a breach.<br/>
     * @param   hex the &lt;code&gt;IHex&lt;/code&gt; the enitity occupies when checking<br/>
     *          This value will be &lt;code&gt;null&lt;/code&gt; if the check is the<br/>
     *          result of an attack, and non-null if it occurs during movement.<br/>
     */<br/>
    private Vector breachCheck(Entity entity, int loc, IHex hex) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // BattleArmor does not breach<br/>
        if (entity instanceof Infantry) {<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        if (entity instanceof VTOL) {<br/>
            return vDesc;<br/>
        }<br/>
        <br/>
        // functional HarJel prevents breach<br/>
        if (entity instanceof Mech &amp;&amp; ((Mech)entity).hasHarJelIn(loc)) {<br/>
            r = new Report(6342);<br/>
            r.subject = entity.getId();<br/>
            r.indent(3);<br/>
            vDesc.addElement(r);<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        // This handles both water and vacuum breaches.<br/>
        if (entity.getLocationStatus(loc) &gt; ILocationExposureStatus.NORMAL) {<br/>
            // Does the location have armor (check rear armor on Mek)<br/>
            // and is the check due to damage?<br/>
            int breachroll = 0;<br/>
            if (entity.getArmor(loc) &gt; 0 &amp;&amp;<br/>
                (entity instanceof Mech ? (entity.getArmor(loc,true)&gt;0) : true)<br/>
                &amp;&amp; null == hex) {<br/>
                breachroll = Compute.d6(2);<br/>
                r = new Report(6345);<br/>
                r.subject = entity.getId();<br/>
                r.indent(3);<br/>
                r.add(entity.getLocationAbbr(loc));<br/>
                r.add(breachroll);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            // Breach by damage or lack of armor.<br/>
            if ( breachroll &gt;= 10<br/>
                 || !(entity.getArmor(loc) &gt; 0)<br/>
                 || !(entity instanceof Mech ? (entity.getArmor(loc,true)&gt;0) :<br/>
                      true) ) {<br/>
                vDesc.addAll( breachLocation(entity, loc, hex, false));<br/>
            }<br/>
        }<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks all equipment in a location on an entity as useless.<br/>
     *<br/>
     * @param   entity the &lt;code&gt;Entity&lt;/code&gt; that needs to be checked.<br/>
     * @param   loc the &lt;code&gt;int&lt;/code&gt; location on the entity that needs<br/>
     *          to be checked for a breach.<br/>
     * @param   hex the &lt;code&gt;IHex&lt;/code&gt; the enitity occupies when checking<br/>
     *          This value will be &lt;code&gt;null&lt;/code&gt; if the check is the<br/>
     *          result of an attack, and non-null if it occurs during movement.<br/>
     * @param   harJel a &lt;code&gt;boolean&lt;/code&gt; value indicating if the uselessness<br/>
     *          is the cause of a critically hit HarJel system<br/>
     */<br/>
    private Vector breachLocation(Entity entity, int loc, IHex hex, boolean harJel) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        if (entity.getInternal(loc) &lt; 0 ||<br/>
            entity.getLocationStatus(loc) &lt; ILocationExposureStatus.NORMAL) {<br/>
            //already destroyed or breached? don't bother<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        r = new Report(6350);<br/>
        if (harJel) r.messageId = 6351;<br/>
        r.subject = entity.getId();<br/>
        r.add(entity.getShortName());<br/>
        r.add(entity.getLocationAbbr(loc));<br/>
        r.newlines = 0;<br/>
        vDesc.addElement(r);<br/>
<br/>
        if (entity instanceof Tank) {<br/>
            vDesc.addAll(<br/>
                destroyEntity(entity, "hull breach", true, true));<br/>
            return vDesc;<br/>
        }<br/>
        // equipment and crits will be marked in applyDamage?<br/>
<br/>
        // equipment marked missing<br/>
        for (Enumeration i = entity.getEquipment(); i.hasMoreElements();) {<br/>
            Mounted mounted = (Mounted)i.nextElement();<br/>
            if (mounted.getLocation() == loc) {<br/>
                mounted.setBreached(true);<br/>
            }<br/>
        }<br/>
        // all critical slots set as useless<br/>
        for (int i = 0; i &lt; entity.getNumberOfCriticals(loc); i++) {<br/>
            final CriticalSlot cs = entity.getCritical(loc, i);<br/>
            if (cs != null) {<br/>
                // for every undamaged actuator destroyed by breaching,<br/>
                // we make a PSR (see bug 1040858)<br/>
                if (entity.locationIsLeg(loc)) {<br/>
                    if (cs.isHittable()) {<br/>
                        switch(cs.getIndex()) {<br/>
                            case Mech.ACTUATOR_UPPER_LEG :<br/>
                            case Mech.ACTUATOR_LOWER_LEG :<br/>
                            case Mech.ACTUATOR_FOOT :<br/>
                                // leg/foot actuator piloting roll<br/>
                                game.addPSR( new PilotingRollData<br/>
                                    (entity.getId(), 1, "leg/foot actuator hit") );<br/>
                                break;<br/>
                            case Mech.ACTUATOR_HIP :<br/>
                                // hip piloting roll (at +0, because we get the +2<br/>
                                // anyway because the location is breached<br/>
                                // phase report will look a bit weird, but the roll<br/>
                                // is correct<br/>
                                game.addPSR( new PilotingRollData<br/>
                                    (entity.getId(), 0, "hip actuator hit") );<br/>
                                break;<br/>
                        }<br/>
                    }<br/>
                }<br/>
                cs.setBreached(true);<br/>
            }<br/>
        }<br/>
<br/>
        //Check location for engine/cockpit breach and report accordingly<br/>
        if (loc == Mech.LOC_CT) {<br/>
            vDesc.addAll( destroyEntity(entity, "hull breach"));<br/>
            if (game.getOptions().booleanOption("auto_abandon_unit")) {<br/>
                vDesc.addAll(abandonEntity(entity));<br/>
            }<br/>
        }<br/>
        if (loc == Mech.LOC_HEAD) {<br/>
            entity.crew.setDoomed(true);<br/>
            vDesc.addAll( destroyEntity(entity, "hull breach"));<br/>
            if (entity.getLocationStatus(loc) == ILocationExposureStatus.WET) {<br/>
                r = new Report(6355);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                vDesc.addElement(r);<br/>
            } else {<br/>
                r = new Report(6360);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                vDesc.addElement(r);<br/>
            }<br/>
        }<br/>
<br/>
        // Set the status of the location.<br/>
        // N.B. if we set the status before rolling water PSRs, we get a<br/>
        // "LEG DESTROYED" modifier; setting the status after gives a hip<br/>
        // actuator modifier.<br/>
        entity.setLocationStatus(loc, ILocationExposureStatus.BREACHED);<br/>
<br/>
        // Did the hull breach destroy the engine?<br/>
        if (entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE,<br/>
                               Mech.LOC_LT) +<br/>
            entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE,<br/>
                               Mech.LOC_CT) +<br/>
            entity.getHitCriticals(CriticalSlot.TYPE_SYSTEM, Mech.SYSTEM_ENGINE,<br/>
                               Mech.LOC_RT)<br/>
            &gt;= 3) {<br/>
            vDesc.addAll( destroyEntity(entity, "engine destruction"));<br/>
            if (game.getOptions().booleanOption("auto_abandon_unit")) {<br/>
                vDesc.addAll(abandonEntity(entity));<br/>
            }<br/>
        }<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks all equipment in a location on an entity as destroyed.<br/>
     */<br/>
    void destroyLocation(Entity en, int loc) {<br/>
        // if it's already marked as destroyed, don't bother<br/>
        if (en.getInternal(loc) &lt; 0) {<br/>
            return;<br/>
        }<br/>
        // mark armor, internal as doomed<br/>
        en.setArmor(IArmorState.ARMOR_DOOMED, loc, false);<br/>
        en.setInternal(IArmorState.ARMOR_DOOMED, loc);<br/>
        if (en.hasRearArmor(loc)) {<br/>
            en.setArmor(IArmorState.ARMOR_DOOMED, loc, true);<br/>
        }<br/>
        // equipment marked missing<br/>
        for (Enumeration i = en.getEquipment(); i.hasMoreElements();) {<br/>
            Mounted mounted = (Mounted)i.nextElement();<br/>
            if (mounted.getLocation() == loc) {<br/>
                mounted.setMissing(true);<br/>
            }<br/>
        }<br/>
        // all critical slots set as missing<br/>
        for (int i = 0; i &lt; en.getNumberOfCriticals(loc); i++) {<br/>
            final CriticalSlot cs = en.getCritical(loc, i);<br/>
            if (cs != null) {<br/>
                // count engine hits for maxtech engine explosions<br/>
                if (cs.getType() == CriticalSlot.TYPE_SYSTEM &amp;&amp;<br/>
                    cs.getIndex() == Mech.SYSTEM_ENGINE &amp;&amp;<br/>
                    !cs.isDamaged()) {<br/>
                        en.engineHitsThisRound++;<br/>
                }<br/>
                cs.setMissing(true);<br/>
            }<br/>
        }<br/>
        // if it's a leg, the entity falls<br/>
        if (en instanceof Mech &amp;&amp; en.locationIsLeg(loc)) {<br/>
            game.addPSR(new PilotingRollData(en.getId(), PilotingRollData.AUTOMATIC_FAIL, 5, "leg destroyed"));<br/>
        }<br/>
        // dependent locations destroyed<br/>
        if (en.getDependentLocation(loc) != Entity.LOC_NONE) {<br/>
            destroyLocation(en, en.getDependentLocation(loc));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Mark the unit as destroyed!  Units transported in the destroyed unit<br/>
     * will get a chance to escape.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @return  a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt; objects<br/>
     *          that can be sent to the output log.<br/>
     */<br/>
    private Vector destroyEntity(Entity entity, String reason) {<br/>
        return destroyEntity( entity, reason, true );<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks a unit as destroyed!  Units transported inside the destroyed<br/>
     * unit will get a chance to escape unless the destruction was not<br/>
     * survivable.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @param   survivable - a &lt;code&gt;boolean&lt;/code&gt; that identifies the<br/>
     *          desctruction as unsurvivable for transported units.<br/>
     * @return  a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt; objects<br/>
     *          that can be sent to the output log.<br/>
     */<br/>
    private Vector destroyEntity(Entity entity, String reason,<br/>
                                 boolean survivable) {<br/>
        // Generally, the entity can still be salvaged.<br/>
        return this.destroyEntity( entity, reason, survivable, true );<br/>
    }<br/>
<br/>
    /**<br/>
     * Marks a unit as destroyed!  Units transported inside the destroyed<br/>
     * unit will get a chance to escape unless the destruction was not<br/>
     * survivable.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that has been destroyed.<br/>
     * @param   reason - a &lt;code&gt;String&lt;/code&gt; detailing why the entity<br/>
     *          was destroyed.<br/>
     * @param   survivable - a &lt;code&gt;boolean&lt;/code&gt; that identifies the<br/>
     *          desctruction as unsurvivable for transported units.<br/>
     * @param   canSalvage - a &lt;code&gt;boolean&lt;/code&gt; that indicates if<br/>
     *          the unit can be salvaged (or cannibalized for spare parts).<br/>
     *          If &lt;code&gt;true&lt;/code&gt;, salvage operations are possible, if<br/>
     *          &lt;code&gt;false&lt;/code&gt;, the unit is too badly damaged.<br/>
     * @return  a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Report&lt;/code&gt; objects<br/>
     *          that can be sent to the output log.<br/>
     */<br/>
    private Vector destroyEntity(Entity entity, String reason,<br/>
                                 boolean survivable, boolean canSalvage) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // The unit can suffer an ammo explosion after it has been destroyed.<br/>
        int condition = IEntityRemovalConditions.REMOVE_SALVAGEABLE;<br/>
        if ( !canSalvage ) {<br/>
            entity.setSalvage( canSalvage );<br/>
            condition = IEntityRemovalConditions.REMOVE_DEVASTATED;<br/>
        }<br/>
<br/>
        // Destroy the entity, unless it's already destroyed.<br/>
        if (!entity.isDoomed() &amp;&amp; !entity.isDestroyed()) {<br/>
            r = new Report(6365);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(reason);<br/>
            r.newlines=0;<br/>
            vDesc.addElement(r);<br/>
<br/>
            entity.setDoomed(true);<br/>
<br/>
            // Kill any picked up MechWarriors<br/>
            Enumeration iter = entity.getPickedUpMechWarriors().elements();<br/>
            while (iter.hasMoreElements() ) {<br/>
                Integer mechWarriorId = (Integer)iter.nextElement();<br/>
                Entity mw = game.getEntity(mechWarriorId.intValue());<br/>
                mw.setDestroyed(true);<br/>
                game.removeEntity( mw.getId(), condition );<br/>
                this.entityUpdate(mw.getId());<br/>
                send( createRemoveEntityPacket(mw.getId(), condition) );<br/>
                r = new Report(6370);<br/>
                r.subject = mw.getId();<br/>
                r.addDesc(mw);<br/>
                vDesc.addElement(r);<br/>
            }<br/>
<br/>
            // Handle escape of transported units.<br/>
            iter = entity.getLoadedUnits().elements();<br/>
            if ( iter.hasMoreElements() ) {<br/>
                Entity other = null;<br/>
                Coords curPos = entity.getPosition();<br/>
                IHex entityHex = game.getBoard().getHex( curPos );<br/>
                int curFacing = entity.getFacing();<br/>
                while ( iter.hasMoreElements() ) {<br/>
                    other = (Entity) iter.nextElement();<br/>
<br/>
                    // Can the other unit survive?<br/>
                    if ( !survivable ) {<br/>
<br/>
                        // Nope.<br/>
                        other.setDestroyed(true);<br/>
                        game.moveToGraveyard( other.getId() );<br/>
                        this.entityUpdate(other.getId());<br/>
                        send( createRemoveEntityPacket(other.getId(),<br/>
                                                       condition) );<br/>
                        r = new Report(6370);<br/>
                        r.subject = other.getId();<br/>
                        r.addDesc(other);<br/>
                        vDesc.addElement(r);<br/>
                    }<br/>
                    // Can we unload the unit to the current hex?<br/>
                    // TODO : unloading into stacking violation is not<br/>
                    //        explicitly prohibited in the BMRr.<br/>
                    else if (null != Compute.stackingViolation(game, other.getId(), curPos)<br/>
                             || other.isHexProhibited(entityHex) ) {<br/>
                        // Nope.<br/>
                        other.setDestroyed(true);<br/>
                        game.moveToGraveyard( other.getId() );<br/>
                        this.entityUpdate(other.getId());<br/>
                        send( createRemoveEntityPacket(other.getId(),<br/>
                                                       condition) );<br/>
                        r = new Report(6375);<br/>
                        r.subject = other.getId();<br/>
                        r.addDesc(other);<br/>
                        vDesc.addElement(r);<br/>
                    } // End can-not-unload<br/>
                    else {<br/>
                        // The other unit survives.<br/>
                        this.unloadUnit( entity, other, curPos, curFacing, entity.getElevation() );<br/>
                    }<br/>
<br/>
                } // Handle the next transported unit.<br/>
<br/>
            } // End has-transported-unit<br/>
<br/>
            // Handle transporting unit.<br/>
            if ( Entity.NONE != entity.getTransportId() ) {<br/>
                final Entity transport = game.getEntity<br/>
                    ( entity.getTransportId() );<br/>
                Coords curPos = transport.getPosition();<br/>
                int curFacing = transport.getFacing();<br/>
                this.unloadUnit( transport, entity, curPos, curFacing, transport.getElevation() );<br/>
                this.entityUpdate( transport.getId() );<br/>
            } // End unit-is-transported<br/>
<br/>
            // Is this unit being swarmed?<br/>
            final int swarmerId = entity.getSwarmAttackerId();<br/>
            if ( Entity.NONE != swarmerId ) {<br/>
                final Entity swarmer = game.getEntity( swarmerId );<br/>
<br/>
                // remove the swarmer from the move queue<br/>
                game.removeTurnFor(swarmer);<br/>
                send(createTurnVectorPacket());<br/>
<br/>
                swarmer.setSwarmTargetId( Entity.NONE );<br/>
                entity.setSwarmAttackerId( Entity.NONE );<br/>
                r = new Report(6380);<br/>
                r.subject = swarmerId;<br/>
                r.addDesc(swarmer);<br/>
                vDesc.addElement(r);<br/>
                this.entityUpdate( swarmerId );<br/>
            }<br/>
<br/>
            // Is this unit swarming somebody?<br/>
            final int swarmedId = entity.getSwarmTargetId();<br/>
            if ( Entity.NONE != swarmedId ) {<br/>
                final Entity swarmed = game.getEntity( swarmedId );<br/>
                swarmed.setSwarmAttackerId( Entity.NONE );<br/>
                entity.setSwarmTargetId( Entity.NONE );<br/>
                r = new Report(6385);<br/>
                r.subject = swarmed.getId();<br/>
                r.addDesc(swarmed);<br/>
                vDesc.addElement(r);<br/>
                this.entityUpdate( swarmedId );<br/>
            }<br/>
<br/>
        } // End entity-not-already-destroyed.<br/>
        <br/>
        // update our entity, so clients have correct data<br/>
        // needed for MekWars stuff<br/>
        this.entityUpdate(entity.getId());<br/>
<br/>
        return vDesc;<br/>
    }<br/>
    <br/>
<br/>
    /**<br/>
     * Makes a piece of equipment on a mech explode!  POW!  This expects either<br/>
     * ammo, or an explosive weapon.  Returns a vector of Report objects.<br/>
     */<br/>
    private Vector explodeEquipment(Entity en, int loc, int slot) {<br/>
        return explodeEquipment(en, loc, en.getEquipment(en.getCritical(loc, slot).getIndex()));<br/>
    }<br/>
<br/>
    private Vector explodeEquipment(Entity en, int loc, Mounted mounted) {<br/>
        Vector vDesc = new Vector();<br/>
        // is this already destroyed?<br/>
        if (mounted.isDestroyed()) {<br/>
            System.err.println("server: explodeEquipment called on destroyed"<br/>
            + " equipment (" + mounted.getName() + ")");<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        // special-case.  RACs only explode when jammed<br/>
        if (mounted.getType() instanceof WeaponType &amp;&amp;<br/>
                ((WeaponType)mounted.getType()).getAmmoType() == AmmoType.T_AC_ROTARY) {<br/>
            if (!mounted.isJammed()) {<br/>
                return vDesc;<br/>
            }<br/>
        }<br/>
<br/>
        // special case.  ACs only explode when firing incendiary ammo<br/>
        if (mounted.getType() instanceof WeaponType &amp;&amp;<br/>
                ((WeaponType)mounted.getType()).getAmmoType() == AmmoType.T_AC) {<br/>
            if (!mounted.isUsedThisRound()) {<br/>
                return vDesc;<br/>
            }<br/>
            Mounted ammo = mounted.getLinked();<br/>
            if(ammo == null || !(ammo.getType() instanceof AmmoType) || <br/>
            ((AmmoType)ammo.getType()).getMunitionType() != AmmoType.M_INCENDIARY_AC ) {<br/>
                return vDesc;<br/>
            }<br/>
            <br/>
            WeaponType wtype = (WeaponType)mounted.getType();<br/>
            if ( ((wtype.getAmmoType() == AmmoType.T_LRM) ||                 <br/>
                    (wtype.getAmmoType() == AmmoType.T_LRM_STREAK) ||<br/>
                    (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO) ||<br/>
                    (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO_COMBO))){<br/>
                return vDesc;<br/>
            }<br/>
            <br/>
        }<br/>
<br/>
        // Inferno ammo causes heat buildup as well as the damage<br/>
        if (mounted.getType() instanceof AmmoType<br/>
                &amp;&amp; ((((AmmoType)mounted.getType()).getAmmoType() == AmmoType.T_SRM)<br/>
                || (((AmmoType)mounted.getType()).getAmmoType() == AmmoType.T_BA_INFERNO))<br/>
                &amp;&amp; ((AmmoType)mounted.getType()).getMunitionType() == AmmoType.M_INFERNO<br/>
                &amp;&amp; mounted.getShotsLeft() &gt; 0) {<br/>
            en.heatBuildup += 30;<br/>
        }<br/>
<br/>
        // determine and deal damage<br/>
        int damage = mounted.getExplosionDamage();<br/>
<br/>
        if (damage &lt;= 0) {<br/>
            return vDesc;<br/>
        }<br/>
<br/>
        Report r = new Report(6390);<br/>
        r.subject = en.getId();<br/>
        r.add(mounted.getName());<br/>
        r.add(damage);<br/>
        r.indent(3);<br/>
        r.newlines = 0;<br/>
        vDesc.addElement(r);<br/>
        mounted.setShotsLeft(0);<br/>
        vDesc.addAll( damageEntity(en, new HitData(loc), damage, true));<br/>
        Report.addNewline(vDesc);<br/>
<br/>
        <br/>
        int pilotDamage = 2;<br/>
        if (en.getCrew().getOptions().booleanOption("pain_resistance")) pilotDamage = 1;<br/>
        if (en.getCrew().getOptions().booleanOption("iron_man")) pilotDamage = 1;<br/>
        vDesc.addAll( damageCrew(en, pilotDamage));<br/>
        if ( en.crew.isDoomed() || en.crew.isDead() ) {<br/>
            vDesc.addAll( destroyEntity(en, "crew death", true) );<br/>
        } else {<br/>
            Report.addNewline(vDesc);<br/>
        }<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes one slot of ammo, determined by certain rules, explode on a mech.<br/>
     */<br/>
    private Vector explodeAmmoFromHeat(Entity entity) {<br/>
        int damage = 0;<br/>
        int rack = 0;<br/>
        int boomloc = -1;<br/>
        int boomslot = -1;<br/>
        Vector vDesc = new Vector();<br/>
<br/>
        for (int j = 0; j &lt; entity.locations(); j++) {<br/>
            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {<br/>
                CriticalSlot cs = entity.getCritical(j, k);<br/>
                if (cs == null || cs.isDestroyed() || cs.isHit() || cs.getType() != CriticalSlot.TYPE_EQUIPMENT) {<br/>
                    continue;<br/>
                }<br/>
                Mounted mounted = entity.getEquipment(entity.getCritical(j, k).getIndex());<br/>
                if (!(mounted.getType() instanceof AmmoType)) {<br/>
                    continue;<br/>
                }<br/>
                AmmoType atype = (AmmoType)mounted.getType();<br/>
                if (!atype.isExplosive()) {<br/>
                    continue;<br/>
                }<br/>
                //ignore empty bins<br/>
                if (atype.getShots() == 0) {<br/>
                    continue;<br/>
                }<br/>
                // BMRr, pg. 48, compare one rack's<br/>
                // damage.  Ties go to most rounds.<br/>
                int newRack = atype.getDamagePerShot() * atype.getRackSize();<br/>
                int newDamage = mounted.getExplosionDamage();<br/>
                if ( !mounted.isHit() &amp;&amp; ( rack &lt; newRack ||<br/>
                       (rack == newRack &amp;&amp; damage &lt; newDamage) ) ) {<br/>
                    rack = newRack;<br/>
                    damage = newDamage;<br/>
                    boomloc = j;<br/>
                    boomslot = k;<br/>
                }<br/>
            }<br/>
        }<br/>
        if (boomloc != -1 &amp;&amp; boomslot != -1) {<br/>
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);<br/>
            slot.setHit(true);<br/>
            entity.getEquipment(slot.getIndex()).setHit(true);<br/>
            vDesc = explodeEquipment(entity, boomloc, boomslot);<br/>
        } else {<br/>
            //Luckily, there is no ammo to explode.<br/>
            Report r = new Report(5105);<br/>
            r.subject = entity.getId();<br/>
            r.indent();<br/>
            vDesc.addElement(r);<br/>
        }<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes a mech fall.<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height, int facing, PilotingRollData roll) {<br/>
        Report r;<br/>
<br/>
        IHex fallHex = game.getBoard().getHex(fallPos);<br/>
<br/>
        // we don't need to deal damage yet, if the entity is doing DFA<br/>
        if (entity.isMakingDfa()) {<br/>
            r = new Report(2305);<br/>
            r.subject = entity.getId();<br/>
            addReport(r);<br/>
            entity.setProne(true);<br/>
            return;<br/>
        }<br/>
        // facing after fall<br/>
        String side;<br/>
        int table;<br/>
        switch(facing) {<br/>
            case 1:<br/>
            case 2:<br/>
                side = "right side";<br/>
                table = ToHitData.SIDE_RIGHT;<br/>
                break;<br/>
            case 3:<br/>
                side = "rear";<br/>
                table = ToHitData.SIDE_REAR;<br/>
                break;<br/>
            case 4:<br/>
            case 5:<br/>
                side = "left side";<br/>
                table = ToHitData.SIDE_LEFT;<br/>
                break;<br/>
            case 0:<br/>
            default:<br/>
                side = "front";<br/>
                table = ToHitData.SIDE_FRONT;<br/>
        }<br/>
<br/>
        int waterDepth = fallHex.terrainLevel(Terrains.WATER);<br/>
        int damageHeight = height;<br/>
<br/>
<br/>
        // HACK: if the dest hex is water, assume that the fall height given is<br/>
        // to the floor of the hex, and modifiy it so that it's to the surface<br/>
        if (waterDepth &gt; 0) {<br/>
            damageHeight = height - waterDepth;<br/>
        } else {<br/>
            waterDepth = 0; //because it will be used to set elevation<br/>
        }<br/>
<br/>
        if(fallHex.containsTerrain(Terrains.ICE)) {<br/>
            waterDepth = 0;<br/>
        }<br/>
        <br/>
        //Falling into water instantly destroys most non-mechs<br/>
        if(waterDepth &gt; 0<br/>
                &amp;&amp; !(entity instanceof Mech)<br/>
                &amp;&amp; !(entity instanceof Protomech)<br/>
                &amp;&amp; (entity.getRunMP() &gt; 0 &amp;&amp; entity.getMovementMode() != IEntityMovementMode.HOVER)<br/>
                &amp;&amp; entity.getMovementMode() != IEntityMovementMode.HYDROFOIL<br/>
                &amp;&amp; entity.getMovementMode() != IEntityMovementMode.NAVAL<br/>
                &amp;&amp; entity.getMovementMode() != IEntityMovementMode.SUBMARINE) {<br/>
            addReport(<br/>
                    destroyEntity(entity, "a watery grave", false));<br/>
            return;<br/>
        }<br/>
<br/>
        // calculate damage for hitting the surface<br/>
        int damage = (int)Math.round(entity.getWeight() / 10.0) * (damageHeight + 1);<br/>
        // calculate damage for hitting the ground, but only if we actually fell<br/>
        // into water<br/>
        // if we fell onto the water surface, that damage is halved.<br/>
        int waterDamage = 0;<br/>
        if (waterDepth &gt; 0) {<br/>
            damage /= 2;<br/>
            waterDamage = (int)Math.round(entity.getWeight() / 10.0) * (waterDepth + 1) /2;<br/>
        }<br/>
<br/>
        // If the waterDepth is larger than the fall height,<br/>
        // we fell underwater<br/>
        if (waterDepth &gt; height) {<br/>
            damage = 0;<br/>
            waterDamage = (int)Math.round(entity.getWeight() / 10.0) * (height + 1) /2;<br/>
        }<br/>
        // adjust damage for gravity<br/>
        damage = Math.round(damage * game.getOptions().floatOption("gravity"));<br/>
        waterDamage = Math.round(waterDamage * game.getOptions().floatOption("gravity"));<br/>
<br/>
        // report falling<br/>
        if (waterDamage == 0) {<br/>
            r = new Report(2310);<br/>
            r.subject = entity.getId();<br/>
            r.indent();<br/>
            r.newlines = 0;<br/>
            r.addDesc(entity);<br/>
            r.add(side); //international issue<br/>
            r.add(damage);<br/>
        } else if (damage &gt; 0) {<br/>
            r = new Report(2315);<br/>
            r.subject = entity.getId();<br/>
            r.indent();<br/>
            r.newlines = 0;<br/>
            r.addDesc(entity);<br/>
            r.add(side); //international issue<br/>
            r.add(damage);<br/>
            r.add(waterDamage);<br/>
        } else {<br/>
            r = new Report(2310);<br/>
            r.subject = entity.getId();<br/>
            r.indent();<br/>
            r.newlines = 0;<br/>
            r.addDesc(entity);<br/>
            r.add(side); //international issue<br/>
            r.add(waterDamage);<br/>
        }<br/>
        addReport(r);<br/>
        damage += waterDamage;<br/>
<br/>
        // Any swarming infantry will be dislodged, but we don't want to<br/>
        // interrupt the fall's report.  We have to get the ID now because<br/>
        // the fall may kill the entity which will reset the attacker ID.<br/>
        final int swarmerId = entity.getSwarmAttackerId();<br/>
<br/>
        // Positioning must be prior to damage for proper handling of breaches<br/>
        // Only Mechs can fall prone.<br/>
        if ( entity instanceof Mech ) {<br/>
            entity.setProne(true);<br/>
        }<br/>
        entity.setPosition(fallPos);<br/>
        entity.setFacing((entity.getFacing() + (facing - 1)) % 6);<br/>
        entity.setSecondaryFacing(entity.getFacing());<br/>
        entity.setElevation(-waterDepth);<br/>
        if (waterDepth &gt; 0) {<br/>
            for (int loop=0; loop&lt; entity.locations();loop++){<br/>
                entity.setLocationStatus(loop, ILocationExposureStatus.WET);<br/>
            }<br/>
        }<br/>
<br/>
        // standard damage loop<br/>
        while (damage &gt; 0) {<br/>
            int cluster = Math.min(5, damage);<br/>
            HitData hit = entity.rollHitLocation(ToHitData.HIT_NORMAL, table);<br/>
            hit.makeFallDamage(true);<br/>
            addReport( damageEntity(entity, hit, cluster));<br/>
            damage -= cluster;<br/>
        }<br/>
<br/>
        //check for location exposure<br/>
        doSetLocationsExposure(entity, fallHex, false, -waterDepth);<br/>
<br/>
        // we want to be able to avoid pilot damage even when it was<br/>
        // an automatic fall, only unconsciousness should cause auto-damage<br/>
        roll.removeAutos();<br/>
<br/>
        if (height &gt; 0) {<br/>
            roll.addModifier(height, "height of fall");<br/>
        }<br/>
<br/>
        entity.addPilotingModifierForTerrain(roll, fallPos);<br/>
<br/>
        if (roll.getValue() == PilotingRollData.IMPOSSIBLE) {<br/>
            r = new Report(2320);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(entity.crew.getName());<br/>
            r.indent();<br/>
            addReport(r);<br/>
            addReport( damageCrew(entity, 1));<br/>
            ((Report) vPhaseReport.elementAt(vPhaseReport.size() - 1)).newlines++;<br/>
        } else {<br/>
            int diceRoll = Compute.d6(2);<br/>
            r = new Report(2325);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(entity.crew.getName());<br/>
            r.add(roll.getValueAsString());<br/>
            r.add(diceRoll);<br/>
            if (diceRoll &gt;= roll.getValue()) {<br/>
                r.choose(true);<br/>
                addReport(r);<br/>
            } else {<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
                addReport( damageCrew(entity, 1));<br/>
                ((Report) vPhaseReport.elementAt(vPhaseReport.size() - 1)).newlines++;<br/>
            }<br/>
        }<br/>
<br/>
        // Now dislodge any swarming infantry.<br/>
        if ( Entity.NONE != swarmerId ) {<br/>
            final Entity swarmer = game.getEntity( swarmerId );<br/>
            entity.setSwarmAttackerId( Entity.NONE );<br/>
            swarmer.setSwarmTargetId( Entity.NONE );<br/>
            // Did the infantry fall into water?<br/>
            if ( waterDepth &gt; 0 ) {<br/>
                // Swarming infantry die.<br/>
                swarmer.setPosition( fallPos );<br/>
                r = new Report(2330);<br/>
                r.newlines = 0;<br/>
                r.subject = swarmer.getId();<br/>
                r.addDesc(swarmer);<br/>
                addReport(r);<br/>
                addReport( destroyEntity(swarmer, "a watery grave", false));<br/>
            } else {<br/>
                // Swarming infantry take an 11 point hit.<br/>
                // ASSUMPTION : damage should not be doubled.<br/>
                r = new Report(2335);<br/>
                r.newlines = 0;<br/>
                r.subject = swarmer.getId();<br/>
                r.addDesc(swarmer);<br/>
                addReport(r);<br/>
                addReport( damageEntity(swarmer, swarmer.rollHitLocation(ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT), 11));<br/>
                ((Report) vPhaseReport.elementAt(vPhaseReport.size() - 1)).newlines++;<br/>
            }<br/>
            swarmer.setPosition( fallPos );<br/>
            entityUpdate( swarmerId );<br/>
        } // End dislodge-infantry<br/>
<br/>
        // clear all PSRs after a fall -- the Mek has already failed ONE and fallen, it'd be cruel to make it fail some more!<br/>
        game.resetPSRs(entity);<br/>
    }<br/>
<br/>
    /**<br/>
     * The mech falls into an unoccupied hex from the given height above<br/>
     */<br/>
    private void doEntityFall(Entity entity, Coords fallPos, int height, PilotingRollData roll) {<br/>
        doEntityFall(entity, fallPos, height, Compute.d6(1), roll);<br/>
    }<br/>
<br/>
    /**<br/>
     * The mech falls down in place<br/>
     */<br/>
    private void doEntityFall(Entity entity, PilotingRollData roll) {<br/>
        doEntityFall(entity, entity.getPosition(), 0, roll);<br/>
    }<br/>
<br/>
    /**<br/>
     * Report:<br/>
     * - Any ammo dumps beginning the following round.<br/>
     * - Any ammo dumps that have ended with the end of this round.<br/>
     */<br/>
    private void resolveAmmoDumps() {<br/>
        Report r;<br/>
        for (Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            Entity entity = (Entity)i.nextElement();<br/>
            for (Enumeration j = entity.getAmmo(); j.hasMoreElements(); ) {<br/>
                Mounted m = (Mounted)j.nextElement();<br/>
                if (m.isPendingDump()) {<br/>
                    //report dumping next round<br/>
                    r = new Report(5110);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(m.getName());<br/>
                    addReport(r);<br/>
                    //update status<br/>
                    m.setPendingDump(false);<br/>
                    m.setDumping(true);<br/>
                }<br/>
                else if (m.isDumping()) {<br/>
                    //report finished dumping<br/>
                    r = new Report(5115);<br/>
                    r.subject = entity.getId();<br/>
                    r.addDesc(entity);<br/>
                    r.add(m.getName());<br/>
                    addReport(r);<br/>
                    //update status<br/>
                    m.setDumping(false);<br/>
                    m.setShotsLeft(0);<br/>
                }<br/>
            }<br/>
            entity.reloadEmptyWeapons();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the hex is set on fire with the specified roll.  Of<br/>
     * course, also checks to see that fire is possible in the specified hex.<br/>
     *<br/>
     * @param   hex - the &lt;code&gt;IHex&lt;/code&gt; to be lit.<br/>
     * @param   roll - the &lt;code&gt;int&lt;/code&gt; target number for the ignition roll<br/>
     * @param   bAnyTerrain - &lt;code&gt;true&lt;/code&gt; if the fire can be lit in any<br/>
     *          terrain.  If this value is &lt;code&gt;false&lt;/code&gt; the hex will be<br/>
     *          lit only if it contains Woods,jungle or a Building.<br/>
     * @param   entityId - the entityId responsible for the ignite attempt.<br/>
     *          If the value is Entity.NONE, then the roll attempt will not<br/>
     *          be included in the report.<br/>
     */<br/>
   public boolean ignite( IHex hex, int roll, boolean bAnyTerrain,<br/>
                          int entityId ) {<br/>
<br/>
        // The hex might be null due to spreadFire translation<br/>
        // goes outside of the board limit.<br/>
        if ( !game.getOptions().booleanOption("fire") || null == hex ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // The hex may already be on fire.<br/>
        if ( hex.containsTerrain( Terrains.FIRE ) ) {<br/>
            return true;<br/>
        }<br/>
<br/>
        if ( !bAnyTerrain &amp;&amp;<br/>
             !(hex.containsTerrain(Terrains.WOODS)) &amp;&amp;<br/>
             !(hex.containsTerrain(Terrains.JUNGLE)) &amp;&amp;<br/>
             !(hex.containsTerrain(Terrains.BUILDING)) ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        int fireRoll = Compute.d6(2);<br/>
        if (entityId != Entity.NONE) {<br/>
            Report r = new Report(3430);<br/>
            r.indent(3);<br/>
            r.subject = entityId;<br/>
            r.add(roll);<br/>
            r.add(fireRoll);<br/>
            addReport(r);<br/>
        }<br/>
        if (fireRoll &gt;= roll) {<br/>
            hex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.FIRE, 1));<br/>
            return true;<br/>
        } else {<br/>
            return false;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the hex is set on fire with the specified roll.  Of<br/>
     * course, also checks to see that fire is possible in the specified hex.<br/>
     * This version of the method will not report the attempt roll.<br/>
     *<br/>
     * @param   hex - the &lt;code&gt;IHex&lt;/code&gt; to be lit.<br/>
     * @param   roll - the &lt;code&gt;int&lt;/code&gt; target number for the ignition roll<br/>
     * @param   bAnyTerrain - &lt;code&gt;true&lt;/code&gt; if the fire can be lit in any<br/>
     *          terrain.  If this value is &lt;code&gt;false&lt;/code&gt; the hex will be<br/>
     *          lit only if it contains Woods, jungle or a Building.<br/>
     */<br/>
    public boolean ignite(IHex hex, int roll, boolean bAnyTerrain)  {<br/>
       return ignite(hex, roll, bAnyTerrain, Entity.NONE);<br/>
    }<br/>
<br/>
    public boolean ignite(IHex hex, int roll) {<br/>
        // default signature, assuming only woods can burn<br/>
        return ignite(hex, roll, false, Entity.NONE);<br/>
    }<br/>
<br/>
    public void removeFire(int x, int y, IHex hex) {<br/>
        Coords fireCoords = new Coords(x, y);<br/>
        hex.removeTerrain(Terrains.FIRE);<br/>
        sendChangedHex(fireCoords);<br/>
        if (!game.getOptions().booleanOption("maxtech_fire")) {<br/>
            // only remove the 3 smoke hexes if under L2 rules!<br/>
            int windDir = game.getWindDirection();<br/>
            removeSmoke(x, y, windDir);<br/>
            removeSmoke(x, y, (windDir + 1) % 6);<br/>
            removeSmoke(x, y, (windDir + 5) % 6);<br/>
        }<br/>
        //fire goes out due to lack of fuel<br/>
        Report r = new Report(5170, Report.PUBLIC);<br/>
        r.add(fireCoords.getBoardNum());<br/>
        addReport(r);<br/>
    }<br/>
<br/>
    /**<br/>
     * called when a fire is burning.  Adds smoke to hex in the direction<br/>
     * specified.  Called 3 times per fire hex<br/>
     * @param x       The &lt;code&gt;int&lt;/code&gt; x-coordinate of the hex<br/>
     * @param y       The &lt;code&gt;int&lt;/code&gt; y-coordinate of the hex<br/>
     * @param windDir The &lt;code&gt;int&lt;/code&gt; specifying the winddirection<br/>
     */<br/>
    public void addSmoke(int x, int y, int windDir) {<br/>
        Coords smokeCoords = new Coords(Coords.xInDir(x, y, windDir), Coords.yInDir(x, y, windDir));<br/>
        IHex nextHex = game.getBoard().getHex(smokeCoords);<br/>
        if (nextHex != null &amp;&amp; !(nextHex.containsTerrain(Terrains.SMOKE))) {<br/>
            nextHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.SMOKE, 1));<br/>
            sendChangedHex(smokeCoords);<br/>
            Report r = new Report(5175, Report.PUBLIC);<br/>
            r.add(smokeCoords.getBoardNum());<br/>
            addReport(r);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Add lvl3 smoke to the hex specified by the parameters. Called once.<br/>
     * @param x       The &lt;code&gt;int&lt;/code&gt; x-coordinate of the hex<br/>
     * @param y       The &lt;code&gt;int&lt;/code&gt; y-coordinate of the hex<br/>
     */<br/>
    public void addL3Smoke(int x, int y) {<br/>
        IBoard board = game.getBoard();<br/>
        Coords smokeCoords = new Coords(x, y);<br/>
        IHex smokeHex = game.getBoard().getHex(smokeCoords);<br/>
        boolean infernoBurning = board.isInfernoBurning( smokeCoords );<br/>
        Report r;<br/>
        if (smokeHex == null) {<br/>
            return;<br/>
        }<br/>
        // Have to check if it's inferno smoke or from a heavy/hardened building - heavy smoke from those<br/>
        if (infernoBurning || Building.MEDIUM &lt; smokeHex.terrainLevel(Terrains.BUILDING)) {<br/>
            if (smokeHex.terrainLevel(Terrains.SMOKE) == 2){<br/>
                //heavy smoke fills hex<br/>
                r = new Report(5180, Report.PUBLIC);<br/>
                r.add(smokeCoords.getBoardNum());<br/>
                addReport(r);<br/>
            } else {<br/>
                if (smokeHex.terrainLevel(Terrains.SMOKE) == 1){<br/>
                    //heavy smoke overrides light<br/>
                    smokeHex.removeTerrain(Terrains.SMOKE);<br/>
                }<br/>
                smokeHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.SMOKE, 2));<br/>
                sendChangedHex(smokeCoords);<br/>
                r = new Report(5185, Report.PUBLIC);<br/>
                r.add(smokeCoords.getBoardNum());<br/>
                addReport(r);<br/>
            }<br/>
        } else {<br/>
            if (smokeHex.terrainLevel(Terrains.SMOKE) == 2){<br/>
                //heavy smoke overpowers light<br/>
                r = new Report(5190, Report.PUBLIC);<br/>
                r.add(smokeCoords.getBoardNum());<br/>
                addReport(r);<br/>
            } else if (smokeHex.terrainLevel(Terrains.SMOKE) == 1){<br/>
                //light smoke continue to fill hex<br/>
                r = new Report(5195, Report.PUBLIC);<br/>
                r.add(smokeCoords.getBoardNum());<br/>
                addReport(r);<br/>
            } else {<br/>
                smokeHex.addTerrain(Terrains.getTerrainFactory().createTerrain(Terrains.SMOKE, 1));<br/>
                sendChangedHex(smokeCoords);<br/>
                //light smoke fills hex<br/>
                r = new Report(5200, Report.PUBLIC);<br/>
                r.add(smokeCoords.getBoardNum());<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    public void removeSmoke(int x, int y, int windDir) { // L2 smoke removal<br/>
        Coords smokeCoords = new Coords(Coords.xInDir(x, y, windDir), Coords.yInDir(x, y, windDir));<br/>
        IHex nextHex = game.getBoard().getHex(smokeCoords);<br/>
        if (nextHex != null &amp;&amp; nextHex.containsTerrain(Terrains.SMOKE)) {<br/>
            nextHex.removeTerrain(Terrains.SMOKE);<br/>
            sendChangedHex(smokeCoords);<br/>
            Report r = new Report(5205, Report.PUBLIC);<br/>
            r.add(smokeCoords.getBoardNum());<br/>
            addReport(r);<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Scans the boards directory for map boards of the appropriate size<br/>
     * and returns them.<br/>
     */<br/>
    private Vector scanForBoardsInDir (File dir, String addPath, int w, int h) {<br/>
        String fileList[] = dir.list();<br/>
        Vector tempList = new Vector();<br/>
        Comparator sortComp = StringUtil.stringComparator();<br/>
        for (int i = 0; i &lt; fileList.length; i++) {<br/>
            if (fileList[i].indexOf(".board") == -1) {<br/>
                continue;<br/>
            }<br/>
            if (Board.boardIsSize(addPath.concat("/").concat(fileList[i]), w, h)) {<br/>
                tempList.addElement(addPath.concat("/").concat(fileList[i].substring(0, fileList[i].lastIndexOf(".board"))));<br/>
            }<br/>
        }<br/>
        return tempList;<br/>
    }<br/>
    <br/>
    private Vector scanForBoards(int boardWidth, int boardHeight) {<br/>
        return scanForBoards (boardWidth, boardHeight, game.getOptions().booleanOption("maps_include_subdir"));<br/>
    }<br/>
    <br/>
    private Vector scanForBoards(int boardWidth, int boardHeight, boolean subdirs) {<br/>
        Vector boards = new Vector();<br/>
<br/>
        File boardDir = new File("data/boards");<br/>
        boards.addElement(MapSettings.BOARD_GENERATED);<br/>
        // just a check...<br/>
        if (!boardDir.isDirectory()) {<br/>
            return boards;<br/>
        }<br/>
<br/>
        // scan files<br/>
        String[] fileList = boardDir.list();<br/>
        Vector tempList = new Vector();<br/>
        Comparator sortComp = StringUtil.stringComparator();<br/>
        for (int i = 0; i &lt; fileList.length; i++) {<br/>
            File x = new File (new String("data/boards/").concat(fileList[i]));<br/>
            if (x.isDirectory() &amp;&amp; subdirs) {<br/>
                tempList.addAll(scanForBoardsInDir(x, fileList[i], boardWidth, boardHeight));<br/>
                continue;<br/>
            }<br/>
            if (fileList[i].indexOf(".board") == -1) {<br/>
                continue;<br/>
            }<br/>
            if (Board.boardIsSize(fileList[i], boardWidth, boardHeight)) {<br/>
                tempList.addElement(fileList[i].substring(0, fileList[i].lastIndexOf(".board")));<br/>
            }<br/>
        }<br/>
<br/>
        // if there are any boards, add these:<br/>
        if (tempList.size() &gt; 0) {<br/>
            boards.addElement( MapSettings.BOARD_RANDOM );<br/>
            boards.addElement( MapSettings.BOARD_SURPRISE );<br/>
            Collections.sort(tempList, sortComp);<br/>
            for ( int loop = 0; loop &lt; tempList.size(); loop++ ) {<br/>
                boards.addElement( tempList.elementAt(loop) );<br/>
            }<br/>
        }<br/>
<br/>
        //TODO: alphabetize files?<br/>
<br/>
        return boards;<br/>
    }<br/>
<br/>
    private boolean doBlind() {<br/>
        return (game.getOptions().booleanOption("double_blind") &amp;&amp;<br/>
        game.getPhase() &gt;= IGame.PHASE_DEPLOYMENT);<br/>
    }<br/>
<br/>
    /**<br/>
     * In a double-blind game, update only visible entities.  Otherwise,<br/>
     * update everyone<br/>
     */<br/>
    private void entityUpdate(int nEntityID) {<br/>
        entityUpdate(nEntityID, new Vector());<br/>
    }<br/>
<br/>
    private void entityUpdate(int nEntityID, Vector movePath) {<br/>
        Entity eTarget = game.getEntity(nEntityID);<br/>
        if(eTarget == null) {<br/>
            if(game.getOutOfGameEntity(nEntityID) != null) {<br/>
                System.err.printf("S: attempted to send entity update for out of game entity, id was %d\n", nEntityID);<br/>
            } else {<br/>
                System.err.printf("S: attempted to send entity update for null entity, id was %d\n", nEntityID);<br/>
            }<br/>
            return; //do not send the update it will crash the client<br/>
        }<br/>
        if (doBlind()) {<br/>
            Vector vPlayers = game.getPlayersVector();<br/>
            Vector vCanSee = whoCanSee(eTarget);<br/>
            // send an entity update to everyone who can see<br/>
            Packet pack = createEntityPacket(nEntityID, movePath);<br/>
            for (int x = 0; x &lt; vCanSee.size(); x++) {<br/>
                Player p = (Player)vCanSee.elementAt(x);<br/>
                send(p.getId(), pack);<br/>
            }<br/>
            // send an entity delete to everyone else<br/>
            pack = createRemoveEntityPacket( nEntityID,<br/>
                                             eTarget.getRemovalCondition() );<br/>
            for (int x = 0; x &lt; vPlayers.size(); x++) {<br/>
                if (!vCanSee.contains(vPlayers.elementAt(x))) {<br/>
                    Player p = (Player)vPlayers.elementAt(x);<br/>
                    send(p.getId(), pack);<br/>
                }<br/>
            }<br/>
        }<br/>
        else {<br/>
            // everyone can see<br/>
            send(createEntityPacket(nEntityID, movePath));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns a vector of which players can see this entity.<br/>
     */<br/>
    private Vector whoCanSee(Entity entity) {<br/>
        <br/>
        //Some times Null entities are sent to this<br/>
        if ( entity == null )<br/>
            return new Vector();<br/>
        <br/>
        boolean bTeamVision = game.getOptions().booleanOption("team_vision");<br/>
        Vector vEntities = game.getEntitiesVector();<br/>
<br/>
        Vector vCanSee = new Vector();<br/>
        vCanSee.addElement(entity.getOwner());<br/>
        if (bTeamVision) {<br/>
            addTeammates(vCanSee, entity.getOwner());<br/>
        }<br/>
<br/>
        for (Enumeration p = game.getPlayers(); p.hasMoreElements();) {<br/>
            Player player = (Player)p.nextElement();<br/>
<br/>
            if (player.canSeeAll() &amp;&amp; !vCanSee.contains(p))<br/>
                vCanSee.addElement(player);<br/>
        }<br/>
<br/>
        for (int i = 0; i &lt; vEntities.size(); i++) {<br/>
            Entity e = (Entity)vEntities.elementAt(i);<br/>
            if (vCanSee.contains(e.getOwner()) || !e.isActive()) {<br/>
                continue;<br/>
            }<br/>
            if(e.isOffBoard()) {<br/>
                continue; //Off board units should not spot on board units<br/>
            }<br/>
            if (Compute.canSee(game, e, entity)) {<br/>
                vCanSee.addElement(e.getOwner());<br/>
                if (bTeamVision) {<br/>
                    addTeammates(vCanSee, e.getOwner());<br/>
                }<br/>
            }<br/>
        }<br/>
        return vCanSee;<br/>
    }<br/>
<br/>
    private boolean canSee(Player p, Entity e) {<br/>
        if (e.getOwner().getId() == p.getId()) {<br/>
            //The owner of an entity should be able to see it, of course.<br/>
            return true;<br/>
        }<br/>
        Vector playersWhoCanSee = whoCanSee(e);<br/>
        for (int i = 0; i &lt; playersWhoCanSee.size(); i++) {<br/>
            Player currentPlayer = (Player)playersWhoCanSee.elementAt(i);<br/>
            if (currentPlayer.equals(p)) {<br/>
                return true;<br/>
            }<br/>
        }<br/>
<br/>
        return false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds teammates of a player to the Vector.<br/>
     * Utility function for whoCanSee.<br/>
     */<br/>
    private void addTeammates(Vector vector, Player player) {<br/>
        Vector vPlayers = game.getPlayersVector();<br/>
        for (int j = 0; j &lt; vPlayers.size(); j++) {<br/>
            Player p = (Player)vPlayers.elementAt(j);<br/>
            if (!player.isEnemyOf(p) &amp;&amp; !vector.contains(p)) {<br/>
                vector.addElement(p);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Send the complete list of entities to the players.<br/>
     * If double_blind is in effect, enforce it by filtering the entities<br/>
     */<br/>
    private void entityAllUpdate() {<br/>
        if (doBlind()) {<br/>
            Vector vPlayers = game.getPlayersVector();<br/>
            for (int x = 0; x &lt; vPlayers.size(); x++) {<br/>
                Player p = (Player)vPlayers.elementAt(x);<br/>
                send(p.getId(), createFilteredEntitiesPacket(p));<br/>
            }<br/>
        }<br/>
        else {<br/>
            send(createEntitiesPacket());<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Filters an entity vector according to LOS<br/>
     */<br/>
    private Vector filterEntities(Player pViewer, Vector vEntities) {<br/>
        Vector vCanSee = new Vector();<br/>
        Vector vAllEntities = game.getEntitiesVector();<br/>
        Vector vMyEntities = new Vector();<br/>
        boolean bTeamVision = game.getOptions().booleanOption("team_vision");<br/>
<br/>
        // If they can see all, return the input list<br/>
        if (pViewer.canSeeAll()) {<br/>
            return vEntities;<br/>
        }<br/>
<br/>
        for (int x = 0; x &lt; vAllEntities.size(); x++) {<br/>
            Entity e = (Entity)vAllEntities.elementAt(x);<br/>
            if (e.getOwner() == pViewer || (bTeamVision &amp;&amp; !e.getOwner().isEnemyOf(pViewer))) {<br/>
                vMyEntities.addElement(e);<br/>
            }<br/>
        }<br/>
<br/>
        for (int x = 0; x &lt; vEntities.size(); x++) {<br/>
            Entity e = (Entity)vEntities.elementAt(x);<br/>
            if (vMyEntities.contains(e)) {<br/>
                vCanSee.addElement(e);<br/>
                continue;<br/>
            }<br/>
            for (int y = 0; y &lt; vMyEntities.size(); y++) {<br/>
                Entity e2 = (Entity)vMyEntities.elementAt(y);<br/>
                if(e2.isOffBoard()) {<br/>
                    continue;<br/>
                }<br/>
                if (Compute.canSee(game, e2, e)) {<br/>
                    vCanSee.addElement(e);<br/>
                    break;<br/>
                }<br/>
            }<br/>
        }<br/>
        return vCanSee;<br/>
    }<br/>
<br/>
    //optimize and document me<br/>
    private Vector filterReportVector(Vector originalReportVector, Player p) {<br/>
        if (!doBlind()) {<br/>
            //don't bother filtering if double-blind rules aren't in effect<br/>
            return (Vector)originalReportVector.clone();<br/>
        }<br/>
        Vector filteredReportVector = new Vector();<br/>
        Report r;<br/>
        for (int i = 0; i &lt; originalReportVector.size(); i++) {<br/>
            r = (Report)originalReportVector.elementAt(i);<br/>
            filteredReportVector.addElement(filterReport(r, p, false));<br/>
        }<br/>
<br/>
        return filteredReportVector;<br/>
    }<br/>
<br/>
    /**<br/>
     * Filter a single report so that the correct double-blind<br/>
     * obscuration takes place.<br/>
     *<br/>
     * @param r the Report to filter<br/>
     * @param p the Player that we are going to send the filtered report to<br/>
     * @param omitCheck boolean indicating that this report hapened in<br/>
     * the past, so we no longer have access to the Player<br/>
     * @return a new Report, which has possibly been obscured<br/>
     */<br/>
    private Report filterReport(Report r, Player p, boolean omitCheck) {<br/>
        if (r.subject == Entity.NONE &amp;&amp; r.type != Report.PUBLIC) {<br/>
            //Reports that don't have a subject should be public.<br/>
            System.err.println("Error: Attempting to filter a Report object that is not public yet has no subject.\n\t\tmessageId: " + r.messageId);<br/>
            return r;<br/>
        }<br/>
        if (r.type == Report.PUBLIC || (p == null &amp;&amp; !omitCheck)) {<br/>
            return r;<br/>
        }<br/>
        Entity entity = game.getEntity(r.subject);<br/>
        Player owner = null;<br/>
        if (entity != null)<br/>
            owner = entity.getOwner();<br/>
        if (!omitCheck &amp;&amp; (entity == null || owner == null)) {<br/>
            System.err.println("Error: Attempting to filter a Report object that is not public but has a subject (" + entity + ") with owner (" + owner + ").\n\tmessageId: " + r.messageId);<br/>
            return r;<br/>
        }<br/>
        //off board (Artillery) units get treated as public messages<br/>
        if ( entity.isOffBoard() )<br/>
            return r;<br/>
        Report copy = new Report(r);<br/>
        for (int j = 0; j &lt; copy.dataCount(); j++) {<br/>
            if (omitCheck || !canSee(p, entity)) {<br/>
                if (r.isValueObscured(j)) {<br/>
                    copy.hideData(j);<br/>
                    //Mark the original report to indicate which players<br/>
                    // received an obscured version of it.<br/>
                    if (p != null)<br/>
                        r.addObscuredRecipient(p.getName());<br/>
                }<br/>
                //simulate hiding the report for *true* double-blind play<br/>
                //***DEBUG*** TESTING ONLY<br/>
                //copy.markForTesting();<br/>
            }<br/>
        }<br/>
        return copy;<br/>
    }<br/>
<br/>
    private Vector filterPastReports(Vector pastReports, Player p) {<br/>
        //This stuff really only needs to be printed for debug reasons. other wise the logs get<br/>
        //filled to the brim when ever someone connects. --Torren.<br/>
        System.err.println("filterPastReports() begin");<br/>
        System.err.println("  player is " + p.getName());<br/>
        if (doBlind()) {<br/>
            //System.err.println("  pastReports vector is\n" + pastReports);<br/>
            Vector filteredReports = new Vector();<br/>
            Vector filteredRoundReports = new Vector();<br/>
            Vector roundReports = new Vector();<br/>
            Report r;<br/>
            for (int i = 0; i &lt; pastReports.size(); i++) {<br/>
                roundReports = (Vector)pastReports.elementAt(i);<br/>
                //System.err.println("  roundReports vector is\n" + roundReports);<br/>
                for (int j = 0; j &lt; roundReports.size(); j++) {<br/>
                    r = (Report)roundReports.elementAt(j);<br/>
                    if (r.isObscuredRecipient(p.getName())) {<br/>
                        //System.err.println("  report is " + r + " -obscuring-");<br/>
                        filteredRoundReports.addElement(filterReport(r, null, true));<br/>
                    } else {<br/>
                        //System.err.println("  report is " + r);<br/>
                        filteredRoundReports.addElement(r);<br/>
                    }<br/>
                }<br/>
                //System.err.println("  filteredRoundReport is\n" + filteredRoundReports);<br/>
                filteredReports.addElement(filteredRoundReports.clone());<br/>
                filteredRoundReports.removeAllElements();<br/>
            }<br/>
            System.err.println("filterPastReports() end");<br/>
            return filteredReports;<br/>
        } else {<br/>
            //don't bother filtering if double-blind rules aren't in effect<br/>
            System.err.println("filterPastReports() end");<br/>
            return pastReports;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Updates entities graphical "visibility indications" which are used<br/>
     *  in double-blind games.<br/>
     */<br/>
    private void updateVisibilityIndicator() {<br/>
        Vector vAllEntities = game.getEntitiesVector();<br/>
        for (int x = 0; x &lt; vAllEntities.size(); x++) {<br/>
            Entity e = (Entity)vAllEntities.elementAt(x);<br/>
            boolean previousVisibleValue = e.isVisibleToEnemy();<br/>
            boolean previousSeenValue = e.isSeenByEnemy();<br/>
            e.setVisibleToEnemy(false);<br/>
            Vector vCanSee = whoCanSee(e);<br/>
            for (int y = 0; y &lt; vCanSee.size(); y++) {<br/>
                Player p = (Player)vCanSee.elementAt(y);<br/>
                if (e.getOwner().isEnemyOf(p) &amp;&amp; !p.isObserver()) {<br/>
                    e.setVisibleToEnemy(true);<br/>
                    e.setSeenByEnemy(true);<br/>
                }<br/>
            }<br/>
            if (previousVisibleValue != e.isVisibleToEnemy()<br/>
                || previousSeenValue != e.isSeenByEnemy()) {<br/>
                sendVisibilityIndicator(e);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks if an entity added by the client is valid and if so, adds it to the list<br/>
     */<br/>
    private void receiveEntityAdd(Packet c, int connIndex) {<br/>
        final Entity entity = (Entity)c.getObject(0);<br/>
<br/>
        //Verify the entity's design<br/>
        if (Server.entityVerifier == null)<br/>
            Server.entityVerifier = new EntityVerifier(new File(VERIFIER_CONFIG_FILENAME));<br/>
        // we can only test meks and vehicles right now<br/>
        if (entity instanceof Mech || entity instanceof Tank) {<br/>
            TestEntity testEntity = null;<br/>
            entity.restore();<br/>
            if (entity instanceof Mech)<br/>
                testEntity = new TestMech((Mech)entity, Server.entityVerifier.mechOption, null);<br/>
            if (entity instanceof VTOL)<br/>
                testEntity = new TestTank((Tank)entity, Server.entityVerifier.tankOption, null);//not implemented yet.<br/>
            if (entity instanceof Tank)<br/>
                testEntity = new TestTank((Tank)entity, Server.entityVerifier.tankOption, null);<br/>
            StringBuffer sb = new StringBuffer();<br/>
            if (testEntity.correctEntity(sb, !game.getOptions().booleanOption("is_eq_limits"))) {<br/>
                entity.setDesignValid(true);<br/>
            } else {<br/>
                if (game.getOptions().booleanOption("allow_illegal_units")) {<br/>
                    entity.setDesignValid(false);<br/>
                } else {<br/>
                    Player cheater = game.getPlayer( connIndex );<br/>
                    sendServerChat("Player " + cheater.getName() + " attempted to add an illegal unit design (" + entity.getShortNameRaw() + "), the unit was rejected.");<br/>
                    System.err.println(sb);<br/>
                    return;<br/>
                }<br/>
            }<br/>
        }<br/>
<br/>
        // If we're adding a Protomech, calculate it's unit number.<br/>
        if ( entity instanceof Protomech ) {<br/>
<br/>
            // How many Protomechs does the player already have?<br/>
            int numPlayerProtos = game.getSelectedEntityCount<br/>
                ( new EntitySelector() {<br/>
                        private final int ownerId = entity.getOwnerId();<br/>
                        public boolean accept( Entity entity ) {<br/>
                            if ( entity instanceof Protomech &amp;&amp;<br/>
                                 ownerId == entity.getOwnerId() )<br/>
                                return true;<br/>
                            return false;<br/>
                        }<br/>
                    } );<br/>
<br/>
            // According to page 54 of the BMRr, Protomechs must be<br/>
            // deployed in full Points of five, unless circumstances have<br/>
            // reduced the number to less that that.<br/>
            entity.setUnitNumber( (char) (numPlayerProtos / 5) );<br/>
<br/>
        } // End added-Protomech<br/>
<br/>
        // Only assign an entity ID when the client hasn't.<br/>
        if ( Entity.NONE == entity.getId() ) {<br/>
            entity.setId(getFreeEntityId());<br/>
        }<br/>
<br/>
        game.addEntity(entity.getId(), entity);<br/>
        send(createAddEntityPacket(entity.getId()));<br/>
    }<br/>
<br/>
    /**<br/>
     * Updates an entity with the info from the client.  Only valid to do this<br/>
     * during the lounge phase, except for heat sink changing.<br/>
     */<br/>
    private void receiveEntityUpdate(Packet c, int connIndex) {<br/>
        Entity entity = (Entity)c.getObject(0);<br/>
        Entity oldEntity = game.getEntity(entity.getId());<br/>
        if (oldEntity != null &amp;&amp; oldEntity.getOwner() == getPlayer(connIndex)) {<br/>
            game.setEntity(entity.getId(), entity);<br/>
            entityUpdate(entity.getId());<br/>
            // In the chat lounge, notify players of customizing of unit<br/>
            if (game.getPhase() == IGame.PHASE_LOUNGE) {<br/>
                StringBuffer message = new StringBuffer();<br/>
                message.append( "Unit " );<br/>
                if(game.getOptions().booleanOption("blind_drop")<br/>
                    || game.getOptions().booleanOption("real_blind_drop")) {<br/>
                    if(Entity.NONE != entity.getExternalId()) {<br/>
                        message.append("[").append(entity.getExternalId()).append("] ");<br/>
                    }<br/>
                    message.append(entity.getId())<br/>
                        .append("(")<br/>
                        .append(entity.getOwner().getName())<br/>
                        .append(")");<br/>
                } else {<br/>
                    message.append( entity.getDisplayName() );<br/>
                }<br/>
                message.append( " has been customized." );<br/>
                sendServerChat( message.toString() );<br/>
            }<br/>
        } else {<br/>
            // hey!<br/>
        }<br/>
    }<br/>
<br/>
    private void receiveEntityModeChange(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        int equipId = c.getIntValue(1);<br/>
        int mode = c.getIntValue(2);<br/>
        Entity e = game.getEntity(entityId);<br/>
        if (e.getOwner() != getPlayer(connIndex)) {<br/>
            return;<br/>
        }<br/>
        Mounted m = e.getEquipment(equipId);<br/>
<br/>
        // a mode change for ammo means dumping<br/>
        if (m.getType() instanceof AmmoType<br/>
            &amp;&amp; !(m.getType().hasInstantModeSwitch())) {<br/>
            m.setPendingDump(mode == 1);<br/>
        }<br/>
        else {<br/>
            m.setMode(mode);<br/>
        }<br/>
    }<br/>
<br/>
    private void receiveEntitySystemModeChange(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        int equipId = c.getIntValue(1);<br/>
        int mode = c.getIntValue(2);<br/>
        Entity e = game.getEntity(entityId);<br/>
        if (e.getOwner() != getPlayer(connIndex)) {<br/>
            return;<br/>
        }<br/>
        if(e instanceof Mech &amp;&amp; equipId == Mech.SYSTEM_COCKPIT) {<br/>
            ((Mech)e).setCockpitStatus(mode);<br/>
        }<br/>
    }<br/>
<br/>
    private void receiveEntityAmmoChange(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        int weaponId = c.getIntValue(1);<br/>
        int ammoId = c.getIntValue(2);<br/>
        Entity e = game.getEntity(entityId);<br/>
<br/>
        // Did we receive a request for a valid Entity?<br/>
        if ( null == e ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: could not find entity #" );<br/>
            System.err.println( entityId );<br/>
            return;<br/>
        }<br/>
        Player player = getPlayer( connIndex );<br/>
        if ( null != player &amp;&amp; e.getOwner() != player ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: player " );<br/>
            System.err.print( player.getName() );<br/>
            System.err.print( " does not own the entity " );<br/>
            System.err.println( e.getDisplayName() );<br/>
            return;<br/>
        }<br/>
<br/>
        // Make sure that the entity has the given equipment.<br/>
        Mounted mWeap = e.getEquipment(weaponId);<br/>
        Mounted mAmmo = e.getEquipment(ammoId);<br/>
        if ( null == mAmmo ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " does not have ammo #" );<br/>
            System.err.println( ammoId );<br/>
            return;<br/>
        }<br/>
        if ( !(mAmmo.getType() instanceof AmmoType) ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: item # " );<br/>
            System.err.print( ammoId );<br/>
            System.err.print( " of entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " is a " );<br/>
            System.err.print( mAmmo.getName() );<br/>
            System.err.println( " and not ammo." );<br/>
            return;<br/>
        }<br/>
        if ( null == mWeap ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " does not have weapon #" );<br/>
            System.err.println( weaponId );<br/>
            return;<br/>
        }<br/>
        if ( !(mWeap.getType() instanceof WeaponType) ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: item # " );<br/>
            System.err.print( weaponId );<br/>
            System.err.print( " of entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " is a " );<br/>
            System.err.print( mWeap.getName() );<br/>
            System.err.println( " and not a weapon." );<br/>
            return;<br/>
        }<br/>
        if ( ((WeaponType) mWeap.getType()).getAmmoType() == AmmoType.T_NA ) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: item # " );<br/>
            System.err.print( weaponId );<br/>
            System.err.print( " of entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " is a " );<br/>
            System.err.print( mWeap.getName() );<br/>
            System.err.println( " and does not use ammo." );<br/>
            return;<br/>
        }<br/>
        if ( ((WeaponType) mWeap.getType()).hasFlag(WeaponType.F_ONESHOT)) {<br/>
            System.err.print<br/>
                ( "Server.receiveEntityAmmoChange: item # " );<br/>
            System.err.print( weaponId );<br/>
            System.err.print( " of entity " );<br/>
            System.err.print( e.getDisplayName() );<br/>
            System.err.print( " is a " );<br/>
            System.err.print( mWeap.getName() );<br/>
            System.err.println( " and cannot use external ammo." );<br/>
            return;<br/>
        }<br/>
<br/>
        // Load the weapon.<br/>
        e.loadWeapon( mWeap, mAmmo );<br/>
    }<br/>
<br/>
    /**<br/>
     * Deletes an entity owned by a certain player from the list<br/>
     */<br/>
    private void receiveEntityDelete(Packet c, int connIndex) {<br/>
        int entityId = c.getIntValue(0);<br/>
        final Entity entity = game.getEntity(entityId);<br/>
<br/>
        // Only allow players to delete their *own* entities.<br/>
        if ( entity != null &amp;&amp; entity.getOwner() == getPlayer(connIndex) ) {<br/>
<br/>
            // If we're deleting a Protomech, recalculate unit numbers.<br/>
            if ( entity instanceof Protomech ) {<br/>
<br/>
                // How many Protomechs does the player have (include this one)?<br/>
                int numPlayerProtos = game.getSelectedEntityCount<br/>
                    ( new EntitySelector() {<br/>
                            private final int ownerId = entity.getOwnerId();<br/>
                            public boolean accept( Entity entity ) {<br/>
                                if ( entity instanceof Protomech &amp;&amp;<br/>
                                     ownerId == entity.getOwnerId() )<br/>
                                    return true;<br/>
                                return false;<br/>
                            }<br/>
                        } );<br/>
<br/>
                // According to page 54 of the BMRr, Protomechs must be<br/>
                // deployed in full Points of five, unless "losses" have<br/>
                // reduced the number to less that that.<br/>
                final char oldMax =<br/>
                    (char)(Math.ceil( numPlayerProtos / 5.0 )-1);<br/>
                char newMax =<br/>
                    (char)(Math.ceil( (numPlayerProtos-1)/ 5.0 )-1);<br/>
                char deletedUnitNum = entity.getUnitNumber();<br/>
<br/>
                // Do we have to update a Protomech from the last unit?<br/>
                if ( oldMax != deletedUnitNum &amp;&amp; oldMax != newMax ) {<br/>
<br/>
                    // Yup.  Find a Protomech from the last unit, and<br/>
                    // set it's unit number to the deleted entity.<br/>
                    Enumeration lastUnit = game.getSelectedEntities<br/>
                        ( new EntitySelector() {<br/>
                            private final int ownerId = entity.getOwnerId();<br/>
                            private final char lastUnitNum = oldMax;<br/>
                            public boolean accept( Entity entity ) {<br/>
                                if ( entity instanceof Protomech &amp;&amp;<br/>
                                     ownerId == entity.getOwnerId() &amp;&amp;<br/>
                                     lastUnitNum == entity.getUnitNumber() )<br/>
                                    return true;<br/>
                                return false;<br/>
                            }<br/>
                        } );<br/>
                    Entity lastUnitMember = (Entity) lastUnit.nextElement();<br/>
                    lastUnitMember.setUnitNumber( deletedUnitNum );<br/>
                    this.entityUpdate( lastUnitMember.getId() );<br/>
<br/>
                } // End update-unit-numbetr<br/>
<br/>
            } // End added-Protomech<br/>
<br/>
            game.removeEntity(entityId, IEntityRemovalConditions.REMOVE_NEVER_JOINED);<br/>
            send(createRemoveEntityPacket(entityId, IEntityRemovalConditions.REMOVE_NEVER_JOINED));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets a player's ready status<br/>
     */<br/>
    private void receivePlayerDone(Packet pkt, int connIndex) {<br/>
        boolean ready = pkt.getBooleanValue(0);<br/>
        Player player = getPlayer(connIndex);<br/>
        if ( null != player ) {<br/>
            player.setDone(ready);<br/>
        }<br/>
    }<br/>
<br/>
    private void receiveInitiativeRerollRequest(Packet pkt, int connIndex) {<br/>
        Player player = getPlayer(connIndex);<br/>
        if ( IGame.PHASE_INITIATIVE_REPORT != game.getPhase() ) {<br/>
            StringBuffer message = new StringBuffer();<br/>
            if ( null == player ) {<br/>
                message.append( "Player #" )<br/>
                    .append( connIndex );<br/>
            } else {<br/>
                message.append( player.getName() );<br/>
            }<br/>
            message.append( " is not allowed to ask for a reroll at this time." );<br/>
            System.err.println( message.toString() );<br/>
            sendServerChat( message.toString() );<br/>
            return;<br/>
        }<br/>
        if (game.hasTacticalGenius(player)) {<br/>
            game.addInitiativeRerollRequest(game.getTeamForPlayer(player));<br/>
        }<br/>
        if ( null != player ) {<br/>
            player.setDone(true);<br/>
        }<br/>
        checkReady();<br/>
    }<br/>
<br/>
    /**<br/>
     * Sets game options, providing that the player has specified the password<br/>
     * correctly.<br/>
     *<br/>
     * @return true if any options have been successfully changed.<br/>
     */<br/>
    private boolean receiveGameOptions(Packet packet, int connId) {<br/>
        Player player = game.getPlayer( connId );<br/>
        // Check player<br/>
        if ( null == player ) {<br/>
            System.err.print<br/>
                ( "Server does not recognize player at connection " );<br/>
            System.err.println( connId );<br/>
            return false;<br/>
        }<br/>
<br/>
        // check password<br/>
        if (password != null &amp;&amp; password.length() &gt; 0 &amp;&amp; !password.equals(packet.getObject(0))) {<br/>
            sendServerChat(connId, "The password you specified to change game options is incorrect.");<br/>
            return false;<br/>
        }<br/>
<br/>
        int changed = 0;<br/>
<br/>
        for (Enumeration i = ((Vector)packet.getObject(1)).elements(); i.hasMoreElements();) {<br/>
            IBasicOption option = (IBasicOption)i.nextElement();<br/>
            IOption originalOption = game.getOptions().getOption(option.getName());<br/>
<br/>
            if (originalOption == null) {<br/>
                continue;<br/>
            }<br/>
<br/>
            StringBuffer message = new StringBuffer();<br/>
            message.append( "Player " )<br/>
                .append( player.getName() )<br/>
                .append( " changed option \"" )<br/>
                .append( originalOption.getDisplayableName() )<br/>
                .append( "\" to " )<br/>
                .append( option.getValue().toString() )<br/>
                .append( "." );<br/>
            sendServerChat( message.toString() );<br/>
            originalOption.setValue(option.getValue());<br/>
            changed++;            <br/>
        }<br/>
<br/>
        // Set proper RNG<br/>
        Compute.setRNG(game.getOptions().intOption("rng_type"));<br/>
<br/>
        return changed &gt; 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Performs the additional processing of the received options after the the <br/>
     * &lt;code&gt;receiveGameOptions&lt;code&gt; done its job; should be called after<br/>
     * &lt;code&gt;receiveGameOptions&lt;code&gt; only if the &lt;code&gt;receiveGameOptions&lt;code&gt; <br/>
     * returned &lt;code&gt;true&lt;/code&gt;    <br/>
     * @param packet<br/>
     * @param connId<br/>
     */<br/>
    private void receiveGameOptionsAux(Packet packet, int connId) {<br/>
<br/>
        for (Enumeration i = ((Vector)packet.getObject(1)).elements(); i.hasMoreElements();) {<br/>
            IBasicOption option = (IBasicOption)i.nextElement();<br/>
            IOption originalOption = game.getOptions().getOption(option.getName());<br/>
            if (originalOption != null) {<br/>
                if ("maps_include_subdir".equals(originalOption.getName())) {<br/>
                    mapSettings.setBoardsAvailableVector(scanForBoards(mapSettings.getBoardWidth(), mapSettings.getBoardHeight()));<br/>
                    mapSettings.removeUnavailable();<br/>
                    mapSettings.setNullBoards(DEFAULT_BOARD);<br/>
                    send(createMapSettingsPacket());                                    <br/>
                }<br/>
            }<br/>
        }<br/>
        <br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out all player info to the specified connection<br/>
     */<br/>
    private void transmitAllPlayerConnects(int connId) {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            send(connId, createPlayerConnectPacket(player.getId()));<br/>
        }<br/>
    }<br/>
<br/>
<br/>
<br/>
    /**<br/>
     * Creates a packet informing that the player has connected<br/>
     */<br/>
    private Packet createPlayerConnectPacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_ADD, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the player info, for update<br/>
     */<br/>
    private Packet createPlayerUpdatePacket(int playerId) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = getPlayer(playerId);<br/>
        return new Packet(Packet.COMMAND_PLAYER_UPDATE, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out the player info updates for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerUpdates() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
            if ( null != player ) {<br/>
                send(createPlayerUpdatePacket(player.getId()));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends out the player ready stats for all players to all connections<br/>
     */<br/>
    private void transmitAllPlayerDones() {<br/>
        for (Enumeration i = game.getPlayers(); i.hasMoreElements();) {<br/>
            final Player player = (Player)i.nextElement();<br/>
<br/>
            send(createPlayerDonePacket(player.getId()));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the player ready status<br/>
     */<br/>
    private Packet createPlayerDonePacket(int playerId) {<br/>
        Object[] data = new Object[2];<br/>
        data[0] = new Integer(playerId);<br/>
        data[1] = new Boolean(getPlayer(playerId).isDone());<br/>
        return new Packet(Packet.COMMAND_PLAYER_READY, data);<br/>
    }<br/>
<br/>
    /** Creates a packet containing the current turn vector */<br/>
    private Packet createTurnVectorPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_TURNS, game.getTurnVector());<br/>
    }<br/>
<br/>
    /** Creates a packet containing the current turn index */<br/>
    private Packet createTurnIndexPacket() {<br/>
        return new Packet(Packet.COMMAND_TURN, new Integer(game.getTurnIndex()));<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the map settings<br/>
     */<br/>
    private Packet createMapSettingsPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_MAP_SETTINGS, mapSettings);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing temporary map settings as a response to a<br/>
     * client query<br/>
     */<br/>
    private Packet createMapQueryPacket(MapSettings temp) {<br/>
        return new Packet(Packet.COMMAND_QUERY_MAP_SETTINGS, temp);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the game settingss<br/>
     */<br/>
    private Packet createGameSettingsPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_GAME_SETTINGS, game.getOptions());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing the game board<br/>
     */<br/>
    private Packet createBoardPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_BOARD, game.getBoard());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a single entity, for update<br/>
     */<br/>
    private Packet createEntityPacket(int entityId) {<br/>
        return createEntityPacket(entityId, new Vector());<br/>
    }<br/>
    private Packet createEntityPacket(int entityId, Vector movePath) {<br/>
        final Entity entity = game.getEntity(entityId);<br/>
        final Object[] data = new Object[3];<br/>
        data[0] = new Integer(entityId);<br/>
        data[1] = entity;<br/>
        data[2] = movePath;<br/>
        return new Packet(Packet.COMMAND_ENTITY_UPDATE, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a Vector of Reports<br/>
     */<br/>
    private Packet createReportPacket(Player p) {<br/>
        //when the final report is created MM sends a null player to create the <br/>
        //report so this will handel that issue.<br/>
        if ( p == null || !doBlind() )<br/>
            return new Packet(Packet.COMMAND_SENDING_REPORTS, filterReportVector(vPhaseReport, p));<br/>
        else<br/>
            return new Packet(Packet.COMMAND_SENDING_REPORTS, p.getTurnReport());   <br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a Vector of special Reports which<br/>
     * needs to be sent during a phase that is not a report phase.<br/>
     */<br/>
    private Packet createSpecialReportPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_REPORTS_SPECIAL, vPhaseReport.clone());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a Vector of Reports that represent<br/>
     * a Tactical Genius re-roll request which needs to update a<br/>
     * current phase's report.<br/>
     */<br/>
    private Packet createTacticalGeniusReportPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_REPORTS_TACTICAL_GENIUS, vPhaseReport.clone());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all the round reports<br/>
     */<br/>
    private Packet createAllReportsPacket(Player p) {<br/>
        return new Packet(Packet.COMMAND_SENDING_REPORTS_ALL, filterPastReports(game.getAllReports(), p));<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all current entities<br/>
     */<br/>
    private Packet createEntitiesPacket() {<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, game.getEntitiesVector());<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all current and out-of-game entities<br/>
     */<br/>
    private Packet createFullEntitiesPacket() {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = game.getEntitiesVector();<br/>
        data[1] = game.getOutOfGameEntitiesVector();<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all entities visible to the player in a blind game<br/>
     */<br/>
    private Packet createFilteredEntitiesPacket(Player p) {<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, filterEntities(p, game.getEntitiesVector()));<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing all entities, including wrecks, visible to the player in a blind game<br/>
     */<br/>
    private Packet createFilteredFullEntitiesPacket(Player p) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = filterEntities(p, game.getEntitiesVector());<br/>
        data[1] = game.getOutOfGameEntitiesVector();<br/>
        return new Packet(Packet.COMMAND_SENDING_ENTITIES, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet detailing the addition of an entity<br/>
     */<br/>
    private Packet createAddEntityPacket(int entityId) {<br/>
        final Entity entity = game.getEntity(entityId);<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = new Integer(entityId);<br/>
        data[1] = entity;<br/>
        return new Packet(Packet.COMMAND_ENTITY_ADD, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet detailing the removal of an entity.<br/>
     * Maintained for backwards compatability.<br/>
     *<br/>
     * @param   entityId - the &lt;code&gt;int&lt;/code&gt; ID of the entity being removed.<br/>
     * @return  A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.<br/>
     */<br/>
    private Packet createRemoveEntityPacket(int entityId) {<br/>
        return this.createRemoveEntityPacket(entityId, IEntityRemovalConditions.REMOVE_SALVAGEABLE);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet detailing the removal of an entity.<br/>
     *<br/>
     * @param   entityId - the &lt;code&gt;int&lt;/code&gt; ID of the entity being removed.<br/>
     * @param   condition - the &lt;code&gt;int&lt;/code&gt; condition the unit was in.<br/>
     *          This value must be one of &lt;code&gt;Game.UNIT_IN_RETREAT&lt;/code&gt;,<br/>
     *          &lt;code&gt;Game.UNIT_PUSHED&lt;/code&gt;, or<br/>
     *          &lt;code&gt;Game.UNIT_SALVAGEABLE&lt;/code&gt;, or<br/>
     *          &lt;code&gt;Game.UNIT_EJECTED&lt;/code&gt;, or<br/>
     *          &lt;code&gt;Game.UNIT_DEVASTATED&lt;/code&gt; or an<br/>
     *          &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.<br/>
     * @return  A &lt;code&gt;Packet&lt;/code&gt; to be sent to clients.<br/>
     */<br/>
    private Packet createRemoveEntityPacket(int entityId, int condition) {<br/>
        if ( condition != IEntityRemovalConditions.REMOVE_UNKNOWN &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_IN_RETREAT &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_PUSHED &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_SALVAGEABLE &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_EJECTED &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_CAPTURED &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_DEVASTATED &amp;&amp;<br/>
             condition != IEntityRemovalConditions.REMOVE_NEVER_JOINED ) {<br/>
            throw new IllegalArgumentException( "Unknown unit condition: " +<br/>
                                                condition );<br/>
        }<br/>
        Object[] array = new Object[2];<br/>
        array[0] = new Integer(entityId);<br/>
        array[1] = new Integer(condition);<br/>
        return new Packet(Packet.COMMAND_ENTITY_REMOVE, array);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet indicating end of game, including detailed unit status<br/>
     */<br/>
    private Packet createEndOfGamePacket() {<br/>
        Object[] array = new Object[3];<br/>
        array[0] = getDetailedVictoryReport();<br/>
        array[1] = new Integer(game.getVictoryPlayerId());<br/>
        array[2] = new Integer(game.getVictoryTeam());<br/>
        return new Packet(Packet.COMMAND_END_OF_GAME, array);<br/>
    }<br/>
<br/>
    /**<br/>
     * Transmits a chat message to all players<br/>
     */<br/>
    private void sendChat(int connId, String origin, String message) {<br/>
        send(connId, new Packet(Packet.COMMAND_CHAT, origin + ": " + message));<br/>
    }<br/>
<br/>
    /**<br/>
     * Transmits a chat message to all players<br/>
     */<br/>
    private void sendChat(String origin, String message) {<br/>
        String chat = origin + ": " + message;<br/>
        send(new Packet(Packet.COMMAND_CHAT, chat));<br/>
    }<br/>
<br/>
    public void sendServerChat(int connId, String message) {<br/>
        sendChat(connId, "***Server", message);<br/>
    }<br/>
<br/>
    public void sendServerChat(String message) {<br/>
        sendChat("***Server", message);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing a hex, and the coordinates it goes at.<br/>
     */<br/>
    private Packet createHexChangePacket(Coords coords, IHex hex) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = coords;<br/>
        data[1] = hex;<br/>
        return new Packet(Packet.COMMAND_CHANGE_HEX, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Sends notification to clients that the specified hex has changed.<br/>
     */<br/>
    public void sendChangedHex(Coords coords) {<br/>
        send(createHexChangePacket(coords, game.getBoard().getHex(coords)));<br/>
    }<br/>
<br/>
    public void sendVisibilityIndicator(Entity e) {<br/>
        final Object[] data = new Object[3];<br/>
        data[0] = new Integer(e.getId());<br/>
        data[1] = new Boolean(e.isSeenByEnemy());<br/>
        data[2] = new Boolean(e.isVisibleToEnemy());<br/>
        send(new Packet(Packet.COMMAND_ENTITY_VISIBILITY_INDICATOR, data));<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet for an attack<br/>
     */<br/>
    private Packet createAttackPacket(Vector vector, int charges) {<br/>
        final Object[] data = new Object[2];<br/>
        data[0] = vector;<br/>
        data[1] = new Integer(charges);<br/>
        return new Packet(Packet.COMMAND_ENTITY_ATTACK, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet for an attack<br/>
     */<br/>
    private Packet createAttackPacket(EntityAction ea, int charge) {<br/>
        Vector vector = new Vector(1);<br/>
        vector.addElement(ea);<br/>
        Object[] data = new Object[2];<br/>
        data[0] = vector;<br/>
        data[1] = new Integer(charge);<br/>
        return new Packet(Packet.COMMAND_ENTITY_ATTACK, data);<br/>
    }<br/>
<br/>
    /**<br/>
     * Creates a packet containing offboard artillery attacks<br/>
     **/<br/>
    private Packet createArtilleryPacket(Player p) {<br/>
        <br/>
        if(p.getSeeAll()) {<br/>
            return new Packet(Packet.COMMAND_SENDING_ARTILLERYATTACKS, game.getArtilleryVector());<br/>
        }<br/>
        Vector v = new Vector();<br/>
        int team = p.getTeam();<br/>
        for(Enumeration i = game.getArtilleryAttacks();i.hasMoreElements();) {<br/>
            ArtilleryAttackAction aaa = (ArtilleryAttackAction)i.nextElement();<br/>
            if(aaa.getPlayerId() == p.getId() ||<br/>
                    (team != Player.TEAM_NONE &amp;&amp; team == game.getPlayer(aaa.getPlayerId()).getTeam())) {<br/>
                v.addElement(aaa);<br/>
            }<br/>
        }<br/>
        return new Packet(Packet.COMMAND_SENDING_ARTILLERYATTACKS, v);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Creates a packet containing flares<br/>
     **/<br/>
    private Packet createFlarePacket() {<br/>
        <br/>
        return new Packet(Packet.COMMAND_SENDING_FLARES, game.getFlares());<br/>
    }<br/>
    <br/>
    /**<br/>
     * Send a packet to all connected clients.<br/>
     */<br/>
    private void send(Packet packet) {<br/>
        if (connections == null) {<br/>
            return;<br/>
        }<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            conn.send(packet);<br/>
        }<br/>
    }<br/>
<br/>
    private void sendReport() {<br/>
        sendReport(false);<br/>
    }<br/>
<br/>
    /**<br/>
     * Send the round report to all connected clients.<br/>
     */<br/>
    private void sendReport(boolean tacticalGeniusReport) {<br/>
        if (connections == null) {<br/>
            return;<br/>
        }<br/>
<br/>
        for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
            final Connection conn = (Connection)i.nextElement();<br/>
            Player p = game.getPlayer(conn.getId());<br/>
            Packet packet;<br/>
            if (tacticalGeniusReport)<br/>
                packet = createTacticalGeniusReportPacket();<br/>
            else<br/>
                packet = createReportPacket(p);<br/>
            conn.send(packet);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Send a packet to a specific connection.<br/>
     */<br/>
    private void send(int connId, Packet packet) {<br/>
        if (getClient(connId) != null) {<br/>
            getClient(connId).send(packet);<br/>
        } else {<br/>
            //What should we do if we've lost this client?<br/>
            // For now, nothing.<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Send a packet to a pending connection<br/>
     */<br/>
    private void sendToPending(int connId, Packet packet) {<br/>
        if (getPendingConnection(connId) != null) {<br/>
            getPendingConnection(connId).send(packet);<br/>
        } else {<br/>
            //What should we do if we've lost this client?<br/>
            // For now, nothing.<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Process an in-game command<br/>
     */<br/>
    private void processCommand(int connId, String commandString) {<br/>
        String[] args;<br/>
        String commandName;<br/>
        // all tokens are read as strings; if they're numbers, string-ize 'em.<br/>
        StringTokenizer st = new StringTokenizer(commandString);<br/>
        args = new String[st.countTokens()];<br/>
        for (int i = 0; i &lt; args.length; i++) {<br/>
            args[i] = st.nextToken();<br/>
        }<br/>
<br/>
        // figure out which command this is<br/>
        commandName = args[0].substring(1);<br/>
<br/>
        // process it<br/>
        ServerCommand command = getCommand(commandName);<br/>
        if (command != null) {<br/>
            command.run(connId, args);<br/>
        } else {<br/>
            sendServerChat(connId, "Command not recognized.  Type /help for a list of commands.");<br/>
        }<br/>
    }<br/>
<br/>
    // Easter eggs.  Happy April Fool's Day!!<br/>
    private static final String DUNE_CALL = "They tried and failed?";<br/>
    private static final String DUNE_RESPONSE = "They tried and died!";<br/>
    private static final String STAR_WARS_CALL = "I'd just as soon kiss a Wookiee.";<br/>
    private static final String STAR_WARS_RESPONSE = "I can arrange that!";<br/>
<br/>
    /**<br/>
     * Process a packet from a connection.<br/>
     *<br/>
     * @param   id - the &lt;code&gt;int&lt;/code&gt; ID the connection that<br/>
     *          received the packet.<br/>
     * @param   packet - the &lt;code&gt;Packet&lt;/code&gt; to be processed.<br/>
     */<br/>
    protected synchronized void handle(int connId, Packet packet) {<br/>
        Player player = game.getPlayer( connId );<br/>
        // Check player.  Please note, the connection may be pending.<br/>
        if ( null == player &amp;&amp; null == getPendingConnection(connId) ) {<br/>
            System.err.print<br/>
                ( "Server does not recognize player at connection " );<br/>
            System.err.println( connId );<br/>
            return;<br/>
        }<br/>
<br/>
        //System.out.println("s(" + cn + "): received command");<br/>
        if (packet == null) {<br/>
            System.out.println("server.connection.handle: got null packet");<br/>
            return;<br/>
        }<br/>
        // act on it<br/>
        switch(packet.getCommand()) {<br/>
            case Packet.COMMAND_CLOSE_CONNECTION :<br/>
                // We have a client going down!<br/>
                Connection c = getConnection(connId);<br/>
                if ( c!= null) {<br/>
                    c.close();<br/>
                }<br/>
                break;<br/>
            case Packet.COMMAND_CLIENT_NAME :<br/>
                receivePlayerName(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_UPDATE :<br/>
                receivePlayerInfo(packet, connId);<br/>
                validatePlayerInfo(connId);<br/>
                send(createPlayerUpdatePacket(connId));<br/>
                break;<br/>
            case Packet.COMMAND_PLAYER_READY :<br/>
                receivePlayerDone(packet, connId);<br/>
                send(createPlayerDonePacket(connId));<br/>
                checkReady();<br/>
                break;<br/>
            case Packet.COMMAND_REROLL_INITIATIVE :<br/>
                receiveInitiativeRerollRequest(packet, connId);<br/>
                send(createPlayerDonePacket(connId));<br/>
                break;<br/>
            case Packet.COMMAND_CHAT :<br/>
                String chat = (String)packet.getObject(0);<br/>
                if (chat.startsWith("/")) {<br/>
                    processCommand(connId, chat);<br/>
                } else {<br/>
                    sendChat(player.getName(), chat);<br/>
                }<br/>
                // Easter eggs.  Happy April Fool's Day!!<br/>
                if ( DUNE_CALL.equals(chat) ) {<br/>
                    sendServerChat( DUNE_RESPONSE );<br/>
                }<br/>
                else if ( STAR_WARS_CALL.equals(chat) ) {<br/>
                    sendServerChat( STAR_WARS_RESPONSE );<br/>
                }<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_MOVE :<br/>
                receiveMovement(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_DEPLOY :<br/>
                receiveDeployment(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_DEPLOY_MINEFIELDS :<br/>
                receiveDeployMinefields(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ATTACK :<br/>
                receiveAttack(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_ADD :<br/>
                receiveEntityAdd(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_UPDATE :<br/>
                receiveEntityUpdate(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_MODECHANGE :<br/>
                receiveEntityModeChange(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_SYSTEMMODECHANGE :<br/>
                receiveEntitySystemModeChange(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_AMMOCHANGE :<br/>
                receiveEntityAmmoChange(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_ENTITY_REMOVE :<br/>
                receiveEntityDelete(packet, connId);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                break;<br/>
            case Packet.COMMAND_SENDING_GAME_SETTINGS :<br/>
                if (receiveGameOptions(packet, connId)) {<br/>
                    resetPlayersDone();<br/>
                    transmitAllPlayerDones();<br/>
                    send(createGameSettingsPacket());<br/>
                    receiveGameOptionsAux(packet, connId);<br/>
                }<br/>
                break;<br/>
            case Packet.COMMAND_SENDING_MAP_SETTINGS :<br/>
                MapSettings newSettings=(MapSettings)packet.getObject(0);<br/>
                if (!mapSettings.equalMapGenParameters(newSettings)) {<br/>
                    sendServerChat("Player " + player.getName() +<br/>
                                   " changed mapsettings");<br/>
                }<br/>
                mapSettings = newSettings;<br/>
                newSettings = null;<br/>
                mapSettings.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
                resetPlayersDone();<br/>
                transmitAllPlayerDones();<br/>
                send(createMapSettingsPacket());<br/>
                break;<br/>
            case Packet.COMMAND_QUERY_MAP_SETTINGS :<br/>
                MapSettings temp = (MapSettings)packet.getObject(0);<br/>
                temp.setBoardsAvailableVector(scanForBoards(temp.getBoardWidth(), temp.getBoardHeight()));<br/>
                temp.removeUnavailable();<br/>
                temp.setNullBoards(DEFAULT_BOARD);<br/>
                temp.replaceBoardWithRandom(MapSettings.BOARD_RANDOM);<br/>
                temp.removeUnavailable();<br/>
                send(connId, createMapQueryPacket(temp));<br/>
                break;<br/>
            case Packet.COMMAND_UNLOAD_STRANDED :<br/>
                receiveUnloadStranded(packet, connId);<br/>
                break;<br/>
            case Packet.COMMAND_SET_ARTYAUTOHITHEXES :<br/>
                receiveArtyAutoHitHexes(packet, connId);<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Listen for incoming clients.<br/>
     */<br/>
    public void run() {<br/>
        Thread currentThread = Thread.currentThread();<br/>
        System.out.println("s: listening for clients...");<br/>
        while (connector == currentThread) {<br/>
            try {<br/>
                Socket s = serverSocket.accept();<br/>
<br/>
                int id = getFreeConnectionId();<br/>
                System.out.println("s: accepting player connection #" + id + " ...");<br/>
<br/>
                Connection c =  ConnectionFactory.getInstance().createServerConnection(s, id);<br/>
                c.addConnectionListener(connectionListener);<br/>
                c.open();<br/>
                connectionsPending.addElement(c);<br/>
<br/>
                greeting(id);<br/>
            } catch(IOException ex) {<br/>
<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes one slot of inferno ammo, determined<br/>
     * by certain rules, explode on a mech.<br/>
     *<br/>
     * @param entity  The &lt;code&gt;Entity&lt;/code&gt; that should suffer an<br/>
     *                inferno ammo explosion.<br/>
     */<br/>
    private Vector explodeInfernoAmmoFromHeat(Entity entity) {<br/>
        int damage = 0;<br/>
        int rack = 0;<br/>
        int boomloc = -1;<br/>
        int boomslot = -1;<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // Find the most destructive Inferno ammo.<br/>
        for (int j = 0; j &lt; entity.locations(); j++) {<br/>
            for (int k = 0; k &lt; entity.getNumberOfCriticals(j); k++) {<br/>
                CriticalSlot cs = entity.getCritical(j, k);<br/>
                // Ignore empty, destroyed, hit, and structure slots.<br/>
                if ( cs == null || cs.isDestroyed() || cs.isHit() ||<br/>
                     cs.getType() != CriticalSlot.TYPE_EQUIPMENT ) {<br/>
                    continue;<br/>
                }<br/>
                // Ignore everything but weapons slots.<br/>
                Mounted mounted = entity.getEquipment<br/>
                    ( entity.getCritical(j, k).getIndex() );<br/>
                if (!(mounted.getType() instanceof AmmoType)) {<br/>
                    continue;<br/>
                }<br/>
                // Ignore everything but Inferno ammo.<br/>
                AmmoType atype = (AmmoType)mounted.getType();<br/>
                if ( !atype.isExplosive() ||<br/>
                     atype.getMunitionType() != AmmoType.M_INFERNO) {<br/>
                    continue;<br/>
                }<br/>
                // Find the most destructive undamaged ammo.<br/>
                // BMRr, pg. 48, compare one rack's<br/>
                // damage.  Ties go to most rounds.<br/>
                int newRack = atype.getDamagePerShot() * atype.getRackSize();<br/>
                int newDamage = mounted.getExplosionDamage();<br/>
                if ( !mounted.isHit() &amp;&amp; ( rack &lt; newRack ||<br/>
                       (rack == newRack &amp;&amp; damage &lt; newDamage) ) ) {<br/>
                    rack = newRack;<br/>
                    damage = newDamage;<br/>
                    boomloc = j;<br/>
                    boomslot = k;<br/>
                }<br/>
            }<br/>
        }<br/>
        // Did we find anything to explode?<br/>
        if (boomloc != -1 &amp;&amp; boomslot != -1) {<br/>
            CriticalSlot slot = entity.getCritical(boomloc, boomslot);<br/>
            slot.setHit(true);<br/>
            entity.getEquipment(slot.getIndex()).setHit(true);<br/>
            // We've allocated heatBuildup to heat in resolveHeat(),<br/>
            // so need to add to the entity's heat instead.<br/>
            vDesc.addAll( explodeEquipment(entity, boomloc, boomslot));<br/>
            entity.heat += 30;<br/>
            r = new Report(5155);<br/>
            r.indent();<br/>
            r.subject = entity.getId();<br/>
            r.add(entity.heat);<br/>
            vDesc.addElement(r);<br/>
            entity.heatBuildup = 0;<br/>
        } else { //no ammo to explode<br/>
            r = new Report(5160);<br/>
            r.indent();<br/>
            r.subject = entity.getId();<br/>
            vDesc.addElement(r);<br/>
        }<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine the results of an entity moving through a wall of a building<br/>
     * after having moved a certain distance.  This gets called when a Mech<br/>
     * or a Tank enters a building, leaves a building, or travels from one<br/>
     * hex to another inside a multi-hex building.<br/>
     *<br/>
     * @param   entity - the &lt;code&gt;Entity&lt;/code&gt; that passed through a wall.<br/>
     *          Don't pass &lt;code&gt;Infantry&lt;/code&gt; units to this method.<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; the entity is passing through.<br/>
     * @param   lastPos - the &lt;code&gt;Coords&lt;/code&gt; of the hex the entity is<br/>
     *          exiting.<br/>
     * @param   curPos - the &lt;code&gt;Coords&lt;/code&gt; of the hex the entity is<br/>
     *          entering<br/>
     * @param   distance - the &lt;code&gt;int&lt;/code&gt; number of hexes the entity<br/>
     *          has moved already this phase.<br/>
     * @param   why - the &lt;code&gt;String&lt;/code&gt; explanatin for this action.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the building collapses due to overloading.<br/>
     */<br/>
    private boolean passBuildingWall( Entity entity,<br/>
                                      Building bldg,<br/>
                                      Coords lastPos,<br/>
                                      Coords curPos,<br/>
                                      int distance,<br/>
                                      String why ) {<br/>
<br/>
        Report r;<br/>
<br/>
        // Need to roll based on building type.<br/>
        PilotingRollData psr = entity.rollMovementInBuilding(bldg, distance, why);<br/>
<br/>
        // Did the entity make the roll?<br/>
        if ( !doSkillCheckWhileMoving( entity, lastPos,<br/>
                                       curPos, psr, false ) ) {<br/>
<br/>
            // Divide the building's current CF by 10, round up.<br/>
            int damage = (int) Math.ceil( bldg.getCurrentCF() / 10.0 );<br/>
<br/>
            // It is possible that the unit takes no damage.<br/>
            if ( damage == 0 ) {<br/>
                r = new Report(6440);<br/>
                r.add(entity.getDisplayName());<br/>
                r.subject = entity.getId();<br/>
                r.indent(2);<br/>
                addReport(r);<br/>
            } else {<br/>
                // BMRr, pg. 50: The attack direction for this damage is the front.<br/>
                HitData hit = entity.rollHitLocation( ToHitData.HIT_NORMAL,<br/>
                                                      ToHitData.SIDE_FRONT );<br/>
                addReport( damageEntity(entity, hit, damage));<br/>
            }<br/>
        }<br/>
<br/>
        // Damage the building.  The CF can never drop below 0.<br/>
        int toBldg = (int) Math.ceil( entity.getWeight() / 10.0 );<br/>
        int curCF = bldg.getCurrentCF();<br/>
        curCF -= Math.min( curCF, toBldg );<br/>
        bldg.setCurrentCF( curCF );<br/>
<br/>
        // Apply the correct amount of damage to infantry in the building.<br/>
        // ASSUMPTION: We inflict toBldg damage to infantry and<br/>
        //             not the amount to bring building to 0 CF.<br/>
        this.damageInfantryIn( bldg, toBldg );<br/>
<br/>
        return checkBuildingCollapseWhileMoving(bldg, entity, curPos);<br/>
    }<br/>
    <br/>
    private boolean checkBuildingCollapseWhileMoving(Building bldg, Entity entity, Coords curPos) {<br/>
        // Get the position map of all entities in the game.<br/>
        Hashtable positionMap = game.getPositionMap();<br/>
<br/>
        // Count the moving entity in its current position, not<br/>
        // its pre-move postition.  Be sure to handle nulls.<br/>
        Vector entities = null;<br/>
        if ( entity.getPosition() != null ) {<br/>
            entities = (Vector) positionMap.get( entity.getPosition() );<br/>
            entities.removeElement( entity );<br/>
        }<br/>
        entities = (Vector) positionMap.get( curPos );<br/>
        if ( entities == null ) {<br/>
            entities = new Vector();<br/>
            positionMap.put( curPos, entities );<br/>
        }<br/>
        entities.addElement( entity );<br/>
<br/>
        // Check for collapse of this building due to overloading, and return.<br/>
        return this.checkForCollapse( bldg, positionMap );<br/>
    }<br/>
<br/>
    /**<br/>
     * Apply the correct amount of damage that passes on to any infantry unit<br/>
     * in the given building, based upon the amount of damage the building<br/>
     * just sustained.  This amount is a percentage dictated by pg. 52 of BMRr.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that sustained the damage.<br/>
     * @param   damage - the &lt;code&gt;int&lt;/code&gt; amount of damage.<br/>
     */<br/>
    private void damageInfantryIn( Building bldg, int damage ) {<br/>
        // Calculate the amount of damage the infantry will sustain.<br/>
        float percent = 0.0f;<br/>
        Report r;<br/>
        switch( bldg.getType() ) {<br/>
        case Building.LIGHT: percent = 0.75f; break;<br/>
        case Building.MEDIUM: percent = 0.5f; break;<br/>
        case Building.HEAVY: percent = 0.25f; break;<br/>
        }<br/>
<br/>
        // Round up at .5 points of damage.<br/>
        int toInf = Math.round( damage * percent );<br/>
<br/>
        // Record if we find any infantry.<br/>
        boolean foundInfantry = false;<br/>
<br/>
        // Walk through the entities in the game.<br/>
        Enumeration entities = game.getEntities();<br/>
        while ( entities.hasMoreElements() ) {<br/>
            Entity entity = (Entity) entities.nextElement();<br/>
            final Coords coords = entity.getPosition();<br/>
<br/>
            // If the entity is infantry in one of the building's hexes?<br/>
            if ( entity instanceof Infantry &amp;&amp;<br/>
                 bldg.isIn( coords ) ) {<br/>
<br/>
                // Is the entity is inside of the building<br/>
                // (instead of just on top of it)?<br/>
                if ( Compute.isInBuilding( game, entity, coords ) ) {<br/>
                    <br/>
                    // Report if the infantry receive no points of damage.<br/>
                    if ( toInf == 0 ) {<br/>
                        r = new Report(6445);<br/>
                        addReport(r);<br/>
                    } else {<br/>
                        // Yup.  Damage the entity.<br/>
                        // Battle Armor units use 5 point clusters.<br/>
                        r = new Report(6450);<br/>
                        r.indent(2);<br/>
                        r.subject = entity.getId();<br/>
                        r.add(entity.getDisplayName());<br/>
                        r.add(toInf);<br/>
                        addReport(r);<br/>
                        int remaining = toInf;<br/>
                        int cluster = toInf;<br/>
                        if ( entity instanceof BattleArmor ) {<br/>
                            cluster = 5;<br/>
                        }<br/>
                        while ( remaining &gt; 0 ) {<br/>
                            int next = Math.min( cluster, remaining );<br/>
                            HitData hit = entity.rollHitLocation<br/>
                                ( ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT );<br/>
                            addReport( damageEntity(entity, hit, next) );<br/>
                            remaining -= next;<br/>
                        }<br/>
                        addReport(new Report(1210));<br/>
                    }<br/>
<br/>
                } // End infantry-inside-building<br/>
<br/>
            } // End entity-is-infantry-in-building-hex<br/>
<br/>
        } // Handle the next entity<br/>
<br/>
        // If we found any infantry, add a line to the phase report.<br/>
        if ( foundInfantry ) {<br/>
            addReport(new Report(1210));<br/>
        }<br/>
<br/>
    } // End private void damageInfantryIn( Building, int )<br/>
<br/>
    /**<br/>
     * Determine if the given building should collapse.  If so,<br/>
     * inflict the appropriate amount of damage on each entity in<br/>
     * the building and update the clients.  If the building does<br/>
     * not collapse, determine if any entities crash through its<br/>
     * floor into its basement.  Again, apply appropriate damage.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; being checked.<br/>
     *          This value should not be &lt;code&gt;null&lt;/code&gt;.<br/>
     * @param   positionMap - a &lt;code&gt;Hashtable&lt;/code&gt; that maps<br/>
     *          the &lt;code&gt;Coords&lt;/code&gt; positions or each unit<br/>
     *          in the game to a &lt;code&gt;Vector&lt;/code&gt; of<br/>
     *          &lt;code&gt;Entity&lt;/code&gt;s at that position.<br/>
     *          This value should not be &lt;code&gt;null&lt;/code&gt;.<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if the building collapsed.<br/>
     */<br/>
    public boolean checkForCollapse( Building bldg, Hashtable positionMap ) {<br/>
<br/>
        // If the input is meaningless, do nothing and throw no exception.<br/>
        if ( bldg == null ||<br/>
             positionMap == null || positionMap.isEmpty() ) {<br/>
            return false;<br/>
        }<br/>
<br/>
        // Get the building's current CF.<br/>
        final int currentCF = bldg.getCurrentCF();<br/>
<br/>
        // Track all units that fall into the building's basement by Coords.<br/>
        Hashtable basementMap = new Hashtable();<br/>
<br/>
        // Walk through the hexes in the building, looking for a collapse.<br/>
        Enumeration bldgCoords = bldg.getCoords();<br/>
        boolean collapse = false;<br/>
        while ( !collapse &amp;&amp; bldgCoords.hasMoreElements() ) {<br/>
            final Coords coords = (Coords) bldgCoords.nextElement();<br/>
<br/>
            // Get the Vector of Entities at these coordinates.<br/>
            final Vector vector = (Vector) positionMap.get( coords );<br/>
<br/>
            // Are there any Entities at these coords?<br/>
            if ( vector != null ) {<br/>
<br/>
                // How many levels does this building have in this hex?<br/>
                final IHex curHex = game.getBoard().getHex( coords );<br/>
                final int hexElev = curHex.surface();<br/>
                final int numFloors = Math.max(0,curHex.terrainLevel( Terrains.BLDG_ELEV )); <br/>
                final int bridgeEl = curHex.terrainLevel(Terrains.BRIDGE_ELEV);<br/>
                int numLoads = numFloors;<br/>
                if(bridgeEl != ITerrain.LEVEL_NONE) {<br/>
                    numLoads ++;<br/>
                }<br/>
                if(numLoads &lt; 1) {<br/>
                    System.err.println("Check for collapse: hex "+coords.toString()+" has no bridge or building");<br/>
                    continue;<br/>
                }<br/>
<br/>
                // Track the load of each floor (and of the roof) separately.<br/>
                // Track all units that fall into the basement in this hex.<br/>
                // N.B. don't track the ground floor, the first floor is at<br/>
                // index 0, the second is at index 1, etc., and the roof is<br/>
                // at index (numFloors-1).<br/>
                // if bridge is present, bridge will be numFloors<br/>
                int[] loads = new int[numLoads];<br/>
                Vector basement = new Vector();<br/>
                for ( int loop = 0; loop &lt; numLoads; loop++ ) {<br/>
                    loads[loop] = 0;<br/>
                }<br/>
<br/>
                // Walk through the entities in this position.<br/>
                Enumeration entities = vector.elements();<br/>
                while ( !collapse &amp;&amp; entities.hasMoreElements() ) {<br/>
                    final Entity entity = (Entity) entities.nextElement();<br/>
                    final int entityElev = entity.getElevation();<br/>
<br/>
                    if(entityElev != bridgeEl) {<br/>
                          // Ignore entities not *inside* the building<br/>
                          if ( entityElev &gt; numFloors) {<br/>
                              continue;<br/>
                          }<br/>
                    }<br/>
                    <br/>
                    if(entity.getMovementMode() == IEntityMovementMode.HYDROFOIL<br/>
                            || entity.getMovementMode() == IEntityMovementMode.NAVAL<br/>
                            || entity.getMovementMode() == IEntityMovementMode.SUBMARINE) {<br/>
                        continue; //under the bridge even at same level<br/>
                    }<br/>
<br/>
                    // Add the weight of a Mek or tank to the correct floor.<br/>
                    if ( entity instanceof Mech || entity instanceof Tank ) {<br/>
                        int load = (int) entity.getWeight();<br/>
                        int floor = entityElev;<br/>
                        if(floor == bridgeEl) {<br/>
                            floor = numLoads;<br/>
                        }<br/>
<br/>
                        // Entities on the ground floor may fall into the<br/>
                        // basement, but they won't collapse the building.<br/>
                        if ( numFloors &gt; 0 &amp;&amp; floor == 0 &amp;&amp; load &gt; currentCF ) {<br/>
                            basement.addElement( entity );<br/>
                        } else if ( floor &gt; 0 ) {<br/>
<br/>
                            // If the load on any floor but the ground floor<br/>
                            // exceeds the building's current CF it collapses.<br/>
                            floor--;<br/>
                            loads[ floor ] += load;<br/>
                            if ( loads[ floor ] &gt; currentCF ) {<br/>
                                collapse = true;<br/>
                            }<br/>
<br/>
                        } // End not-ground-floor<br/>
<br/>
                    } // End increase-load<br/>
<br/>
                } // Handle the next entity.<br/>
<br/>
                // Track all entities that fell into the basement.<br/>
                if ( !basement.isEmpty() ) {<br/>
                    basementMap.put( coords, basement );<br/>
                }<br/>
<br/>
            } // End have-entities-here<br/>
<br/>
        } // Check the next hex of the building.<br/>
<br/>
        // Collapse the building if the flag is set.<br/>
        if ( collapse ) {<br/>
            Report r = new Report(2375);<br/>
            r.add(bldg.getName());<br/>
            addReport(r);<br/>
            this.collapseBuilding( bldg, positionMap );<br/>
        }<br/>
<br/>
        // Otherwise, did any entities fall into the basement?<br/>
        else if ( !basementMap.isEmpty() ) {<br/>
            // TODO: implement basements<br/>
        }<br/>
<br/>
        // Return true if the building collapsed.<br/>
        return collapse;<br/>
<br/>
    } // End private boolean checkForCollapse( Building, Hashtable )<br/>
<br/>
    /**<br/>
     * Collapse the building.  Inflict the appropriate amount of damage<br/>
     * on all entities in the building.  Update all clients.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that has collapsed.<br/>
     * @param   positionMap - a &lt;code&gt;Hashtable&lt;/code&gt; that maps<br/>
     *          the &lt;code&gt;Coords&lt;/code&gt; positions or each unit<br/>
     *          in the game to a &lt;code&gt;Vector&lt;/code&gt; of<br/>
     *          &lt;code&gt;Entity&lt;/code&gt;s at that position.<br/>
     *          This value should not be &lt;code&gt;null&lt;/code&gt;.<br/>
     */<br/>
    public void collapseBuilding( Building bldg, Hashtable positionMap ) {<br/>
        // Loop through the hexes in the building, and apply<br/>
        // damage to all entities inside or on top of the building.<br/>
        Report r;<br/>
        final int phaseCF = bldg.getPhaseCF();<br/>
        Enumeration bldgCoords = bldg.getCoords();<br/>
        while ( bldgCoords.hasMoreElements() ) {<br/>
            final Coords coords = (Coords) bldgCoords.nextElement();<br/>
<br/>
            // Get the Vector of Entities at these coordinates.<br/>
            final Vector vector = (Vector) positionMap.get( coords );<br/>
<br/>
            // Are there any Entities at these coords?<br/>
            if ( vector != null ) {<br/>
<br/>
                // How many levels does this building have in this hex?<br/>
                final IHex curHex = game.getBoard().getHex( coords );<br/>
                final int hexElev = curHex.surface();<br/>
                final int bridgeEl = curHex.terrainLevel(Terrains.BRIDGE_ELEV);<br/>
                final int numFloors = Math.max(bridgeEl, curHex.terrainLevel( Terrains.BLDG_ELEV ));<br/>
<br/>
                // Sort in elevation order<br/>
                Collections.sort(vector, new Comparator&lt;Entity&gt;() {<br/>
                    public int compare(Entity a, Entity b) {<br/>
                        if(a.getElevation() &gt; b.getElevation())<br/>
                            return -1;<br/>
                        else if(a.getElevation() &gt; b.getElevation())<br/>
                            return 1;<br/>
                        return 0;<br/>
                    }<br/>
                });<br/>
                // Walk through the entities in this position.<br/>
                Enumeration entities = vector.elements();<br/>
                while ( entities.hasMoreElements() ) {<br/>
                    final Entity entity = (Entity) entities.nextElement();<br/>
                    //final int entityElev = entity.elevationOccupied( curHex );<br/>
                    int floor = entity.getElevation();<br/>
<br/>
                    // Ignore units above the building / bridge.<br/>
                    if ( floor &gt; numFloors) {<br/>
                        continue;<br/>
                    }<br/>
<br/>
                    // Treat units on the roof like<br/>
                    // they were in the top floor.<br/>
                    if ( floor == numFloors ) {<br/>
                        floor--;<br/>
                    }<br/>
<br/>
                    // Calculate collapse damage for this entity.<br/>
                    int damage = (int) Math.ceil<br/>
                        ( phaseCF * (numFloors-floor) / 10.0 );<br/>
<br/>
                    // Infantry suffer triple damage.<br/>
                    if ( entity instanceof Infantry ) {<br/>
                        damage *= 3;<br/>
                    }<br/>
<br/>
                    // Apply collapse damage the entity.<br/>
                    // ASSUMPTION: use 5 point clusters.<br/>
                    r = new Report(6455);<br/>
                    r.indent();<br/>
                    r.subject = entity.getId();<br/>
                    r.add(entity.getDisplayName());<br/>
                    r.add(damage);<br/>
                    addReport(r);<br/>
                    int remaining = damage;<br/>
                    int cluster = damage;<br/>
                    if ( entity instanceof BattleArmor ||<br/>
                         entity instanceof Mech ||<br/>
                         entity instanceof Tank ) {<br/>
                        cluster = 5;<br/>
                    }<br/>
                    while ( remaining &gt; 0 ) {<br/>
                        int next = Math.min( cluster, remaining );<br/>
                        // In www.classicbattletech.com/PDF/AskPMForumArchiveandFAQ.pdf,<br/>
                        // pg. 18, Randall Bills says that all damage from a<br/>
                        // collapsing building is applied to the front.<br/>
<br/>
                        HitData hit = entity.rollHitLocation<br/>
                            (ToHitData.HIT_NORMAL, ToHitData.SIDE_FRONT );<br/>
                        addReport( damageEntity(entity, hit, next) );<br/>
                        remaining -= next;<br/>
                    }<br/>
                    addReport(new Report(1210));<br/>
                    // TODO: Why are dead entities showing up on firing phase?<br/>
<br/>
                    // Do we need to handle falling Meks?<br/>
                    // BMRr, pg. 53 only mentions falling BattleMechs;<br/>
                    // Tanks can't be above the floor and I guess that<br/>
                    // infantry don't suffer falling damage.<br/>
                    // TODO: implement basements, then fall into it.<br/>
                    // ASSUMPTION: we'll let the Mech fall twice: once<br/>
                    // during damageEntity() above and once here.<br/>
                    floor = entity.getElevation();<br/>
                    if ( floor &gt; 0 || floor == bridgeEl) {<br/>
                        // ASSUMPTION: PSR to avoid pilot damage<br/>
                        // should use mods for entity damage and<br/>
                        // 20+ points of collapse damage (if any).<br/>
                        PilotingRollData psr = entity.getBasePilotingRoll();<br/>
                        entity.addPilotingModifierForTerrain(psr, coords);<br/>
                        if ( damage &gt;= 20 ) {<br/>
                            psr.addModifier( 1, "20+ damage" );<br/>
                        }<br/>
                        this.doEntityFallsInto( entity, coords, coords, psr );<br/>
                    }<br/>
<br/>
                    // Update this entity.<br/>
                    // ASSUMPTION: this is the correct thing to do.<br/>
                    this.entityUpdate( entity.getId() );<br/>
<br/>
                } // Handle the next entity.<br/>
<br/>
            } // End have-entities-here.<br/>
<br/>
        } // Handle the next hex of the building.<br/>
<br/>
        // Update the building.<br/>
        bldg.setCurrentCF( 0 );<br/>
        bldg.setPhaseCF( 0 );<br/>
        send( createCollapseBuildingPacket(bldg) );<br/>
        game.getBoard().collapseBuilding( bldg );<br/>
<br/>
    } // End private void collapseBuilding( Building )<br/>
<br/>
    /**<br/>
     * Tell the clients to replace the given building with rubble hexes.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that has collapsed.<br/>
     * @return  a &lt;code&gt;Packet&lt;/code&gt; for the command.<br/>
     */<br/>
    private Packet createCollapseBuildingPacket( Building bldg ) {<br/>
        Vector buildings = new Vector();<br/>
        buildings.addElement( bldg );<br/>
        return this.createCollapseBuildingPacket( buildings );<br/>
    }<br/>
<br/>
    /**<br/>
     * Tell the clients to replace the given buildings with rubble hexes.<br/>
     *<br/>
     * @param   buildings - a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Building&lt;/code&gt;s<br/>
     *          that has collapsed.<br/>
     * @return  a &lt;code&gt;Packet&lt;/code&gt; for the command.<br/>
     */<br/>
    private Packet createCollapseBuildingPacket( Vector buildings ) {<br/>
        return new Packet( Packet.COMMAND_BLDG_COLLAPSE, buildings );<br/>
    }<br/>
<br/>
    /**<br/>
     * Tell the clients to update the CFs of the given buildings.<br/>
     *<br/>
     * @param   buildings - a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Building&lt;/code&gt;s<br/>
     *          that need to be updated.<br/>
     * @return  a &lt;code&gt;Packet&lt;/code&gt; for the command.<br/>
     */<br/>
    private Packet createUpdateBuildingCFPacket( Vector buildings ) {<br/>
        return new Packet( Packet.COMMAND_BLDG_UPDATE_CF, buildings );<br/>
    }<br/>
<br/>
    /**<br/>
     * Apply this phase's damage to all buildings.  Buildings may<br/>
     * collapse due to damage.<br/>
     */<br/>
    private void applyBuildingDamage() {<br/>
<br/>
        // Walk through the buildings in the game.<br/>
        // Build the collapse and update vectors as you go.<br/>
        // N.B. never, NEVER, collapse buildings while you are walking through<br/>
        //      the Enumeration from megamek.common.Board#getBuildings.<br/>
        Vector collapse = new Vector();<br/>
        Vector update = new Vector();<br/>
        Enumeration buildings = game.getBoard().getBuildings();<br/>
        while ( buildings.hasMoreElements() ) {<br/>
            Building bldg = (Building) buildings.nextElement();<br/>
<br/>
            // If the CF is zero, the building should fall.<br/>
            if ( bldg.getCurrentCF() == 0 ) {<br/>
                collapse.addElement( bldg );<br/>
            }<br/>
<br/>
            // If the building took damage this round, update it.<br/>
            else if ( bldg.getPhaseCF() != bldg.getCurrentCF() ) {<br/>
                bldg.setPhaseCF( bldg.getCurrentCF() );<br/>
                update.addElement( bldg );<br/>
            }<br/>
<br/>
        } // Handle the next building<br/>
<br/>
        // If we have any buildings to collapse, collapse them now.<br/>
        if ( !collapse.isEmpty() ) {<br/>
<br/>
            // Get the position map of all entities in the game.<br/>
            Hashtable positionMap = game.getPositionMap();<br/>
<br/>
            // Walk through the buildings that have collapsed.<br/>
            buildings = collapse.elements();<br/>
            while ( buildings.hasMoreElements() ) {<br/>
                Building bldg = (Building) buildings.nextElement();<br/>
                Report r = new Report(6460,Report.PUBLIC);<br/>
                r.add(bldg.getName());<br/>
                addReport(r);<br/>
                this.collapseBuilding( bldg, positionMap );<br/>
            }<br/>
<br/>
        }<br/>
<br/>
        //check for buildings which should collapse due to being overloaded now CF is reduced<br/>
        if(!update.isEmpty()) {<br/>
            Hashtable positionMap = game.getPositionMap();<br/>
            for(Iterator i=update.iterator();i.hasNext();) {<br/>
                Building bldg = (Building) i.next();<br/>
                if(checkForCollapse(bldg, positionMap)) i.remove();<br/>
            }<br/>
        }<br/>
<br/>
        // If we have any buildings to update, send the message.<br/>
        if ( !update.isEmpty() ) {<br/>
            sendChangedCFBuildings( update );<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Apply the given amount of damage to the building.  Please note,<br/>
     * this method does &lt;b&gt;not&lt;/b&gt; apply any damage to units inside the<br/>
     * building, update the clients, or check for the building's collapse.<br/>
     * &lt;p/&gt;<br/>
     * A default message will be used to describe why the building<br/>
     * took the damage.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that has been damaged.<br/>
     *          This value should not be &lt;code&gt;null&lt;/code&gt;, but no<br/>
     *          exception will occur.<br/>
     * @param   damage - the &lt;code&gt;int&lt;/code&gt; amount of damage.<br/>
     * @return  a &lt;code&gt;Report&lt;/code&gt; to be shown to the players.<br/>
     */<br/>
    private Report damageBuilding( Building bldg, int damage ) {<br/>
        final String defaultWhy = " absorbs ";<br/>
        return damageBuilding( bldg, damage, defaultWhy );<br/>
    }<br/>
<br/>
    /**<br/>
     * Apply the given amount of damage to the building.  Please note,<br/>
     * this method does &lt;b&gt;not&lt;/b&gt; apply any damage to units inside the<br/>
     * building, update the clients, or check for the building's collapse.<br/>
     *<br/>
     * @param   bldg - the &lt;code&gt;Building&lt;/code&gt; that has been damaged.<br/>
     *          This value should not be &lt;code&gt;null&lt;/code&gt;, but no<br/>
     *          exception will occur.<br/>
     * @param   damage - the &lt;code&gt;int&lt;/code&gt; amount of damage.<br/>
     * @param   why - the &lt;code&gt;String&lt;/code&gt; message that describes<br/>
     *          why the building took the damage.<br/>
     * @return  a &lt;code&gt;Report&lt;/code&gt; to be shown to the players.<br/>
     */<br/>
    private Report damageBuilding( Building bldg, int damage, String why ) {<br/>
        Report r = new Report(1210);<br/>
        r.newlines = 0;<br/>
<br/>
        // Do nothing if no building or no damage was passed.<br/>
        if ( bldg != null &amp;&amp; damage &gt; 0 ) {<br/>
            int curCF = bldg.getCurrentCF();<br/>
            final int startingCF = curCF;<br/>
            curCF -= Math.min( curCF, damage );<br/>
            bldg.setCurrentCF( curCF );<br/>
            r.messageId = 3435;<br/>
            r.add( bldg.getName() );<br/>
            r.add( why );<br/>
            r.add( damage );<br/>
<br/>
            // If the CF is zero, the building should fall.<br/>
            if ( curCF == 0 &amp;&amp; startingCF != 0 ) {<br/>
                r.messageId = 3440;<br/>
            }<br/>
<br/>
        }<br/>
        return r;<br/>
    }<br/>
<br/>
    public void sendChangedCFBuildings(Vector&lt;Building&gt; buildings) {<br/>
        send(createUpdateBuildingCFPacket(buildings));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Receives an packet to unload entityis stranded on immobile transports,<br/>
     * and queue all valid requests for execution.  If all players that have<br/>
     * stranded entities have answered, executes the pending requests and end<br/>
     * the current turn.<br/>
     */<br/>
    private void receiveUnloadStranded( Packet packet, int connId ) {<br/>
        GameTurn.UnloadStrandedTurn turn = null;<br/>
        final Player player = game.getPlayer( connId );<br/>
        int[] entityIds = (int[]) packet.getObject(0);<br/>
        Vector declared = null;<br/>
        Player other = null;<br/>
        Enumeration pending = null;<br/>
        UnloadStrandedAction action = null;<br/>
        Entity entity = null;<br/>
<br/>
        // Is this the right phase?<br/>
        if (game.getPhase() != IGame.PHASE_MOVEMENT) {<br/>
            System.err.println<br/>
                ("error: server got unload stranded packet in wrong phase");<br/>
            return;<br/>
        }<br/>
<br/>
        // Are we in an "unload stranded entities" turn?<br/>
        if ( game.getTurn() instanceof GameTurn.UnloadStrandedTurn ) {<br/>
            turn = (GameTurn.UnloadStrandedTurn) game.getTurn();<br/>
        } else {<br/>
            System.err.println<br/>
                ("error: server got unload stranded packet out of sequence");<br/>
            StringBuffer message = new StringBuffer();<br/>
            message.append( player.getName() )<br/>
                .append( " should not be sending 'unload stranded entity' packets at this time." );<br/>
            sendServerChat( message.toString() );<br/>
            return;<br/>
        }<br/>
<br/>
        // Can this player act right now?<br/>
        if (!turn.isValid(connId, game)) {<br/>
            System.err.println<br/>
                ("error: server got unload stranded packet from invalid player");<br/>
            StringBuffer message = new StringBuffer();<br/>
            message.append( player.getName() )<br/>
                .append( " should not be sending 'unload stranded entity' packets." );<br/>
            sendServerChat( message.toString() );<br/>
            return;<br/>
        }<br/>
<br/>
        // Did the player already send an 'unload' request?<br/>
        // N.B. we're also building the list of players who<br/>
        //      have declared their "unload stranded" actions.<br/>
        declared = new Vector();<br/>
        pending = game.getActions();<br/>
        while ( pending.hasMoreElements() ) {<br/>
            action = (UnloadStrandedAction) pending.nextElement();<br/>
            if ( action.getPlayerId() == connId ) {<br/>
                System.err.println("error: server got multiple unload stranded packets from player");<br/>
                StringBuffer message = new StringBuffer();<br/>
                message.append( player.getName() )<br/>
                    .append( " should not send multiple 'unload stranded entity' packets." );<br/>
                sendServerChat( message.toString() );<br/>
                return;<br/>
            } else {<br/>
                // This player is not from the current connection.<br/>
                // Record this player to determine if this turn is done.<br/>
                other = game.getPlayer( action.getPlayerId() );<br/>
                if ( !declared.contains( other ) ) {<br/>
                    declared.addElement( other );<br/>
                }<br/>
            }<br/>
        } // Handle the next "unload stranded" action.<br/>
<br/>
        // Make sure the player selected at least *one* valid entity ID.<br/>
        boolean foundValid = false;<br/>
        for ( int index = 0; null != entityIds &amp;&amp; index &lt; entityIds.length;<br/>
              index++ ) {<br/>
            entity = game.getEntity( entityIds[index] );<br/>
            if (!game.getTurn().isValid(connId, entity, game)) {<br/>
                System.err.println("error: server got unload stranded packet for invalid entity");<br/>
                StringBuffer message = new StringBuffer();<br/>
                message.append( player.getName() )<br/>
                    .append( " can not unload stranded entity " );<br/>
                if ( null == entity ) {<br/>
                    message.append( "#" )<br/>
                        .append( entityIds[index] );<br/>
                } else {<br/>
                    message.append( entity.getDisplayName() );<br/>
                }<br/>
                message.append( " at this time." );<br/>
                sendServerChat( message.toString() );<br/>
            } else {<br/>
                foundValid = true;<br/>
                game.addAction( new UnloadStrandedAction( connId,<br/>
                                                          entityIds[index] ) );<br/>
            }<br/>
        }<br/>
<br/>
        // Did the player choose not to unload any valid stranded entity?<br/>
        if ( !foundValid ) {<br/>
            game.addAction( new UnloadStrandedAction( connId, Entity.NONE ) );<br/>
        }<br/>
<br/>
        // Either way, the connection's player has now declared.<br/>
        declared.addElement( player );<br/>
<br/>
        // Are all players who are unloading entities done? Walk<br/>
        // through the turn's stranded entities, and look to see<br/>
        // if their player has finished their turn.<br/>
        entityIds = turn.getEntityIds();<br/>
        for ( int index = 0; index &lt; entityIds.length; index++ ) {<br/>
            entity = game.getEntity( entityIds[index] );<br/>
            other = entity.getOwner();<br/>
            if ( !declared.contains( other ) ) {<br/>
                // At least one player still needs to declare.<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // All players have declared whether they're unloading stranded units.<br/>
        // Walk the list of pending actions and unload the entities.<br/>
        pending = game.getActions();<br/>
        while ( pending.hasMoreElements() ) {<br/>
            action = (UnloadStrandedAction) pending.nextElement();<br/>
<br/>
            // Some players don't want to unload any stranded units.<br/>
            if ( Entity.NONE != action.getEntityId() ) {<br/>
                entity = game.getEntity( action.getEntityId() );<br/>
                if ( null == entity ) {<br/>
                    // After all this, we couldn't find the entity!!!<br/>
                    System.err.print<br/>
                        ("error: server could not find stranded entity #");<br/>
                    System.err.print( action.getEntityId() );<br/>
                    System.err.println( " to unload!!!");<br/>
                } else {<br/>
                    // Unload the entity.  Get the unit's transporter.<br/>
                    Entity transporter =<br/>
                        game.getEntity( entity.getTransportId() );<br/>
                    this.unloadUnit( transporter, entity,<br/>
                                     transporter.getPosition(),<br/>
                                     transporter.getFacing(),<br/>
                                     transporter.getElevation());<br/>
                }<br/>
            }<br/>
<br/>
        } // Handle the next pending unload action<br/>
<br/>
        // Clear the list of pending units and move to the next turn.<br/>
        game.resetActions();<br/>
        changeToNextTurn();<br/>
    }<br/>
    /**<br/>
     * For all current artillery attacks in the air from this entity<br/>
     * with this weapon, clear the list of spotters.  Needed because<br/>
     * firing another round before first lands voids spotting.<br/>
     *<br/>
     * @param entityID int<br/>
     */<br/>
    private void clearArtillerySpotters(int entityID,int weaponID)  {<br/>
        for (Enumeration i = game.getArtilleryAttacks(); i.hasMoreElements();) {<br/>
            ArtilleryAttackAction aaa = (ArtilleryAttackAction) i.nextElement();<br/>
            if ( aaa.getWR().waa.getEntityId()==entityID &amp;&amp;<br/>
                 aaa.getWR().waa.getWeaponId()==weaponID ) {<br/>
                aaa.setSpotterIds(null);<br/>
            }<br/>
<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
    * Find the tagged entity for this attack<br/>
    *<br/>
    * Each TAG will attract a number of shots up to its priority number (mode setting)<br/>
    * When all the TAGs are used up, the shots fired are reset.<br/>
    * So if you leave them all on 1-shot, then homing attacks will be evenly split, however many shots you fire.<br/>
    *<br/>
    * Priority setting is to allocate more homing attacks to a more important target as decided by player.<br/>
    * <br/>
    * TAGs fired by the enemy aren't eligable, nor are TAGs fired at a target on a different map sheet.<br/>
    */<br/>
    private WeaponResult convertHomingShotToEntityTarget(ArtilleryAttackAction aaa, Entity ae) {<br/>
        WeaponResult wr = aaa.getWR();<br/>
        Targetable target = wr.waa.getTarget(game);<br/>
        <br/>
        final Coords tc = target.getPosition();<br/>
        Entity entityTarget = null;<br/>
<br/>
        TagInfo info = null;<br/>
        Entity tagger = null;<br/>
<br/>
        for(int pass=0;pass&lt;2;pass++) {<br/>
            int bestDistance = Integer.MAX_VALUE;<br/>
            int bestIndex = -1;<br/>
            Vector v = game.getTagInfo();<br/>
            for(int i=0;i&lt;v.size();i++) {<br/>
                info = (TagInfo)v.elementAt(i);<br/>
                tagger = game.getEntity(info.attackerId);<br/>
                if(info.shots &lt; info.priority &amp;&amp; !ae.isEnemyOf(tagger)) {<br/>
                    System.err.println("Checking TAG "+i+" with priority "+info.priority);<br/>
                    entityTarget = game.getEntity(info.targetId);<br/>
                    if(entityTarget != null &amp;&amp; entityTarget.isOnSameSheet(tc)) {<br/>
                        if(tc.distance(entityTarget.getPosition()) &lt; bestDistance) {<br/>
                            bestIndex = i;<br/>
                            bestDistance = tc.distance(entityTarget.getPosition());<br/>
                            if(!game.getOptions().booleanOption("a4homing_target_area")) {<br/>
                                break; //first will do if mapsheets can't overlap<br/>
                            }<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
            if(bestIndex != -1) {<br/>
                info = (TagInfo)v.elementAt(bestIndex);<br/>
                entityTarget = game.getEntity(info.targetId);<br/>
                tagger = game.getEntity(info.attackerId);<br/>
                System.err.println("attacker: " + ae.getDisplayName());<br/>
                System.err.println("   " + tagger.getDisplayName() + " selected to TAG");<br/>
                System.err.println("   " + entityTarget.getDisplayName() + " selected as target");<br/>
                info.shots++;<br/>
                game.updateTagInfo(info,bestIndex);<br/>
                break; //got a target, stop searching<br/>
            } else {<br/>
                entityTarget = null;<br/>
            }<br/>
            //nothing found on 1st pass, so clear shots fired to 0<br/>
            System.err.println("nothing on 1st pass");<br/>
            game.clearTagInfoShots(ae, tc);<br/>
        }<br/>
<br/>
        if(entityTarget == null || info == null) {<br/>
            wr.toHit = new ToHitData(ToHitData.IMPOSSIBLE, "no targets tagged on map sheet");<br/>
        } <br/>
        else if(info.missed) {<br/>
            wr.waa.setTargetId(entityTarget.getId());<br/>
            wr.waa.setTargetType(Targetable.TYPE_ENTITY);<br/>
            wr.toHit = new ToHitData(ToHitData.IMPOSSIBLE, "tag missed the target");<br/>
        } else {<br/>
            //update for hit table resolution<br/>
            wr.artyAttackerCoords = tagger.getPosition();<br/>
            wr.waa.setTargetId(entityTarget.getId());<br/>
            wr.waa.setTargetType(Targetable.TYPE_ENTITY);<br/>
        }<br/>
<br/>
        return wr;<br/>
    }<br/>
<br/>
    /**<br/>
     * resolve Indirect Artillery Attacks for this turn<br/>
     */<br/>
    private void resolveIndirectArtilleryAttacks()  {<br/>
        Vector results = new Vector(game.getArtillerySize());<br/>
        Vector attacks = new Vector(game.getArtillerySize());<br/>
<br/>
        // loop thru received attack actions, getting weapon results<br/>
        for (Enumeration i = game.getArtilleryAttacks(); i.hasMoreElements();) {<br/>
            ArtilleryAttackAction aaa =<br/>
                (ArtilleryAttackAction) i.nextElement();<br/>
<br/>
            // Does the attack land this turn?<br/>
            if (aaa.turnsTilHit &lt;= 0) {<br/>
                WeaponResult wr = aaa.getWR();<br/>
                //HACK, for correct hit table resolution.<br/>
                wr.artyAttackerCoords=aaa.getCoords();<br/>
                final Vector spottersBefore=aaa.getSpotterIds();<br/>
                final Targetable target = wr.waa.getTarget(game);<br/>
                final Coords targetPos = target.getPosition();<br/>
                final int playerId = aaa.getPlayerId();<br/>
                Entity bestSpotter=null;<br/>
<br/>
                Entity ae = game.getEntity(wr.waa.getEntityId());<br/>
                if (ae == null) {<br/>
                  ae = game.getOutOfGameEntity( wr.waa.getEntityId() );<br/>
                }<br/>
                Mounted ammo = ae.getEquipment(wr.waa.getAmmoId());<br/>
                final AmmoType atype = ammo == null ? null : (AmmoType) ammo.getType();<br/>
                if(atype != null &amp;&amp; atype.getMunitionType() == AmmoType.M_HOMING) {<br/>
                    wr = convertHomingShotToEntityTarget(aaa, ae);<br/>
                } else {<br/>
                    // Are there any valid spotters?<br/>
                    if ( null != spottersBefore ) {<br/>
<br/>
                        //fetch possible spotters now<br/>
                        Enumeration spottersAfter=<br/>
                            game.getSelectedEntities( new EntitySelector() {<br/>
                                    public int player = playerId;<br/>
                                    public Targetable targ = target;<br/>
                                    public boolean accept(Entity entity) {<br/>
                                        Integer id = new Integer( entity.getId() );<br/>
                                        if ( player == entity.getOwnerId() &amp;&amp;<br/>
                                             spottersBefore.contains(id) &amp;&amp;<br/>
                                             !( LosEffects.calculateLos<br/>
                                                (game, entity.getId(), targ)<br/>
                                                ).isBlocked() &amp;&amp;<br/>
                                             entity.isActive() &amp;&amp;<br/>
                                             !entity.isINarcedWith(INarcPod.HAYWIRE)) {<br/>
                                            return true;<br/>
                                        }<br/>
                                        return false;<br/>
                                    }<br/>
                                } );<br/>
<br/>
                        // Out of any valid spotters, pick the best.<br/>
                        while ( spottersAfter.hasMoreElements() ) {<br/>
                            Entity ent = (Entity) spottersAfter.nextElement();<br/>
                            if ( bestSpotter == null || ent.crew.getGunnery() &lt;<br/>
                                 bestSpotter.crew.getGunnery() ){<br/>
                                bestSpotter = ent;<br/>
                            }<br/>
                        }<br/>
<br/>
                    } // End have-valid-spotters<br/>
<br/>
                    //If at least one valid spotter, then get the benefits thereof.<br/>
                    if (null != bestSpotter) {<br/>
                        int mod = (bestSpotter.crew.getGunnery() - 4) / 2;<br/>
                        wr.toHit.addModifier(mod, "Spotting modifier");<br/>
                    }<br/>
<br/>
                    // Is the attacker still alive?<br/>
                    Entity artyAttacker = wr.waa.getEntity( game );<br/>
                    if (null != artyAttacker) {<br/>
<br/>
                        // Get the arty weapon.<br/>
                        Mounted weapon = artyAttacker.getEquipment<br/>
                            ( wr.waa.getWeaponId() );<br/>
<br/>
                        // If the shot hit the target hex, then all subsequent<br/>
                        // fire will hit the hex automatically.<br/>
                        if(wr.roll &gt;= wr.toHit.getValue()) {<br/>
                            artyAttacker.aTracker.setModifier<br/>
                                ( weapon,<br/>
                                  ToHitData.AUTOMATIC_SUCCESS,<br/>
                                  targetPos );<br/>
                        }<br/>
                        // If the shot missed, but was adjusted by a<br/>
                        // spotter, future shots are more likely to hit.<br/>
                        else if (null != bestSpotter) {<br/>
                            artyAttacker.aTracker.setModifier<br/>
                                ( weapon,<br/>
                                  artyAttacker.aTracker.getModifier<br/>
                                  ( weapon, targetPos ) - 1,<br/>
                                  targetPos );<br/>
                        }<br/>
<br/>
                    } // End artyAttacker-alive<br/>
                }<br/>
<br/>
                // Schedule this attack to be resolved.<br/>
                results.addElement(wr);<br/>
                attacks.addElement( aaa );<br/>
<br/>
            } // End attack-hits-this-turn<br/>
<br/>
            // This attack is one round closer to hitting.<br/>
            aaa.turnsTilHit--;<br/>
<br/>
        } // Handle the next attack<br/>
<br/>
        // loop through weapon results and resolve<br/>
        int lastEntityId = Entity.NONE;<br/>
        for (Enumeration i = results.elements();i.hasMoreElements();) {<br/>
            WeaponResult wr = (WeaponResult) i.nextElement();<br/>
            resolveWeaponAttack(wr, lastEntityId);<br/>
            lastEntityId = wr.waa.getEntityId();<br/>
        }<br/>
<br/>
        // Clear out all resolved attacks.<br/>
        for (Enumeration i = attacks.elements(); i.hasMoreElements();) {<br/>
            game.removeArtilleryAttack<br/>
                ( (ArtilleryAttackAction) i.nextElement() );<br/>
        }<br/>
        for(Enumeration i = game.getPlayers();i.hasMoreElements();) {<br/>
            Player player = (Player)i.nextElement();<br/>
            int connId = player.getId();<br/>
            send(connId, createArtilleryPacket(player));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * enqueues any indirect artillery attacks made this turn<br/>
     */<br/>
    private void enqueueIndirectArtilleryAttacks() {<br/>
        resolveAllButWeaponAttacks();<br/>
        ArtilleryAttackAction aaa;<br/>
        for (Enumeration i = game.getActions();i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction) i.nextElement();<br/>
            final Entity firingEntity = game.getEntity(ea.getEntityId());<br/>
            if (ea instanceof WeaponAttackAction) {<br/>
                final WeaponAttackAction waa = (WeaponAttackAction) ea;<br/>
                WeaponResult wr = preTreatWeaponAttack(waa);<br/>
                boolean firingAtNewHex = false;<br/>
                for (Enumeration j = game.getArtilleryAttacks();<br/>
                     !firingAtNewHex &amp;&amp; j.hasMoreElements();) {<br/>
                    ArtilleryAttackAction oaaa = (ArtilleryAttackAction) j.nextElement();<br/>
                    if ( oaaa.getWR().waa.getEntityId() == wr.waa.getEntityId() &amp;&amp;<br/>
                         !oaaa.getWR().waa.getTarget(game).getPosition().equals(wr.waa.getTarget(game).getPosition())) {<br/>
                        firingAtNewHex = true;<br/>
                    }<br/>
                }<br/>
                if (firingAtNewHex) {<br/>
                    clearArtillerySpotters( firingEntity.getId(),<br/>
                                            waa.getWeaponId() );<br/>
                }<br/>
                Enumeration spotters = game.getSelectedEntities(new EntitySelector() {<br/>
                    public int player = firingEntity.getOwnerId();<br/>
                    public Targetable target = waa.getTarget(game);<br/>
                    public boolean accept(Entity entity) {<br/>
                        if ( (player == entity.getOwnerId()) &amp;&amp;<br/>
                            !((LosEffects.calculateLos(game, entity.getId(), target)).isBlocked()) &amp;&amp; entity.isActive()) {<br/>
                            return true;<br/>
                        } else {<br/>
                            return false;<br/>
                        }<br/>
<br/>
                    }<br/>
                } );<br/>
<br/>
                Vector spotterIds = new Vector();<br/>
                while ( spotters.hasMoreElements() ) {<br/>
                    Integer id = new Integer<br/>
                        ( ((Entity) spotters.nextElement() ).getId() );<br/>
                    spotterIds.addElement( id );<br/>
                }<br/>
                aaa = new ArtilleryAttackAction( wr, game,<br/>
                                                 firingEntity.getOwnerId(),<br/>
                                                 spotterIds, firingEntity.getPosition());<br/>
                game.addArtilleryAttack(aaa);<br/>
            }<br/>
        }<br/>
        game.resetActions();<br/>
        for(Enumeration i = game.getPlayers();i.hasMoreElements();) {<br/>
            Player player = (Player)i.nextElement();<br/>
            int connId = player.getId();<br/>
            send(connId, createArtilleryPacket(player));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Credits a Kill for an entity, if the target got killed.<br/>
     *<br/>
     * @param target   The &lt;code&gt;Entity&lt;/code&gt; that got killed.<br/>
     * @param attacker The &lt;code&gt;Entity&lt;/code&gt; that did the killing.<br/>
     */<br/>
    private void creditKill(Entity target, Entity attacker) {<br/>
        if (target.isDoomed() &amp;&amp; !target.getGaveKillCredit()) {<br/>
            attacker.addKill(target);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * pre-treats a physical attack<br/>
     *<br/>
     * @param aaa The &lt;code&gt;AbstractAttackAction&lt;/code&gt; of the physical attack<br/>
     *            to pre-treat<br/>
     *<br/>
     * @return    The &lt;code&gt;PhysicalResult&lt;/code&gt; of that action, including<br/>
     *            possible damage.<br/>
     */<br/>
    private PhysicalResult preTreatPhysicalAttack(AbstractAttackAction aaa) {<br/>
        final Entity ae = game.getEntity(aaa.getEntityId());<br/>
        int damage = 0;<br/>
        PhysicalResult pr = new PhysicalResult();<br/>
        ToHitData toHit = new ToHitData();<br/>
        pr.roll = Compute.d6(2);<br/>
        pr.aaa = aaa;<br/>
        if (aaa instanceof BrushOffAttackAction) {<br/>
            BrushOffAttackAction baa = (BrushOffAttackAction)aaa;<br/>
            int arm = baa.getArm();<br/>
            baa.setArm(BrushOffAttackAction.LEFT);<br/>
            toHit = BrushOffAttackAction.toHit(game, aaa.getEntityId(), aaa.getTarget(game), BrushOffAttackAction.LEFT);<br/>
            baa.setArm(BrushOffAttackAction.RIGHT);<br/>
            pr.toHitRight = BrushOffAttackAction.toHit(game, aaa.getEntityId(), aaa.getTarget(game), BrushOffAttackAction.RIGHT);<br/>
            damage = BrushOffAttackAction.getDamageFor(ae, BrushOffAttackAction.LEFT);<br/>
            pr.damageRight = BrushOffAttackAction.getDamageFor(ae, BrushOffAttackAction.RIGHT);<br/>
            baa.setArm(arm);<br/>
            pr.rollRight = Compute.d6(2);<br/>
        } else if (aaa instanceof ChargeAttackAction) {<br/>
            ChargeAttackAction caa = (ChargeAttackAction)aaa;<br/>
            toHit = caa.toHit(game);<br/>
            damage = ChargeAttackAction.getDamageFor(ae);<br/>
        } else if (aaa instanceof ClubAttackAction) {<br/>
            ClubAttackAction caa = (ClubAttackAction)aaa;<br/>
            toHit = caa.toHit(game);<br/>
            damage = ClubAttackAction.getDamageFor(ae, caa.getClub());<br/>
        } else if (aaa instanceof DfaAttackAction) {<br/>
            DfaAttackAction daa = (DfaAttackAction)aaa;<br/>
            toHit = daa.toHit(game);<br/>
            damage = DfaAttackAction.getDamageFor(ae);<br/>
        } else if (aaa instanceof KickAttackAction) {<br/>
            KickAttackAction kaa = (KickAttackAction)aaa;<br/>
            toHit = kaa.toHit(game);<br/>
            damage = KickAttackAction.getDamageFor(ae, kaa.getLeg());<br/>
        } else if (aaa instanceof ProtomechPhysicalAttackAction) {<br/>
            ProtomechPhysicalAttackAction paa = (ProtomechPhysicalAttackAction)aaa;<br/>
            toHit = paa.toHit(game);<br/>
            damage = ProtomechPhysicalAttackAction.getDamageFor(ae);<br/>
        } else if (aaa instanceof PunchAttackAction) {<br/>
            PunchAttackAction paa = (PunchAttackAction)aaa;<br/>
            int arm = paa.getArm();<br/>
            int damageRight = 0;<br/>
            paa.setArm(PunchAttackAction.LEFT);<br/>
            toHit = paa.toHit(game);<br/>
            paa.setArm(PunchAttackAction.RIGHT);<br/>
            ToHitData toHitRight = paa.toHit(game);<br/>
            damage = PunchAttackAction.getDamageFor(ae, PunchAttackAction.LEFT);<br/>
            damageRight = PunchAttackAction.getDamageFor(ae, PunchAttackAction.RIGHT);<br/>
            paa.setArm(arm);<br/>
            // If we're punching while prone (at a Tank,<br/>
            // duh), then we can only use one arm.<br/>
            if ( ae.isProne() ) {<br/>
                double oddsLeft = Compute.oddsAbove(toHit.getValue());<br/>
                double oddsRight = Compute.oddsAbove(toHitRight.getValue());<br/>
                // Use the best attack.<br/>
                if (  oddsLeft*damage &gt; oddsRight*damageRight ) {<br/>
                    paa.setArm(PunchAttackAction.LEFT);<br/>
                } else paa.setArm(PunchAttackAction.RIGHT);<br/>
            }<br/>
            pr.damageRight = damageRight;<br/>
            pr.toHitRight = toHitRight;<br/>
            pr.rollRight = Compute.d6(2);<br/>
        } else if (aaa instanceof PushAttackAction) {<br/>
            PushAttackAction paa = (PushAttackAction)aaa;<br/>
            toHit = paa.toHit(game);<br/>
        } else if (aaa instanceof LayExplosivesAttackAction) {<br/>
            LayExplosivesAttackAction leaa = (LayExplosivesAttackAction)aaa;<br/>
            toHit = leaa.toHit(game);<br/>
            damage = LayExplosivesAttackAction.getDamageFor(ae);<br/>
        } else if (aaa instanceof ThrashAttackAction) {<br/>
            ThrashAttackAction taa = (ThrashAttackAction)aaa;<br/>
            toHit = taa.toHit(game);<br/>
            damage = ThrashAttackAction.getDamageFor(ae);<br/>
        }<br/>
        pr.toHit = toHit;<br/>
        pr.damage = damage;<br/>
        return pr;<br/>
    }<br/>
<br/>
    /**<br/>
     * Resolve a Physical Attack<br/>
     *<br/>
     * @param pr  The &lt;code&gt;PhysicalResult&lt;/code&gt; of the physical attack<br/>
     * @param cen The &lt;code&gt;int&lt;/code&gt; Entity Id of the entit's whose<br/>
     *            physical attack was last resolved<br/>
     */<br/>
    private void resolvePhysicalAttack(PhysicalResult pr, int cen) {<br/>
        AbstractAttackAction aaa = pr.aaa;<br/>
        if (aaa instanceof PunchAttackAction) {<br/>
            PunchAttackAction paa = (PunchAttackAction)aaa;<br/>
            if (paa.getArm() == PunchAttackAction.BOTH) {<br/>
                paa.setArm(PunchAttackAction.LEFT);<br/>
                pr.aaa = paa;<br/>
                resolvePunchAttack(pr, cen);<br/>
                cen = paa.getEntityId();<br/>
                paa.setArm(PunchAttackAction.RIGHT);<br/>
                pr.aaa = paa;<br/>
                resolvePunchAttack(pr, cen);<br/>
            } else {<br/>
                resolvePunchAttack(pr, cen);<br/>
                cen = paa.getEntityId();<br/>
            }<br/>
        } else if (aaa instanceof KickAttackAction) {<br/>
            resolveKickAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        } else if (aaa instanceof BrushOffAttackAction) {<br/>
            BrushOffAttackAction baa = (BrushOffAttackAction)aaa;<br/>
            if (baa.getArm() == BrushOffAttackAction.BOTH) {<br/>
                baa.setArm(BrushOffAttackAction.LEFT);<br/>
                pr.aaa = baa;<br/>
                resolveBrushOffAttack(pr, cen);<br/>
                cen = baa.getEntityId();<br/>
                baa.setArm(BrushOffAttackAction.RIGHT);<br/>
                pr.aaa = baa;<br/>
                resolveBrushOffAttack(pr, cen);<br/>
            } else {<br/>
                resolveBrushOffAttack(pr, cen);<br/>
                cen = baa.getEntityId();<br/>
            }<br/>
        } else if (aaa instanceof ThrashAttackAction) {<br/>
            resolveThrashAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        } else if (aaa instanceof ProtomechPhysicalAttackAction) {<br/>
            resolveProtoAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        } else if (aaa instanceof ClubAttackAction) {<br/>
            resolveClubAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        } else if (aaa instanceof PushAttackAction) {<br/>
            resolvePushAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        }  else if (aaa instanceof ChargeAttackAction) {<br/>
            resolveChargeAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        }  else if (aaa instanceof DfaAttackAction) {<br/>
            resolveDfaAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        }  else if (aaa instanceof LayExplosivesAttackAction) {<br/>
            resolveLayExplosivesAttack(pr, cen);<br/>
            cen = aaa.getEntityId();<br/>
        } else {<br/>
            // hmm, error.<br/>
        }<br/>
        // Not all targets are Entities.<br/>
        Targetable target = game.getTarget( aaa.getTargetType(),<br/>
                                        aaa.getTargetId() );<br/>
        if ( target instanceof Entity ) {<br/>
            creditKill( (Entity) target, game.getEntity(cen) );<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Add any extreme gravity PSRs the entity gets due to its movement<br/>
     *<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; to check.<br/>
     * @param step   The last &lt;code&gt;MoveStep&lt;/code&gt; of this entity<br/>
     * @param curPos The current &lt;code&gt;Coords&lt;/code&gt; of this entity<br/>
     * @param cachedMaxMPExpenditure Server checks run/jump MP at start of move, as appropriate, caches to avoid mid-move change in MP causing erroneous grav check<br/>
     */<br/>
    private void checkExtremeGravityMovement(Entity entity, MoveStep step, Coords curPos, int cachedMaxMPExpenditure) {<br/>
        PilotingRollData rollTarget;<br/>
        if (game.getOptions().floatOption("gravity") != 1) {<br/>
            if (entity instanceof Mech) {<br/>
                if (step.getMovementType() == IEntityMovementType.MOVE_WALK<br/>
                        || (step.getMovementType() == IEntityMovementType.MOVE_VTOL_WALK)<br/>
                        || step.getMovementType() == IEntityMovementType.MOVE_RUN<br/>
                        || (step.getMovementType() == IEntityMovementType.MOVE_VTOL_RUN)) {<br/>
                    if (step.getMpUsed() &gt; cachedMaxMPExpenditure) {<br/>
                        // We moved too fast, let's make PSR to see if we get damage<br/>
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(step));<br/>
                    }<br/>
                } else if (step.getMovementType() == IEntityMovementType.MOVE_JUMP) {<br/>
                    if (step.getMpUsed() &gt; cachedMaxMPExpenditure) {<br/>
                        // We jumped too far, let's make PSR to see if we get damage<br/>
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(step));<br/>
                    } else if (game.getOptions().floatOption("gravity") &gt; 1) {<br/>
                        // jumping in high g is bad for your legs<br/>
                        rollTarget = entity.getBasePilotingRoll();<br/>
                        entity.addPilotingModifierForTerrain(rollTarget, step);<br/>
                        rollTarget.append(new PilotingRollData(entity.getId(), 0, "jumped in high gravity"));<br/>
                        game.addExtremeGravityPSR(rollTarget);<br/>
                    }<br/>
                }<br/>
            } else if (entity instanceof Tank) {<br/>
                if (step.getMovementType() == IEntityMovementType.MOVE_WALK<br/>
                        || (step.getMovementType() == IEntityMovementType.MOVE_VTOL_WALK)<br/>
                        || step.getMovementType() == IEntityMovementType.MOVE_RUN<br/>
                        || (step.getMovementType() == IEntityMovementType.MOVE_VTOL_RUN)) {<br/>
                    // For Tanks, we need to check if the tank had<br/>
                    // more MPs because it was moving along a road.<br/>
                    if ((step.getMpUsed() &gt; cachedMaxMPExpenditure) &amp;&amp; !step.isOnlyPavement()) {<br/>
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(step));<br/>
                    }<br/>
                    else if (step.getMpUsed() &gt; cachedMaxMPExpenditure + 1) {<br/>
                        // If the tank was moving on a road, he got a +1 bonus.<br/>
                        // N.B. The Ask Precentor Martial forum said that a 4/6<br/>
                        //      tank on a road can move 5/7, **not** 5/8.<br/>
                        game.addExtremeGravityPSR(entity.checkMovedTooFast(step));<br/>
                    } // End tank-has-road-bonus<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Damage the inner structure of a mech's leg / a tank's front.<br/>
     * This only happens when the Entity fails an extreme Gravity PSR.<br/>
     * @param entity The &lt;code&gt;Entity&lt;/code&gt; to damage.<br/>
     * @param damage The &lt;code&gt;int&lt;/code&gt; amount of damage.<br/>
     */<br/>
    private void doExtremeGravityDamage(Entity entity, int damage) {<br/>
        HitData hit;<br/>
        if (entity instanceof BipedMech) {<br/>
            for (int i = 6; i&lt;=7; i++) {<br/>
                hit = new HitData (i);<br/>
                addReport( damageEntity(entity, hit, damage, false, 0, true));<br/>
            }<br/>
        } if (entity instanceof QuadMech) {<br/>
            for (int i = 4; i&lt;=7; i++) {<br/>
                hit = new HitData (i);<br/>
                addReport( damageEntity(entity, hit, damage, false, 0, true));<br/>
            }<br/>
        } else if (entity instanceof Tank) {<br/>
            hit = new HitData (Tank.LOC_FRONT);<br/>
            addReport( damageEntity(entity, hit, damage, false, 0, true));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Eject an Entity.<br/>
     * @param entity    The &lt;code&gt;Entity&lt;/code&gt; to eject.<br/>
     * @param autoEject The &lt;code&gt;boolean&lt;/code&gt; state of the entity's auto-<br/>
     *                  ejection system<br/>
     * @return a &lt;code&gt;Vector&lt;/code&gt; of report objects for the gamelog.<br/>
     */<br/>
    public Vector ejectEntity(Entity entity, boolean autoEject) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // An entity can only eject it's crew once.<br/>
        if (entity.getCrew().isEjected())<br/>
            return vDesc;<br/>
        <br/>
        // If the crew are already dead, don't bother<br/>
        if(entity.getCrew().isDead() || entity.getCrew().isDoomed())<br/>
            return vDesc;<br/>
<br/>
        // Mek pilots may get hurt during ejection,<br/>
        // and run around the board afterwards.<br/>
        if (entity instanceof Mech) {<br/>
            PilotingRollData rollTarget = new PilotingRollData(entity.getId(), entity.getCrew().getPiloting(), "ejecting");<br/>
            if (entity.isProne()) {<br/>
                rollTarget.addModifier(5, "Mech is prone");<br/>
            }<br/>
            if (entity.getCrew().isUnconscious()) {<br/>
                rollTarget.addModifier(3, "pilot unconscious");<br/>
            }<br/>
            if (autoEject) {<br/>
                rollTarget.addModifier(1, "automatic ejection");<br/>
            }<br/>
            if (entity.getInternal(Mech.LOC_HEAD) &lt; 3) {<br/>
                rollTarget.addModifier(Math.min(3 - entity.getInternal(Mech.LOC_HEAD),2), "Head Internal Structure Damage");<br/>
            }<br/>
            int facing = entity.getFacing();<br/>
            Coords targetCoords = entity.getPosition().translated((facing + 3)%6);<br/>
            IHex targetHex = game.getBoard().getHex(targetCoords);<br/>
            if (targetHex != null) {<br/>
                if (targetHex.terrainLevel(Terrains.WATER) &gt; 0 &amp;&amp; !(targetHex.containsTerrain(Terrains.ICE))) {<br/>
                    rollTarget.addModifier(-1, "landing in water");<br/>
                } else if (targetHex.containsTerrain(Terrains.ROUGH)) {<br/>
                    rollTarget.addModifier(0, "landing in rough");<br/>
                } else if (targetHex.containsTerrain(Terrains.RUBBLE)) {<br/>
                    rollTarget.addModifier(0, "landing in rubble");<br/>
                } else if (targetHex.terrainLevel(Terrains.WOODS) == 1) {<br/>
                    rollTarget.addModifier(2, "landing in light woods");<br/>
                } else if (targetHex.terrainLevel(Terrains.WOODS) == 2) {<br/>
                    rollTarget.addModifier(3, "landing in heavy woods");<br/>
                } else if (targetHex.terrainLevel(Terrains.WOODS) == 3) {<br/>
                    rollTarget.addModifier(4, "landing in ultra heavy woods");<br/>
                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 1) {<br/>
                    rollTarget.addModifier(3, "landing in light jungle");<br/>
                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 2) {<br/>
                    rollTarget.addModifier(5, "landing in heavy jungle");<br/>
                } else if (targetHex.terrainLevel(Terrains.JUNGLE) == 3) {<br/>
                    rollTarget.addModifier(7, "landing in ultra heavy jungle");<br/>
                } else if (targetHex.terrainLevel(Terrains.BLDG_ELEV) &gt; 0) {<br/>
                    rollTarget.addModifier(targetHex.terrainLevel(Terrains.BLDG_ELEV), "landing in a building");<br/>
                } else rollTarget.addModifier(-2, "landing in clear terrain");<br/>
            } else {<br/>
                rollTarget.addModifier(-2, "landing off the board");<br/>
            }<br/>
            if (autoEject) {<br/>
                r = new Report(6395);<br/>
                r.subject = entity.getId();<br/>
                r.addDesc(entity);<br/>
                r.indent(2);<br/>
                r.newlines = 0;<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            // okay, print the info<br/>
            r = new Report(2180);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(rollTarget.getLastPlainDesc(), true);<br/>
            r.indent(3);<br/>
            vDesc.addElement(r);<br/>
            // roll<br/>
            final int diceRoll = Compute.d6(2);<br/>
            r = new Report(2190);<br/>
            r.subject = entity.getId();<br/>
            r.add(rollTarget.getValueAsString());<br/>
            r.add(rollTarget.getDesc());<br/>
            r.add(diceRoll);<br/>
            r.indent(4);<br/>
            r.newlines = 0;<br/>
            // create the MechWarrior in any case, for campaign tracking<br/>
            MechWarrior pilot = new MechWarrior(entity);<br/>
            pilot.setDeployed(true);<br/>
            pilot.setId(getFreeEntityId());<br/>
            game.addEntity(pilot.getId(), pilot);<br/>
            send(createAddEntityPacket(pilot.getId()));<br/>
            // make him not get a move this turn<br/>
            pilot.setDone(true);<br/>
            if (diceRoll &lt; rollTarget.getValue()) {<br/>
                r.choose(false);<br/>
                vDesc.addElement(r);<br/>
                Report.addNewline(vDesc);<br/>
                Vector v = damageCrew(pilot, 1);<br/>
                if(v.size() &gt; 0) {<br/>
                    r = (Report)v.firstElement();<br/>
                    r.indent(3);<br/>
                    vDesc.addElement(r);<br/>
                }<br/>
            } else {<br/>
                r.choose(true);<br/>
                vDesc.addElement(r);<br/>
            }<br/>
            if (entity.getCrew().isDoomed()) {<br/>
                vDesc.addAll(<br/>
                        destroyEntity(pilot, "deadly ejection", false, false));<br/>
            }<br/>
            else {<br/>
                // Add the pilot as an infantry unit on the battlefield.<br/>
                if (game.getBoard().contains(targetCoords)) {<br/>
                    pilot.setPosition(targetCoords);<br/>
/* Can pilots eject into water???<br/>
   ASSUMPTION : They can (because they get a -1 mod to the PSR.<br/>
                    // Did the pilot land in water?<br/>
                    if ( game.getBoard().getHex( targetCoords).levelOf<br/>
                         ( Terrain.WATER ) &gt; 0 ) {<br/>
                         //report missing<br/>
                        desc.append("and the pilot ejects, but lands in water!!!\n");<br/>
                        //report missing<br/>
                        desc.append(destroyEntity( pilot, "a watery grave", false ));<br/>
                    } else {<br/>
                        //report missing<br/>
                        desc.append("and the pilot ejects safely!\n");<br/>
                    }<br/>
*/<br/>
                    //report safe ejection<br/>
                    r = new Report(6400);<br/>
                    r.subject = entity.getId();<br/>
                    r.indent(5);<br/>
                    vDesc.addElement(r);<br/>
                    if (game.getOptions().booleanOption("vacuum")) {<br/>
                        //ended up in a vacuum<br/>
                        r = new Report(6405);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent(3);<br/>
                        vDesc.addElement(r);<br/>
                        vDesc.addAll(<br/>
                            destroyEntity(pilot, "explosive decompression", false, false));<br/>
                    }<br/>
                    // Update the entity<br/>
                    this.entityUpdate(pilot.getId());<br/>
                    // check if the pilot lands in a minefield<br/>
                    doEntityDisplacementMinefieldCheck( pilot,<br/>
                            entity.getPosition(),<br/>
                            targetCoords );<br/>
                } else {<br/>
                    //ejects safely<br/>
                    r = new Report(6410);<br/>
                    r.subject = entity.getId();<br/>
                    r.indent(3);<br/>
                    vDesc.addElement(r);<br/>
                    if (game.getOptions().booleanOption("vacuum")) {<br/>
                        //landed in vacuum<br/>
                        r = new Report(6405);<br/>
                        r.subject = entity.getId();<br/>
                        r.indent(3);<br/>
                        vDesc.addElement(r);<br/>
                        vDesc.addAll(<br/>
                            destroyEntity(pilot, "explosive decompression", false, false));<br/>
                    } else {<br/>
                        game.removeEntity( pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT );<br/>
                        send(createRemoveEntityPacket(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT) );<br/>
                    }<br/>
                }<br/>
                if (game.getOptions().booleanOption("ejected_pilots_flee")) {<br/>
                    game.removeEntity(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);<br/>
                    send(createRemoveEntityPacket(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));<br/>
                }<br/>
            } // Pilot safely ejects.<br/>
<br/>
        } // End entity-is-Mek<br/>
<br/>
        // Mark the entity's crew as "ejected".<br/>
        entity.getCrew().setEjected( true );<br/>
        vDesc.addAll(<br/>
            destroyEntity(entity, "ejection", true, true));<br/>
<br/>
        // only remove the unit that ejected manually<br/>
        if (!autoEject) {<br/>
            game.removeEntity( entity.getId(), IEntityRemovalConditions.REMOVE_EJECTED );<br/>
            send(createRemoveEntityPacket(entity.getId(), IEntityRemovalConditions.REMOVE_EJECTED));<br/>
        }<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Abandon an Entity.<br/>
     * @param entity    The &lt;code&gt;Entity&lt;/code&gt; to abandon.<br/>
     *<br/>
     * @return a &lt;code&gt;Vector&lt;/code&gt; of report objects for the gamelog.<br/>
     */<br/>
    public Vector abandonEntity(Entity entity) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
<br/>
        // An entity can only eject it's crew once.<br/>
        if (entity.getCrew().isEjected())<br/>
            return vDesc;<br/>
<br/>
        if (entity.getCrew().isDoomed()) <br/>
            return vDesc;<br/>
        <br/>
        //Don't make them abandon into vacuum<br/>
        if (game.getOptions().booleanOption("vacuum")) <br/>
            return vDesc;<br/>
        <br/>
        Coords targetCoords = entity.getPosition();<br/>
        <br/>
        if (entity instanceof Mech) {<br/>
            // okay, print the info<br/>
            r = new Report(2027);<br/>
            r.subject = entity.getId();<br/>
            r.add(entity.getCrew().getName());<br/>
            r.addDesc(entity);<br/>
            r.indent(3);<br/>
            vDesc.addElement(r);<br/>
<br/>
            // create the MechWarrior in any case, for campaign tracking<br/>
            MechWarrior pilot = new MechWarrior(entity);<br/>
            pilot.getCrew().setUnconscious(entity.getCrew().isUnconscious());<br/>
            pilot.setDeployed(true);<br/>
            pilot.setId(getFreeEntityId());<br/>
            game.addEntity(pilot.getId(), pilot);<br/>
            send(createAddEntityPacket(pilot.getId()));<br/>
            // make him not get a move this turn<br/>
            pilot.setDone(true);<br/>
            // Add the pilot as an infantry unit on the battlefield.<br/>
            if (game.getBoard().contains(targetCoords))<br/>
                    pilot.setPosition(targetCoords);<br/>
            // Update the entity<br/>
            this.entityUpdate(pilot.getId());<br/>
            // check if the pilot lands in a minefield<br/>
            doEntityDisplacementMinefieldCheck( pilot,<br/>
                    entity.getPosition(),<br/>
                    targetCoords );<br/>
            if (game.getOptions().booleanOption("ejected_pilots_flee")) {<br/>
                game.removeEntity(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT);<br/>
                send(createRemoveEntityPacket(pilot.getId(), IEntityRemovalConditions.REMOVE_IN_RETREAT));<br/>
            }<br/>
        } // End entity-is-Mek<br/>
<br/>
        // Mark the entity's crew as "ejected".<br/>
        entity.getCrew().setEjected( true );<br/>
<br/>
        return vDesc;<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks if ejected Mechwarriors are eligible to be picked up,<br/>
     * and if so, captures them or picks them up<br/>
     */<br/>
    private void resolveMechWarriorPickUp() {<br/>
        Report r;<br/>
<br/>
        // fetch all mechWarriors that are not picked up<br/>
        Enumeration mechWarriors =<br/>
            game.getSelectedEntities( new EntitySelector() {<br/>
                public boolean accept(Entity entity) {<br/>
                    if (entity instanceof MechWarrior) {<br/>
                        MechWarrior mw = (MechWarrior)entity;<br/>
                        if (mw.getPickedUpById() == Entity.NONE &amp;&amp;<br/>
                            !mw.isDoomed() &amp;&amp; (mw.getTransportId() == Entity.NONE) ) {<br/>
                            return true;<br/>
                        }<br/>
                    }<br/>
                    return false;<br/>
                }<br/>
            } );<br/>
        // loop through them, check if they are in a hex occupied by another<br/>
        // unit<br/>
        while ( mechWarriors.hasMoreElements() ) {<br/>
            boolean pickedUp = false;<br/>
            MechWarrior e = (MechWarrior) mechWarriors.nextElement();<br/>
            Enumeration pickupEntities = game.getEntities(e.getPosition());<br/>
            while (pickupEntities.hasMoreElements() ) {<br/>
                Entity pe = (Entity) pickupEntities.nextElement();<br/>
                if (pe.isDoomed() || pe.isShutDown() || pe.getCrew().isUnconscious()) {<br/>
                    continue;<br/>
                }<br/>
                if (!pickedUp &amp;&amp; pe.getOwnerId() == e.getOwnerId() &amp;&amp; pe.getId() != e.getId()) {<br/>
                    if (pe instanceof MechWarrior) {<br/>
                        //picked up by friendlies<br/>
                        r = new Report(6415, Report.PUBLIC); //no subject we can use...<br/>
                        r.add(pe.getDisplayName());<br/>
                        addReport(r);<br/>
                        continue;<br/>
                    }<br/>
                    // Pick up the unit.<br/>
                    pe.pickUp(e);<br/>
                    // The picked unit is being carried by the loader.<br/>
                    e.setPickedUpById(pe.getId());<br/>
                    e.setPickedUpByExternalId(pe.getExternalId());<br/>
                    pickedUp = true;<br/>
                    r = new Report(6420, Report.PUBLIC);<br/>
                    r.add(e.getDisplayName());<br/>
                    r.addDesc(pe);<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
            if (!pickedUp) {<br/>
                Enumeration pickupEnemyEntities = game.getEnemyEntities(e.getPosition(), e);<br/>
                while (pickupEnemyEntities.hasMoreElements() ) {<br/>
                    Entity pe = (Entity) pickupEnemyEntities.nextElement();<br/>
                    if (pe.isDoomed() || pe.isShutDown() ||<br/>
                        pe.getCrew().isUnconscious()) {<br/>
                        continue;<br/>
                    }<br/>
                    if (pe instanceof MechWarrior) {<br/>
                        //picked up by friendlies<br/>
                        r = new Report(6415, Report.PUBLIC); //no subject we can use...<br/>
                        r.add(pe.getDisplayName());<br/>
                        addReport(r);<br/>
                        continue;<br/>
                    }<br/>
                    // Capture the unit.<br/>
                    pe.pickUp(e);<br/>
                    // The captured unit is being carried by the loader.<br/>
                    e.setCaptured( true );<br/>
                    e.setPickedUpById(pe.getId());<br/>
                    e.setPickedUpByExternalId(pe.getExternalId());<br/>
                    pickedUp = true;<br/>
                    r = new Report(6420, Report.PUBLIC);<br/>
                    r.add(e.getDisplayName());<br/>
                    r.addDesc(pe);<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
            if (pickedUp) {<br/>
                // Remove the picked-up unit from the screen.<br/>
                e.setPosition( null );<br/>
                // Update the loaded unit.<br/>
                this.entityUpdate( e.getId() );<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * destroy all wheeled and tracked Tanks that got displaced into water<br/>
     */<br/>
    private void resolveSinkVees() {<br/>
        Enumeration sinkableTanks =<br/>
            game.getSelectedEntities( new EntitySelector() {<br/>
            public boolean accept(Entity entity) {<br/>
                if (entity.isOffBoard()) {<br/>
                    return false;<br/>
                }<br/>
                <br/>
                if (entity instanceof Tank<br/>
                        &amp;&amp; (entity.getPosition() != null)<br/>
                        &amp;&amp; (entity.getMovementMode() == IEntityMovementMode.TRACKED<br/>
                        || entity.getMovementMode() == IEntityMovementMode.WHEELED )<br/>
                        &amp;&amp; game.getBoard().getHex(entity.getPosition()).terrainLevel(Terrains.WATER) &gt; 0<br/>
                        &amp;&amp; entity.getElevation() &lt; 0) {<br/>
                        return true;<br/>
                }<br/>
                return false;<br/>
            }<br/>
        });<br/>
        while (sinkableTanks.hasMoreElements()) {<br/>
            Entity e = (Entity)sinkableTanks.nextElement();<br/>
            addReport(<br/>
                                  destroyEntity(e, "a watery grave", false));<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * let all Entities make their "break-free-of-swamp-stickyness" PSR<br/>
     */<br/>
    private void doTryUnstuck() {<br/>
        if (game.getPhase() != IGame.PHASE_MOVEMENT)<br/>
            return;<br/>
<br/>
        Report r;<br/>
<br/>
        Enumeration stuckEntities =<br/>
            game.getSelectedEntities( new EntitySelector() {<br/>
            public boolean accept(Entity entity) {<br/>
                if (entity.isStuck()) {<br/>
                    return true;<br/>
                }<br/>
                return false;<br/>
            }<br/>
        });<br/>
        PilotingRollData rollTarget;<br/>
        while (stuckEntities.hasMoreElements()) {<br/>
            Entity entity = (Entity)stuckEntities.nextElement();<br/>
            rollTarget = entity.getBasePilotingRoll();<br/>
            entity.addPilotingModifierForTerrain(rollTarget);<br/>
            // apart from swamp &amp; liquid magma, -1 modifier<br/>
            IHex hex = game.getBoard().getHex(entity.getPosition());<br/>
            if(!(hex.containsTerrain(Terrains.SWAMP))<br/>
                &amp;&amp; !(hex.terrainLevel(Terrains.MAGMA) == 2)) {<br/>
                rollTarget.addModifier(-1, "bogged down");<br/>
            }<br/>
            // okay, print the info<br/>
            r = new Report(2340);<br/>
            r.addDesc(entity);<br/>
            addReport(r);<br/>
<br/>
            // roll<br/>
            final int diceRoll = Compute.d6(2);<br/>
            r = new Report(2190);<br/>
            r.add(rollTarget.getValueAsString());<br/>
            r.add(rollTarget.getDesc());<br/>
            r.add(diceRoll);<br/>
            if (diceRoll &lt; rollTarget.getValue()) {<br/>
                r.choose(false);<br/>
            } else {<br/>
                r.choose(true);<br/>
                entity.setStuck(false);<br/>
                entity.setCanUnstickByJumping(false);<br/>
            }<br/>
            addReport(r);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Remove all iNarc pods from all vehicles that did not<br/>
     * move and shoot this round<br/>
     * NOTE: this is not quite what the rules say, the player<br/>
     * should be able to choose whether or not to remove all iNarc Pods<br/>
     * that are attached.<br/>
     */<br/>
    private void resolveVeeINarcPodRemoval() {<br/>
        Enumeration vees =<br/>
            game.getSelectedEntities( new EntitySelector() {<br/>
            public boolean accept(Entity entity) {<br/>
                if (entity instanceof Tank &amp;&amp;<br/>
                    entity.mpUsed == 0) {<br/>
                    return true;<br/>
                }<br/>
                return false;<br/>
            }<br/>
        });<br/>
        boolean canSwipePods;<br/>
        while (vees.hasMoreElements()) {<br/>
            canSwipePods = true;<br/>
            Entity entity = (Entity)vees.nextElement();<br/>
            for (int i=0;i&lt;=5;i++) {<br/>
                if ( entity.weaponFiredFrom(i) ) {<br/>
                    canSwipePods = false;<br/>
                }<br/>
            }<br/>
            if (canSwipePods &amp;&amp; entity.hasINarcPodsAttached() &amp;&amp;<br/>
                entity.getCrew().isActive()) {<br/>
                entity.removeAllINarcPods();<br/>
                Report r = new Report(2345);<br/>
                r.addDesc(entity);<br/>
                addReport(r);<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    private void deadEntitiesCleanup() {<br/>
        //See note above where knownDeadEntities variable is declared<br/>
        /*<br/>
        Entity en = null;<br/>
        for(Enumeration k = game.getGraveyardEntities(); k.hasMoreElements(); en = (Entity) k.nextElement()) {<br/>
            if (en != null) {<br/>
                if (!knownDeadEntities.contains(en)) {<br/>
                    knownDeadEntities.add(en);<br/>
                }<br/>
            }           <br/>
        }<br/>
        */<br/>
    }<br/>
    <br/>
    private void resolveIceBroken(Coords c) {<br/>
        game.getBoard().getHex(c).removeTerrain(Terrains.ICE);<br/>
        sendChangedHex(c);<br/>
        //drop entities on the surface into the water<br/>
        for(Enumeration entities = game.getEntities(c);entities.hasMoreElements();) {<br/>
            Entity e = (Entity)entities.nextElement();<br/>
            if(e.getElevation() == 0) {<br/>
                doEntityFall(e, new PilotingRollData(TargetRoll.AUTOMATIC_FAIL));<br/>
            }<br/>
        }<br/>
    }<br/>
        <br/>
    private void checkForVehicleFire(Tank tank, boolean inferno) {<br/>
        int boomroll = Compute.d6(2);<br/>
        int penalty = 0;<br/>
        switch(tank.getMovementMode()) {<br/>
        case IEntityMovementMode.HOVER:<br/>
            penalty = 4;<br/>
            break;<br/>
        case IEntityMovementMode.VTOL:<br/>
        case IEntityMovementMode.WHEELED:<br/>
            penalty = 2;<br/>
            break;<br/>
        }<br/>
        if(inferno) {<br/>
            boomroll = 12;<br/>
        }<br/>
        Report r = new Report(5250);<br/>
        r.subject = tank.getId();<br/>
        r.addDesc(tank);<br/>
        r.add(8-penalty);<br/>
        r.add(boomroll);<br/>
        if (boomroll + penalty &lt; 8) {<br/>
            //phew!<br/>
            r.choose(true);<br/>
            addReport(r);<br/>
        } else {<br/>
            //eek<br/>
            if(!inferno) {<br/>
                r.choose(false);<br/>
                addReport(r);<br/>
            }<br/>
            if(boomroll + penalty &lt; 10) {<br/>
                vehicleMotiveDamage(tank, penalty - 1);<br/>
            } else {<br/>
                resolveVehicleFire(tank, false);<br/>
                if(boomroll + penalty &gt;= 12) {<br/>
                    r = new Report(5255);<br/>
                    r.subject = tank.getId();<br/>
                    r.indent(3);<br/>
                    addReport(r);<br/>
                    tank.setOnFire();<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    private void resolveVehicleFire(Tank tank, boolean existingStatus) {<br/>
        if(existingStatus &amp;&amp; !tank.isOnFire())<br/>
            return;<br/>
        for(int i=0;i&lt;tank.locations();i++) {<br/>
            if(i==Tank.LOC_BODY || (tank instanceof VTOL &amp;&amp; i==VTOL.LOC_ROTOR))<br/>
                continue;<br/>
            if(existingStatus &amp;&amp; !(tank.isLocationBurning(i)))<br/>
                continue;<br/>
            HitData hit = new HitData(i);<br/>
            int damage =Compute.d6(1);<br/>
            addReport(damageEntity(tank, hit, damage));<br/>
            if(damage == 1 &amp;&amp; existingStatus) {<br/>
                tank.extinguishLocation(i);<br/>
            }<br/>
        }        <br/>
       addNewLines();<br/>
    }<br/>
    <br/>
    private void vehicleMotiveDamage(Tank te, int modifier) {<br/>
        Vector vDesc = new Vector();<br/>
        Report r;<br/>
        int roll = Compute.d6(2) + modifier;<br/>
        r = new Report(6305);<br/>
        r.subject = te.getId();<br/>
        r.add("movement system");<br/>
        r.newlines = 0;<br/>
        r.indent(3);<br/>
        vDesc.addElement(r);<br/>
        r = new Report(6310);<br/>
        r.subject = te.getId();<br/>
        r.add(roll);<br/>
        r.newlines = 0;<br/>
        vDesc.addElement(r);<br/>
        if(roll &lt;= 7) {<br/>
            //no effect<br/>
            r = new Report(6005);<br/>
            r.subject = te.getId();<br/>
            r.add(roll);<br/>
            vDesc.addElement(r);<br/>
        } else if (roll &lt;=9) {<br/>
            //minor damage<br/>
            r = new Report(6470);<br/>
            r.subject = te.getId();<br/>
            r.add(roll);<br/>
            vDesc.addElement(r);<br/>
            te.addMovementDamage(1);<br/>
        } else if (roll &lt;12) {<br/>
            //major damage<br/>
            r = new Report(6135);<br/>
            r.subject = te.getId();<br/>
            vDesc.addElement(r);<br/>
            te.addMovementDamage(2);<br/>
            int nMP = te.getOriginalWalkMP();<br/>
            if (nMP &gt; 0) {<br/>
                te.setOriginalWalkMP(nMP - 1);<br/>
<br/>
                if (te.getOriginalWalkMP()==0) {<br/>
                    // Hovercraft reduced to 0MP over water sink<br/>
                    if ( te.getMovementMode() == IEntityMovementMode.HOVER &amp;&amp;<br/>
                         game.getBoard().getHex( te.getPosition() ).terrainLevel(Terrains.WATER) &gt; 0 &amp;&amp;<br/>
                         !(game.getBoard().getHex( te.getPosition() ).containsTerrain(Terrains.ICE))) {<br/>
                        vDesc.addAll( destroyEntity(te, "a watery grave", false) );<br/>
                    }<br/>
                }<br/>
            }<br/>
        } else  {<br/>
            r = new Report(6140);<br/>
            r.subject = te.getId();<br/>
            vDesc.addElement(r);<br/>
            te.immobilize();<br/>
            // Does the hovercraft sink?<br/>
            IHex te_hex = game.getBoard().getHex( te.getPosition() );<br/>
            if ( te.getMovementMode() == IEntityMovementMode.HOVER &amp;&amp;<br/>
                 te_hex.terrainLevel(Terrains.WATER) &gt; 0 &amp;&amp;<br/>
                 !(te_hex.containsTerrain(Terrains.ICE))) {<br/>
                vDesc.addAll( destroyEntity(te, "a watery grave", false) );<br/>
            }<br/>
            if(te instanceof VTOL) {<br/>
                Report.addNewline(vDesc);<br/>
                //report problem: add tab<br/>
                vDesc.addAll( crashVTOL((VTOL)te));<br/>
            }<br/>
        }<br/>
        addReport(vDesc);<br/>
    }<br/>
<br/>
    <br/>
    /**<br/>
     * Add a whole lotta Reports to the players report queues<br/>
     * as well as the Master report queue vPhaseReport.<br/>
     */<br/>
    private  void addReport(Vector reports){<br/>
        //Only bother with player reports if doing double blind.<br/>
        if ( doBlind())<br/>
            for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
                final Connection conn = (Connection)i.nextElement();<br/>
                Player p = game.getPlayer(conn.getId());<br/>
    <br/>
                p.getTurnReport().addAll(filterReportVector(reports,p));<br/>
            }<br/>
        vPhaseReport.addAll(reports);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Add a single report to the report queue of all players and the master<br/>
     * vPhaseReport queue<br/>
     */<br/>
    private void addReport(Report report){<br/>
        //Only bother with player reports if doing double blind.<br/>
        if ( doBlind())<br/>
            for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
                final Connection conn = (Connection)i.nextElement();<br/>
                Player p = game.getPlayer(conn.getId());<br/>
    <br/>
                p.getTurnReport().addElement(filterReport(report,p,false));<br/>
            }<br/>
        vPhaseReport.addElement(report);<br/>
    }<br/>
<br/>
    /**<br/>
     * New Round has started clear everyones report queue<br/>
     */<br/>
    private void clearReports(){<br/>
        //Only bother with player reports if doing double blind.<br/>
        if ( doBlind())<br/>
            for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
                final Connection conn = (Connection)i.nextElement();<br/>
                Player p = game.getPlayer(conn.getId());<br/>
    <br/>
                p.getTurnReport().removeAllElements();<br/>
            }<br/>
        vPhaseReport.removeAllElements();        <br/>
    }<br/>
    <br/>
    /**<br/>
     * make sure all teh new lines that where added to the old vPhaseReport<br/>
     * get added to all of the players filters<br/>
     */<br/>
    private void addNewLines(){<br/>
        //Only bother with player reports if doing double blind.<br/>
        if ( doBlind())<br/>
            for (Enumeration i = connections.elements(); i.hasMoreElements();) {<br/>
                final Connection conn = (Connection)i.nextElement();<br/>
                Player p = game.getPlayer(conn.getId());<br/>
    <br/>
                Report.addNewline(p.getTurnReport());<br/>
            }<br/>
        Report.addNewline(vPhaseReport);<br/>
    }<br/>
    <br/>
    public void doAssaultDrop(Entity entity) {<br/>
        PilotingRollData psr;<br/>
        if(entity instanceof Mech) {<br/>
            psr=entity.getBasePilotingRoll();<br/>
        } else {<br/>
            psr=new PilotingRollData(entity.getId(),4,"landing assault drop");<br/>
        }<br/>
        int roll = Compute.d6(2);<br/>
        //check for a safe landing<br/>
        Report r = new Report(2380);<br/>
        r.subject = entity.getId();<br/>
        r.add(entity.getDisplayName(), true);<br/>
        r.add(psr.getValueAsString());<br/>
        r.add(roll);<br/>
        r.choose(roll &gt;= psr.getValue());<br/>
        addReport(r);<br/>
        if(roll &lt; psr.getValue()) {<br/>
            int fallHeight = psr.getValue() - roll;<br/>
            //determine where we really land<br/>
            int distance = Compute.d6(fallHeight);<br/>
            Coords c = Compute.scatter(entity.getPosition(), distance);<br/>
            r = new Report(2385);<br/>
            r.subject = entity.getId();<br/>
            r.add(distance);<br/>
            r.indent(3);<br/>
            r.newlines = 0;<br/>
            addReport(r);<br/>
            if(fallHeight &gt;=5 || !game.getBoard().contains(c)) {<br/>
                r = new Report(2386);<br/>
                addReport(r);<br/>
                game.removeEntity(entity.getId(),IEntityRemovalConditions.REMOVE_NEVER_JOINED);<br/>
                return;<br/>
            }<br/>
            entity.setPosition(c);<br/>
            <br/>
            //do fall damage<br/>
            if(entity instanceof Mech || entity instanceof Protomech) {<br/>
                entity.setElevation(fallHeight);<br/>
                doEntityFallsInto(entity, c, c, psr, true);<br/>
            }<br/>
            else if(entity instanceof BattleArmor) {<br/>
                for(int i=1;i&lt;entity.locations();i++) {<br/>
                    HitData h = new HitData(i);<br/>
                    addReport(damageEntity(entity,h,Compute.d6(fallHeight)));<br/>
                    addNewLines();<br/>
                }<br/>
            }<br/>
            else if(entity instanceof Infantry) {<br/>
                HitData h = new HitData(Infantry.LOC_INFANTRY);<br/>
                addReport(damageEntity(entity,h, 1));<br/>
                addNewLines();<br/>
            }<br/>
        }<br/>
        //set entity to expected elevation<br/>
        IHex hex = game.getBoard().getHex(entity.getPosition());<br/>
        entity.setElevation(entity.elevationOccupied(hex) - hex.floor());<br/>
        //finally, check for any stacking violations<br/>
        Entity violated = Compute.stackingViolation(game, entity, entity.getPosition(), null);<br/>
        if(violated != null) {<br/>
            //handle this as accidental fall from above<br/>
            entity.setElevation(violated.getElevation() + 2);<br/>
            r = new Report(2390);<br/>
            r.subject = entity.getId();<br/>
            r.add(entity.getDisplayName(), true);<br/>
            r.add(violated.getDisplayName(), true);<br/>
            addReport(r);<br/>
            doEntityFallsInto(entity, entity.getPosition(), entity.getPosition(), psr);<br/>
        }<br/>
        return;<br/>
    }<br/>
    <br/>
    void doAllAssaultDrops() {<br/>
        for(Enumeration i = game.getEntities();i.hasMoreElements();) {<br/>
            Entity e = (Entity)(i.nextElement());<br/>
            if(e.isAssaultDropInProgress()) {<br/>
                doAssaultDrop(e);<br/>
                e.setLandedAssaultDrop();<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    void doMagmaDamage(Entity en, boolean eruption) {<br/>
        if((en.getMovementMode() == IEntityMovementMode.VTOL ||<br/>
           (en.getMovementMode() == IEntityMovementMode.HOVER &amp;&amp; en.getOriginalWalkMP() &gt; 0 &amp;&amp; !eruption))<br/>
           &amp;&amp; !(en.isImmobile())) {<br/>
           return;<br/>
        }<br/>
        Report r;<br/>
        boolean isMech = en instanceof Mech;<br/>
        if(isMech)<br/>
            r = new Report(2405);<br/>
        else<br/>
            r = new Report(2400);<br/>
        r.addDesc(en);<br/>
        r.subject = en.getId();<br/>
        addReport(r);<br/>
        if(isMech) {<br/>
            HitData h;<br/>
            for(int i=0;i&lt;en.locations();i++) {<br/>
                if(eruption || en.locationIsLeg(i) || en.isProne()) {<br/>
                    h = new HitData(i);<br/>
                    addReport(damageEntity(en, h, Compute.d6(2)));<br/>
                }<br/>
            }<br/>
        } else {<br/>
            addReport(destroyEntity(en, "fell into magma", false, false));<br/>
        }<br/>
        addNewLines();<br/>
    }<br/>
    <br/>
    /**<br/>
     * deal area saturation damage to an individual hex<br/>
     * @param coords         The hex being hit<br/>
     * @param attackSource   The location the attack came from.  For hit table resolution<br/>
     * @param damage         Amount of damage to deal to each entity<br/>
     * @param ammo           The ammo type being used<br/>
     * @param subjectId      Subject for reports<br/>
     * @param killer         Who should be credited with kills<br/>
     * @param exclude        Entity that should take no damage (used for homing splash)<br/>
     * @param flak           Flak, hits flying units only, instead of flyers being immune<br/>
     * @param altitude       Absolute altitude for flak attack<br/>
     */<br/>
    void artilleryDamageHex(Coords coords, Coords attackSource, int damage, AmmoType ammo, int subjectId, Entity killer, Entity exclude, boolean flak, int altitude) {<br/>
<br/>
        IHex hex = game.getBoard().getHex(coords);<br/>
        if(hex == null) return; //not on board.<br/>
<br/>
        int flakElevation = altitude - hex.surface();<br/>
<br/>
        Report r;<br/>
<br/>
        Building bldg = game.getBoard().getBuildingAt(coords);<br/>
        int bldgAbsorbs = 0;<br/>
        if(bldg != null<br/>
           &amp;&amp; !(flak &amp;&amp; flakElevation &gt; hex.terrainLevel(Terrains.BLDG_ELEV))) {<br/>
            bldgAbsorbs = bldg.getPhaseCF() / 10;<br/>
            if(!(ammo != null &amp;&amp; ammo.getMunitionType() == AmmoType.M_FLECHETTE)) {<br/>
                //damage the building<br/>
                r = damageBuilding( bldg, damage );<br/>
                r.subject = subjectId;<br/>
                addReport(r);<br/>
                addNewLines();<br/>
            }<br/>
        }<br/>
<br/>
        if(flak<br/>
           &amp;&amp; (flakElevation &lt;= 0<br/>
               || flakElevation &lt;= hex.terrainLevel(Terrains.BLDG_ELEV)<br/>
               || flakElevation == hex.terrainLevel(Terrains.BRIDGE_ELEV))) {<br/>
            //Flak in this hex would only hit landed units<br/>
            return;<br/>
        }<br/>
<br/>
        // get units in hex<br/>
        for (Enumeration impactHexHits = game.getEntities(coords);impactHexHits.hasMoreElements();) {<br/>
            Entity entity = (Entity)impactHexHits.nextElement();<br/>
            int hits = damage;<br/>
            ToHitData toHit = new ToHitData();<br/>
            int cluster = 5;<br/>
            <br/>
            //Check: is entity excluded?<br/>
            if(entity == exclude)<br/>
                continue;<br/>
<br/>
            //Check: is entity inside building?<br/>
            if(bldg != null &amp;&amp;<br/>
               bldgAbsorbs &gt; 0 &amp;&amp;<br/>
               entity.getElevation() &lt; hex.terrainLevel(Terrains.BLDG_ELEV)) {<br/>
                cluster -= bldgAbsorbs;<br/>
                if(entity instanceof Infantry) {<br/>
                    continue; //took its damage already from building damage<br/>
                }<br/>
                else if(cluster &lt;= 0) {<br/>
                    //entity takes no damage<br/>
                    r = new Report(6426);<br/>
                    r.subject = subjectId;<br/>
                    r.addDesc(entity);<br/>
                    addReport(r);<br/>
                    continue;<br/>
                } else {<br/>
                    r = new Report(6425);<br/>
                    r.subject = subjectId;<br/>
                    r.add(bldgAbsorbs);<br/>
                    addReport(r);<br/>
                }<br/>
            }<br/>
<br/>
            if(flak) {<br/>
                //Check: is entity not a VTOL in flight<br/>
                if (!(entity instanceof VTOL ||<br/>
                    entity.getMovementMode()==IEntityMovementMode.VTOL)) {<br/>
                    continue;<br/>
                }<br/>
                //Check: is entity at correct elevation?<br/>
                if(entity.getElevation() != flakElevation)<br/>
                    continue;<br/>
            } else {<br/>
                //Check: is entity a VTOL in flight?<br/>
                if (entity instanceof VTOL ||<br/>
                    entity.getMovementMode()==IEntityMovementMode.VTOL) {<br/>
                    // VTOLs take no damage from normal artillery unless landed<br/>
                    if (entity.getElevation()!=0<br/>
                        &amp;&amp; entity.getElevation()!=hex.terrainLevel(Terrains.BLDG_ELEV)<br/>
                        &amp;&amp; entity.getElevation()!=hex.terrainLevel(Terrains.BRIDGE_ELEV)) {<br/>
                        continue;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            //Work out hit table to use<br/>
            if (attackSource!=null) {<br/>
                toHit.setSideTable(entity.sideTable(attackSource));<br/>
                if(ammo != null <br/>
                   &amp;&amp; entity instanceof Mech<br/>
                   &amp;&amp; ammo.getMunitionType() == AmmoType.M_CLUSTER<br/>
                   &amp;&amp; attackSource.equals(coords)) {<br/>
                    toHit.setHitTable(ToHitData.HIT_ABOVE);<br/>
                }<br/>
            }<br/>
<br/>
            //Entity/ammo specific damage modifiers<br/>
            if(ammo != null) {<br/>
                if(ammo.getMunitionType() == AmmoType.M_CLUSTER) {<br/>
                    if(hex.containsTerrain(Terrains.FORTIFIED) <br/>
                            &amp;&amp; entity instanceof Infantry<br/>
                            &amp;&amp; !(entity instanceof BattleArmor)) {<br/>
                        hits *= 2;<br/>
                    }<br/>
                    if(hex.containsTerrain(Terrains.WOODS)<br/>
                            || hex.containsTerrain(Terrains.JUNGLE)) {<br/>
                        hits = (hits + 1) / 2;<br/>
                    }<br/>
                }<br/>
                else if(ammo.getMunitionType() == AmmoType.M_FLECHETTE) {<br/>
                    //wheeled and hover tanks take movement critical<br/>
                    if(entity instanceof Tank &amp;&amp;<br/>
                       (entity.getMovementMode() == IEntityMovementMode.WHEELED ||<br/>
                        entity.getMovementMode() == IEntityMovementMode.HOVER)) {<br/>
                        r = new Report(6480);<br/>
                        r.subject = entity.getId();<br/>
                        r.addDesc(entity);<br/>
                        r.add(toHit.getTableDesc());<br/>
                        r.add(0);<br/>
                        addReport(r);<br/>
                        vehicleMotiveDamage((Tank)entity, 0);<br/>
                        continue;<br/>
                    }<br/>
                    //non infantry are immune<br/>
                    if(entity instanceof BattleArmor ||<br/>
                       !(entity instanceof Infantry)) {<br/>
                        continue;<br/>
                    }<br/>
                    if(hex.containsTerrain(Terrains.WOODS)<br/>
                            || hex.containsTerrain(Terrains.JUNGLE)) {<br/>
                        hits = (hits + 1) / 2;<br/>
                    }<br/>
                }<br/>
            }<br/>
<br/>
            //Do the damage<br/>
            addNewLines();<br/>
            r = new Report(6480);<br/>
            r.subject = entity.getId();<br/>
            r.addDesc(entity);<br/>
            r.add(toHit.getTableDesc());<br/>
            r.add(hits);<br/>
            addReport(r);<br/>
            while(hits&gt;0) {<br/>
                HitData hit = entity.rollHitLocation(toHit.getHitTable(), toHit.getSideTable());<br/>
<br/>
                addReport( damageEntity(entity, hit, Math.min(cluster, hits), false, 0, false, true, false));<br/>
                hits -= Math.min(5,hits);<br/>
            }<br/>
            if(killer != null) {<br/>
                creditKill(entity, killer);<br/>
            }<br/>
            addNewLines();<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * deal area saturation damage to the map, used for artillery<br/>
     * @param centre         The hex on which damage is centred<br/>
     * @param attackSource   The position the attack came from<br/>
     * @param ammo           The ammo type doing the damage<br/>
     * @param subjectId      Subject for reports<br/>
     * @param killer         Who should be credited with kills<br/>
     * @param flak           Flak, hits flying units only, instead of flyers being immune<br/>
     * @param altitude       Absolute altitude for flak attack<br/>
     */<br/>
    void artilleryDamageArea(Coords centre, Coords attackSource, AmmoType ammo, int subjectId, Entity killer, boolean flak, int altitude) {<br/>
        int damage; <br/>
        int falloff=5;<br/>
        if(ammo.getMunitionType() == AmmoType.M_FLECHETTE) {<br/>
            damage = ammo.getRackSize() + 10;<br/>
        } <br/>
        else if(ammo.getMunitionType() == AmmoType.M_CLUSTER) {<br/>
            if(ammo.getAmmoType() == AmmoType.T_SNIPER)<br/>
                damage = 15;<br/>
            else<br/>
                damage = ammo.getRackSize();<br/>
            attackSource = centre;<br/>
        }<br/>
        else if(game.getOptions().booleanOption("maxtech_artillery")) {<br/>
            //"standard" mutates into high explosive<br/>
            if(ammo.getAmmoType() == AmmoType.T_LONG_TOM)<br/>
                damage = 25;<br/>
            else<br/>
                damage = ammo.getRackSize() + 10;<br/>
            falloff = 10;<br/>
        }<br/>
        else {<br/>
            //level 2 ammo<br/>
            damage = ammo.getRackSize();<br/>
            falloff = (damage + 1) / 2;<br/>
        }<br/>
        artilleryDamageArea(centre, attackSource, ammo, subjectId, killer, damage, falloff, flak, altitude);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Deals area-saturation damage to an area of the board.<br/>
     * Used for artillery, bombs, or anything else with linear decreas in damage<br/>
     * @param centre         The hex on which damage is centred<br/>
     * @param attackSource   The position the attack came from<br/>
     * @param ammo           The ammo type doing the damage<br/>
     * @param subjectId      Subject for reports<br/>
     * @param killer         Who should be credited with kills<br/>
     * @param damage         Damage at ground zero<br/>
     * @param falloff        Reduction in damage for each hex of distance<br/>
     * @param flak           Flak, hits flying units only, instead of flyers being immune<br/>
     * @param altitude       Absolute altitude for flak attack<br/>
     */<br/>
    void artilleryDamageArea(Coords centre, Coords attackSource, AmmoType ammo, int subjectId, Entity killer, int damage, int falloff, boolean flak, int altitude) {<br/>
        for(int ring=0;damage &gt; 0;ring++,damage-=falloff) {<br/>
            ArrayList&lt;Coords&gt; hexes = Compute.coordsAtRange(centre, ring);<br/>
            for(Coords c : hexes) {<br/>
                artilleryDamageHex(c, attackSource, damage, ammo, subjectId, killer, null, flak, altitude);<br/>
            }<br/>
            attackSource = centre; // all splash comes from ground zero<br/>
        }<br/>
    }<br/>
}<br/>
<br/>
</div>
</div>
</div>
<div class="clear"></div>
</div>
</body>
</html>