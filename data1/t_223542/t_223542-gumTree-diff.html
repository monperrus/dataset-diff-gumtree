<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Diff result</title>
<style type="text/css">
body { width: 100%; font-size: 10pt; }
h1 { font-size: 125%; }
div.content { font-family: Verdana, "DejaVu Sans Condensed", "Liberation Sans","Nimbus Sans L", Helvetica, sans-serif; margin : 1em auto; width: 100%; }
div.left { float: left; width: 48%; padding: 1em; }
div.right { float: right; width: 48%; padding: 1em; }
div.code { font-family: "Liberation Mono", "Courrier New", monospace; border:1px solid black;}
div.clear { clear: both; }
span.del { background-color : red; font-weight: normal; font-style: normal;}
span.add { background-color : lightgreen; font-weight: bold; font-style: normal;}
span.upd { background-color : orange; font-weight: bold; font-style: italic;}
span.id { background-color : white; font-weight: normal; font-style: normal;}
span.mv { background-color : yellow; font-weight: normal; font-style: normal;}
</style></head><body><div class="content"><div class="left">
<h1>left_BoardView1_1.214.java</h1>
<div class="code">
<div class="id">
/*<br/>
 * MegaMek -<br/>
 * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)<br/>
 *<br/>
 *  This program is free software; you can redistribute it and/or modify it<br/>
 *  under the terms of the GNU General Public License as published by the Free<br/>
 *  Software Foundation; either version 2 of the License, or (at your option)<br/>
 *  any later version.<br/>
 *<br/>
 *  This program is distributed in the hope that it will be useful, but<br/>
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<br/>
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License<br/>
 *  for more details.<br/>
 */<br/>
<br/>
package megamek.client.ui.AWT;<br/>
<br/>
// Defines Iterator class for JDK v1.1<br/>
import com.sun.java.util.collections.*;<br/>
import java.awt.*;<br/>
import java.awt.event.*;<br/>
import java.awt.image.*;<br/>
import java.util.Enumeration;<br/>
<br/>
import megamek.client.event.BoardViewEvent;<br/>
import megamek.client.event.BoardViewListener;<br/>
import megamek.client.ui.AWT.util.*;<br/>
import megamek.common.*;<br/>
import megamek.common.actions.*;<br/>
import megamek.common.event.BoardEvent;<br/>
import megamek.common.event.BoardListener;<br/>
import megamek.common.event.GameEntityRemoveEvent;<br/>
import megamek.common.event.GameNewActionEvent;<br/>
import megamek.common.event.GameBoardNewEvent;<br/>
import megamek.common.event.GameBoardChangeEvent;<br/>
import megamek.common.event.GameEntityChangeEvent;<br/>
import megamek.common.event.GameEntityNewEvent;<br/>
import megamek.common.event.GameListener;<br/>
import megamek.common.event.GameListenerAdapter;<br/>
import megamek.common.preference.PreferenceManager;<br/>
<br/>
import java.util.Properties;<br/>
<br/>
/**<br/>
 * Displays the board; lets the user scroll around and select points on it.<br/>
 */<br/>
public class BoardView1<br/>
    extends Canvas<br/>
    implements IBoardView, BoardListener, MouseListener, MouseMotionListener, KeyListener, AdjustmentListener<br/>
{<br/>
    private static final int        TRANSPARENT = 0xFFFF00FF;<br/>
<br/>
    // the dimensions of megamek's hex images<br/>
    private static final int        HEX_W = 84;<br/>
    private static final int        HEX_H = 72;<br/>
    private static final int        HEX_WC = HEX_W - HEX_W/4;<br/>
    <br/>
    // The list of valid zoom factors.  Other values cause map aliasing,<br/>
    // I can't be bothered figuring out why.  - Ben<br/>
    private static final float[] ZOOM_FACTORS =<br/>
            {   0.30f, 0.41f, 0.50f,<br/>
                0.60f, 0.68f, 0.79f,<br/>
                0.90f, 1.00f<br/>
                //1.09f, 1.17f<br/>
            };<br/>
    <br/>
    private ImageCache[] scaledImageCaches;<br/>
<br/>
    // the index of zoom factor 1.00f<br/>
    private static final int BASE_ZOOM_INDEX = 7;<br/>
<br/>
    // line width of the c3 network lines<br/>
    private static final int C3_LINE_WIDTH = 1;<br/>
<br/>
    private static Font FONT_7 = new Font("SansSerif", Font.PLAIN, 7); //$NON-NLS-1$<br/>
    private static Font FONT_8 = new Font("SansSerif", Font.PLAIN, 8); //$NON-NLS-1$<br/>
    private static Font FONT_9 = new Font("SansSerif", Font.PLAIN, 9); //$NON-NLS-1$<br/>
    private static Font FONT_10 = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
    private static Font FONT_12 = new Font("SansSerif", Font.PLAIN, 12); //$NON-NLS-1$<br/>
<br/>
    private Dimension       hex_size = null;<br/>
    private boolean         isJ2RE;<br/>
    <br/>
    private Font       font_hexnum          = FONT_10;<br/>
    private Font       font_elev        = FONT_9;<br/>
    private Font       font_minefield   = FONT_12;<br/>
<br/>
    private IGame game;<br/>
    private Frame frame;<br/>
<br/>
    private Point       mousePos = new Point();<br/>
    private Rectangle   view = new Rectangle();<br/>
    private Point       offset = new Point();<br/>
    private Dimension boardSize;<br/>
<br/>
    // scrolly stuff:<br/>
    private Scrollbar vScrollbar = null;<br/>
    private Scrollbar hScrollbar = null;<br/>
    private boolean isScrolling = false;<br/>
    private Point scroll = new Point();<br/>
    private boolean initCtlScroll;<br/>
    private boolean ctlKeyHeld = false;<br/>
    private int previousMouseX;<br/>
    private int previousMouseY;<br/>
<br/>
    // back buffer to draw to<br/>
    private Image backImage;<br/>
    private Dimension backSize;<br/>
    private Graphics backGraph;<br/>
<br/>
    // buffer for all the hexes you can possibly see<br/>
    private Image boardImage;<br/>
    private Rectangle boardRect;<br/>
    private Graphics boardGraph;<br/>
<br/>
    // entity sprites<br/>
    private Vector entitySprites = new Vector();<br/>
    private Hashtable entitySpriteIds = new Hashtable();<br/>
<br/>
    // sprites for the three selection cursors<br/>
    private CursorSprite cursorSprite;<br/>
    private CursorSprite highlightSprite;<br/>
    private CursorSprite selectedSprite;<br/>
    private CursorSprite firstLOSSprite;<br/>
    private CursorSprite secondLOSSprite;<br/>
<br/>
    // sprite for current movement<br/>
    private Vector pathSprites = new Vector();<br/>
<br/>
    // vector of sprites for all firing lines<br/>
    private Vector attackSprites = new Vector();<br/>
<br/>
    // vector of sprites for C3 network lines<br/>
    private Vector C3Sprites = new Vector();<br/>
<br/>
    // tooltip stuff<br/>
    private Window tipWindow;<br/>
    private boolean isTipPossible = false;<br/>
    private long lastIdle;<br/>
<br/>
    private TilesetManager tileManager = null;<br/>
<br/>
    // polygons for a few things<br/>
    private Polygon              hexPoly;<br/>
    private Polygon[]            facingPolys;<br/>
    private Polygon[]            movementPolys;<br/>
<br/>
    // the player who owns this BoardView's client<br/>
    private Player               localPlayer = null;<br/>
<br/>
    // should we mark deployment hexes for a player?<br/>
    private Player               m_plDeployer = null;<br/>
<br/>
    // should be able to turn it off(board editor)<br/>
    private boolean              useLOSTool = true;<br/>
<br/>
    // Initial scale factor for sprites and map<br/>
    private boolean                 hasZoomed = false;<br/>
    public      int                     zoomIndex;<br/>
    private float               scale;<br/>
    private Hashtable scaledImageCache = new Hashtable();<br/>
        <br/>
    // Displayables (Chat box, etc.)<br/>
    private Vector               displayables = new Vector();<br/>
<br/>
    // Move units step by step<br/>
    private Vector                           movingUnits = new Vector();<br/>
    private long                             moveWait = 0;<br/>
<br/>
    // moving entity sprites<br/>
    private Vector movingEntitySprites = new Vector();<br/>
    private Hashtable movingEntitySpriteIds = new Hashtable();<br/>
    private Vector ghostEntitySprites = new Vector();<br/>
    protected transient Vector boardListeners = new Vector();<br/>
<br/>
    // wreck sprites<br/>
    private Vector wreckSprites = new Vector();<br/>
<br/>
    private Coords rulerStart; // added by kenn<br/>
    private Coords rulerEnd; // added by kenn<br/>
    private Color rulerStartColor; // added by kenn<br/>
    private Color rulerEndColor; // added by kenn<br/>
<br/>
    // Position of the mouse before right mouse button was pressed. Used to have an anchor for scrolling <br/>
    private Point oldMousePosition = null;<br/>
    <br/>
    // Indicate that a scrolling took place, so no popup should be drawn on right mouse button release<br/>
    private boolean scrolled = false;<br/>
    <br/>
    private Coords lastCursor;<br/>
    private Coords highlighted;<br/>
    private Coords selected;<br/>
    private Coords firstLOS;<br/>
<br/>
    private ClientGUI clientgui;<br/>
    <br/>
    private RedrawWorker redrawWorker = new RedrawWorker();<br/>
<br/>
    /**<br/>
     * Construct a new board view for the specified game<br/>
     */<br/>
    public BoardView1(IGame game, Frame frame) throws java.io.IOException {<br/>
        this(game, frame, null);<br/>
    }<br/>
<br/>
    /**<br/>
     * Construct a new board view for the specified game<br/>
     */<br/>
    public BoardView1(IGame game, Frame frame, ClientGUI clientgui) throws java.io.IOException {<br/>
        this.clientgui = clientgui;<br/>
        this.game = game;<br/>
        this.frame = frame;<br/>
<br/>
        tileManager = new TilesetManager(this);<br/>
<br/>
        game.addGameListener(gameListener);<br/>
        game.getBoard().addBoardListener(this);<br/>
        redrawWorker.start();<br/>
        addKeyListener(this);<br/>
        addMouseListener(this);<br/>
        addMouseMotionListener(this);<br/>
        /* MouseWheelListener isn't a v1.3.1 API **<br/>
        try{<br/>
            addMouseWheelListener( new MouseWheelListener(){<br/>
                public void mouseWheelMoved(MouseWheelEvent we){<br/>
                    if (we.getWheelRotation() &gt; 0){<br/>
                            zoomIn();<br/>
                    } else {<br/>
                            zoomOut();<br/>
                    }<br/>
                }<br/>
            });<br/>
        } catch ( Throwable error ){<br/>
            System.out.println("Mouse wheel not supported by this jvm");<br/>
        }<br/>
        /* MouseWheelListener isn't a v1.3.1 API */<br/>
        <br/>
        // only use scaling if we're using Java 2, otherwise we get memory leaks etc.<br/>
        Properties p = System.getProperties();<br/>
        String javaVersion = p.getProperty( "java.version" ); //$NON-NLS-1$<br/>
        if ( javaVersion.charAt(2) == '1' ){<br/>
            isJ2RE = false;<br/>
            zoomIndex = BASE_ZOOM_INDEX;<br/>
        } else {<br/>
            isJ2RE = true;<br/>
            zoomIndex = GUIPreferences.getInstance().getMapZoomIndex();<br/>
            checkZoomIndex();<br/>
            hasZoomed = true;<br/>
        }<br/>
        scale = ZOOM_FACTORS[ zoomIndex ];<br/>
        <br/>
        updateFontSizes();<br/>
        updateBoardSize();<br/>
<br/>
        // tooltip<br/>
        tipWindow = new Window(frame);<br/>
        <br/>
        hex_size = new Dimension((int)(HEX_W*scale), (int)(HEX_H*scale));<br/>
        <br/>
        initPolys();<br/>
<br/>
        cursorSprite = new CursorSprite(Color.cyan);<br/>
        highlightSprite = new CursorSprite(Color.white);<br/>
        selectedSprite = new CursorSprite(Color.blue);<br/>
        firstLOSSprite = new CursorSprite(Color.red);<br/>
        secondLOSSprite = new CursorSprite(Color.red);<br/>
        <br/>
        scaledImageCaches = new ImageCache[ZOOM_FACTORS.length];<br/>
        for(int i = 0;i&lt;scaledImageCaches.length;i++) {<br/>
            scaledImageCaches[i] = new ImageCache();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds the specified board listener to receive<br/>
     * board events from this board.<br/>
     *<br/>
     * @param listener the board listener.<br/>
     */<br/>
    public void addBoardViewListener(BoardViewListener listener) {<br/>
        if (!boardListeners.contains(listener)) {<br/>
            boardListeners.addElement(listener);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Removes the specified board listener.<br/>
     *<br/>
     * @param listener the board listener.<br/>
     */<br/>
    public void removeBoardViewListener(BoardViewListener listener) {<br/>
        boardListeners.removeElement(listener);<br/>
    }<br/>
<br/>
    /**<br/>
     * Notifies attached board listeners of the event.<br/>
     *<br/>
     * @param event the board event.<br/>
     */<br/>
    public void processBoardViewEvent(BoardViewEvent event) {<br/>
        if (boardListeners == null) {<br/>
            return;<br/>
        }<br/>
        for(Enumeration e = boardListeners.elements(); e.hasMoreElements();) {<br/>
            BoardViewListener l = (BoardViewListener)e.nextElement();<br/>
            switch(event.getType()) {<br/>
            case BoardViewEvent.BOARD_HEX_CLICKED :<br/>
            case BoardViewEvent.BOARD_HEX_DOUBLECLICKED :<br/>
            case BoardViewEvent.BOARD_HEX_DRAGGED :<br/>
                l.hexMoused(event);<br/>
                break;<br/>
            case BoardViewEvent.BOARD_HEX_CURSOR :<br/>
                l.hexCursor(event);<br/>
                break;<br/>
            case BoardViewEvent.BOARD_HEX_HIGHLIGHTED :<br/>
                l.boardHexHighlighted(event);<br/>
                break;<br/>
            case BoardViewEvent.BOARD_HEX_SELECTED :<br/>
                l.hexSelected(event);<br/>
                break;<br/>
            case BoardViewEvent.BOARD_FIRST_LOS_HEX :<br/>
                l.firstLOSHex(event);<br/>
                break;<br/>
            case BoardViewEvent.BOARD_SECOND_LOS_HEX :<br/>
                l.secondLOSHex(event, getFirstLOS());<br/>
                break;<br/>
            case BoardViewEvent.FINISHED_MOVING_UNITS :<br/>
                l.finishedMovingUnits(event);<br/>
                break;<br/>
            case BoardViewEvent.SELECT_UNIT :<br/>
                l.unitSelected(event);<br/>
                break;<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    public void addMovingUnit(Entity entity, java.util.Vector movePath) {<br/>
        if ( !movePath.isEmpty() ) {<br/>
            Object[] o = new Object[2];<br/>
            o[0] = entity;<br/>
            o[1] = movePath;<br/>
            movingUnits.addElement(o);<br/>
<br/>
            GhostEntitySprite ghostSprite = new GhostEntitySprite(entity);<br/>
            ghostEntitySprites.addElement(ghostSprite);<br/>
<br/>
            // Center on the starting hex of the moving unit.<br/>
            UnitLocation loc = ( (UnitLocation) movePath.elementAt(0) );<br/>
            centerOnHex( loc.getCoords() );<br/>
        }<br/>
    }<br/>
<br/>
    public void addDisplayable(Displayable disp) {<br/>
        displayables.addElement(disp);<br/>
    }<br/>
<br/>
    public void removeDisplayable(Displayable disp) {<br/>
        displayables.removeElement(disp);<br/>
    }<br/>
<br/>
    /**<br/>
     * Specify the scrollbars that control this view's positioning.<br/>
     *<br/>
     * @param   vertical - the vertical &lt;code&gt;Scrollbar&lt;/code&gt;<br/>
     * @param   horizontal - the horizontal &lt;code&gt;Scrollbar&lt;/code&gt;<br/>
     */<br/>
    public void setScrollbars (Scrollbar vertical, Scrollbar horizontal) {<br/>
        this.vScrollbar = vertical;<br/>
        this.hScrollbar = horizontal;<br/>
<br/>
        // When the scroll bars are adjusted, update our offset.<br/>
        this.vScrollbar.addAdjustmentListener (this);<br/>
        this.hScrollbar.addAdjustmentListener (this);<br/>
    }<br/>
<br/>
    /**<br/>
     * Update ourself when a scroll bar is adjusted.<br/>
     *<br/>
     * @param   event - the &lt;code&gt;AdjustmentEvent&lt;/code&gt; that caused this call.<br/>
     */<br/>
    public void adjustmentValueChanged (AdjustmentEvent event) {<br/>
        Point oldPt = this.scroll;<br/>
        Point newPt = new Point (oldPt.x, oldPt.y);<br/>
        if (event.getAdjustable().getOrientation() == Adjustable.VERTICAL) {<br/>
            newPt.y = event.getValue();<br/>
        } else {<br/>
            newPt.x = event.getValue();<br/>
        }<br/>
        this.scroll.setLocation (newPt);<br/>
        this.repaint();<br/>
    }<br/>
<br/>
    public void paint(Graphics g) {<br/>
        update(g);<br/>
    }<br/>
<br/>
    /**<br/>
     * Draw the screen!<br/>
     */<br/>
    public void update(Graphics g) {<br/>
        // Limit our size to the viewport of the scroll pane.<br/>
        final Dimension size = getSize();<br/>
        //         final long startTime = System.currentTimeMillis(); // commentme<br/>
<br/>
        // Make sure our scrollbars have the right sizes.<br/>
        // N.B. A buggy Sun implementation makes me to do this here instead <br/>
        // of updateBoardSize() (which is where *I* think it belongs).<br/>
        if (null != this.vScrollbar) {<br/>
            this.vScrollbar.setVisibleAmount (size.height);<br/>
            this.vScrollbar.setBlockIncrement (size.height);<br/>
            this.vScrollbar.setUnitIncrement ((int) (scale * HEX_H / 2.0));<br/>
            this.vScrollbar.setMaximum (boardSize.height);<br/>
        }<br/>
        if (null != this.hScrollbar) {<br/>
            this.hScrollbar.setVisibleAmount (size.width);<br/>
            this.hScrollbar.setBlockIncrement (size.width);<br/>
            this.hScrollbar.setUnitIncrement ((int) (scale * HEX_W / 2.0));<br/>
            this.hScrollbar.setMaximum (boardSize.width);<br/>
        }<br/>
<br/>
        // update view, offset<br/>
        view.setLocation(scroll);<br/>
        view.setSize(getOptimalView(size));<br/>
        offset.setLocation(getOptimalOffset(size));<br/>
<br/>
        if (!this.isTileImagesLoaded()) {<br/>
            g.drawString(Messages.getString("BoardView1.loadingImages"), 20, 50); //$NON-NLS-1$<br/>
            if (!tileManager.isStarted()) {<br/>
                System.out.println("boardview1: loading images for board"); //$NON-NLS-1$<br/>
                tileManager.loadNeededImages(game);<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // make sure back buffer is valid<br/>
        if (backGraph == null || !view.getSize().equals(backSize)) {<br/>
            // make new back buffer<br/>
            backSize = view.getSize();<br/>
            backImage = createImage(backSize.width, backSize.height);<br/>
            backGraph = backImage.getGraphics();<br/>
        }<br/>
        <br/>
        // make sure board rectangle contains our current view rectangle<br/>
        if (boardImage == null || !boardRect.union(view).equals(boardRect)) {<br/>
            updateBoardImage();<br/>
        }<br/>
<br/>
        // draw onto the back buffer:<br/>
<br/>
        // draw the board<br/>
        backGraph.drawImage(boardImage, 0, 0, this);<br/>
<br/>
        // draw wrecks<br/>
        if (GUIPreferences.getInstance().getShowWrecks()) {<br/>
            drawSprites(wreckSprites);<br/>
        }<br/>
<br/>
        // Minefield signs all over the place!<br/>
        drawMinefields();<br/>
        <br/>
        // Artillery targets<br/>
        drawArtilleryHexes();<br/>
<br/>
        // draw highlight border<br/>
        drawSprite(highlightSprite);<br/>
<br/>
        // draw cursors<br/>
        drawSprite(cursorSprite);<br/>
        drawSprite(selectedSprite);<br/>
        drawSprite(firstLOSSprite);<br/>
        drawSprite(secondLOSSprite);<br/>
<br/>
        // draw deployment indicators<br/>
        if (m_plDeployer != null) {<br/>
            drawDeployment();<br/>
        }<br/>
<br/>
        // draw C3 links<br/>
        drawSprites(C3Sprites);<br/>
<br/>
        // draw onscreen entities<br/>
        drawSprites(entitySprites);<br/>
<br/>
        // draw moving onscreen entities<br/>
        drawSprites(movingEntitySprites);<br/>
<br/>
        // draw ghost onscreen entities<br/>
        drawSprites(ghostEntitySprites);<br/>
<br/>
        // draw onscreen attacks<br/>
        drawSprites(attackSprites);<br/>
<br/>
        // draw movement, if valid<br/>
        drawSprites(pathSprites);<br/>
<br/>
        // added by kenn<br/>
        // draw the ruler line<br/>
        if (rulerStart != null) {<br/>
            Point start =  getCentreHexLocation(rulerStart);<br/>
            if (rulerEnd != null) {<br/>
                Point end = getCentreHexLocation(rulerEnd);<br/>
                backGraph.setColor(Color.yellow);<br/>
                backGraph.drawLine(start.x - boardRect.x, start.y - boardRect.y, end.x - boardRect.x, end.y - boardRect.y);<br/>
<br/>
                backGraph.setColor(rulerEndColor);<br/>
                backGraph.fillRect(end.x - boardRect.x - 1, end.y - boardRect.y - 1, 2, 2);<br/>
            }<br/>
<br/>
            backGraph.setColor(rulerStartColor);<br/>
            backGraph.fillRect(start.x - boardRect.x - 1, start.y - boardRect.y - 1, 2, 2);<br/>
        }<br/>
        // end kenn<br/>
<br/>
        // draw all the "displayables"<br/>
        for (int i = 0; i &lt; displayables.size(); i++) {<br/>
            Displayable disp = (Displayable) displayables.elementAt(i);<br/>
            disp.draw(backGraph, backSize);<br/>
        }<br/>
<br/>
        // draw the back buffer onto the screen<br/>
        // first clear the entire view if the map has been zoomed<br/>
        if ( hasZoomed == true ){<br/>
            Image tmpImage = createImage( size.width, size.height );<br/>
            Graphics tmpGraphics = tmpImage.getGraphics();<br/>
            tmpGraphics.drawImage(backImage, offset.x, offset.y, this);<br/>
            g.drawImage(tmpImage, 0, 0, this);<br/>
            hasZoomed=false;<br/>
        } else {<br/>
            g.drawImage(backImage, offset.x, offset.y, this);<br/>
        }<br/>
        //g.drawString(""+scale, 10, 10);<br/>
<br/>
        //         final long finishTime = System.currentTimeMillis();//commentme<br/>
        //         System.out.println("BoardView1: updated screen in " + (finishTime - startTime) + " ms."); //commentme<br/>
    }<br/>
<br/>
    /**<br/>
     * Updates the boardSize variable with the proper values for this board.<br/>
     */<br/>
    private void updateBoardSize() {<br/>
        int width = game.getBoard().getWidth() * (int)(HEX_WC*scale) + (int)(HEX_W/4*scale);<br/>
        int height = game.getBoard().getHeight() * (int)(HEX_H*scale) + (int)(HEX_H/2*scale);<br/>
        boardSize = new Dimension(width, height);<br/>
    }<br/>
<br/>
    /**<br/>
     * Think up the size of the view rectangle based on the size of the component<br/>
     * and the size of board<br/>
     */<br/>
    private Dimension getOptimalView(Dimension size) {<br/>
        return new Dimension(<br/>
                Math.min(size.width, boardSize.width),<br/>
                Math.min(size.height, boardSize.height));<br/>
    }<br/>
<br/>
    /**<br/>
     * Where should the offset be for this screen size?<br/>
     */<br/>
    private Point getOptimalOffset(Dimension size) {<br/>
        int ox = 0;<br/>
        int oy = 0;<br/>
        if (size.width &gt; boardSize.width) {<br/>
            ox = (size.width - boardSize.width) / 2;<br/>
        }<br/>
        if (size.height &gt; boardSize.height) {<br/>
            oy = (size.height - boardSize.height) / 2;<br/>
        }<br/>
        return new Point(ox, oy);<br/>
    }<br/>
<br/>
    /**<br/>
     * Repaint the bounds of a sprite, offset by view<br/>
     */<br/>
    private void repaintBounds(Rectangle bounds) {<br/>
        if (view != null) {<br/>
            repaint(bounds.x - view.x + offset.x, bounds.y - view.y + offset.y, bounds.width, bounds.height);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Looks through a vector of buffered images and draws them if they're<br/>
     * onscreen.<br/>
     */<br/>
    private synchronized void drawSprites(Vector spriteVector) {<br/>
        for (int i = 0; i &lt; spriteVector.size(); i++) {<br/>
            final Sprite sprite = (Sprite)spriteVector.get(i);<br/>
            drawSprite(sprite);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Draws a sprite, if it is in the current view<br/>
     */<br/>
    private final void drawSprite(Sprite sprite) {<br/>
        if (view.intersects(sprite.getBounds())) {<br/>
            final int drawX = sprite.getBounds().x - view.x;<br/>
            final int drawY = sprite.getBounds().y - view.y;<br/>
            if (!sprite.isReady()) {<br/>
                sprite.prepare();<br/>
            }<br/>
            sprite.drawOnto(backGraph, drawX, drawY, this);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Manages a cache of scaled images.<br/>
     */<br/>
    private Image getScaledImage(Image base) {<br/>
        if (base == null) {<br/>
            return null;<br/>
        }<br/>
        if ( zoomIndex == BASE_ZOOM_INDEX ) {<br/>
            return base;<br/>
        }<br/>
        <br/>
        <br/>
        Image scaled = (Image) scaledImageCaches[zoomIndex].get(base);<br/>
        if (scaled == null) {<br/>
            Dimension d = getImageBounds(base).getSize();<br/>
            d.width *= scale;<br/>
            d.height *= scale;<br/>
            <br/>
            scaled = scale(base, d.width, d.height);<br/>
<br/>
            MediaTracker tracker = new MediaTracker(this);<br/>
            tracker.addImage( scaled, 1 );<br/>
            // Wait for image to load<br/>
            try{<br/>
                tracker.waitForID( 1 );<br/>
            } catch ( InterruptedException e ){ e.printStackTrace(); }<br/>
              <br/>
            scaledImageCaches[zoomIndex].put(base, scaled);<br/>
        }<br/>
        return scaled;<br/>
    }<br/>
   <br/>
    /**<br/>
     * The actual scaling code.<br/>
     */<br/>
    private Image scale(Image img, int width, int height) {<br/>
        ImageFilter filter;<br/>
<br/>
        filter = new ImprovedAveragingScaleFilter(img.getWidth(null),<br/>
                                                  img.getHeight(null),<br/>
                                                  width, height);<br/>
        <br/>
        ImageProducer prod;<br/>
        prod = new FilteredImageSource(img.getSource(), filter);<br/>
        return Toolkit.getDefaultToolkit().createImage(prod);<br/>
    }<br/>
    <br/>
    private static Rectangle getImageBounds(Image im) {<br/>
        return new Rectangle(-im.getWidth(null) / 2, -im.getHeight(null) / 2, im.getWidth(null), im.getHeight(null));<br/>
    }<br/>
<br/>
    /**<br/>
     * The key assigned to each scaled and cached image. Enables easy<br/>
     * retrieval from the hash table.<br/>
     */<br/>
    private static class ScaledCacheKey {<br/>
        private Image base;<br/>
        private Dimension bounds;<br/>
<br/>
        public ScaledCacheKey(Image base, Dimension bounds) {<br/>
          this.bounds = bounds;<br/>
          this.base = base;<br/>
        }<br/>
<br/>
        public boolean equals(Object o) {<br/>
          if (this == o) return true;<br/>
          if (!(o instanceof ScaledCacheKey)) return false;<br/>
<br/>
          final ScaledCacheKey scaledCacheKey = (ScaledCacheKey) o;<br/>
<br/>
          if (!base.equals(scaledCacheKey.base)) return false;<br/>
          if (!bounds.equals(scaledCacheKey.bounds)) return false;<br/>
<br/>
          return true;<br/>
        }<br/>
<br/>
        public int hashCode() {<br/>
          int result;<br/>
          result = base.hashCode();<br/>
          result = 29 * result + bounds.hashCode();<br/>
          return result;<br/>
        }<br/>
      }<br/>
    <br/>
    /**<br/>
     * Draw an outline around legal deployment hexes<br/>
     */<br/>
    private void drawDeployment() {<br/>
        // only update visible hexes<br/>
        int drawX = view.x / (int)(HEX_WC*scale) - 1;<br/>
        int drawY = view.y / (int)(HEX_H*scale) - 1;<br/>
<br/>
        int drawWidth = view.width / (int)(HEX_WC*scale) + 3;<br/>
        int drawHeight = view.height / (int)(HEX_H*scale) + 3;<br/>
        IBoard board = game.getBoard();<br/>
        // loop through the hexes<br/>
        for (int i = 0; i &lt; drawHeight; i++) {<br/>
            for (int j = 0; j &lt; drawWidth; j++) {<br/>
                Coords c = new Coords(j + drawX, i + drawY);<br/>
                Point p = getHexLocation(c);<br/>
                p.translate(-(view.x), -(view.y));<br/>
                if (board.isLegalDeployment(c, m_plDeployer)) {<br/>
                    backGraph.setColor(Color.yellow);<br/>
                    int[] xcoords = { p.x + (int)(21*scale), p.x + (int)(62*scale), p.x + (int)(83*scale), p.x + (int)(83*scale),<br/>
                            p.x + (int)(62*scale), p.x + (int)(21*scale), p.x, p.x };<br/>
                    int[] ycoords = { p.y, p.y, p.y + (int)(35*scale), p.y + (int)(36*scale), p.y + (int)(71*scale),<br/>
                            p.y + (int)(71*scale), p.y + (int)(36*scale), p.y + (int)(35*scale) };<br/>
                    backGraph.drawPolygon(xcoords, ycoords, 8);<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * returns the weapon selected in the mech display,<br/>
     * or null if none selected or it is not artillery<br/>
     **/<br/>
    private Mounted getSelectedArtilleryWeapon() {<br/>
        Entity e = clientgui.mechD.getCurrentEntity();<br/>
        Mounted weapon = null;<br/>
        <br/>
        if(e != null) {<br/>
            weapon = e.getEquipment(clientgui.mechD.wPan.getSelectedWeaponNum());<br/>
        }<br/>
        if (weapon != null) {<br/>
            if(!(weapon.getType() instanceof WeaponType &amp;&amp; weapon.getType().hasFlag(WeaponType.F_ARTILLERY))) {<br/>
                weapon = null;<br/>
            }<br/>
            //otherwise, a weapon is selected, and it is artillery<br/>
        }<br/>
        return weapon;<br/>
    }<br/>
    <br/>
    /** Display artillery modifier in pretargeted hexes<br/>
     */<br/>
    private void drawArtilleryHexes() {<br/>
        if (clientgui != null) {<br/>
            Entity e = clientgui.mechD.getCurrentEntity();<br/>
            Mounted weapon = getSelectedArtilleryWeapon();<br/>
            <br/>
            if(game.getArtillerySize()==0 &amp;&amp; weapon==null) {<br/>
                return; //nothing to do<br/>
            }<br/>
            <br/>
            if (!e.getOwner().equals(clientgui.getClient().getLocalPlayer())) {<br/>
                return; // Not my business to see this<br/>
            }<br/>
            <br/>
            int drawX = view.x / (int)(HEX_WC*scale) - 1;<br/>
            int drawY = view.y / (int)(HEX_H*scale) - 1;<br/>
    <br/>
            int drawWidth = view.width / (int)(HEX_WC*scale) + 3;<br/>
            int drawHeight = view.height / (int)(HEX_H*scale) + 3;<br/>
    <br/>
            IBoard board = game.getBoard();<br/>
            Image scaledImage;<br/>
    <br/>
            // loop through the hexes<br/>
            for (int i = 0; i &lt; drawHeight; i++) {<br/>
                for (int j = 0; j &lt; drawWidth; j++) {<br/>
                    Coords c = new Coords(j + drawX, i + drawY);<br/>
                    Point p = getHexLocation(c);<br/>
                    p.translate(-(view.x), -(view.y));<br/>
    <br/>
                    if (!board.contains(c)){ continue; }<br/>
    <br/>
                    if(weapon != null) {<br/>
                        //process targetted hexes<br/>
                        int amod = 0;<br/>
                        //Check the predesignated hexes<br/>
                        if(e.getOwner().getArtyAutoHitHexes().contains(c)) {<br/>
                            amod = TargetRoll.AUTOMATIC_SUCCESS;<br/>
                        }<br/>
                        else {<br/>
                            amod = e.aTracker.getModifier(weapon, c);<br/>
                        }<br/>
    <br/>
                        if(amod!=0) {<br/>
    <br/>
                            //draw the crosshairs<br/>
                            if(amod==TargetRoll.AUTOMATIC_SUCCESS) {<br/>
                                //predesignated or already hit<br/>
                                scaledImage = getScaledImage(tileManager.getArtilleryTarget(TilesetManager.ARTILLERY_AUTOHIT));<br/>
                            } else {<br/>
                                scaledImage = getScaledImage(tileManager.getArtilleryTarget(TilesetManager.ARTILLERY_ADJUSTED));<br/>
                            }<br/>
    <br/>
                            backGraph.drawImage(scaledImage, p.x, p.y, this);<br/>
                        }<br/>
                    }<br/>
                    //process incoming attacks - requires server to update client's view of game<br/>
                    <br/>
                    for(Enumeration attacks=game.getArtilleryAttacks();attacks.hasMoreElements();) {<br/>
                        ArtilleryAttackAction a = (ArtilleryAttackAction)attacks.nextElement();<br/>
    <br/>
                        if(a.getWR().waa.getTarget(game).getPosition().equals(c)) {<br/>
                            scaledImage = getScaledImage(tileManager.getArtilleryTarget(TilesetManager.ARTILLERY_INCOMING));<br/>
                            backGraph.drawImage(scaledImage, p.x, p.y, this);<br/>
                            break; //do not draw multiple times, tooltop will show all attacks<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    private Vector getArtilleryAttacksAtLocation(Coords c) {<br/>
        Vector v = new Vector();<br/>
        for(Enumeration attacks=game.getArtilleryAttacks();attacks.hasMoreElements();) {<br/>
            ArtilleryAttackAction a = (ArtilleryAttackAction)attacks.nextElement();<br/>
<br/>
            if(a.getWR().waa.getTarget(game).getPosition().equals(c)) {<br/>
                v.addElement(a);<br/>
            }<br/>
        }<br/>
        return v;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Writes "MINEFIELD" in minefield hexes...<br/>
     */<br/>
    private void drawMinefields() {<br/>
        // only update visible hexes<br/>
        int drawX = view.x / (int)(HEX_WC*scale) - 1;<br/>
        int drawY = view.y / (int)(HEX_H*scale) - 1;<br/>
<br/>
        int drawWidth = view.width / (int)(HEX_WC*scale) + 3;<br/>
        int drawHeight = view.height / (int)(HEX_H*scale) + 3;<br/>
<br/>
        IBoard board = game.getBoard();<br/>
        // loop through the hexes<br/>
        for (int i = 0; i &lt; drawHeight; i++) {<br/>
            for (int j = 0; j &lt; drawWidth; j++) {<br/>
                Coords c = new Coords(j + drawX, i + drawY);<br/>
                Point p = getHexLocation(c);<br/>
                p.translate(-(view.x), -(view.y));<br/>
                <br/>
                if (!board.contains(c)){ continue; }<br/>
                if (!game.containsMinefield(c)){ continue; }<br/>
                <br/>
                Minefield mf = (Minefield) game.getMinefields(c).elementAt(0);<br/>
                <br/>
                Image tmpImage = getScaledImage( tileManager.getMinefieldSign());<br/>
                backGraph.drawImage(<br/>
                        tmpImage,<br/>
                        p.x + (int)(13*scale), <br/>
                        p.y + (int)(13*scale), <br/>
                        this);<br/>
                <br/>
                backGraph.setColor(Color.black);<br/>
                int nbrMfs = game.getNbrMinefields(c);<br/>
                if (nbrMfs &gt; 1) {<br/>
                    drawCenteredString(Messages.getString("BoardView1.Multiple"),  //$NON-NLS-1$<br/>
                                p.x,<br/>
                                p.y + (int)(51*scale),<br/>
                                font_minefield,<br/>
                                backGraph);<br/>
                } else if (nbrMfs == 1) {<br/>
                    switch (mf.getType()) {<br/>
                        case (Minefield.TYPE_CONVENTIONAL) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Conventional"), //$NON-NLS-1$<br/>
                                    p.x,<br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                            break;<br/>
                        case (Minefield.TYPE_THUNDER) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Thunder") + mf.getDamage() + ")",  //$NON-NLS-1$ //$NON-NLS-2$<br/>
                                    p.x, <br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                        break;<br/>
                        case (Minefield.TYPE_THUNDER_INFERNO) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Thunder-Inf") + mf.getDamage() + ")",  //$NON-NLS-1$ //$NON-NLS-2$<br/>
                                    p.x,<br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                        break;<br/>
                        case (Minefield.TYPE_THUNDER_ACTIVE) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Thunder-Actv") + mf.getDamage() + ")",  //$NON-NLS-1$ //$NON-NLS-2$<br/>
                                    p.x,<br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                        break;<br/>
                        case (Minefield.TYPE_COMMAND_DETONATED) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Command-"),  //$NON-NLS-1$<br/>
                                    p.x,<br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.detonated"),  //$NON-NLS-1$<br/>
                                    p.x,<br/>
                                    p.y + (int)(60*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                        break;<br/>
                        case (Minefield.TYPE_VIBRABOMB) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Vibrabomb"),  //$NON-NLS-1$<br/>
                                    p.x,<br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                  if (mf.getPlayerId() == localPlayer.getId()) {<br/>
                      drawCenteredString(<br/>
                                    "(" + mf.getSetting() + ")",  //$NON-NLS-1$ //$NON-NLS-2$<br/>
                                        p.x,<br/>
                                        p.y + (int)(60*scale),<br/>
                                        font_minefield,<br/>
                                        backGraph);<br/>
                  }<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    private void drawCenteredString( String string, int x, int y, Font font, Graphics graph ){<br/>
        FontMetrics currentMetrics = getFontMetrics(font);<br/>
        int stringWidth = currentMetrics.stringWidth(string);<br/>
        <br/>
        x += (int)((hex_size.width - stringWidth)/2);<br/>
        <br/>
        graph.setFont(font);<br/>
        graph.drawString( string, x, y );<br/>
    }<br/>
    <br/>
    /**<br/>
     * Updates the board buffer to contain all the hexes needed by the view.<br/>
     */<br/>
    private void updateBoardImage() {<br/>
        // check to make sure image is big enough<br/>
        if (boardGraph == null || view.width &gt; boardRect.width<br/>
            || view.height &gt; boardRect.height) {<br/>
            /* Ok, some history here.  Before the zoom patch, the<br/>
               boardImage was created with the same size as the view.<br/>
               After the zoom patch, the boardImage was created with<br/>
               the same size as the entire board (all maps).  This<br/>
               change ate up a hideous amount of memory (eg: in a 3x3<br/>
               map set test with one mech, memory usage went from<br/>
               about 15MB to 60MB).  I have now changed it back to the<br/>
               old way, and the zoom feature *seems* to still work.<br/>
               Why the zoom author made the change, I cannot say. */<br/>
            boardImage = createImage(view.width, view.height);<br/>
            //boardImage = createImage(boardSize.width, boardSize.height);<br/>
            /* ----- */<br/>
<br/>
            boardGraph = boardImage.getGraphics();<br/>
<br/>
            // Handle resizes correctly.<br/>
            checkScrollBounds();<br/>
            boardRect = new Rectangle(view);<br/>
            System.out.println("boardview1: made a new board buffer " + boardRect); //$NON-NLS-1$<br/>
            drawHexes(view);<br/>
            <br/>
        }<br/>
        if (!boardRect.union(view).equals(boardRect)) {<br/>
            moveBoardImage();<br/>
        }<br/>
    }<br/>
<br/>
    /** <br/>
     * This method creates an image the size of the entire board (all<br/>
     * mapsheets), draws the hexes onto it, and returns that image.<br/>
     */<br/>
    public Image getEntireBoardImage() {<br/>
        Image entireBoard = createImage(boardSize.width, boardSize.height);<br/>
        Graphics temp = boardImage.getGraphics();<br/>
        boardGraph = entireBoard.getGraphics();<br/>
        drawHexes(new Rectangle(boardSize));<br/>
        boardGraph = temp;<br/>
        return entireBoard;<br/>
    }<br/>
<br/>
    /**<br/>
     * Moves the board view to another area.<br/>
     */<br/>
    private void moveBoardImage() {<br/>
        // salvage the old<br/>
<br/>
        boardGraph.setClip(0, 0, boardRect.width, boardRect.height);<br/>
        boardGraph.copyArea(0, 0, boardRect.width, boardRect.height,<br/>
                            boardRect.x - view.x, boardRect.y - view.y);<br/>
<br/>
        // what's left to paint?<br/>
        int midX = Math.max(view.x, boardRect.x);<br/>
        int midWidth = view.width - Math.abs(view.x - boardRect.x);<br/>
        Rectangle unLeft = new Rectangle(view.x, view.y, boardRect.x - view.x, view.height);<br/>
        Rectangle unRight = new Rectangle(boardRect.x + boardRect.width, view.y, view.x -boardRect.x, view.height);<br/>
        Rectangle unTop = new Rectangle(midX, view.y, midWidth, boardRect.y - view.y);<br/>
        Rectangle unBottom = new Rectangle(midX, boardRect.y + boardRect.height, midWidth, view.y - boardRect.y);<br/>
<br/>
        // update boardRect<br/>
        boardRect = new Rectangle(view);<br/>
<br/>
        // paint needed areas<br/>
        if (unLeft.width &gt; 0) {<br/>
            drawHexes(unLeft);<br/>
        } else if (unRight.width &gt; 0) {<br/>
            drawHexes(unRight);<br/>
        }<br/>
        if (unTop.height &gt; 0) {<br/>
            drawHexes(unTop);<br/>
        } else if (unBottom.height &gt; 0) {<br/>
            drawHexes(unBottom);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Redraws all hexes in the specified rectangle<br/>
     */<br/>
    private void drawHexes(Rectangle rect) {<br/>
        <br/>
        // rect is the view<br/>
        int drawX = (int)(rect.x / (HEX_WC*scale))-1;<br/>
        int drawY = (int)(rect.y / (HEX_H*scale))-1;<br/>
<br/>
        int drawWidth = (int)(rect.width / (HEX_WC*scale))+3;<br/>
        int drawHeight = (int)(rect.height / (HEX_H*scale))+3;<br/>
<br/>
        // only draw what we came to draw<br/>
        boardGraph.setClip(rect.x - boardRect.x, rect.y - boardRect.y,<br/>
                           rect.width, rect.height);<br/>
<br/>
        // clear, if we need to<br/>
        if (rect.x &lt; (21*scale)) {<br/>
            boardGraph.clearRect(<br/>
                    rect.x - boardRect.x, rect.y - boardRect.y,<br/>
                    (int)(21*scale) - rect.x, rect.height);<br/>
        }<br/>
        if (rect.y &lt; (36*scale)) {<br/>
            boardGraph.clearRect(<br/>
                    rect.x - boardRect.x, rect.y - boardRect.y,<br/>
                    rect.width, (int)(36*scale) - rect.y);<br/>
        }<br/>
        if (rect.x &gt; boardSize.width - view.width - (21*scale)) {<br/>
            boardGraph.clearRect(<br/>
                    boardRect.width - (int)(21*scale), rect.y - boardRect.y,<br/>
                    (int)(21*scale), rect.height);<br/>
        }<br/>
        if (rect.y &gt; boardSize.height - view.height - (int)(36*scale)) {<br/>
            boardGraph.clearRect(<br/>
                    rect.x - boardRect.x, boardRect.height - (int)(36*scale),<br/>
                    rect.width, (int)(36*scale));<br/>
        }<br/>
<br/>
        // draw some hexes<br/>
        for (int i = 0; i &lt; drawHeight; i++) {<br/>
            for (int j = 0; j &lt; drawWidth; j++) {<br/>
                drawHex(new Coords(j + drawX, i + drawY));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Redraws a hex and all the hexes immediately around it.  Used when the<br/>
     * hex is on the screen, as opposed to when it is scrolling onto the screen,<br/>
     * so it resets the clipping rectangle before drawing.<br/>
     */<br/>
    private void redrawAround(Coords c) {<br/>
        boardGraph.setClip(0, 0, boardRect.width, boardRect.height);<br/>
        drawHex(c);<br/>
        drawHex(c.translated(0));<br/>
        drawHex(c.translated(1));<br/>
        drawHex(c.translated(2));<br/>
        drawHex(c.translated(3));<br/>
        drawHex(c.translated(4));<br/>
        drawHex(c.translated(5));<br/>
    }<br/>
<br/>
    /**<br/>
     * Draws a hex onto the board buffer.  This assumes that boardRect is<br/>
     * current, and does not check if the hex is visible.<br/>
     */<br/>
    private void drawHex(Coords c) {<br/>
        if (!game.getBoard().contains(c)) {<br/>
            return;<br/>
        }<br/>
<br/>
        final IHex hex = game.getBoard().getHex(c);<br/>
        final Point hexLoc = getHexLocation(c);<br/>
<br/>
        int level = hex.getElevation();<br/>
        int depth = hex.depth();<br/>
<br/>
        // offset drawing point<br/>
        <br/>
        int drawX = hexLoc.x - boardRect.x;<br/>
        int drawY = hexLoc.y - boardRect.y;<br/>
<br/>
        // draw picture<br/>
        Image baseImage = tileManager.baseFor(hex);<br/>
        Image scaledImage = getScaledImage(baseImage);<br/>
        <br/>
        boardGraph.drawImage(scaledImage, drawX, drawY, this);<br/>
        <br/>
        if (tileManager.supersFor(hex) != null) {<br/>
            for (Iterator i = tileManager.supersFor(hex).iterator(); i.hasNext();){<br/>
                scaledImage = getScaledImage((Image)i.next());<br/>
                boardGraph.drawImage(scaledImage, drawX, drawY, this);<br/>
            }<br/>
        }<br/>
        <br/>
        if(GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_DARKEN_MAP_AT_NIGHT) &amp;&amp; <br/>
            game.getOptions().booleanOption("night_battle") &amp;&amp;<br/>
            !game.isPositionIlluminated(c)) {<br/>
            scaledImage = getScaledImage(tileManager.getNightFog());<br/>
            boardGraph.drawImage(scaledImage, drawX, drawY, this);<br/>
        }<br/>
        boardGraph.setColor(GUIPreferences.getInstance().getMapTextColor());<br/>
        <br/>
        // draw hex number<br/>
        if (scale &gt;= 0.5){<br/>
            drawCenteredString(<br/>
                    c.getBoardNum(),<br/>
                    drawX,<br/>
                    drawY + (int)(12*scale),<br/>
                    font_hexnum,<br/>
                    boardGraph);<br/>
        }<br/>
        // level | depth<br/>
        if (level != 0 &amp;&amp; depth == 0 &amp;&amp; zoomIndex &gt; 3) {<br/>
            drawCenteredString(<br/>
                    Messages.getString("BoardView1.LEVEL") + level, //$NON-NLS-1$<br/>
                    drawX,<br/>
                    drawY + (int)(70*scale),<br/>
                    font_elev,<br/>
                    boardGraph);<br/>
        } else if (depth != 0 &amp;&amp; level == 0  &amp;&amp; zoomIndex &gt; 3 ) {<br/>
            drawCenteredString(<br/>
                    Messages.getString("BoardView1.DEPTH") + depth, //$NON-NLS-1$<br/>
                    drawX,<br/>
                    drawY + (int)(70*scale),<br/>
                    font_elev,<br/>
                    boardGraph);<br/>
        } else if (level != 0 &amp;&amp; depth != 0  &amp;&amp; zoomIndex &gt; 3) {<br/>
            drawCenteredString(<br/>
                        Messages.getString("BoardView1.LEVEL") + level, //$NON-NLS-1$<br/>
                    drawX,<br/>
                    drawY + (int)(60*scale),<br/>
                    font_elev,<br/>
                    boardGraph);<br/>
                drawCenteredString(<br/>
                        Messages.getString("BoardView1.DEPTH") + depth, //$NON-NLS-1$<br/>
                    drawX,<br/>
                    drawY + (int)(70*scale),<br/>
                    font_elev,<br/>
                    boardGraph);<br/>
        }<br/>
        <br/>
        // draw elevation borders<br/>
        boardGraph.setColor(Color.black);<br/>
        if (drawElevationLine(c, 0)) {<br/>
            boardGraph.drawLine(drawX + (int)(21*scale), drawY, drawX + (int)(62*scale), drawY);<br/>
        }<br/>
        if (drawElevationLine(c, 1)) {<br/>
            boardGraph.drawLine(drawX + (int)(62*scale), drawY, drawX + (int)(83*scale), drawY + (int)(35*scale));<br/>
        }<br/>
        if (drawElevationLine(c, 2)) {<br/>
            boardGraph.drawLine(drawX + (int)(83*scale), drawY + (int)(36*scale), drawX + (int)(62*scale), drawY + (int)(71*scale));<br/>
        }<br/>
        if (drawElevationLine(c, 3)) {<br/>
            boardGraph.drawLine(drawX + (int)(62*scale), drawY + (int)(71*scale), drawX + (int)(21*scale), drawY + (int)(71*scale));<br/>
        }<br/>
        if (drawElevationLine(c, 4)) {<br/>
            boardGraph.drawLine(drawX + (int)(21*scale), drawY + (int)(71*scale), drawX, drawY + (int)(36*scale));<br/>
        }<br/>
        if (drawElevationLine(c, 5)) {<br/>
            boardGraph.drawLine(drawX, drawY + (int)(35*scale), drawX + (int)(21*scale), drawY);<br/>
        }<br/>
<br/>
        // draw mapsheet borders<br/>
        if(GUIPreferences.getInstance().getShowMapsheets()) {<br/>
            boardGraph.setColor(GUIPreferences.getInstance().getColor(GUIPreferences.ADVANCED_MAPSHEET_COLOR));<br/>
            if(c.x % 16 == 0) {<br/>
                //left edge of sheet (edge 4 &amp; 5)<br/>
                boardGraph.drawLine(drawX + (int)(21*scale), drawY + (int)(71*scale), drawX, drawY + (int)(36*scale));<br/>
                boardGraph.drawLine(drawX, drawY + (int)(35*scale), drawX + (int)(21*scale), drawY);<br/>
            }<br/>
            else if(c.x % 16 == 15) {<br/>
                //right edge of sheet (edge 1 &amp; 2)<br/>
                boardGraph.drawLine(drawX + (int)(62*scale), drawY, drawX + (int)(83*scale), drawY + (int)(35*scale));<br/>
                boardGraph.drawLine(drawX + (int)(83*scale), drawY + (int)(36*scale), drawX + (int)(62*scale), drawY + (int)(71*scale));<br/>
            }<br/>
            if(c.y % 17 == 0) {<br/>
                //top edge of sheet (edge 0 and possible 1 &amp; 5)<br/>
                boardGraph.drawLine(drawX + (int)(21*scale), drawY, drawX + (int)(62*scale), drawY);<br/>
                if(c.x % 2 == 0) {<br/>
                    boardGraph.drawLine(drawX + (int)(62*scale), drawY, drawX + (int)(83*scale), drawY + (int)(35*scale));<br/>
                    boardGraph.drawLine(drawX, drawY + (int)(35*scale), drawX + (int)(21*scale), drawY);<br/>
                }<br/>
            } else if (c.y % 17 == 16) {<br/>
                //bottom edge of sheet (edge 3 and possible 2 &amp; 4)<br/>
                boardGraph.drawLine(drawX + (int)(62*scale), drawY + (int)(71*scale), drawX + (int)(21*scale), drawY + (int)(71*scale));<br/>
                if(c.x % 2 == 1) {<br/>
                    boardGraph.drawLine(drawX + (int)(83*scale), drawY + (int)(36*scale), drawX + (int)(62*scale), drawY + (int)(71*scale));<br/>
                    boardGraph.drawLine(drawX + (int)(21*scale), drawY + (int)(71*scale), drawX, drawY + (int)(36*scale));<br/>
                }<br/>
            }<br/>
            boardGraph.setColor(Color.black);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if an elevation line should be drawn between the starting<br/>
     * hex and the hex in the direction specified.  Results should be<br/>
     * transitive, that is, if a line is drawn in one direction, it should be<br/>
     * drawn in the opposite direction as well.<br/>
     */<br/>
    private final boolean drawElevationLine(Coords src, int direction) {<br/>
        final IHex srcHex = game.getBoard().getHex(src);<br/>
        final IHex destHex = game.getBoard().getHexInDir(src, direction);<br/>
        return destHex != null &amp;&amp; srcHex.floor() != destHex.floor();<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the absolute position of the upper-left hand corner<br/>
     * of the hex graphic<br/>
     */<br/>
    private Point getHexLocation(int x, int y) {<br/>
        return new Point(<br/>
                x * (int)(HEX_WC*scale),<br/>
                y * (int)(HEX_H*scale) + ((x &amp; 1) == 1 ? (int)(HEX_H/2*scale) : 0));<br/>
    }<br/>
    private Point getHexLocation(Coords c) {<br/>
        return getHexLocation(c.x, c.y);<br/>
    }<br/>
<br/>
    // added by kenn<br/>
    /**<br/>
     * Returns the absolute position of the centre<br/>
     * of the hex graphic<br/>
     */<br/>
    private Point getCentreHexLocation(int x, int y) {<br/>
        Point p = getHexLocation(x, y);<br/>
        p.x += (HEX_W/2*scale);<br/>
        p.y += (HEX_H/2*scale);<br/>
        return p;<br/>
    }<br/>
    private Point getCentreHexLocation(Coords c) {<br/>
        return getCentreHexLocation(c.x, c.y);<br/>
    }<br/>
    // end kenn<br/>
<br/>
    /**<br/>
     * Returns the coords at the specified point<br/>
     */<br/>
    Coords getCoordsAt(Point p) {<br/>
        final int x = (p.x + scroll.x - offset.x) / (int)(HEX_WC*scale);<br/>
        final int y = ((p.y + scroll.y - offset.y) - ((x &amp; 1) == 1 ? (int)(HEX_H/2*scale) : 0)) / (int)(HEX_H*scale);<br/>
        return new Coords(x, y);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Shows the tooltip thinger<br/>
     */<br/>
    private void showTooltip() {<br/>
        try {<br/>
            final Point tipLoc = new Point(getLocationOnScreen());<br/>
            // retrieve tip text<br/>
            String[] tipText = getTipText(mousePos);<br/>
            if (tipText == null) {<br/>
                return;<br/>
            }<br/>
<br/>
            // update tip text<br/>
            tipWindow.removeAll();<br/>
            tipWindow.add(new TooltipCanvas(tipText));<br/>
            tipWindow.pack();<br/>
<br/>
            tipLoc.translate(mousePos.x, mousePos.y + 20);<br/>
<br/>
            // adjust horizontal location for the tipWindow if it goes off the frame<br/>
            if (frame.getLocation().x + frame.getSize().width &lt; tipLoc.x + tipWindow.getSize().width + 10) {<br/>
                if (frame.getSize().width &gt; tipWindow.getSize().width) {<br/>
                    // bound it by the right edge of the frame<br/>
                    tipLoc.x -= tipLoc.x + tipWindow.getSize().width + 10 - frame.getSize().width - frame.getLocation().x;<br/>
                }<br/>
                else {<br/>
                    // too big to fit, left justify to the frame (roughly).<br/>
                    // how do I extract the first term of HEX_SIZE to use here?--LDE<br/>
                    tipLoc.x = getLocationOnScreen().x + hex_size.width;<br/>
                }<br/>
            }<br/>
<br/>
            // set tip location<br/>
            tipWindow.setLocation(tipLoc);<br/>
<br/>
            tipWindow.show();<br/>
        } catch (Exception e) {<br/>
            tipWindow = new Window(frame);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * The text to be displayed when the mouse is at a certain point<br/>
     */<br/>
    private String[] getTipText(Point point) {<br/>
<br/>
        int stringsSize = 0;<br/>
        IHex mhex = null;<br/>
<br/>
        // first, we have to determine how much text we are going to have<br/>
        // are we on a hex?<br/>
        final Coords mcoords = getCoordsAt(point);<br/>
        if (GUIPreferences.getInstance().getShowMapHexPopup() &amp;&amp; game.getBoard().contains(mcoords)) {<br/>
            mhex = game.getBoard().getHex(mcoords);<br/>
            stringsSize += 1;<br/>
        }<br/>
<br/>
        // check if it's on any entities<br/>
        for (Iterator i = entitySprites.iterator(); i.hasNext();) {<br/>
            final EntitySprite eSprite = (EntitySprite)i.next();<br/>
            if (eSprite.isInside(point)) {<br/>
                stringsSize += 3;<br/>
            }<br/>
        }<br/>
<br/>
        // check if it's on any attacks<br/>
        for (Iterator i = attackSprites.iterator(); i.hasNext();) {<br/>
            final AttackSprite aSprite = (AttackSprite)i.next();<br/>
            if (aSprite.isInside(point)) {<br/>
                stringsSize += 1 + aSprite.weaponDescs.size();<br/>
            }<br/>
        }<br/>
<br/>
        // If the hex contains a building or rubble, make more space.<br/>
        if ( mhex != null &amp;&amp;<br/>
             (mhex.containsTerrain(Terrains.RUBBLE) ||<br/>
              mhex.containsTerrain(Terrains.BUILDING)) ) {<br/>
            stringsSize += 1;<br/>
        }<br/>
<br/>
        stringsSize += game.getNbrMinefields(mcoords);<br/>
        <br/>
        // Artillery<br/>
        final Vector artilleryAttacks = getArtilleryAttacksAtLocation(mcoords);<br/>
        stringsSize += artilleryAttacks.size();<br/>
<br/>
        // Artillery fire adjustment<br/>
        final Mounted selectedWeapon = getSelectedArtilleryWeapon();<br/>
        if(selectedWeapon != null)<br/>
            stringsSize++;<br/>
<br/>
        // if the size is zip, you must a'quit<br/>
        if (stringsSize == 0) {<br/>
            return null;<br/>
        }<br/>
<br/>
        // now we can allocate an array of strings<br/>
        String[] strings = new String[stringsSize];<br/>
        int stringsIndex = 0;<br/>
<br/>
        // are we on a hex?<br/>
        if (mhex != null) {<br/>
            strings[stringsIndex] = Messages.getString("BoardView1.Hex") + mcoords.getBoardNum() //$NON-NLS-1$<br/>
                + Messages.getString("BoardView1.level") + mhex.getElevation(); //$NON-NLS-1$<br/>
            stringsIndex += 1;<br/>
<br/>
            // Do we have rubble?<br/>
            if ( mhex.containsTerrain(Terrains.RUBBLE) ) {<br/>
                strings[stringsIndex] = Messages.getString("BoardView1.Rubble"); //$NON-NLS-1$<br/>
                stringsIndex += 1;<br/>
            }<br/>
<br/>
            // Do we have a building?<br/>
            else if ( mhex.containsTerrain(Terrains.BUILDING) ) {<br/>
                // Get the building.<br/>
                Building bldg = game.getBoard().getBuildingAt( mcoords );<br/>
                StringBuffer buf = new StringBuffer( Messages.getString("BoardView1.Height") ); //$NON-NLS-1$<br/>
                // Each hex of a building has its own elevation.<br/>
                buf.append( mhex.terrainLevel(Terrains.BLDG_ELEV) );<br/>
                buf.append( " " ); //$NON-NLS-1$<br/>
                buf.append( bldg.toString() );<br/>
                buf.append( Messages.getString("BoardView1.CF") ); //$NON-NLS-1$<br/>
                buf.append( bldg.getCurrentCF() );<br/>
                strings[stringsIndex] = buf.toString();<br/>
                stringsIndex += 1;<br/>
            }<br/>
<br/>
            if (game.containsMinefield(mcoords)) {<br/>
                java.util.Vector minefields = game.getMinefields(mcoords);<br/>
                for (int i = 0; i &lt; minefields.size(); i++){<br/>
                    Minefield mf = (Minefield) minefields.elementAt(i);<br/>
                    String owner =  " (" + game.getPlayer(mf.getPlayerId()).getName() + ")"; //$NON-NLS-1$ //$NON-NLS-2$<br/>
<br/>
                    switch (mf.getType()) {<br/>
                    case (Minefield.TYPE_CONVENTIONAL) :<br/>
                        strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield") +" " + owner; //$NON-NLS-1$ //$NON-NLS-2$<br/>
                        break;<br/>
                    case (Minefield.TYPE_THUNDER) :<br/>
                        strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield")+"(" + mf.getDamage() + ")" + owner; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$<br/>
                        break;<br/>
                    case (Minefield.TYPE_COMMAND_DETONATED) :<br/>
                        strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield") +" " + owner; //$NON-NLS-1$ //$NON-NLS-2$<br/>
                        break;<br/>
                    case (Minefield.TYPE_VIBRABOMB) :<br/>
                        if (mf.getPlayerId() == localPlayer.getId()) {<br/>
                            strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield")+"(" + mf.getSetting() + ") " + owner; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$<br/>
                        } else {<br/>
                            strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield") + " " + owner; //$NON-NLS-1$ //$NON-NLS-2$<br/>
                        }<br/>
                        break;<br/>
                    case (Minefield.TYPE_THUNDER_ACTIVE) :<br/>
                        strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield")+"(" + mf.getDamage() + ")" + owner; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$<br/>
                        break;<br/>
                    case (Minefield.TYPE_THUNDER_INFERNO) :<br/>
                        strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield")+"(" + mf.getDamage() + ")" + owner; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$<br/>
                        break;<br/>
                    }<br/>
                    stringsIndex++;<br/>
                }<br/>
            }<br/>
        }<br/>
        // check if it's on any entities<br/>
        for (Iterator i = entitySprites.iterator(); i.hasNext();) {<br/>
            final EntitySprite eSprite = (EntitySprite)i.next();<br/>
            if (eSprite.isInside(point)) {<br/>
                final String[] entityStrings = eSprite.getTooltip();<br/>
                java.lang.System.arraycopy(entityStrings, 0, strings, stringsIndex, entityStrings.length);<br/>
                stringsIndex += entityStrings.length;<br/>
            }<br/>
        }<br/>
<br/>
        // check if it's on any attacks<br/>
        for (Iterator i = attackSprites.iterator(); i.hasNext();) {<br/>
            final AttackSprite aSprite = (AttackSprite)i.next();<br/>
            if (aSprite.isInside(point)) {<br/>
                final String[] attackStrings = aSprite.getTooltip();<br/>
                java.lang.System.arraycopy(attackStrings, 0, strings, stringsIndex, attackStrings.length);<br/>
                stringsIndex += 1 + aSprite.weaponDescs.size();<br/>
            }<br/>
        }<br/>
        <br/>
        // check artillery attacks<br/>
        for(Iterator i = artilleryAttacks.iterator(); i.hasNext();) {<br/>
            final ArtilleryAttackAction aaa = (ArtilleryAttackAction)i.next();<br/>
            final WeaponResult wr = aaa.getWR();<br/>
            final Entity ae = game.getEntity(wr.waa.getEntityId());<br/>
            String s = null;<br/>
            if(ae != null) {<br/>
                if(wr.waa.getWeaponId() &gt; -1) {<br/>
                    Mounted weap = ae.getEquipment(wr.waa.getWeaponId());<br/>
                    s = weap.getName();<br/>
                    if(wr.waa.getAmmoId() &gt; -1) {<br/>
                        Mounted ammo = ae.getEquipment(wr.waa.getAmmoId());<br/>
                        s += "(" + ammo.getName() + ")";<br/>
                    }<br/>
                }<br/>
            }<br/>
            if(s == null) {<br/>
                s = Messages.getString("BoardView1.Artillery");<br/>
            }<br/>
            strings[stringsIndex++] = Messages.getString("BoardView1.ArtilleryAttack", <br/>
                    new Object[] { s, new Integer(aaa.turnsTilHit), wr.toHit.getValueAsString() } );<br/>
        }<br/>
        //check artillery fire adjustment<br/>
        final Entity selectedEntity = clientgui.mechD.getCurrentEntity();<br/>
        if(selectedWeapon != null &amp;&amp; selectedEntity != null) {<br/>
            //process targetted hexes<br/>
            int amod = 0;<br/>
            //Check the predesignated hexes<br/>
            if(selectedEntity.getOwner().getArtyAutoHitHexes().contains(mcoords)) {<br/>
                amod = TargetRoll.AUTOMATIC_SUCCESS;<br/>
            }<br/>
            else {<br/>
                amod = selectedEntity.aTracker.getModifier(selectedWeapon, mcoords);<br/>
            }<br/>
<br/>
            if(amod==TargetRoll.AUTOMATIC_SUCCESS) {<br/>
                strings[stringsIndex++] = Messages.getString("BoardView1.ArtilleryAutohit");<br/>
            } else {<br/>
                strings[stringsIndex++] = Messages.getString("BoardView1.ArtilleryAdjustment", new Object[] { new Integer(amod) } );<br/>
            }<br/>
        }<br/>
        return strings;<br/>
    }<br/>
<br/>
    /**<br/>
     * Hides the tooltip thinger<br/>
     */<br/>
    public void hideTooltip() {<br/>
        tipWindow.setVisible(false);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the tooltip is showing<br/>
     */<br/>
    private boolean isTipShowing() {<br/>
        return tipWindow.isShowing();<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks if the mouse has been idling for a while and if so, shows the<br/>
     * tooltip window<br/>
     */<br/>
    private void checkTooltip() {<br/>
        if (isTipShowing()) {<br/>
            if (!isTipPossible) {<br/>
                hideTooltip();<br/>
            }<br/>
        } else if (isTipPossible &amp;&amp; System.currentTimeMillis() - lastIdle &gt; GUIPreferences.getInstance().getTooltipDelay()) {<br/>
            showTooltip();<br/>
        }<br/>
    }<br/>
<br/>
    public void redrawMovingEntity(Entity entity, Coords position, int facing) {<br/>
        Integer entityId = new Integer( entity.getId() );<br/>
        EntitySprite sprite = (EntitySprite) entitySpriteIds.get( entityId );<br/>
        Vector newSprites;<br/>
        Hashtable newSpriteIds;<br/>
<br/>
        if (sprite != null) {<br/>
            newSprites = new Vector(entitySprites);<br/>
            newSpriteIds = new Hashtable(entitySpriteIds);<br/>
<br/>
            newSprites.removeElement(sprite);<br/>
<br/>
            entitySprites = newSprites;<br/>
            entitySpriteIds = newSpriteIds;<br/>
        }<br/>
<br/>
        MovingEntitySprite mSprite =<br/>
            (MovingEntitySprite) movingEntitySpriteIds.get( entityId );<br/>
        newSprites = new Vector(movingEntitySprites);<br/>
        newSpriteIds = new Hashtable(movingEntitySpriteIds);<br/>
<br/>
<br/>
        if (mSprite != null) {<br/>
            newSprites.removeElement(mSprite);<br/>
        }<br/>
<br/>
        if (entity.getPosition() != null) {<br/>
            mSprite = new MovingEntitySprite(entity, position, facing);<br/>
            newSprites.addElement(mSprite);<br/>
            newSpriteIds.put( entityId, mSprite );<br/>
        }<br/>
<br/>
        movingEntitySprites = newSprites;<br/>
        movingEntitySpriteIds = newSpriteIds;<br/>
    }<br/>
<br/>
    public boolean isMovingUnits() {<br/>
        return movingUnits.size() &gt; 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears the sprite for an entity and prepares it to be re-drawn.<br/>
     *  Replaces the old sprite with the new!<br/>
     *<br/>
     *  Try to prevent annoying ConcurrentModificationExceptions<br/>
     */<br/>
    public void redrawEntity(Entity entity) {<br/>
        Integer entityId = new Integer( entity.getId() );<br/>
        EntitySprite sprite = (EntitySprite)entitySpriteIds.get( entityId );<br/>
        Vector newSprites = new Vector(entitySprites);<br/>
        Hashtable newSpriteIds = new Hashtable(entitySpriteIds);<br/>
<br/>
<br/>
        if (sprite != null) {<br/>
            newSprites.removeElement(sprite);<br/>
        }<br/>
        Coords position = entity.getPosition();<br/>
        if (position != null) {<br/>
            /*drawHex(position);<br/>
            IHex foo = game.getBoard().getHex(position);<br/>
            foo.markChanged(); */// TODO: Is this really necessary?<br/>
            <br/>
            sprite = new EntitySprite(entity);<br/>
            newSprites.addElement(sprite);<br/>
            newSpriteIds.put( entityId, sprite );<br/>
        }<br/>
<br/>
        entitySprites = newSprites;<br/>
        entitySpriteIds = newSpriteIds;<br/>
<br/>
        for (java.util.Enumeration i = C3Sprites.elements(); i.hasMoreElements();) {<br/>
            final C3Sprite c3sprite = (C3Sprite)i.nextElement();<br/>
            if (c3sprite.entityId == entity.getId())<br/>
                C3Sprites.removeElement(c3sprite);<br/>
            else if(c3sprite.masterId == entity.getId()) {<br/>
                // Only redraw client-to-master; otherwise<br/>
                // we leave stray lines when we move.<br/>
                if(entity.hasC3()) {<br/>
                    C3Sprites.addElement(new C3Sprite(game.getEntity(c3sprite.entityId), game.getEntity(c3sprite.masterId)));<br/>
                }<br/>
                C3Sprites.removeElement(c3sprite);<br/>
<br/>
            }<br/>
        }<br/>
<br/>
        if(entity.hasC3() || entity.hasC3i()) addC3Link(entity);<br/>
<br/>
        repaint(100);<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears all old entity sprites out of memory and sets up new ones.<br/>
     */<br/>
    private void redrawAllEntities() {<br/>
        Vector newSprites = new Vector(game.getNoOfEntities());<br/>
        Hashtable newSpriteIds = new Hashtable(game.getNoOfEntities());<br/>
        Vector newWrecks = new Vector();<br/>
<br/>
        Enumeration e = game.getWreckedEntities();<br/>
        while (e.hasMoreElements()) {<br/>
            Entity entity = (Entity) e.nextElement();<br/>
            if (!(entity instanceof Infantry) &amp;&amp; (entity.getPosition() != null)) {<br/>
                WreckSprite ws = new WreckSprite(entity);<br/>
                newWrecks.addElement(ws);<br/>
            }<br/>
        }<br/>
<br/>
        clearC3Networks();<br/>
        for (java.util.Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (entity.getPosition() == null) continue;<br/>
<br/>
            EntitySprite sprite = new EntitySprite(entity);<br/>
            newSprites.add(sprite);<br/>
            newSpriteIds.put(new Integer(entity.getId()), sprite);<br/>
<br/>
            if(entity.hasC3() || entity.hasC3i()) addC3Link(entity);<br/>
        }<br/>
<br/>
        entitySprites = newSprites;<br/>
        entitySpriteIds = newSpriteIds;<br/>
        wreckSprites = newWrecks;<br/>
<br/>
        repaint(100);<br/>
    }<br/>
<br/>
    /**<br/>
     * Moves the cursor to the new position, or hides it, if newPos is null<br/>
     */<br/>
    private void moveCursor(CursorSprite cursor, Coords newPos) {<br/>
        final Rectangle oldBounds = new Rectangle(cursor.getBounds());<br/>
        if (newPos != null) {<br/>
            //cursor.setLocation(getHexLocation(newPos));<br/>
            cursor.setHexLocation(newPos);<br/>
        } else {<br/>
            cursor.setOffScreen();<br/>
        }<br/>
        // repaint affected area<br/>
        repaintBounds(oldBounds);<br/>
        repaintBounds(cursor.getBounds());<br/>
    }<br/>
<br/>
<br/>
    public void centerOnHex(Coords c) {<br/>
        if ( null == c ) return;<br/>
        scroll.setLocation(getHexLocation(c));<br/>
        scroll.translate((int)(42*scale) - (view.width / 2), (int)(36*scale) - (view.height / 2));<br/>
<br/>
        isScrolling = false;<br/>
        checkScrollBounds();<br/>
        repaint();<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears the old movement data and draws the new.  Since it's less<br/>
     * expensive to check for and reuse old step sprites than to make a whole<br/>
     * new one, we do that.<br/>
     */<br/>
    public void drawMovementData(Entity entity, MovePath md) {<br/>
        Vector temp = pathSprites;<br/>
<br/>
        clearMovementData();<br/>
<br/>
        for (java.util.Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MoveStep step = (MoveStep)i.nextElement();<br/>
            // check old movement path for reusable step sprites<br/>
            boolean found = false;<br/>
            for (Iterator j = temp.iterator(); j.hasNext();) {<br/>
                final StepSprite sprite = (StepSprite)j.next();<br/>
                if (sprite.getStep().canReuseSprite(step)) {<br/>
                    pathSprites.addElement(sprite);<br/>
                    found = true;<br/>
                }<br/>
            }<br/>
            if (!found) {<br/>
                pathSprites.addElement(new StepSprite(step));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears current movement data from the screen<br/>
     */<br/>
    public void clearMovementData() {<br/>
        Vector temp = pathSprites;<br/>
        pathSprites = new Vector();<br/>
        for (Iterator i = temp.iterator(); i.hasNext();) {<br/>
            final Sprite sprite = (Sprite)i.next();<br/>
            repaintBounds(sprite.getBounds());<br/>
        }<br/>
    }<br/>
<br/>
    public void setLocalPlayer(Player p) {<br/>
        localPlayer = p;<br/>
    }<br/>
<br/>
    public Player getLocalPlayer() {<br/>
        return localPlayer;<br/>
    }<br/>
<br/>
    /**<br/>
     * Specifies that this should mark the deployment hexes for a player.  If<br/>
     * the player is set to null, no hexes will be marked.<br/>
     */<br/>
    public void markDeploymentHexesFor(Player p)<br/>
    {<br/>
        m_plDeployer = p;<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a c3 line to the sprite list.<br/>
     */<br/>
    public void addC3Link(Entity e) {<br/>
        if (e.getPosition() == null) return;<br/>
<br/>
        if(e.hasC3i()) {<br/>
            for (java.util.Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
                final Entity fe = (Entity)i.nextElement();<br/>
                if (fe.getPosition() == null) return;<br/>
                if ( e.onSameC3NetworkAs(fe)) {<br/>
                    C3Sprites.addElement(new C3Sprite(e, fe));<br/>
                }<br/>
            }<br/>
        }<br/>
        else if(e.getC3Master() != null) {<br/>
            Entity eMaster = e.getC3Master();<br/>
            if (eMaster.getPosition() == null) return;<br/>
<br/>
            // ECM cuts off the network<br/>
            if (!Compute.isAffectedByECM(e, e.getPosition(), eMaster.getPosition())) {<br/>
                C3Sprites.addElement(new C3Sprite(e, e.getC3Master()));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds an attack to the sprite list.<br/>
     */<br/>
    public void addAttack(AttackAction aa) {<br/>
        // do not make a sprite unless we're aware of both entities<br/>
        // this is not a great solution but better than a crash<br/>
        Entity ae = game.getEntity(aa.getEntityId());<br/>
        Targetable t = game.getTarget(aa.getTargetType(), aa.getTargetId());<br/>
        if (ae == null || t == null || t.getTargetType() == Targetable.TYPE_INARC_POD) {<br/>
            return;<br/>
        }<br/>
<br/>
        for (final Iterator i = attackSprites.iterator(); i.hasNext();) {<br/>
            final AttackSprite sprite = (AttackSprite)i.next();<br/>
<br/>
            // can we just add this attack to an existing one?<br/>
            if (sprite.getEntityId() == aa.getEntityId()<br/>
                &amp;&amp; sprite.getTargetId() == aa.getTargetId()) {<br/>
                // use existing attack, but add this weapon<br/>
                if (aa instanceof WeaponAttackAction) {<br/>
                    WeaponAttackAction waa = (WeaponAttackAction)aa;<br/>
                    if ( aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY <br/>
                        &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_FASCAM<br/>
                        &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_INFERNO_IV<br/>
                        &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_VIBRABOMB_IV) {<br/>
                        sprite.addWeapon(waa);<br/>
                    } else if ( waa.getEntity(game).getOwner().getId() == localPlayer.getId()) {<br/>
                        sprite.addWeapon(waa);<br/>
                    }<br/>
                }<br/>
                if (aa instanceof KickAttackAction) {<br/>
                    sprite.addWeapon((KickAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof PunchAttackAction) {<br/>
                    sprite.addWeapon((PunchAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof PushAttackAction) {<br/>
                    sprite.addWeapon((PushAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof ClubAttackAction) {<br/>
                    sprite.addWeapon((ClubAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof ChargeAttackAction) {<br/>
                    sprite.addWeapon((ChargeAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof DfaAttackAction) {<br/>
                    sprite.addWeapon((DfaAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof ProtomechPhysicalAttackAction) {<br/>
                    sprite.addWeapon((ProtomechPhysicalAttackAction)aa);<br/>
                }<br/>
                return;<br/>
            }<br/>
        }<br/>
        // no re-use possible, add a new one<br/>
        // don't add a sprite for an artillery attack made by the other player<br/>
        if (aa instanceof WeaponAttackAction) {<br/>
            WeaponAttackAction waa = (WeaponAttackAction)aa;<br/>
            if ( aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY <br/>
                &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_FASCAM<br/>
                &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_INFERNO_IV<br/>
                &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_VIBRABOMB_IV) {<br/>
                attackSprites.addElement(new AttackSprite(aa));<br/>
            } else if ( waa.getEntity(game).getOwner().getId() == localPlayer.getId()) {<br/>
                attackSprites.addElement(new AttackSprite(aa));<br/>
            }<br/>
        } else {<br/>
            attackSprites.addElement(new AttackSprite(aa));<br/>
        }<br/>
    }<br/>
<br/>
    /** Removes all attack sprites from a certain entity */<br/>
    public void removeAttacksFor(int entityId) {<br/>
        // or rather, only keep sprites NOT for that entity<br/>
        Vector toKeep = new Vector(attackSprites.size());<br/>
        for (Iterator i = attackSprites.iterator(); i.hasNext();) {<br/>
            AttackSprite sprite = (AttackSprite)i.next();<br/>
            if (sprite.getEntityId() != entityId) {<br/>
                toKeep.addElement(sprite);<br/>
            }<br/>
        }<br/>
        this.attackSprites = toKeep;<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears out all attacks and re-adds the ones in the current game.<br/>
     */<br/>
    public void refreshAttacks() {<br/>
        clearAllAttacks();<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
            if (ea instanceof AttackAction) {<br/>
                addAttack((AttackAction)ea);<br/>
            }<br/>
        }<br/>
        for (Enumeration i = game.getCharges(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
            if (ea instanceof AttackAction) {<br/>
                addAttack((AttackAction)ea);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    public void clearC3Networks() {<br/>
        C3Sprites.removeAllElements();<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears out all attacks that were being drawn<br/>
     */<br/>
    public void clearAllAttacks() {<br/>
        attackSprites.removeAllElements();<br/>
    }<br/>
<br/>
    public Image baseFor(IHex hex) {<br/>
        return tileManager.baseFor(hex);<br/>
    }<br/>
<br/>
    public com.sun.java.util.collections.List supersFor(IHex hex) {<br/>
        return tileManager.supersFor(hex);<br/>
    }<br/>
<br/>
    protected void firstLOSHex(Coords c) {<br/>
        if (useLOSTool) {<br/>
            moveCursor(secondLOSSprite, null);<br/>
            moveCursor(firstLOSSprite, c);<br/>
        }<br/>
    }<br/>
<br/>
    protected void secondLOSHex(Coords c2, Coords c1) {<br/>
        if (useLOSTool) {<br/>
            moveCursor(firstLOSSprite, c1);<br/>
            moveCursor(secondLOSSprite, c2);<br/>
            <br/>
            boolean mechInFirst = GUIPreferences.getInstance().getMechInFirst();<br/>
            boolean mechInSecond = GUIPreferences.getInstance().getMechInSecond();<br/>
            <br/>
            LosEffects.AttackInfo ai = new LosEffects.AttackInfo();<br/>
            ai.attackPos = c1;<br/>
            ai.targetPos = c2;<br/>
            ai.attackHeight = mechInFirst?1:0;<br/>
            ai.targetHeight = mechInSecond?1:0;<br/>
            ai.attackAbsHeight = game.getBoard().getHex(c1).floor() + ai.attackHeight;<br/>
            ai.targetAbsHeight = game.getBoard().getHex(c2).floor() + ai.targetHeight;<br/>
<br/>
            LosEffects le = LosEffects.calculateLos(game, ai);<br/>
            StringBuffer message = new StringBuffer();<br/>
            message.append(Messages.getString("BoardView1.Attacker", new Object[]{ //$NON-NLS-1$<br/>
                    mechInFirst ? Messages.getString("BoardView1.Mech") : Messages.getString("BoardView1.NonMech"), //$NON-NLS-1$ //$NON-NLS-2$<br/>
                    c1.getBoardNum()}));<br/>
            message.append(Messages.getString("BoardView1.Target", new Object[]{ //$NON-NLS-1$<br/>
                    mechInSecond ? Messages.getString("BoardView1.Mech") : Messages.getString("BoardView1.NonMech"), //$NON-NLS-1$ //$NON-NLS-2$<br/>
                    c1.getBoardNum()}));<br/>
            if (!le.canSee()) {<br/>
                message.append(Messages.getString("BoardView1.LOSBlocked", new Object[]{ //$NON-NLS-1$<br/>
                    new Integer(c1.distance(c2))}));<br/>
            } else {<br/>
                message.append(Messages.getString("BoardView1.LOSNotBlocked", new Object[]{ //$NON-NLS-1$<br/>
                        new Integer(c1.distance(c2))}));<br/>
                if (le.getHeavyWoods() &gt; 0) {<br/>
                    message.append(Messages.getString("BoardView1.HeavyWoods", new Object[]{ //$NON-NLS-1$<br/>
                            new Integer(le.getHeavyWoods())}));<br/>
                }<br/>
                if (le.getLightWoods() &gt; 0) {<br/>
                    message.append(Messages.getString("BoardView1.LightWoods", new Object[]{ //$NON-NLS-1$<br/>
                            new Integer(le.getLightWoods())}));<br/>
                }<br/>
                if (le.getLightSmoke() &gt; 0) {<br/>
                    message.append(Messages.getString("BoardView1.LightSmoke", new Object[]{ //$NON-NLS-1$<br/>
                            new Integer(le.getLightSmoke())}));<br/>
                }<br/>
                if (le.getHeavySmoke() &gt; 0) {<br/>
                    if (game.getOptions().booleanOption("maxtech_fire")) { //$NON-NLS-1$<br/>
                        message.append(Messages.getString("BoardView1.HeavySmoke", new Object[]{ //$NON-NLS-1$<br/>
                                new Integer(le.getHeavySmoke())}));<br/>
                    }<br/>
                    else {<br/>
                        message.append(Messages.getString("BoardView1.Smoke", new Object[]{ //$NON-NLS-1$<br/>
                                new Integer(le.getHeavySmoke())}));<br/>
                    }<br/>
                }<br/>
                if (le.isTargetCover()) {<br/>
                    message.append(Messages.getString("BoardView1.TargetPartialCover")); //$NON-NLS-1$<br/>
                }<br/>
                if (le.isAttackerCover()) {<br/>
                    message.append(Messages.getString("BoardView1.AttackerPartialCover")); //$NON-NLS-1$<br/>
                }<br/>
            }<br/>
            AlertDialog alert = new AlertDialog(frame,<br/>
                                                Messages.getString("BoardView1.LOSTitle"), //$NON-NLS-1$<br/>
                                                message.toString(), false);<br/>
            alert.show();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * If the mouse is at the edges of the screen, this<br/>
     * scrolls the board image on the canvas.<br/>
     * NOTE: CTL scroll is handled in mouseMoved()<br/>
     */<br/>
    public boolean doScroll() {<br/>
        final Point oldScroll = new Point(scroll);<br/>
        boolean s = false;<br/>
        <br/>
        if ( isScrolling &amp;&amp; GUIPreferences.getInstance().getRightDragScroll()) {<br/>
            if (! (oldMousePosition == null || mousePos.equals(oldMousePosition)) ) {<br/>
                scroll.x -= GUIPreferences.getInstance().getScrollSensitivity() * (mousePos.x - oldMousePosition.x);<br/>
                scroll.y -= GUIPreferences.getInstance().getScrollSensitivity() * (mousePos.y - oldMousePosition.y);<br/>
                checkScrollBounds();<br/>
                oldMousePosition.setLocation(mousePos);<br/>
                s = !oldScroll.equals(scroll);<br/>
                scrolled = scrolled || s;<br/>
            }<br/>
        }<br/>
<br/>
        if (isScrolling &amp;&amp; (GUIPreferences.getInstance().getClickEdgeScroll() ||GUIPreferences.getInstance().getAutoEdgeScroll()) ) {<br/>
            final int sf = GUIPreferences.getInstance().getScrollSensitivity(); // scroll factor<br/>
            // adjust x scroll<br/>
            // scroll when the mouse is at the edges<br/>
            if (mousePos.x &lt; 100) {<br/>
                scroll.x -= (100 - mousePos.x) / sf;<br/>
            } else if (mousePos.x &gt; (backSize.width - 100)) {<br/>
                scroll.x -= ((backSize.width - 100) - mousePos.x) / sf;<br/>
            }<br/>
            // scroll when the mouse is at the edges<br/>
            if (mousePos.y &lt; 100) {<br/>
                scroll.y -= (100 - mousePos.y) / sf;<br/>
            } else if (mousePos.y &gt; (backSize.height - 100)) {<br/>
                scroll.y -= ((backSize.height - 100) - mousePos.y) / sf;<br/>
            }<br/>
            checkScrollBounds();<br/>
            if (!oldScroll.equals(scroll)) {<br/>
                //            repaint();<br/>
                s = true;<br/>
                scrolled = s;<br/>
            }<br/>
        }<br/>
<br/>
        return s;<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes sure that the scroll dimensions stay in bounds<br/>
     */<br/>
    public void checkScrollBounds() {<br/>
        if (scroll.x &lt; 0) {<br/>
            scroll.x = 0;<br/>
        } else if (scroll.x &gt; (boardSize.width - view.width)) {<br/>
            scroll.x = (boardSize.width - view.width);<br/>
        }<br/>
<br/>
        if (scroll.y &lt; 0) {<br/>
            scroll.y = 0;<br/>
        } else if (scroll.y &gt; (boardSize.height - view.height)) {<br/>
            scroll.y = (boardSize.height - view.height);<br/>
        }<br/>
<br/>
        // Update our scroll bars.<br/>
        if (null != this.vScrollbar) {<br/>
            this.vScrollbar.setValue (scroll.y);<br/>
        }<br/>
        if (null != this.hScrollbar) {<br/>
            this.hScrollbar.setValue (scroll.x);<br/>
        }<br/>
    }<br/>
<br/>
    protected void stopScrolling() {<br/>
        isScrolling = false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Initializes the various overlay polygons with their<br/>
     * vertices.<br/>
     */<br/>
    public void initPolys() {<br/>
        // hex polygon<br/>
        hexPoly = new Polygon();<br/>
        hexPoly.addPoint(21, 0);<br/>
        hexPoly.addPoint(62, 0);<br/>
        hexPoly.addPoint(83, 35);<br/>
        hexPoly.addPoint(83, 36);<br/>
        hexPoly.addPoint(62, 71);<br/>
        hexPoly.addPoint(21, 71);<br/>
        hexPoly.addPoint(0, 36);<br/>
        hexPoly.addPoint(0, 35);<br/>
<br/>
        // facing polygons<br/>
        facingPolys = new Polygon[6];<br/>
        facingPolys[0] = new Polygon();<br/>
        facingPolys[0].addPoint(41, 3);<br/>
        facingPolys[0].addPoint(38, 6);<br/>
        facingPolys[0].addPoint(45, 6);<br/>
        facingPolys[0].addPoint(42, 3);<br/>
        facingPolys[1] = new Polygon();<br/>
        facingPolys[1].addPoint(69, 17);<br/>
        facingPolys[1].addPoint(64, 17);<br/>
        facingPolys[1].addPoint(68, 23);<br/>
        facingPolys[1].addPoint(70, 19);<br/>
        facingPolys[2] = new Polygon();<br/>
        facingPolys[2].addPoint(69, 53);<br/>
        facingPolys[2].addPoint(68, 49);<br/>
        facingPolys[2].addPoint(64, 55);<br/>
        facingPolys[2].addPoint(68, 54);<br/>
        facingPolys[3] = new Polygon();<br/>
        facingPolys[3].addPoint(41, 68);<br/>
        facingPolys[3].addPoint(38, 65);<br/>
        facingPolys[3].addPoint(45, 65);<br/>
        facingPolys[3].addPoint(42, 68);<br/>
        facingPolys[4] = new Polygon();<br/>
        facingPolys[4].addPoint(15, 53);<br/>
        facingPolys[4].addPoint(18, 54);<br/>
        facingPolys[4].addPoint(15, 48);<br/>
        facingPolys[4].addPoint(14, 52);<br/>
        facingPolys[5] = new Polygon();<br/>
        facingPolys[5].addPoint(13, 19);<br/>
        facingPolys[5].addPoint(15, 23);<br/>
        facingPolys[5].addPoint(19, 17);<br/>
        facingPolys[5].addPoint(17, 17);<br/>
<br/>
        // movement polygons<br/>
        movementPolys = new Polygon[8];<br/>
        movementPolys[0] = new Polygon();<br/>
        movementPolys[0].addPoint(41, 65);<br/>
        movementPolys[0].addPoint(38, 68);<br/>
        movementPolys[0].addPoint(45, 68);<br/>
        movementPolys[0].addPoint(42, 65);<br/>
        movementPolys[1] = new Polygon();<br/>
        movementPolys[1].addPoint(17, 48);<br/>
        movementPolys[1].addPoint(12, 48);<br/>
        movementPolys[1].addPoint(16, 54);<br/>
        movementPolys[1].addPoint(17, 49);<br/>
        movementPolys[2] = new Polygon();<br/>
        movementPolys[2].addPoint(18, 19);<br/>
        movementPolys[2].addPoint(17, 15);<br/>
        movementPolys[2].addPoint(13, 21);<br/>
        movementPolys[2].addPoint(17, 20);<br/>
        movementPolys[3] = new Polygon();<br/>
        movementPolys[3].addPoint(41, 6);<br/>
        movementPolys[3].addPoint(38, 3);<br/>
        movementPolys[3].addPoint(45, 3);<br/>
        movementPolys[3].addPoint(42, 6);<br/>
        movementPolys[4] = new Polygon();<br/>
        movementPolys[4].addPoint(67, 15);<br/>
        movementPolys[4].addPoint(66, 19);<br/>
        movementPolys[4].addPoint(67, 20);<br/>
        movementPolys[4].addPoint(71, 20);<br/>
        movementPolys[5] = new Polygon();<br/>
        movementPolys[5].addPoint(69, 55);<br/>
        movementPolys[5].addPoint(66, 50);<br/>
        movementPolys[5].addPoint(67, 49);<br/>
        movementPolys[5].addPoint(72, 48);<br/>
<br/>
        movementPolys[6] = new Polygon(); // up arrow with tail<br/>
        movementPolys[6].addPoint(35, 44);<br/>
        movementPolys[6].addPoint(30, 49);<br/>
        movementPolys[6].addPoint(33, 49);<br/>
        movementPolys[6].addPoint(33, 53);<br/>
        movementPolys[6].addPoint(38, 53);<br/>
        movementPolys[6].addPoint(38, 49);<br/>
        movementPolys[6].addPoint(41, 49);<br/>
        movementPolys[6].addPoint(36, 44);<br/>
        movementPolys[7] = new Polygon(); // down arrow with tail<br/>
        movementPolys[7].addPoint(34, 53);<br/>
        movementPolys[7].addPoint(29, 48);<br/>
        movementPolys[7].addPoint(32, 48);<br/>
        movementPolys[7].addPoint(32, 44);<br/>
        movementPolys[7].addPoint(37, 44);<br/>
        movementPolys[7].addPoint(37, 48);<br/>
        movementPolys[7].addPoint(40, 48);<br/>
        movementPolys[7].addPoint(35, 53);<br/>
    }<br/>
<br/>
    private synchronized boolean doMoveUnits(long idleTime) {<br/>
        boolean movingSomething = false;<br/>
<br/>
        if (movingUnits.size() &gt; 0) {<br/>
<br/>
            moveWait += idleTime;<br/>
<br/>
            if (moveWait &gt; GUIPreferences.getInstance().getInt("AdvancedMoveStepDelay")) {<br/>
<br/>
                java.util.Vector spent = new java.util.Vector();<br/>
<br/>
                for (int i = 0; i &lt; movingUnits.size(); i++) {<br/>
                    Object[] move = (Object[]) movingUnits.elementAt(i);<br/>
                    Entity e = (Entity) move[0];<br/>
                    java.util.Vector movePath = (java.util.Vector) move[1];<br/>
                    movingSomething = true;<br/>
                    Entity ge = game.getEntity(e.getId()); <br/>
                    if (movePath.size() &gt; 0) {<br/>
                        UnitLocation loc =<br/>
                            ( (UnitLocation) movePath.elementAt(0) );<br/>
                        if (ge != null) {<br/>
                            redrawMovingEntity( e,<br/>
                                                loc.getCoords(),<br/>
                                                loc.getFacing() );<br/>
                        }<br/>
                        movePath.removeElementAt(0);<br/>
                    } else {<br/>
                        if (ge != null) {<br/>
                            redrawEntity(ge);<br/>
                        }<br/>
                        spent.addElement(move);<br/>
                    }<br/>
<br/>
                }<br/>
<br/>
                for (int i = 0; i &lt; spent.size(); i++) {<br/>
                    Object[] move = (Object[]) spent.elementAt(i);<br/>
                    movingUnits.removeElement(move);<br/>
                }<br/>
                moveWait = 0;<br/>
<br/>
                if (movingUnits.size() == 0) {<br/>
                    movingEntitySpriteIds.clear();<br/>
                    movingEntitySprites.removeAllElements();<br/>
                    ghostEntitySprites.removeAllElements();<br/>
                    processBoardViewEvent(new BoardViewEvent(this, BoardViewEvent.FINISHED_MOVING_UNITS));<br/>
                }<br/>
            }<br/>
        }<br/>
        return movingSomething;<br/>
    }<br/>
<br/>
    //<br/>
    // KeyListener<br/>
    //<br/>
    public void keyPressed(KeyEvent ke) {<br/>
        switch(ke.getKeyCode()) {<br/>
        case KeyEvent.VK_NUMPAD7 :<br/>
            scroll.y -= 36;<br/>
            scroll.x -= 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD8 :<br/>
            scroll.y -= 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD9 :<br/>
            scroll.y -= 36;<br/>
            scroll.x += 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD1 :<br/>
            scroll.y += 36;<br/>
            scroll.x -= 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD2 :<br/>
            scroll.y += 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD3 :<br/>
            scroll.y += 36;<br/>
            scroll.x += 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD4 :<br/>
            scroll.x -= 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD6 :<br/>
            scroll.x += 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD5 :<br/>
            // center on the selected entity<br/>
            java.util.Vector v = game.getPlayerEntities(localPlayer);<br/>
            Entity se = clientgui == null?null:game.getEntity(clientgui.getSelectedEntityNum());<br/>
            for (int i = 0; i &lt; v.size(); i++) {<br/>
                Entity e = (Entity) v.elementAt(i);<br/>
                if (e==se) {<br/>
                    centerOnHex(e.getPosition());<br/>
                }<br/>
            }<br/>
            break;<br/>
        case KeyEvent.VK_CONTROL :<br/>
            ctlKeyHeld = true;<br/>
            initCtlScroll = true;<br/>
            break;<br/>
        }<br/>
<br/>
        if (isTipShowing()) {<br/>
            hideTooltip();<br/>
        }<br/>
        lastIdle = System.currentTimeMillis();<br/>
        checkScrollBounds();<br/>
        repaint();<br/>
    }<br/>
<br/>
    public void keyReleased(KeyEvent ke) {<br/>
        if (ke.getKeyCode() == KeyEvent.VK_CONTROL) {<br/>
            ctlKeyHeld = false;<br/>
        }<br/>
    }<br/>
    public void keyTyped(KeyEvent ke) {<br/>
    }<br/>
<br/>
    //<br/>
    // MouseListener<br/>
    //<br/>
    public void mousePressed(MouseEvent me) {<br/>
        scrolled = false; // not scrolled yet<br/>
<br/>
        Point point = me.getPoint();<br/>
        if ( null == point ) {<br/>
            return;<br/>
        }<br/>
        oldMousePosition = point;<br/>
<br/>
        isTipPossible = false;<br/>
        for (int i = 0; i &lt; displayables.size(); i++) {<br/>
            Displayable disp = (Displayable) displayables.elementAt(i);<br/>
            if (disp.isHit(point, backSize)) {<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // Disable scrolling when ctrl or alt is held down, since this<br/>
        //  means the user wants to use the LOS/ruler tools.<br/>
        int mask = InputEvent.CTRL_MASK | InputEvent.ALT_MASK;<br/>
        if ( !GUIPreferences.getInstance().getRightDragScroll() &amp;&amp;<br/>
            !GUIPreferences.getInstance().getAlwaysRightClickScroll() &amp;&amp;    <br/>
            game.getPhase() == IGame.PHASE_FIRING ) {<br/>
            // In the firing phase, also disable scrolling if<br/>
            // the right or middle buttons are clicked, since<br/>
            // this means the user wants to activate the<br/>
            // popup menu or ruler tool.<br/>
            mask |= InputEvent.BUTTON2_MASK | InputEvent.BUTTON3_MASK;<br/>
        }<br/>
<br/>
        // disable auto--edge-scrolling if no option set<br/>
        if ( !GUIPreferences.getInstance().getAutoEdgeScroll() ) {<br/>
            mask |= InputEvent.BUTTON1_MASK;<br/>
        }<br/>
        // disable edge-scrolling if no option set<br/>
        if ( !GUIPreferences.getInstance().getClickEdgeScroll() ) {<br/>
            mask |= InputEvent.BUTTON3_MASK;<br/>
        }<br/>
        <br/>
        if ( GUIPreferences.getInstance().getRightDragScroll() ) {<br/>
            mask |= InputEvent.BUTTON2_MASK;<br/>
        }<br/>
<br/>
        if ( (me.getModifiers() &amp; mask ) == 0 ) {<br/>
            isScrolling = true; //activate scrolling<br/>
        } else {<br/>
            isScrolling = false; //activate scrolling<br/>
        }<br/>
<br/>
        if (isTipShowing()) {<br/>
            hideTooltip();<br/>
        }<br/>
<br/>
        mouseAction(getCoordsAt(point), BOARD_HEX_DRAG, me.getModifiers());<br/>
    }<br/>
<br/>
    public void mouseReleased(MouseEvent me) {<br/>
        isTipPossible = true;<br/>
        oldMousePosition = mousePos;<br/>
<br/>
        for (int i = 0; i &lt; displayables.size(); i++) {<br/>
            Displayable disp = (Displayable) displayables.elementAt(i);<br/>
            if (disp.isReleased()) {<br/>
                return;<br/>
            }<br/>
        }<br/>
        isScrolling = false;<br/>
<br/>
        // no click action triggered if click was for scrolling the map. Real clicks are without scrolling.<br/>
        if (scrolled)<br/>
            return;<br/>
        if (me.getClickCount() == 1) {<br/>
            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_CLICK, me.getModifiers());<br/>
        } else {<br/>
            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_DOUBLECLICK, me.getModifiers());<br/>
        }<br/>
    }<br/>
<br/>
    public void mouseEntered(MouseEvent me) {<br/>
    }<br/>
<br/>
    public void mouseExited(MouseEvent me) {<br/>
        isTipPossible = false;<br/>
    }<br/>
    public void mouseClicked(MouseEvent me) {<br/>
    }<br/>
<br/>
    //<br/>
    // MouseMotionListener<br/>
    //<br/>
    public void mouseDragged(MouseEvent me) {<br/>
        isTipPossible = false;<br/>
<br/>
        Point point = me.getPoint();<br/>
        if ( null == point ) {<br/>
            return;<br/>
        }<br/>
<br/>
        for (int i = 0; i &lt; displayables.size(); i++) {<br/>
            Displayable disp = (Displayable) displayables.elementAt(i);<br/>
            if (disp.isDragged(point, backSize)) {<br/>
                repaint();<br/>
                return;<br/>
            }<br/>
        }<br/>
        mousePos = point;<br/>
<br/>
        // Disable scrolling when ctrl or alt is held down, since this<br/>
        //  means the user wants to use the LOS/ruler tools.<br/>
        int mask = InputEvent.CTRL_MASK | InputEvent.ALT_MASK;<br/>
<br/>
        if ( !GUIPreferences.getInstance().getRightDragScroll() &amp;&amp;<br/>
            !GUIPreferences.getInstance().getAlwaysRightClickScroll() &amp;&amp;<br/>
            game.getPhase() == IGame.PHASE_FIRING) {<br/>
            // In the firing phase, also disable scrolling if<br/>
            //  the right or middle buttons are clicked, since<br/>
            //  this means the user wants to activate the<br/>
            //  popup menu or ruler tool.<br/>
            mask |= InputEvent.BUTTON2_MASK | InputEvent.BUTTON3_MASK;<br/>
        }<br/>
<br/>
        if ( GUIPreferences.getInstance().getRightDragScroll() ) {<br/>
            mask |= InputEvent.BUTTON1_MASK | InputEvent.BUTTON2_MASK;<br/>
        }<br/>
<br/>
        // disable auto--edge-scrolling if no option set<br/>
        if ( !GUIPreferences.getInstance().getAutoEdgeScroll() ) {<br/>
            mask |= InputEvent.BUTTON1_MASK;<br/>
        }<br/>
<br/>
        // disable edge-scrolling if no option set<br/>
        if ( !GUIPreferences.getInstance().getClickEdgeScroll() &amp;&amp; !GUIPreferences.getInstance().getRightDragScroll() ) {<br/>
            mask |= InputEvent.BUTTON3_MASK;<br/>
        }<br/>
        <br/>
        if ( (me.getModifiers() &amp; mask ) == 0 ) {<br/>
            isScrolling = true; //activate scrolling<br/>
        } else {<br/>
            isScrolling = false; //activate scrolling<br/>
        }<br/>
<br/>
        mouseAction(getCoordsAt(point), BOARD_HEX_DRAG, me.getModifiers());<br/>
    }<br/>
<br/>
    public void mouseMoved(MouseEvent me) {<br/>
        Point point = me.getPoint();<br/>
        if ( null == point ) {<br/>
            return;<br/>
        }<br/>
<br/>
        for (int i = 0; i &lt; displayables.size(); i++) {<br/>
            Displayable disp = (Displayable) displayables.elementAt(i);<br/>
            if (disp.isBeingDragged()) {<br/>
                isTipPossible = false;<br/>
                return;<br/>
            }<br/>
            if (backSize != null) {<br/>
                disp.isMouseOver(point, backSize);<br/>
            }<br/>
        }<br/>
        mousePos = point;<br/>
        if (isTipShowing()) {<br/>
            hideTooltip();<br/>
        }<br/>
        if (ctlKeyHeld &amp;&amp; GUIPreferences.getInstance().getCtlScroll()) {<br/>
            if (initCtlScroll) {<br/>
                previousMouseX = me.getX();<br/>
                previousMouseY = me.getY();<br/>
                initCtlScroll = false;<br/>
            }<br/>
            scroll.x += GUIPreferences.getInstance().getScrollSensitivity() * (me.getX() - previousMouseX);<br/>
            scroll.y += GUIPreferences.getInstance().getScrollSensitivity() * (me.getY() - previousMouseY);<br/>
            previousMouseX = me.getX();<br/>
            previousMouseY = me.getY();<br/>
            checkScrollBounds();<br/>
            repaint();<br/>
        }<br/>
        lastIdle = System.currentTimeMillis();<br/>
        isTipPossible = true;<br/>
    }<br/>
<br/>
    /**<br/>
     * Increases zoomIndex and refreshes the map.<br/>
     * <br/>
     */<br/>
    public void zoomIn(){<br/>
        int tmpZoomIndex = zoomIndex + 1;<br/>
        if ( isJ2RE == true ){<br/>
            zoomIndex++;<br/>
            zoom();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Decreases zoomIndex and refreshes the map.<br/>
     *<br/>
     */<br/>
    public void zoomOut(){<br/>
        if ( isJ2RE == true ){<br/>
            zoomIndex--;<br/>
            zoom();<br/>
        }<br/>
        }<br/>
<br/>
    /**<br/>
     * zoomIndex is a reference to a static array of scale factors.<br/>
     * The index ranges from 0 to 9 and by default is set to 7 which corresponds<br/>
     * to a scale of 1.0 (draws megamek images at normal size).  To zoom out the<br/>
     * index needs to be set to a lower value.  To zoom in make it larger.<br/>
     * If only zooming a step at a time use the zoomIn and zoomOut methods instead.<br/>
     * <br/>
     * @param zoomIndex<br/>
     */<br/>
    public void setZoomIndex( int zoomIndex ){<br/>
        if ( isJ2RE == true ){<br/>
            this.zoomIndex = zoomIndex;<br/>
            zoom();<br/>
        }<br/>
    }<br/>
<br/>
    public int getZoomIndex(){<br/>
        return zoomIndex;<br/>
    }<br/>
    <br/>
    private void checkZoomIndex(){<br/>
        if ( zoomIndex &gt; ZOOM_FACTORS.length-1 ) {<br/>
            zoomIndex = ZOOM_FACTORS.length-1;<br/>
        }<br/>
        if ( zoomIndex &lt; 0 ) zoomIndex = 0;<br/>
    }<br/>
    <br/>
    //<br/>
    // Changes hex dimensions and refreshes the map with the new scale<br/>
    //<br/>
    private void zoom(){<br/>
        checkZoomIndex();<br/>
        scale = ZOOM_FACTORS[zoomIndex];<br/>
        GUIPreferences.getInstance().setMapZoomIndex(zoomIndex);<br/>
<br/>
        hex_size = new Dimension((int)(HEX_W*scale), (int)(HEX_H*scale));<br/>
<br/>
        final Dimension size = getSize();<br/>
        //Coords c = getCoordsAt(new Point((int)(size.width/2), (int)(size.height/2)));<br/>
<br/>
        boardGraph=null;<br/>
        backGraph=null;<br/>
        hasZoomed=true;<br/>
<br/>
        updateBoardSize();<br/>
<br/>
        view.setLocation(scroll);<br/>
        view.setSize(getOptimalView(size));<br/>
        offset.setLocation(getOptimalOffset(size));<br/>
<br/>
        updateFontSizes();<br/>
        updateBoardImage();<br/>
        <br/>
        update(this.getGraphics());<br/>
    }<br/>
    <br/>
    private void updateFontSizes(){<br/>
        if ( zoomIndex &lt;= 4 ) {<br/>
                font_elev = FONT_7;<br/>
                font_hexnum = FONT_7;<br/>
                font_minefield = FONT_7;<br/>
        }<br/>
        if ( zoomIndex &lt;= 5 &amp; zoomIndex &gt; 4 ){<br/>
                font_elev = FONT_8;<br/>
                font_hexnum = FONT_8;<br/>
                font_minefield = FONT_8;<br/>
        }<br/>
        if ( zoomIndex &gt; 5 ){<br/>
            font_elev = FONT_9;<br/>
            font_hexnum = FONT_9;<br/>
            font_minefield = FONT_9;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Displays a bit of text in a box.<br/>
     *<br/>
     * TODO: make multi-line<br/>
     */<br/>
    private class TooltipCanvas extends Canvas<br/>
    {<br/>
        private String[] tipStrings;<br/>
        private Dimension size;<br/>
<br/>
        public TooltipCanvas(String[] tipStrings) {<br/>
            this.tipStrings = tipStrings;<br/>
<br/>
            // setup<br/>
            setFont(new Font("SansSerif", Font.PLAIN, 12)); //$NON-NLS-1$<br/>
            setBackground(SystemColor.info);<br/>
            setForeground(SystemColor.infoText);<br/>
<br/>
            // determine size<br/>
            final FontMetrics fm = getFontMetrics(getFont());<br/>
            int width = 0;<br/>
            for (int i = 0; i &lt; tipStrings.length; i++) {<br/>
                if (fm.stringWidth(tipStrings[i]) &gt; width) {<br/>
                    width = fm.stringWidth(tipStrings[i]);<br/>
                }<br/>
            }<br/>
            size = new Dimension(width + 5, fm.getAscent() * tipStrings.length + 4);<br/>
            setSize(size);<br/>
        }<br/>
<br/>
        public void paint(Graphics g) {<br/>
            final FontMetrics fm = getFontMetrics(getFont());<br/>
            g.setColor(getBackground());<br/>
            g.fillRect(0, 0, size.width, size.height);<br/>
            g.setColor(getForeground());<br/>
            g.drawRect(0, 0, size.width - 1, size.height - 1);<br/>
            for (int i = 0; i &lt; tipStrings.length; i++) {<br/>
                g.drawString(tipStrings[i], 2, (i + 1) * fm.getAscent());<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Everything in the main map view is either the board or it's a sprite<br/>
     * displayed on top of the board.  Most sprites store a transparent image<br/>
     * which they draw onto the screen when told to.  Sprites keep a bounds<br/>
     * rectangle, so it's easy to tell when they'return onscreen.<br/>
     */<br/>
    private abstract class Sprite implements ImageObserver<br/>
    {<br/>
        protected Rectangle bounds;<br/>
        protected Image image;<br/>
<br/>
        /**<br/>
         * Do any necessary preparation.  This is called after creation,<br/>
         * but before drawing, when a device context is ready to draw with.<br/>
         */<br/>
        public abstract void prepare();<br/>
<br/>
        /**<br/>
         * When we draw our buffered images, it's necessary to implement<br/>
         * the ImageObserver interface.  This provides the necesasry<br/>
         * functionality.<br/>
         */<br/>
        public boolean imageUpdate(Image image, int infoflags, int x, int y,<br/>
                                   int width, int height) {<br/>
            if (infoflags == ImageObserver.ALLBITS) {<br/>
                prepare();<br/>
                repaint();<br/>
                return false;<br/>
            } else {<br/>
                return true;<br/>
            }<br/>
        }<br/>
<br/>
        /**<br/>
         * Returns our bounding rectangle.  The coordinates here are stored<br/>
         * with the top left corner of the _board_ being 0, 0, so these do<br/>
         * not always correspond to screen coordinates.<br/>
         */<br/>
        public Rectangle getBounds() {<br/>
            return bounds;<br/>
        }<br/>
<br/>
        /**<br/>
         * Are we ready to draw?  By default, checks to see that our buffered<br/>
         * image has been created.<br/>
         */<br/>
        public boolean isReady() {<br/>
            return image != null;<br/>
        }<br/>
<br/>
        /**<br/>
         * Draws this sprite onto the specified graphics context.<br/>
         */<br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer) {<br/>
            drawOnto(g, x, y, observer, false);<br/>
        }<br/>
<br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer, boolean makeTranslucent) {<br/>
            if (isReady()) {<br/>
                Image tmpImage;<br/>
                if (zoomIndex == BASE_ZOOM_INDEX ){<br/>
                    tmpImage = image;<br/>
                } else {<br/>
                    tmpImage = getScaledImage(image);<br/>
                }<br/>
                if (makeTranslucent &amp;&amp; isJ2RE) {<br/>
                    Graphics2D g2 = (Graphics2D) g;<br/>
                    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));<br/>
                    g2.drawImage(tmpImage, x, y, observer);<br/>
                    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));<br/>
                } else {<br/>
                    g.drawImage(tmpImage, x, y, observer);<br/>
                }<br/>
            } else {<br/>
                // grrr... we'll be ready next time!<br/>
                prepare();<br/>
            }<br/>
        }<br/>
<br/>
        /**<br/>
         * Returns true if the point is inside this sprite.  Uses board<br/>
         * coordinates, not screen coordinates.   By default, just checks our<br/>
         * bounding rectangle, though some sprites override this for a smaller<br/>
         * sensitive area.<br/>
         */<br/>
        public boolean isInside(Point point) {<br/>
            return bounds.contains(point);<br/>
        }<br/>
<br/>
        /**<br/>
         * Since most sprites being drawn correspond to something in the game,<br/>
         * this returns a little info for a tooltip.<br/>
         */<br/>
        private String[] getTooltip() {<br/>
            return null;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sprite for a cursor.  Just a hexagon outline in a specified color.<br/>
     */<br/>
    private class CursorSprite extends Sprite<br/>
    {<br/>
        private Color color;<br/>
        private Coords hexLoc;<br/>
        <br/>
        public CursorSprite(Color color) {<br/>
            this.color = color;<br/>
            this.bounds = new Rectangle(hexPoly.getBounds().width + 1,<br/>
                    hexPoly.getBounds().height + 1);<br/>
            this.image = null;<br/>
<br/>
            // start offscreen<br/>
            setOffScreen();<br/>
        }<br/>
<br/>
        public void prepare() {<br/>
            // create image for buffer<br/>
            Image tempImage = createImage(bounds.width, bounds.height);<br/>
            Graphics graph = tempImage.getGraphics();<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
            // draw attack poly<br/>
            graph.setColor(color);<br/>
            graph.drawPolygon(hexPoly);<br/>
<br/>
            // create final image<br/>
            this.image = createImage(new FilteredImageSource(tempImage.getSource(),<br/>
                                                             new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
<br/>
        public void setOffScreen(){<br/>
            bounds.setLocation(-100, -100);<br/>
            hexLoc = new Coords(-2, -2);<br/>
        }<br/>
        <br/>
        public void setHexLocation( Coords hexLoc ){<br/>
            this.hexLoc = hexLoc;<br/>
            bounds.setLocation(getHexLocation(hexLoc));<br/>
        }<br/>
        <br/>
        public Rectangle getBounds(){<br/>
            this.bounds = new Rectangle(hexPoly.getBounds().width + 1,<br/>
                    hexPoly.getBounds().height + 1);<br/>
            bounds.setLocation(getHexLocation( hexLoc ));<br/>
            <br/>
            return bounds;<br/>
        }<br/>
    }<br/>
<br/>
    <br/>
    private class GhostEntitySprite extends Sprite {<br/>
        private Entity entity;<br/>
        private Rectangle entityRect;<br/>
        private Rectangle modelRect;<br/>
<br/>
        public GhostEntitySprite(Entity entity) {<br/>
            this.entity = entity;<br/>
<br/>
            String shortName = entity.getShortName();<br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            modelRect = new Rectangle(47, 55,<br/>
                            getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                            getFontMetrics(font).getAscent());<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
<br/>
            this.bounds = tempBounds;<br/>
            this.entityRect = new Rectangle(<br/>
                    bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale), <br/>
                    (int)(44*scale), <br/>
                    (int)(44*scale));<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        /**<br/>
         * Creates the sprite for this entity.  It is an extra pain to<br/>
         * create transparent images in AWT.<br/>
         */<br/>
        public void prepare() {<br/>
            // create image for buffer<br/>
            Image tempImage;<br/>
            Graphics graph;<br/>
            try {<br/>
                tempImage = createImage(bounds.width, bounds.height);<br/>
                graph = tempImage.getGraphics();<br/>
            } catch (NullPointerException ex) {<br/>
                // argh!  but I want it!<br/>
                return;<br/>
            }<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
<br/>
            // draw entity image<br/>
            graph.drawImage(tileManager.imageFor(entity), 0, 0, this);<br/>
<br/>
            // create final image<br/>
            this.image = createImage(new FilteredImageSource(tempImage.getSource(),<br/>
                                                             new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
<br/>
        public Rectangle getBounds(){<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
            this.bounds = tempBounds;<br/>
        <br/>
            this.entityRect = new Rectangle(bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale),<br/>
                    (int)(44*scale),<br/>
                    (int)(44*scale));<br/>
            <br/>
            return bounds;<br/>
        }<br/>
        <br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer) {<br/>
            drawOnto(g, x, y, observer, true);<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    private class MovingEntitySprite extends Sprite {<br/>
        private int facing;<br/>
        private Entity entity;<br/>
        private Rectangle entityRect;<br/>
        private Rectangle modelRect;<br/>
<br/>
        public MovingEntitySprite(Entity entity, Coords position, int facing) {<br/>
            this.entity = entity;<br/>
            this.facing = facing;<br/>
<br/>
            String shortName = entity.getShortName();<br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            modelRect = new Rectangle(47, 55,<br/>
                            getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                            getFontMetrics(font).getAscent());<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(position));<br/>
<br/>
            this.bounds = tempBounds;<br/>
            this.entityRect = new Rectangle(bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale),<br/>
                    (int)(44*scale),<br/>
                    (int)(44*scale));<br/>
            this.image = null;<br/>
        }<br/>
        <br/>
        /**<br/>
         * Creates the sprite for this entity.  It is an extra pain to<br/>
         * create transparent images in AWT.<br/>
         */<br/>
        public void prepare() {<br/>
            // create image for buffer<br/>
            Image tempImage;<br/>
            Graphics graph;<br/>
            try {<br/>
                tempImage = createImage(bounds.width, bounds.height);<br/>
                graph = tempImage.getGraphics();<br/>
            } catch (NullPointerException ex) {<br/>
                // argh!  but I want it!<br/>
                return;<br/>
            }<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
<br/>
            // draw entity image<br/>
            graph.drawImage(tileManager.imageFor(entity, facing), 0, 0, this);<br/>
<br/>
            // create final image<br/>
            this.image = createImage(new FilteredImageSource(tempImage.getSource(),<br/>
                                                             new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Sprite for an wreck.  Consists<br/>
     * of an image, drawn from the Tile Manager and an identification label.<br/>
     */<br/>
    private class WreckSprite extends Sprite<br/>
    {<br/>
        private Entity entity;<br/>
        private Rectangle entityRect;<br/>
        private Rectangle modelRect;<br/>
<br/>
        public WreckSprite(Entity entity) {<br/>
            this.entity = entity;<br/>
<br/>
            String shortName = entity.getShortName();<br/>
            <br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            modelRect = new Rectangle(47, 55,<br/>
                                    getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                                    getFontMetrics(font).getAscent());<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
<br/>
            this.bounds = tempBounds;<br/>
            this.entityRect = new Rectangle(<br/>
                    bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale),<br/>
                    (int)(44*scale),<br/>
                    (int)(44*scale));<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        public Rectangle getBounds(){<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
            this.bounds = tempBounds;<br/>
        <br/>
            this.entityRect = new Rectangle(<br/>
                    bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale),<br/>
                    (int)(44*scale),<br/>
                    (int)(44*scale));<br/>
            <br/>
            return bounds;<br/>
        }<br/>
        <br/>
        /**<br/>
         * Creates the sprite for this entity.  It is an extra pain to<br/>
         * create transparent images in AWT.<br/>
         */<br/>
        public void prepare() {<br/>
            // figure out size<br/>
            String shortName = entity.getShortName();<br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            Rectangle tempRect =<br/>
                new Rectangle(47, 55,<br/>
                              getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                              getFontMetrics(font).getAscent());<br/>
<br/>
            // create image for buffer<br/>
            Image tempImage;<br/>
            Graphics graph;<br/>
            try {<br/>
                tempImage = createImage(bounds.width, bounds.height);<br/>
                graph = tempImage.getGraphics();<br/>
            } catch (NullPointerException ex) {<br/>
                // argh!  but I want it!<br/>
                return;<br/>
            }<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
<br/>
            // Draw wreck image,if we've got one.<br/>
            Image wreck = tileManager.wreckMarkerFor(entity);<br/>
            if ( null != wreck ) {<br/>
                graph.drawImage( wreck, 0, 0, this );<br/>
            }<br/>
<br/>
            // draw box with shortName<br/>
            Color text = Color.lightGray;<br/>
            Color bkgd = Color.darkGray;<br/>
            Color bord = Color.black;<br/>
<br/>
            graph.setFont(font);<br/>
            graph.setColor(bord);<br/>
            graph.fillRect(tempRect.x, tempRect.y,<br/>
                           tempRect.width, tempRect.height);<br/>
            tempRect.translate(-1, -1);<br/>
            graph.setColor(bkgd);<br/>
            graph.fillRect(tempRect.x, tempRect.y,<br/>
                           tempRect.width, tempRect.height);<br/>
            graph.setColor(text);<br/>
            graph.drawString(shortName, tempRect.x + 1,<br/>
                             tempRect.y + tempRect.height - 1);<br/>
<br/>
            // create final image<br/>
            this.image = createImage<br/>
                (new FilteredImageSource(tempImage.getSource(),<br/>
                                         new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
<br/>
        /**<br/>
         * Overrides to provide for a smaller sensitive area.<br/>
         */<br/>
        public boolean isInside(Point point) {<br/>
            return false;<br/>
        }<br/>
<br/>
    }<br/>
    /**<br/>
     * Sprite for an entity.  Changes whenever the entity changes.  Consists<br/>
     * of an image, drawn from the Tile Manager; facing and possibly secondary<br/>
     * facing arrows; armor and internal bars; and an identification label.<br/>
     */<br/>
    private class EntitySprite extends Sprite<br/>
    {<br/>
        private Entity entity;<br/>
        private Rectangle entityRect;<br/>
        private Rectangle modelRect;<br/>
<br/>
        public EntitySprite(Entity entity) {<br/>
            this.entity = entity;<br/>
<br/>
            String shortName = entity.getShortName();<br/>
            <br/>
            if (entity.getMovementMode() == IEntityMovementMode.VTOL) {<br/>
                shortName = shortName.concat(" (FL: ").concat(Integer.toString(entity.getElevation())).concat(")");<br/>
            }<br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            modelRect = new Rectangle(47, 55,<br/>
                                        getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                                        getFontMetrics(font).getAscent());<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
<br/>
            this.bounds = tempBounds;<br/>
            this.entityRect = new Rectangle(bounds.x + (int)(20*scale),<br/>
                                            bounds.y + (int)(14*scale),<br/>
                                            (int)(44*scale),<br/>
                                            (int)(44*scale));<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        public Rectangle getBounds(){<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
            this.bounds = tempBounds;<br/>
        <br/>
            this.entityRect = new Rectangle(<br/>
                    bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale),<br/>
                    (int)(44*scale),<br/>
                    (int)(44*scale));<br/>
            <br/>
            return bounds;<br/>
        }<br/>
        <br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer) {<br/>
            if (trackThisEntitiesVisibilityInfo(this.entity)<br/>
                &amp;&amp; !this.entity.isVisibleToEnemy()) {<br/>
                // create final image with translucency<br/>
                drawOnto(g, x, y, observer, true);<br/>
            } else {<br/>
                drawOnto(g, x, y, observer, false);<br/>
            }<br/>
        }<br/>
<br/>
        /**<br/>
         * Creates the sprite for this entity.  It is an extra pain to<br/>
         * create transparent images in AWT.<br/>
         */<br/>
        public void prepare() {<br/>
            // figure out size<br/>
            String shortName = entity.getShortName();<br/>
            if (entity.getMovementMode() == IEntityMovementMode.VTOL) {<br/>
                shortName = shortName.concat(" (FL: ").concat(Integer.toString(entity.getElevation())).concat(")");<br/>
            }<br/>
            if (PreferenceManager.getClientPreferences().getShowUnitId()) {<br/>
                shortName+=(Messages.getString("BoardView1.ID")+entity.getId()); //$NON-NLS-1$<br/>
            }<br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            Rectangle tempRect =<br/>
                new Rectangle(47, 55,<br/>
                              getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                              getFontMetrics(font).getAscent());<br/>
<br/>
            // create image for buffer<br/>
            Image tempImage;<br/>
            Graphics graph;<br/>
            try {<br/>
                tempImage = createImage(bounds.width, bounds.height);<br/>
                graph = tempImage.getGraphics();<br/>
            } catch (NullPointerException ex) {<br/>
                // argh!  but I want it!<br/>
                return;<br/>
            }<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
<br/>
            // draw entity image<br/>
            graph.drawImage(tileManager.imageFor(entity), 0, 0, this);<br/>
<br/>
            // draw box with shortName<br/>
            Color text, bkgd, bord;<br/>
            if (entity.isDone()) {<br/>
                text = Color.lightGray;<br/>
                bkgd = Color.darkGray;<br/>
                bord = Color.black;<br/>
            } else if (entity.isImmobile()) {<br/>
                text = Color.darkGray;<br/>
                bkgd = Color.black;<br/>
                bord = Color.lightGray;<br/>
            } else {<br/>
                text = Color.black;<br/>
                bkgd = Color.lightGray;<br/>
                bord = Color.darkGray;<br/>
            }<br/>
            graph.setFont(font);<br/>
            graph.setColor(bord);<br/>
            graph.fillRect(tempRect.x, tempRect.y,<br/>
                           tempRect.width, tempRect.height);<br/>
            tempRect.translate(-1, -1);<br/>
            graph.setColor(bkgd);<br/>
            graph.fillRect(tempRect.x, tempRect.y,<br/>
                           tempRect.width, tempRect.height);<br/>
            graph.setColor(text);<br/>
            graph.drawString(shortName, tempRect.x + 1,<br/>
                             tempRect.y + tempRect.height - 1);<br/>
<br/>
            // draw facing<br/>
            graph.setColor(Color.white);<br/>
            if (entity.getFacing() != -1) {<br/>
                graph.drawPolygon(facingPolys[entity.getFacing()]);<br/>
            }<br/>
<br/>
            // determine secondary facing for non-mechs &amp; flipped arms<br/>
            int secFacing = entity.getFacing();<br/>
            if (!(entity instanceof Mech || entity instanceof Protomech)) {<br/>
                secFacing = entity.getSecondaryFacing();<br/>
            } else if (entity.getArmsFlipped()) {<br/>
                secFacing = (entity.getFacing() + 3) % 6;<br/>
            }<br/>
            // draw red secondary facing arrow if necessary<br/>
            if (secFacing != -1 &amp;&amp; secFacing != entity.getFacing()) {<br/>
                graph.setColor(Color.red);<br/>
                graph.drawPolygon(facingPolys[secFacing]);<br/>
            }<br/>
<br/>
            // Determine if the entity is a tank with a locked turret.<br/>
            boolean turretLocked = false;<br/>
            if ( entity instanceof Tank &amp;&amp;<br/>
                 !( (Tank) entity ).hasNoTurret() &amp;&amp;<br/>
                 !entity.canChangeSecondaryFacing() ) {<br/>
                turretLocked = true;<br/>
            }<br/>
<br/>
            // draw condition strings<br/>
            if ( entity.isImmobile() &amp;&amp; !entity.isProne() &amp;&amp; !turretLocked ) {<br/>
                // draw "IMMOBILE"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 18, 39); //$NON-NLS-1$<br/>
                graph.setColor(Color.red);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 17, 38); //$NON-NLS-1$<br/>
            } else if (!entity.isImmobile() &amp;&amp; entity.isProne()) {<br/>
                // draw "PRONE"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.PRONE"), 26, 39); //$NON-NLS-1$<br/>
                graph.setColor(Color.yellow);<br/>
                graph.drawString(Messages.getString("BoardView1.PRONE"), 25, 38); //$NON-NLS-1$<br/>
            } else if ( !entity.isImmobile() &amp;&amp; turretLocked ) {<br/>
                // draw "LOCKED"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.LOCKED"), 22, 39); //$NON-NLS-1$<br/>
                graph.setColor(Color.yellow);<br/>
                graph.drawString(Messages.getString("BoardView1.LOCKED"), 21, 38); //$NON-NLS-1$<br/>
            } else if (entity.isImmobile() &amp;&amp; entity.isProne()) {<br/>
                // draw "IMMOBILE" and "PRONE"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 18, 35); //$NON-NLS-1$<br/>
                graph.drawString(Messages.getString("BoardView1.PRONE"), 26, 48); //$NON-NLS-1$<br/>
                graph.setColor(Color.red);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 17, 34); //$NON-NLS-1$<br/>
                graph.setColor(Color.yellow);<br/>
                graph.drawString(Messages.getString("BoardView1.PRONE"), 25, 47); //$NON-NLS-1$<br/>
            } else if ( entity.isImmobile() &amp;&amp; turretLocked ) {<br/>
                // draw "IMMOBILE" and "LOCKED"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 18, 35); //$NON-NLS-1$<br/>
                graph.drawString(Messages.getString("BoardView1.LOCKED"), 22, 48); //$NON-NLS-1$<br/>
                graph.setColor(Color.red);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 17, 34); //$NON-NLS-1$<br/>
                graph.setColor(Color.yellow);<br/>
                graph.drawString(Messages.getString("BoardView1.LOCKED"), 21, 47); //$NON-NLS-1$<br/>
            }<br/>
<br/>
            // If this unit is being swarmed or is swarming another, say so.<br/>
            if ( Entity.NONE != entity.getSwarmAttackerId() ) {<br/>
                // draw "SWARMED"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.SWARMED"), 17, 22); //$NON-NLS-1$<br/>
                graph.setColor(Color.red);<br/>
                graph.drawString(Messages.getString("BoardView1.SWARMED"), 16, 21); //$NON-NLS-1$<br/>
            }<br/>
<br/>
            // If this unit is transporting another, say so.<br/>
            if ((entity.getLoadedUnits()).size() &gt; 0) {<br/>
                // draw "T"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString("T", 20, 71); //$NON-NLS-1$<br/>
                graph.setColor(Color.black);<br/>
                graph.drawString("T", 19, 70); //$NON-NLS-1$<br/>
            }<br/>
            <br/>
            // If this unit is stuck, say so.<br/>
            if ((entity.isStuck())) {<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.STUCK"), 26, 61); //$NON-NLS-1$<br/>
                graph.setColor(Color.orange);<br/>
                graph.drawString(Messages.getString("BoardView1.STUCK"), 25, 60); //$NON-NLS-1$<br/>
                <br/>
            }<br/>
<br/>
            // If this unit is currently unknown to the enemy, say so.<br/>
            if (trackThisEntitiesVisibilityInfo(entity)) {<br/>
                if (!entity.isSeenByEnemy()) {<br/>
                    // draw "U"<br/>
                    graph.setColor(Color.darkGray);<br/>
                    graph.drawString("U", 30, 71); //$NON-NLS-1$<br/>
                    graph.setColor(Color.black);<br/>
                    graph.drawString("U", 29, 70); //$NON-NLS-1$<br/>
                } else if (!entity.isVisibleToEnemy() &amp;&amp; !isJ2RE) {<br/>
                    // If this unit is currently hidden from the enemy, say so.<br/>
                    // draw "H"<br/>
                    graph.setColor(Color.darkGray);<br/>
                    graph.drawString("H", 30, 71); //$NON-NLS-1$<br/>
                    graph.setColor(Color.black);<br/>
                    graph.drawString("H", 29, 70); //$NON-NLS-1$<br/>
                }<br/>
            }<br/>
<br/>
            //Lets draw our armor and internal status bars<br/>
            int baseBarLength = 23;<br/>
            int barLength = 0;<br/>
            double percentRemaining = 0.00;<br/>
<br/>
            percentRemaining = entity.getArmorRemainingPercent();<br/>
            barLength = (int)(baseBarLength * percentRemaining);<br/>
<br/>
            graph.setColor(Color.darkGray);<br/>
            graph.fillRect(56, 7, 23, 3);<br/>
            graph.setColor(Color.lightGray);<br/>
            graph.fillRect(55, 6, 23, 3);<br/>
            graph.setColor(getStatusBarColor(percentRemaining));<br/>
            graph.fillRect(55, 6, barLength, 3);<br/>
<br/>
            percentRemaining = entity.getInternalRemainingPercent();<br/>
            barLength = (int)(baseBarLength * percentRemaining);<br/>
<br/>
            graph.setColor(Color.darkGray);<br/>
            graph.fillRect(56, 11, 23, 3);<br/>
            graph.setColor(Color.lightGray);<br/>
            graph.fillRect(55, 10, 23, 3);<br/>
            graph.setColor(getStatusBarColor(percentRemaining));<br/>
            graph.fillRect(55, 10, barLength, 3);<br/>
<br/>
            // create final image<br/>
            this.image = createImage(new FilteredImageSource(tempImage.getSource(),<br/>
                                                             new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
<br/>
        /*<br/>
         * We only want to show double-blind visibility indicators on<br/>
         * our own mechs and teammates mechs (assuming team vision option).<br/>
         */<br/>
        private boolean trackThisEntitiesVisibilityInfo(Entity e) {<br/>
            if (getLocalPlayer() == null) {<br/>
                return false;<br/>
            }<br/>
<br/>
            if (game.getOptions().booleanOption("double_blind") //$NON-NLS-1$<br/>
                &amp;&amp; (e.getOwner().getId() == getLocalPlayer().getId()<br/>
                    || (game.getOptions().booleanOption("team_vision") //$NON-NLS-1$<br/>
                        &amp;&amp; e.getOwner().getTeam() == getLocalPlayer().getTeam()))) {<br/>
                return true;<br/>
            } else {<br/>
                return false;<br/>
            }<br/>
        }<br/>
<br/>
        private Color getStatusBarColor(double percentRemaining) {<br/>
            if ( percentRemaining &lt;= .25 )<br/>
                return Color.red;<br/>
            else if ( percentRemaining &lt;= .75 )<br/>
                return Color.yellow;<br/>
            else<br/>
                return new Color(16, 196, 16);<br/>
        }<br/>
<br/>
        /**<br/>
         * Overrides to provide for a smaller sensitive area.<br/>
         */<br/>
        public boolean isInside(Point point) {<br/>
            return entityRect.contains(     point.x + view.x - offset.x,<br/>
                                        point.y + view.y - offset.y);<br/>
        }<br/>
<br/>
        private String[] getTooltip() {<br/>
            String[] tipStrings = new String[3];<br/>
            StringBuffer buffer;<br/>
<br/>
            buffer = new StringBuffer();<br/>
            buffer.append( entity.getChassis() )<br/>
                .append( " (" ) //$NON-NLS-1$<br/>
                .append( entity.getOwner().getName() )<br/>
                .append( "); " ) //$NON-NLS-1$<br/>
                .append( entity.getCrew().getGunnery() )<br/>
                .append( "/" ) //$NON-NLS-1$<br/>
                .append( entity.getCrew().getPiloting() )<br/>
                .append( Messages.getString("BoardView1.pilot") ); //$NON-NLS-1$<br/>
            int numAdv = entity.getCrew().countAdvantages();<br/>
            if (numAdv &gt; 0) {<br/>
                buffer.append( " &lt;" ) //$NON-NLS-1$<br/>
                    .append( numAdv )<br/>
                    .append( Messages.getString("BoardView1.advs") ); //$NON-NLS-1$<br/>
            }<br/>
            tipStrings[0] = buffer.toString();<br/>
<br/>
            buffer = new StringBuffer();<br/>
            buffer.append( Messages.getString("BoardView1.move") ) //$NON-NLS-1$<br/>
                .append( entity.getMovementAbbr(entity.moved) )<br/>
                .append( ":" ) //$NON-NLS-1$<br/>
                .append( entity.delta_distance )<br/>
                .append( " (+" ) //$NON-NLS-1$<br/>
                .append( Compute.getTargetMovementModifier<br/>
                         (game, entity.getId()).getValue() )<br/>
                .append( ");" ) //$NON-NLS-1$<br/>
                .append( Messages.getString("BoardView1.Heat") ) //$NON-NLS-1$<br/>
                .append( entity.heat );<br/>
            if (entity.isDone())<br/>
                buffer.append(" (").append(Messages.getString("BoardView1.done")).append(")");<br/>
            tipStrings[1] = buffer.toString();<br/>
<br/>
            buffer = new StringBuffer();<br/>
            buffer.append( Messages.getString("BoardView1.Armor") ) //$NON-NLS-1$<br/>
                .append( entity.getTotalArmor() )<br/>
                .append( Messages.getString("BoardView1.internal") ) //$NON-NLS-1$<br/>
                .append( entity.getTotalInternal() );<br/>
            tipStrings[2] = buffer.toString();<br/>
<br/>
            return tipStrings;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sprite for a step in a movement path.  Only one sprite should exist for<br/>
     * any hex in a path.  Contains a colored number, and arrows indicating<br/>
     * entering, exiting or turning.<br/>
     */<br/>
    private class StepSprite extends Sprite<br/>
    {<br/>
        private MoveStep step;<br/>
<br/>
        public StepSprite(MoveStep step) {<br/>
            this.step = step;<br/>
<br/>
            // step is the size of the hex that this step is in<br/>
            bounds = new Rectangle(getHexLocation(step.getPosition()), hex_size);<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        public void prepare() {<br/>
            // create image for buffer<br/>
            Image tempImage = createImage(bounds.width, bounds.height);<br/>
            Graphics graph = tempImage.getGraphics();<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
<br/>
            // setup some variables<br/>
            final Point stepPos = getHexLocation(step.getPosition());<br/>
            stepPos.translate(-bounds.x, -bounds.y);<br/>
            final Polygon facingPoly = facingPolys[step.getFacing()];<br/>
            final Polygon movePoly = movementPolys[step.getFacing()];<br/>
            Point offsetCostPos;<br/>
            Polygon myPoly;<br/>
            Color col;<br/>
            // set color<br/>
            switch (step.getMovementType()) {<br/>
                case IEntityMovementType.MOVE_RUN:<br/>
                case IEntityMovementType.MOVE_VTOL_RUN:<br/>
                    if (step.isUsingMASC()) {<br/>
                        col = GUIPreferences.getInstance().getColor("AdvancedMoveMASCColor");<br/>
                    } else {<br/>
                        col = GUIPreferences.getInstance().getColor("AdvancedMoveRunColor");<br/>
                    }<br/>
                    break;<br/>
                case IEntityMovementType.MOVE_JUMP :<br/>
                    col = GUIPreferences.getInstance().getColor("AdvancedMoveJumpColor");<br/>
                    break;<br/>
                case IEntityMovementType.MOVE_ILLEGAL :<br/>
                    col = GUIPreferences.getInstance().getColor("AdvancedMoveIllegalColor");<br/>
                    break;<br/>
                default :<br/>
                    if (step.getType()==MovePath.STEP_BACKWARDS) {<br/>
                        col = GUIPreferences.getInstance().getColor("AdvancedMoveBackColor");<br/>
                    } else {<br/>
                        col = GUIPreferences.getInstance().getColor("AdvancedMoveDefaultColor");<br/>
                    }<br/>
                    break;<br/>
            }<br/>
<br/>
            // draw arrows and cost for the step<br/>
            switch (step.getType()) {<br/>
            case MovePath.STEP_FORWARDS :<br/>
            case MovePath.STEP_BACKWARDS :<br/>
            case MovePath.STEP_CHARGE :<br/>
            case MovePath.STEP_DFA :<br/>
            case MovePath.STEP_LATERAL_LEFT :<br/>
            case MovePath.STEP_LATERAL_RIGHT :<br/>
            case MovePath.STEP_LATERAL_LEFT_BACKWARDS :<br/>
            case MovePath.STEP_LATERAL_RIGHT_BACKWARDS :<br/>
                // draw arrows showing them entering the next<br/>
                myPoly = new Polygon(movePoly.xpoints, movePoly.ypoints,<br/>
                                     movePoly.npoints);<br/>
                graph.setColor(Color.darkGray);<br/>
                myPoly.translate(stepPos.x + 1, stepPos.y + 1);<br/>
                graph.drawPolygon(myPoly);<br/>
                graph.setColor(col);<br/>
                myPoly.translate(-1, -1);<br/>
                graph.drawPolygon(myPoly);<br/>
                // draw movement cost<br/>
                drawMovementCost(step, stepPos, graph, col, true);<br/>
                break;<br/>
            case MovePath.STEP_GO_PRONE:<br/>
                // draw arrow indicating dropping prone<br/>
                Polygon downPoly = movementPolys[7];<br/>
                myPoly = new Polygon(downPoly.xpoints, downPoly.ypoints, downPoly.npoints);<br/>
                graph.setColor(Color.darkGray);<br/>
                myPoly.translate(stepPos.x, stepPos.y);<br/>
                graph.drawPolygon(myPoly);<br/>
                graph.setColor(col);<br/>
                myPoly.translate(-1, -1);<br/>
                graph.drawPolygon(myPoly);<br/>
                offsetCostPos = new Point(stepPos.x + 1, stepPos.y + 15);<br/>
                drawMovementCost(step, offsetCostPos, graph, col, false);<br/>
                break;<br/>
            case MovePath.STEP_GET_UP:<br/>
                // draw arrow indicating standing up<br/>
                Polygon upPoly = movementPolys[6];<br/>
                myPoly = new Polygon(upPoly.xpoints, upPoly.ypoints, upPoly.npoints);<br/>
                graph.setColor(Color.darkGray);<br/>
                myPoly.translate(stepPos.x, stepPos.y);<br/>
                graph.drawPolygon(myPoly);<br/>
                graph.setColor(col);<br/>
                myPoly.translate(-1, -1);<br/>
                graph.drawPolygon(myPoly);<br/>
                offsetCostPos = new Point(stepPos.x, stepPos.y + 15);<br/>
                drawMovementCost(step, offsetCostPos, graph, col, false);<br/>
                break;<br/>
            case MovePath.STEP_TURN_LEFT:<br/>
            case MovePath.STEP_TURN_RIGHT:<br/>
                // draw arrows showing the facing<br/>
                myPoly = new Polygon(facingPoly.xpoints, facingPoly.ypoints,<br/>
                                     facingPoly.npoints);<br/>
                graph.setColor(Color.darkGray);<br/>
                myPoly.translate(stepPos.x + 1, stepPos.y + 1);<br/>
                graph.drawPolygon(myPoly);<br/>
                graph.setColor(col);<br/>
                myPoly.translate(-1, -1);<br/>
                graph.drawPolygon(myPoly);<br/>
                break;<br/>
            case MovePath.STEP_LOAD:<br/>
                // Announce load.<br/>
                String load = Messages.getString("BoardView1.Load"); //$NON-NLS-1$<br/>
                if (step.isPastDanger()) {<br/>
                    load = "(" + load + ")"; //$NON-NLS-1$ //$NON-NLS-2$<br/>
                }<br/>
                graph.setFont(new Font("SansSerif", Font.PLAIN, 12)); //$NON-NLS-1$<br/>
                int loadX = stepPos.x + 42 - (graph.getFontMetrics(graph.getFont()).stringWidth(load) / 2);<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(load, loadX, stepPos.y + 39);<br/>
                graph.setColor(col);<br/>
                graph.drawString(load, loadX - 1, stepPos.y + 38);<br/>
                break;<br/>
            case MovePath.STEP_UNLOAD:<br/>
                // Announce unload.<br/>
                String unload = Messages.getString("BoardView1.Unload"); //$NON-NLS-1$<br/>
                if (step.isPastDanger()) {<br/>
                    unload = "(" + unload + ")"; //$NON-NLS-1$ //$NON-NLS-2$<br/>
                }<br/>
                graph.setFont(new Font("SansSerif", Font.PLAIN, 12)); //$NON-NLS-1$<br/>
                int unloadX = stepPos.x + 42 - (graph.getFontMetrics(graph.getFont()).stringWidth(unload) / 2);<br/>
                int unloadY = stepPos.y + 38 + graph.getFontMetrics(graph.getFont()).getHeight();<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(unload, unloadX, unloadY + 1);<br/>
                graph.setColor(col);<br/>
                graph.drawString(unload, unloadX - 1, unloadY);<br/>
                break;<br/>
<br/>
            default :<br/>
                break;<br/>
            }<br/>
<br/>
            // create final image<br/>
            this.image = createImage(new FilteredImageSource(tempImage.getSource(),<br/>
                                                             new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
<br/>
        public Rectangle getBounds(){<br/>
            bounds = new Rectangle(getHexLocation(step.getPosition()), hex_size);<br/>
            return bounds;<br/>
        }<br/>
        <br/>
        public MoveStep getStep() {<br/>
            return step;<br/>
        }<br/>
<br/>
        private void drawMovementCost(MoveStep step, Point stepPos, Graphics graph, Color col, boolean shiftFlag) {<br/>
            String costString = null;<br/>
            StringBuffer costStringBuf = new StringBuffer();<br/>
            costStringBuf.append( step.getMpUsed() );<br/>
<br/>
            // If the step is using a road bonus, mark it.<br/>
            if ( step.isPavementStep() &amp;&amp; step.getParent().getEntity() instanceof Tank ) {<br/>
                costStringBuf.append( "+" ); //$NON-NLS-1$<br/>
            }<br/>
<br/>
            // If the step is dangerous, mark it.<br/>
            if ( step.isDanger() ) {<br/>
                costStringBuf.append( "*" ); //$NON-NLS-1$<br/>
            }<br/>
<br/>
            // If the step is past danger, mark that.<br/>
            if (step.isPastDanger()) {<br/>
                costStringBuf.insert( 0, "(" ); //$NON-NLS-1$<br/>
                costStringBuf.append( ")" ); //$NON-NLS-1$<br/>
            }<br/>
<br/>
            if (step.isUsingMASC()) {<br/>
                costStringBuf.append("["); //$NON-NLS-1$<br/>
                costStringBuf.append(step.getTargetNumberMASC());<br/>
                costStringBuf.append("+]"); //$NON-NLS-1$<br/>
            }<br/>
            <br/>
            if (<span class="mv">step.getMovementType() == IEntityMovementType.MOVE_VTOL_RUN</span> ||<br/>
                step.getMovementType() == <span class="upd">IEntityMovementType.<span class="upd">MOVE_VTOL_RUN</span></span>) {<br/>
                costStringBuf.append("{").append(step.getElevation()).append("}");<br/>
            }<br/>
<br/>
            // Convert the buffer to a String and draw it.<br/>
            costString = costStringBuf.toString();<br/>
            graph.setFont(new Font("SansSerif", Font.PLAIN, 12)); //$NON-NLS-1$<br/>
            int costX = stepPos.x + 42;<br/>
            if (shiftFlag) {<br/>
                costX -= (graph.getFontMetrics(graph.getFont()).stringWidth(costString) / 2);<br/>
            }<br/>
            graph.setColor(Color.darkGray);<br/>
            graph.drawString(costString, costX, stepPos.y + 39);<br/>
            graph.setColor(col);<br/>
            graph.drawString(costString, costX - 1, stepPos.y + 38);<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Sprite and info for a C3 network.  Does not actually use the image buffer<br/>
     * as this can be horribly inefficient for long diagonal lines.<br/>
     */<br/>
    private class C3Sprite extends Sprite<br/>
    {<br/>
        private Polygon C3Poly;<br/>
<br/>
        protected int entityId;<br/>
        protected int masterId;<br/>
        protected Entity entityE;<br/>
        protected Entity entityM;<br/>
        <br/>
        Color spriteColor;<br/>
<br/>
        public C3Sprite(Entity e, Entity m) {<br/>
            this.entityE = e;<br/>
            this.entityM = m;<br/>
            this.entityId = e.getId();<br/>
            this.masterId = m.getId();<br/>
            this.spriteColor = PlayerColors.getColor(e.getOwner().getColorIndex());<br/>
<br/>
            if(e.getPosition() == null || m.getPosition() == null) {<br/>
                C3Poly = new Polygon();<br/>
                C3Poly.addPoint(0, 0);<br/>
                C3Poly.addPoint(1,0);<br/>
                C3Poly.addPoint(0,1);<br/>
                this.bounds = new Rectangle(C3Poly.getBounds());<br/>
                bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
                this.image = null;<br/>
                return;<br/>
            }<br/>
<br/>
            makePoly();<br/>
<br/>
            // set bounds<br/>
            this.bounds = new Rectangle(C3Poly.getBounds());<br/>
            bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
<br/>
            // move poly to upper right of image<br/>
            C3Poly.translate(-bounds.getLocation().x, -bounds.getLocation().y);<br/>
<br/>
            // set names &amp; stuff<br/>
<br/>
            // nullify image<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        public void prepare() {<br/>
        }<br/>
<br/>
        private void makePoly( ){<br/>
            // make a polygon<br/>
            final Point a = getHexLocation(entityE.getPosition());<br/>
            final Point t = getHexLocation(entityM.getPosition());<br/>
<br/>
            final double an = (entityE.getPosition().radian(entityM.getPosition()) + (Math.PI * 1.5)) % (Math.PI * 2); // angle<br/>
            final double lw = scale*C3_LINE_WIDTH; // line width<br/>
            <br/>
            C3Poly = new Polygon();<br/>
            C3Poly.addPoint(<br/>
                    a.x + (int)(scale*(HEX_W/2) - (int)Math.round(Math.sin(an) * lw)),<br/>
                    a.y + (int)(scale*(HEX_H/2) + (int)Math.round(Math.cos(an) * lw)));<br/>
            C3Poly.addPoint(<br/>
                    a.x + (int)(scale*(HEX_W/2) + (int)Math.round(Math.sin(an) * lw)), <br/>
                    a.y + (int)(scale*(HEX_H/2) - (int)Math.round(Math.cos(an) * lw)));<br/>
            C3Poly.addPoint(<br/>
                    t.x + (int)(scale*(HEX_W/2) + (int)Math.round(Math.sin(an) * lw)), <br/>
                    t.y + (int)(scale*(HEX_H/2) - (int)Math.round(Math.cos(an) * lw)));<br/>
            C3Poly.addPoint(<br/>
                    t.x + (int)(scale*(HEX_W/2) - (int)Math.round(Math.sin(an) * lw)), <br/>
                    t.y + (int)(scale*(HEX_H/2) + (int)Math.round(Math.cos(an) * lw)));<br/>
        }<br/>
<br/>
        public Rectangle getBounds(){<br/>
            makePoly();<br/>
            // set bounds<br/>
            this.bounds = new Rectangle(C3Poly.getBounds());<br/>
            bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
<br/>
            // move poly to upper right of image<br/>
            C3Poly.translate(-bounds.getLocation().x, -bounds.getLocation().y);<br/>
            this.image = null;<br/>
            <br/>
            return bounds;<br/>
        }<br/>
        <br/>
        public boolean isReady() {<br/>
            return true;<br/>
        }<br/>
<br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer) {<br/>
            //makePoly();<br/>
            <br/>
            Polygon drawPoly = new Polygon(C3Poly.xpoints, C3Poly.ypoints, C3Poly.npoints);<br/>
            drawPoly.translate(x, y);<br/>
<br/>
            g.setColor(spriteColor);<br/>
            g.fillPolygon(drawPoly);<br/>
            g.setColor(Color.black);<br/>
            g.drawPolygon(drawPoly);<br/>
        }<br/>
<br/>
        /**<br/>
         * Return true if the point is inside our polygon<br/>
         */<br/>
        public boolean isInside(Point point) {<br/>
            return C3Poly.contains(point.x + view.x - bounds.x - offset.x,<br/>
                                   point.y + view.y - bounds.y - offset.y);<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Sprite and info for an attack.  Does not actually use the image buffer<br/>
     * as this can be horribly inefficient for long diagonal lines.<br/>
     *<br/>
     * Appears as an arrow. Arrow becoming cut in half when two Meks attacking<br/>
     * each other.<br/>
     */<br/>
    private class AttackSprite extends Sprite<br/>
    {<br/>
        private java.util.Vector attacks = new java.util.Vector();<br/>
        private Point a;<br/>
        private Point t;<br/>
        private double an;<br/>
        private StraightArrowPolygon attackPoly;<br/>
        private Color attackColor;<br/>
        private int entityId;<br/>
        private int targetType;<br/>
        private int targetId;<br/>
        private String attackerDesc;<br/>
        private String targetDesc;<br/>
        private Vector weaponDescs = new Vector();<br/>
        private final Entity ae;<br/>
        private final Targetable target;<br/>
<br/>
        public AttackSprite(AttackAction attack) {<br/>
            this.attacks.addElement(attack);<br/>
            this.entityId = attack.getEntityId();<br/>
            this.targetType = attack.getTargetType();<br/>
            this.targetId = attack.getTargetId();<br/>
            this.ae = game.getEntity(attack.getEntityId());<br/>
            this.target = game.getTarget(targetType, targetId);<br/>
<br/>
            // color?<br/>
            attackColor = PlayerColors.getColor(ae.getOwner().getColorIndex());<br/>
            //angle of line connecting two hexes<br/>
            this.an = (ae.getPosition().radian(target.getPosition()) + (Math.PI * 1.5)) % (Math.PI * 2); // angle<br/>
            makePoly();<br/>
<br/>
            // set bounds<br/>
            this.bounds = new Rectangle(attackPoly.getBounds());<br/>
            bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
            // move poly to upper right of image<br/>
            attackPoly.translate(-bounds.getLocation().x, -bounds.getLocation().y);<br/>
<br/>
            // set names &amp; stuff<br/>
            attackerDesc = ae.getDisplayName();<br/>
            targetDesc = target.getDisplayName();<br/>
            if (attack instanceof WeaponAttackAction) {<br/>
                addWeapon((WeaponAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof KickAttackAction) {<br/>
                addWeapon((KickAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof PunchAttackAction) {<br/>
                addWeapon((PunchAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof PushAttackAction) {<br/>
                addWeapon((PushAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof ClubAttackAction) {<br/>
                addWeapon((ClubAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof ChargeAttackAction) {<br/>
                addWeapon((ChargeAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof DfaAttackAction) {<br/>
                addWeapon((DfaAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof ProtomechPhysicalAttackAction) {<br/>
                addWeapon((ProtomechPhysicalAttackAction)attack);<br/>
            }<br/>
<br/>
            // nullify image<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        private void makePoly(){<br/>
            // make a polygon<br/>
            this.a = getHexLocation(ae.getPosition());<br/>
            this.t = getHexLocation(target.getPosition());<br/>
            // OK, that is actually not good. I do not like hard coded figures.<br/>
            // HEX_W/2 - x distance in pixels from origin of hex bounding box to the center of hex.<br/>
            // HEX_H/2 - y distance in pixels from origin of hex bounding box to the center of hex.<br/>
            // 18 - is actually 36/2 - we do not want arrows to start and end directly<br/>
            // in the centes of hex and hiding mek under.<br/>
<br/>
            a.x = a.x + (int)(HEX_W/2*scale) + (int)Math.round(Math.cos(an) * (int)(18*scale));<br/>
            t.x = t.x + (int)(HEX_W/2*scale) - (int)Math.round(Math.cos(an) * (int)(18*scale));<br/>
            a.y = a.y + (int)(HEX_H/2*scale) + (int)Math.round(Math.sin(an) * (int)(18*scale));<br/>
            t.y = t.y + (int)(HEX_H/2*scale) - (int)Math.round(Math.sin(an) * (int)(18*scale));<br/>
<br/>
            // Checking if given attack is mutual. In this case we building halved arrow<br/>
            if (isMutualAttack()){<br/>
                attackPoly = new StraightArrowPolygon(a, t, (int)(8*scale), (int)(12*scale), true);<br/>
            } else {<br/>
                attackPoly = new StraightArrowPolygon(a, t, (int)(4*scale), (int)(8*scale), false);<br/>
            }<br/>
        }<br/>
        <br/>
        public Rectangle getBounds(){<br/>
            makePoly();<br/>
            // set bounds<br/>
            this.bounds = new Rectangle(attackPoly.getBounds());<br/>
            bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
            // move poly to upper right of image<br/>
            attackPoly.translate(-bounds.getLocation().x, -bounds.getLocation().y);<br/>
            <br/>
            return bounds;<br/>
        }<br/>
<br/>
        /** If we have build full arrow already with single attack and have got<br/>
         * counter attack from our target lately - lets change arrow to halved.<br/>
         */<br/>
        public void rebuildToHalvedPolygon(){<br/>
            attackPoly = new StraightArrowPolygon(a, t, (int)(8*scale), (int)(12*scale), true);<br/>
            // set bounds<br/>
            this.bounds = new Rectangle(attackPoly.getBounds());<br/>
            bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
            // move poly to upper right of image<br/>
            attackPoly.translate(-bounds.getLocation().x, -bounds.getLocation().y);<br/>
        }<br/>
        /** Cheking if attack is mutual and changing target arrow to half-arrow<br/>
         */<br/>
        private boolean isMutualAttack(){<br/>
            for (final Iterator i = attackSprites.iterator(); i.hasNext();) {<br/>
                final AttackSprite sprite = (AttackSprite)i.next();<br/>
                if (sprite.getEntityId() == this.targetId &amp;&amp; sprite.getTargetId() == this.entityId) {<br/>
                    sprite.rebuildToHalvedPolygon();<br/>
                    return true;<br/>
                }<br/>
            }<br/>
            return false;<br/>
        }<br/>
<br/>
        public void prepare() {<br/>
        }<br/>
<br/>
        public boolean isReady() {<br/>
            return true;<br/>
        }<br/>
<br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer) {<br/>
            Polygon drawPoly = new Polygon(attackPoly.xpoints, attackPoly.ypoints, attackPoly.npoints);<br/>
            drawPoly.translate(x, y);<br/>
<br/>
            g.setColor(attackColor);<br/>
            g.fillPolygon(drawPoly);<br/>
            g.setColor(Color.gray.darker());<br/>
            g.drawPolygon(drawPoly);<br/>
        }<br/>
<br/>
        /**<br/>
         * Return true if the point is inside our polygon<br/>
         */<br/>
        public boolean isInside(Point point) {<br/>
            return attackPoly.contains(point.x + view.x - bounds.x - offset.x,<br/>
                                       point.y + view.y - bounds.y - offset.y);<br/>
        }<br/>
<br/>
        public int getEntityId() {<br/>
            return entityId;<br/>
        }<br/>
<br/>
        public int getTargetId() {<br/>
            return targetId;<br/>
        }<br/>
<br/>
        /**<br/>
         * Adds a weapon to this attack<br/>
         */<br/>
        public void addWeapon(WeaponAttackAction attack) {<br/>
            final Entity entity = game.getEntity(attack.getEntityId());<br/>
            final WeaponType wtype = (WeaponType)entity.getEquipment(attack.getWeaponId()).getType();<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            weaponDescs.addElement( wtype.getName() + Messages.getString("BoardView1.needs") + roll ); //$NON-NLS-1$<br/>
        }<br/>
<br/>
        public void addWeapon(KickAttackAction attack) {<br/>
            String bufer = ""; //$NON-NLS-1$<br/>
            String rollLeft = ""; //$NON-NLS-1$<br/>
            String rollRight = ""; //$NON-NLS-1$<br/>
            final int leg = attack.getLeg();<br/>
            switch (leg){<br/>
            case KickAttackAction.BOTH:<br/>
                rollLeft = KickAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), KickAttackAction.LEFT).getValueAsString();<br/>
                rollRight = KickAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), KickAttackAction.RIGHT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.kickBoth", new Object[]{rollLeft,rollRight}); //$NON-NLS-1$<br/>
                break;<br/>
            case KickAttackAction.LEFT:<br/>
                rollLeft = KickAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), KickAttackAction.LEFT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.kickLeft", new Object[]{rollLeft}); //$NON-NLS-1$<br/>
                break;<br/>
            case KickAttackAction.RIGHT:<br/>
                rollRight = KickAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), KickAttackAction.RIGHT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.kickRight", new Object[]{rollRight}); //$NON-NLS-1$<br/>
                break;<br/>
            }<br/>
            weaponDescs.addElement(bufer);<br/>
        }<br/>
<br/>
        public void addWeapon(PunchAttackAction attack) {<br/>
            String bufer = ""; //$NON-NLS-1$<br/>
            String rollLeft = ""; //$NON-NLS-1$<br/>
            String rollRight = ""; //$NON-NLS-1$<br/>
            final int arm = attack.getArm();<br/>
            switch (arm){<br/>
            case PunchAttackAction.BOTH:<br/>
                rollLeft = PunchAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), PunchAttackAction.LEFT).getValueAsString();<br/>
                rollRight = PunchAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), PunchAttackAction.RIGHT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.punchBoth", new Object[]{rollLeft,rollRight}); //$NON-NLS-1$<br/>
                break;<br/>
            case PunchAttackAction.LEFT:<br/>
                rollLeft = PunchAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), PunchAttackAction.LEFT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.punchLeft", new Object[]{rollLeft}); //$NON-NLS-1$<br/>
                break;<br/>
            case PunchAttackAction.RIGHT:<br/>
                rollRight = PunchAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), PunchAttackAction.RIGHT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.punchRight", new Object[]{rollRight}); //$NON-NLS-1$<br/>
                break;<br/>
            }<br/>
            weaponDescs.addElement(bufer);<br/>
        }<br/>
<br/>
        public void addWeapon(PushAttackAction attack) {<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            weaponDescs.addElement(Messages.getString("BoardView1.push", new Object[]{roll})); //$NON-NLS-1$<br/>
        }<br/>
<br/>
        public void addWeapon(ClubAttackAction attack) {<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            final String club = attack.getClub().getName();<br/>
            weaponDescs.addElement(Messages.getString("BoardView1.hit", new Object[]{club,roll})); //$NON-NLS-1$<br/>
        }<br/>
<br/>
        public void addWeapon(ChargeAttackAction attack) {<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            weaponDescs.addElement(Messages.getString("BoardView1.charge", new Object[]{roll})); //$NON-NLS-1$<br/>
        }<br/>
        public void addWeapon(DfaAttackAction attack) {<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            weaponDescs.addElement(Messages.getString("BoardView1.DFA", new Object[]{roll})); //$NON-NLS-1$<br/>
        }<br/>
        public void addWeapon(ProtomechPhysicalAttackAction attack) {<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            weaponDescs.addElement(Messages.getString("BoardView1.proto", new Object[]{roll})); //$NON-NLS-1$<br/>
        }<br/>
<br/>
        private String[] getTooltip() {<br/>
            String[] tipStrings = new String[1 + weaponDescs.size()];<br/>
            int tip = 1;<br/>
            tipStrings[0] = attackerDesc + " "+Messages.getString("BoardView1.on")+" " + targetDesc; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$<br/>
            for (Iterator i = weaponDescs.iterator(); i.hasNext();) {<br/>
                tipStrings[tip++] = (String)i.next();<br/>
            }<br/>
            return tipStrings;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine if the tile manager's images have been loaded.<br/>
     *<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if all images have been loaded.<br/>
     *          &lt;code&gt;false&lt;/code&gt; if more need to be loaded.<br/>
     */<br/>
    public boolean isTileImagesLoaded() {<br/>
        return this.tileManager.isLoaded();<br/>
    }<br/>
<br/>
    public void setUseLOSTool(boolean use) {<br/>
        useLOSTool = use;<br/>
    }<br/>
<br/>
    public TilesetManager getTilesetManager() {<br/>
        return tileManager;<br/>
    }<br/>
<br/>
    // added by kenn<br/>
    public void drawRuler(Coords s, Coords e, Color sc, Color ec) {<br/>
        rulerStart = s;<br/>
        rulerEnd = e;<br/>
        rulerStartColor = sc;<br/>
        rulerEndColor = ec;<br/>
<br/>
        repaint();<br/>
    }<br/>
    // end kenn<br/>
<br/>
    /**<br/>
     * @param lastCursor The lastCursor to set.<br/>
     */<br/>
    public void setLastCursor(Coords lastCursor) {<br/>
        this.lastCursor = lastCursor;<br/>
    }<br/>
<br/>
    /**<br/>
     * @return Returns the lastCursor.<br/>
     */<br/>
    public Coords getLastCursor() {<br/>
        return lastCursor;<br/>
    }<br/>
<br/>
    /**<br/>
     * @param highlighted The highlighted to set.<br/>
     */<br/>
    public void setHighlighted(Coords highlighted) {<br/>
        this.highlighted = highlighted;<br/>
    }<br/>
<br/>
    /**<br/>
     * @return Returns the highlighted.<br/>
     */<br/>
    public Coords getHighlighted() {<br/>
        return highlighted;<br/>
    }<br/>
<br/>
    /**<br/>
     * @param selected The selected to set.<br/>
     */<br/>
    public void setSelected(Coords selected) {<br/>
        this.selected = selected;<br/>
    }<br/>
<br/>
    /**<br/>
     * @return Returns the selected.<br/>
     */<br/>
    public Coords getSelected() {<br/>
        return selected;<br/>
    }<br/>
<br/>
    /**<br/>
     * @param firstLOS The firstLOS to set.<br/>
     */<br/>
    public void setFirstLOS(Coords firstLOS) {<br/>
        this.firstLOS = firstLOS;<br/>
    }<br/>
<br/>
    /**<br/>
     * @return Returns the firstLOS.<br/>
     */<br/>
    public Coords getFirstLOS() {<br/>
        return firstLOS;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Determines if this Board contains the Coords,<br/>
     * and if so, "selects" that Coords.<br/>
     *<br/>
     * @param coords the Coords.<br/>
     */<br/>
    public void select(Coords coords) {<br/>
        if(coords == null || game.getBoard().contains(coords)) {<br/>
            setSelected(coords);<br/>
            moveCursor(selectedSprite, coords);<br/>
            moveCursor(firstLOSSprite, null);<br/>
            moveCursor(secondLOSSprite, null);<br/>
            processBoardViewEvent(new BoardViewEvent(this, coords, null, BoardViewEvent.BOARD_HEX_SELECTED,0));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * "Selects" the specified Coords.<br/>
     *<br/>
     * @param x the x coordinate.<br/>
     * @param y the y coordinate.<br/>
     */<br/>
    public void select(int x, int y) {<br/>
        select(new Coords(x, y));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Determines if this Board contains the Coords,<br/>
     * and if so, highlights that Coords.<br/>
     *<br/>
     * @param coords the Coords.<br/>
     */<br/>
    public void highlight(Coords coords) {<br/>
        if(coords == null || game.getBoard().contains(coords)) {<br/>
            setHighlighted(coords);<br/>
            moveCursor(highlightSprite, coords);<br/>
            moveCursor(firstLOSSprite, null);<br/>
            moveCursor(secondLOSSprite, null);<br/>
            processBoardViewEvent(new BoardViewEvent(this, coords, null, BoardViewEvent.BOARD_HEX_HIGHLIGHTED, 0));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Highlights the specified Coords.<br/>
     *<br/>
     * @param x the x coordinate.<br/>
     * @param y the y coordinate.<br/>
     */<br/>
    public void highlight(int x, int y) {<br/>
        highlight(new Coords(x, y));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Determines if this Board contains the Coords,<br/>
     * and if so, "cursors" that Coords.<br/>
     *<br/>
     * @param coords the Coords.<br/>
     */<br/>
    public void cursor(Coords coords) {<br/>
        if(coords == null || game.getBoard().contains(coords)) {<br/>
            if(getLastCursor() == null || coords == null || !coords.equals(getLastCursor())) {<br/>
                setLastCursor(coords);<br/>
                moveCursor(cursorSprite, coords);<br/>
                moveCursor(firstLOSSprite, null);<br/>
                moveCursor(secondLOSSprite, null);<br/>
                processBoardViewEvent(new BoardViewEvent(this, coords, null, BoardViewEvent.BOARD_HEX_CURSOR, 0));<br/>
            } else {<br/>
                setLastCursor(coords);<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * "Cursors" the specified Coords.<br/>
     *<br/>
     * @param x the x coordinate.<br/>
     * @param y the y coordinate.<br/>
     */<br/>
    public void cursor(int x, int y) {<br/>
        cursor(new Coords(x, y));<br/>
    }<br/>
<br/>
    public void checkLOS(Coords c) {<br/>
        if(c == null || game.getBoard().contains(c)) {<br/>
            if (getFirstLOS() == null) {<br/>
                setFirstLOS(c);<br/>
                firstLOSHex(c);<br/>
                processBoardViewEvent(new BoardViewEvent(this, c, null, BoardViewEvent.BOARD_FIRST_LOS_HEX, 0));<br/>
            } else {<br/>
                secondLOSHex(c,getFirstLOS());<br/>
                processBoardViewEvent(new BoardViewEvent(this, c, null, BoardViewEvent.BOARD_SECOND_LOS_HEX, 0));<br/>
                setFirstLOS(null);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Determines if this Board contains the (x, y) Coords,<br/>
     * and if so, notifies listeners about the specified mouse<br/>
     * action.<br/>
     */<br/>
    public void mouseAction(int x, int y, int mtype, int modifiers) {<br/>
        if(game.getBoard().contains(x, y)) {<br/>
            Coords c = new Coords(x, y);<br/>
            switch(mtype) {<br/>
            case BOARD_HEX_CLICK :<br/>
                if ((modifiers &amp; java.awt.event.InputEvent.CTRL_MASK) != 0) {<br/>
                    checkLOS(c);<br/>
                } else {<br/>
                    processBoardViewEvent(new BoardViewEvent(this, c, null, BoardViewEvent.BOARD_HEX_CLICKED, modifiers));<br/>
                }<br/>
                break;<br/>
            case BOARD_HEX_DOUBLECLICK :<br/>
                processBoardViewEvent(new BoardViewEvent(this, c, null, BoardViewEvent.BOARD_HEX_DOUBLECLICKED, modifiers));<br/>
                break;<br/>
            case BOARD_HEX_DRAG :<br/>
                processBoardViewEvent(new BoardViewEvent(this, c, null, BoardViewEvent.BOARD_HEX_DRAGGED, modifiers));<br/>
                break;<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Notifies listeners about the specified mouse action.<br/>
     *<br/>
     * @param coords the Coords.<br/>
     */<br/>
    public void mouseAction(Coords coords, int mtype, int modifiers) {<br/>
        mouseAction(coords.x, coords.y, mtype, modifiers);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Return, whether a popup may be drawn, this currently means, whether no scrolling took place.<br/>
     */<br/>
    public boolean mayDrawPopup() {<br/>
        return !scrolled;<br/>
    }<br/>
<br/>
    /* (non-Javadoc)<br/>
     * @see megamek.common.BoardListener#boardNewBoard(megamek.common.BoardEvent)<br/>
     */<br/>
    public void boardNewBoard(BoardEvent b) {        <br/>
        updateBoard();<br/>
    }<br/>
<br/>
    /* (non-Javadoc)<br/>
     * @see megamek.common.BoardListener#boardChangedHex(megamek.common.BoardEvent)<br/>
     */<br/>
    public void boardChangedHex(BoardEvent b) {<br/>
        IHex hex = game.getBoard().getHex(b.getCoords());<br/>
        tileManager.clearHex(hex);<br/>
        tileManager.waitForHex(hex);<br/>
        if (boardGraph != null) {<br/>
            redrawAround(b.getCoords());<br/>
        }<br/>
    }<br/>
<br/>
    //TODO Is there a better solution?<br/>
    //This is required because the BoardView creates the redraw thread <br/>
    //that must be stopped explicitly     <br/>
    public void die() {<br/>
        redrawWorker.stop();<br/>
    }<br/>
<br/>
    private GameListener gameListener = new GameListenerAdapter(){<br/>
        <br/>
        public void gameEntityNew(GameEntityNewEvent e) {<br/>
            redrawAllEntities();            <br/>
        }<br/>
<br/>
        public void gameEntityRemove(GameEntityRemoveEvent e) {<br/>
            redrawAllEntities();            <br/>
        }<br/>
<br/>
        public void gameEntityChange(GameEntityChangeEvent e) {<br/>
            java.util.Vector mp = e.getMovePath();<br/>
            if (mp != null &amp;&amp; mp.size() &gt; 0 &amp;&amp; GUIPreferences.getInstance().getShowMoveStep()) {<br/>
                addMovingUnit(e.getEntity(), mp);<br/>
            }else {<br/>
                redrawEntity(e.getEntity());<br/>
            }<br/>
        }<br/>
<br/>
        public void gameNewAction(GameNewActionEvent e) {<br/>
            EntityAction ea = e.getAction();<br/>
            if (ea instanceof AttackAction) {            <br/>
                addAttack((AttackAction)ea);<br/>
            }<br/>
        }<br/>
<br/>
        public void gameBoardNew(GameBoardNewEvent e) {<br/>
            IBoard b = e.getOldBoard();<br/>
            if (b != null) {<br/>
                b.removeBoardListener(BoardView1.this);<br/>
            }<br/>
            b = e.getNewBoard();<br/>
            if (b != null) {<br/>
                b.addBoardListener(BoardView1.this);<br/>
            }<br/>
            updateBoard();<br/>
        }        <br/>
<br/>
        public void gameBoardChanged(GameBoardChangeEvent e) {<br/>
            boardImage = null;<br/>
            boardGraph = null;<br/>
            redrawAllEntities();<br/>
        }<br/>
    };<br/>
<br/>
    protected void updateBoard() {<br/>
        updateBoardSize();<br/>
        backGraph = null;<br/>
        backImage = null;<br/>
        backSize = null;<br/>
        boardImage = null;<br/>
        boardGraph = null;<br/>
        tileManager.reset();<br/>
        redrawAllEntities();<br/>
    }<br/>
    <br/>
    /*<br/>
     * It's not quite polished solution, but on other hand it's better then nothing.<br/>
     */<br/>
    protected class RedrawWorker implements Runnable {<br/>
<br/>
        private boolean finished = false;<br/>
<br/>
        public void start() {<br/>
            Thread thread = new Thread(this, "BoardView RedrawWorker Thread"); //$NON-NLS-1$<br/>
            thread.start();<br/>
            <br/>
        }<br/>
        <br/>
        public void stop() {<br/>
            finished = true;<br/>
        }<br/>
<br/>
        public void run() {<br/>
            long lastTime = System.currentTimeMillis();<br/>
            long currentTime = System.currentTimeMillis();<br/>
            while (!finished) {<br/>
                try {<br/>
                    Thread.sleep(20);<br/>
                } catch(InterruptedException ex) {<br/>
                    // duh?<br/>
                }<br/>
                if (finished) {<br/>
                    break;<br/>
                }<br/>
                if (!isShowing()) {<br/>
                    currentTime = System.currentTimeMillis();<br/>
                    lastTime = currentTime;<br/>
                    continue;<br/>
                }<br/>
                currentTime = System.currentTimeMillis();<br/>
                boolean redraw = false;<br/>
                for (int i = 0; i &lt; displayables.size(); i++) {<br/>
                    Displayable disp = (Displayable) displayables.elementAt(i);<br/>
                    if (!disp.isSliding()) {<br/>
                        disp.setIdleTime(currentTime - lastTime, true);<br/>
                    } else {<br/>
                        redraw = redraw || disp.slide();<br/>
                    }<br/>
                }<br/>
                if (backSize != null) {<br/>
                    redraw = redraw || doMoveUnits(currentTime - lastTime);<br/>
                    redraw = redraw || doScroll();<br/>
                    checkTooltip();<br/>
                } else {<br/>
                    repaint(100);<br/>
                }<br/>
                if (redraw) {<br/>
                    repaint();<br/>
                }<br/>
                lastTime = currentTime;<br/>
            }<br/>
        }<br/>
    }<br/>
}<br/>
</div>
</div>
</div>
<div class="right">
<h1>right_BoardView1_1.215.java</h1>
<div class="code">
<div class="id">
/*<br/>
 * MegaMek -<br/>
 * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)<br/>
 *<br/>
 *  This program is free software; you can redistribute it and/or modify it<br/>
 *  under the terms of the GNU General Public License as published by the Free<br/>
 *  Software Foundation; either version 2 of the License, or (at your option)<br/>
 *  any later version.<br/>
 *<br/>
 *  This program is distributed in the hope that it will be useful, but<br/>
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY<br/>
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License<br/>
 *  for more details.<br/>
 */<br/>
<br/>
package megamek.client.ui.AWT;<br/>
<br/>
// Defines Iterator class for JDK v1.1<br/>
import com.sun.java.util.collections.*;<br/>
import java.awt.*;<br/>
import java.awt.event.*;<br/>
import java.awt.image.*;<br/>
import java.util.Enumeration;<br/>
<br/>
import megamek.client.event.BoardViewEvent;<br/>
import megamek.client.event.BoardViewListener;<br/>
import megamek.client.ui.AWT.util.*;<br/>
import megamek.common.*;<br/>
import megamek.common.actions.*;<br/>
import megamek.common.event.BoardEvent;<br/>
import megamek.common.event.BoardListener;<br/>
import megamek.common.event.GameEntityRemoveEvent;<br/>
import megamek.common.event.GameNewActionEvent;<br/>
import megamek.common.event.GameBoardNewEvent;<br/>
import megamek.common.event.GameBoardChangeEvent;<br/>
import megamek.common.event.GameEntityChangeEvent;<br/>
import megamek.common.event.GameEntityNewEvent;<br/>
import megamek.common.event.GameListener;<br/>
import megamek.common.event.GameListenerAdapter;<br/>
import megamek.common.preference.PreferenceManager;<br/>
<br/>
import java.util.Properties;<br/>
<br/>
/**<br/>
 * Displays the board; lets the user scroll around and select points on it.<br/>
 */<br/>
public class BoardView1<br/>
    extends Canvas<br/>
    implements IBoardView, BoardListener, MouseListener, MouseMotionListener, KeyListener, AdjustmentListener<br/>
{<br/>
    private static final int        TRANSPARENT = 0xFFFF00FF;<br/>
<br/>
    // the dimensions of megamek's hex images<br/>
    private static final int        HEX_W = 84;<br/>
    private static final int        HEX_H = 72;<br/>
    private static final int        HEX_WC = HEX_W - HEX_W/4;<br/>
    <br/>
    // The list of valid zoom factors.  Other values cause map aliasing,<br/>
    // I can't be bothered figuring out why.  - Ben<br/>
    private static final float[] ZOOM_FACTORS =<br/>
            {   0.30f, 0.41f, 0.50f,<br/>
                0.60f, 0.68f, 0.79f,<br/>
                0.90f, 1.00f<br/>
                //1.09f, 1.17f<br/>
            };<br/>
    <br/>
    private ImageCache[] scaledImageCaches;<br/>
<br/>
    // the index of zoom factor 1.00f<br/>
    private static final int BASE_ZOOM_INDEX = 7;<br/>
<br/>
    // line width of the c3 network lines<br/>
    private static final int C3_LINE_WIDTH = 1;<br/>
<br/>
    private static Font FONT_7 = new Font("SansSerif", Font.PLAIN, 7); //$NON-NLS-1$<br/>
    private static Font FONT_8 = new Font("SansSerif", Font.PLAIN, 8); //$NON-NLS-1$<br/>
    private static Font FONT_9 = new Font("SansSerif", Font.PLAIN, 9); //$NON-NLS-1$<br/>
    private static Font FONT_10 = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
    private static Font FONT_12 = new Font("SansSerif", Font.PLAIN, 12); //$NON-NLS-1$<br/>
<br/>
    private Dimension       hex_size = null;<br/>
    private boolean         isJ2RE;<br/>
    <br/>
    private Font       font_hexnum          = FONT_10;<br/>
    private Font       font_elev        = FONT_9;<br/>
    private Font       font_minefield   = FONT_12;<br/>
<br/>
    private IGame game;<br/>
    private Frame frame;<br/>
<br/>
    private Point       mousePos = new Point();<br/>
    private Rectangle   view = new Rectangle();<br/>
    private Point       offset = new Point();<br/>
    private Dimension boardSize;<br/>
<br/>
    // scrolly stuff:<br/>
    private Scrollbar vScrollbar = null;<br/>
    private Scrollbar hScrollbar = null;<br/>
    private boolean isScrolling = false;<br/>
    private Point scroll = new Point();<br/>
    private boolean initCtlScroll;<br/>
    private boolean ctlKeyHeld = false;<br/>
    private int previousMouseX;<br/>
    private int previousMouseY;<br/>
<br/>
    // back buffer to draw to<br/>
    private Image backImage;<br/>
    private Dimension backSize;<br/>
    private Graphics backGraph;<br/>
<br/>
    // buffer for all the hexes you can possibly see<br/>
    private Image boardImage;<br/>
    private Rectangle boardRect;<br/>
    private Graphics boardGraph;<br/>
<br/>
    // entity sprites<br/>
    private Vector entitySprites = new Vector();<br/>
    private Hashtable entitySpriteIds = new Hashtable();<br/>
<br/>
    // sprites for the three selection cursors<br/>
    private CursorSprite cursorSprite;<br/>
    private CursorSprite highlightSprite;<br/>
    private CursorSprite selectedSprite;<br/>
    private CursorSprite firstLOSSprite;<br/>
    private CursorSprite secondLOSSprite;<br/>
<br/>
    // sprite for current movement<br/>
    private Vector pathSprites = new Vector();<br/>
<br/>
    // vector of sprites for all firing lines<br/>
    private Vector attackSprites = new Vector();<br/>
<br/>
    // vector of sprites for C3 network lines<br/>
    private Vector C3Sprites = new Vector();<br/>
<br/>
    // tooltip stuff<br/>
    private Window tipWindow;<br/>
    private boolean isTipPossible = false;<br/>
    private long lastIdle;<br/>
<br/>
    private TilesetManager tileManager = null;<br/>
<br/>
    // polygons for a few things<br/>
    private Polygon              hexPoly;<br/>
    private Polygon[]            facingPolys;<br/>
    private Polygon[]            movementPolys;<br/>
<br/>
    // the player who owns this BoardView's client<br/>
    private Player               localPlayer = null;<br/>
<br/>
    // should we mark deployment hexes for a player?<br/>
    private Player               m_plDeployer = null;<br/>
<br/>
    // should be able to turn it off(board editor)<br/>
    private boolean              useLOSTool = true;<br/>
<br/>
    // Initial scale factor for sprites and map<br/>
    private boolean                 hasZoomed = false;<br/>
    public      int                     zoomIndex;<br/>
    private float               scale;<br/>
    private Hashtable scaledImageCache = new Hashtable();<br/>
        <br/>
    // Displayables (Chat box, etc.)<br/>
    private Vector               displayables = new Vector();<br/>
<br/>
    // Move units step by step<br/>
    private Vector                           movingUnits = new Vector();<br/>
    private long                             moveWait = 0;<br/>
<br/>
    // moving entity sprites<br/>
    private Vector movingEntitySprites = new Vector();<br/>
    private Hashtable movingEntitySpriteIds = new Hashtable();<br/>
    private Vector ghostEntitySprites = new Vector();<br/>
    protected transient Vector boardListeners = new Vector();<br/>
<br/>
    // wreck sprites<br/>
    private Vector wreckSprites = new Vector();<br/>
<br/>
    private Coords rulerStart; // added by kenn<br/>
    private Coords rulerEnd; // added by kenn<br/>
    private Color rulerStartColor; // added by kenn<br/>
    private Color rulerEndColor; // added by kenn<br/>
<br/>
    // Position of the mouse before right mouse button was pressed. Used to have an anchor for scrolling <br/>
    private Point oldMousePosition = null;<br/>
    <br/>
    // Indicate that a scrolling took place, so no popup should be drawn on right mouse button release<br/>
    private boolean scrolled = false;<br/>
    <br/>
    private Coords lastCursor;<br/>
    private Coords highlighted;<br/>
    private Coords selected;<br/>
    private Coords firstLOS;<br/>
<br/>
    private ClientGUI clientgui;<br/>
    <br/>
    private RedrawWorker redrawWorker = new RedrawWorker();<br/>
<br/>
    /**<br/>
     * Construct a new board view for the specified game<br/>
     */<br/>
    public BoardView1(IGame game, Frame frame) throws java.io.IOException {<br/>
        this(game, frame, null);<br/>
    }<br/>
<br/>
    /**<br/>
     * Construct a new board view for the specified game<br/>
     */<br/>
    public BoardView1(IGame game, Frame frame, ClientGUI clientgui) throws java.io.IOException {<br/>
        this.clientgui = clientgui;<br/>
        this.game = game;<br/>
        this.frame = frame;<br/>
<br/>
        tileManager = new TilesetManager(this);<br/>
<br/>
        game.addGameListener(gameListener);<br/>
        game.getBoard().addBoardListener(this);<br/>
        redrawWorker.start();<br/>
        addKeyListener(this);<br/>
        addMouseListener(this);<br/>
        addMouseMotionListener(this);<br/>
        /* MouseWheelListener isn't a v1.3.1 API **<br/>
        try{<br/>
            addMouseWheelListener( new MouseWheelListener(){<br/>
                public void mouseWheelMoved(MouseWheelEvent we){<br/>
                    if (we.getWheelRotation() &gt; 0){<br/>
                            zoomIn();<br/>
                    } else {<br/>
                            zoomOut();<br/>
                    }<br/>
                }<br/>
            });<br/>
        } catch ( Throwable error ){<br/>
            System.out.println("Mouse wheel not supported by this jvm");<br/>
        }<br/>
        /* MouseWheelListener isn't a v1.3.1 API */<br/>
        <br/>
        // only use scaling if we're using Java 2, otherwise we get memory leaks etc.<br/>
        Properties p = System.getProperties();<br/>
        String javaVersion = p.getProperty( "java.version" ); //$NON-NLS-1$<br/>
        if ( javaVersion.charAt(2) == '1' ){<br/>
            isJ2RE = false;<br/>
            zoomIndex = BASE_ZOOM_INDEX;<br/>
        } else {<br/>
            isJ2RE = true;<br/>
            zoomIndex = GUIPreferences.getInstance().getMapZoomIndex();<br/>
            checkZoomIndex();<br/>
            hasZoomed = true;<br/>
        }<br/>
        scale = ZOOM_FACTORS[ zoomIndex ];<br/>
        <br/>
        updateFontSizes();<br/>
        updateBoardSize();<br/>
<br/>
        // tooltip<br/>
        tipWindow = new Window(frame);<br/>
        <br/>
        hex_size = new Dimension((int)(HEX_W*scale), (int)(HEX_H*scale));<br/>
        <br/>
        initPolys();<br/>
<br/>
        cursorSprite = new CursorSprite(Color.cyan);<br/>
        highlightSprite = new CursorSprite(Color.white);<br/>
        selectedSprite = new CursorSprite(Color.blue);<br/>
        firstLOSSprite = new CursorSprite(Color.red);<br/>
        secondLOSSprite = new CursorSprite(Color.red);<br/>
        <br/>
        scaledImageCaches = new ImageCache[ZOOM_FACTORS.length];<br/>
        for(int i = 0;i&lt;scaledImageCaches.length;i++) {<br/>
            scaledImageCaches[i] = new ImageCache();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds the specified board listener to receive<br/>
     * board events from this board.<br/>
     *<br/>
     * @param listener the board listener.<br/>
     */<br/>
    public void addBoardViewListener(BoardViewListener listener) {<br/>
        if (!boardListeners.contains(listener)) {<br/>
            boardListeners.addElement(listener);<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Removes the specified board listener.<br/>
     *<br/>
     * @param listener the board listener.<br/>
     */<br/>
    public void removeBoardViewListener(BoardViewListener listener) {<br/>
        boardListeners.removeElement(listener);<br/>
    }<br/>
<br/>
    /**<br/>
     * Notifies attached board listeners of the event.<br/>
     *<br/>
     * @param event the board event.<br/>
     */<br/>
    public void processBoardViewEvent(BoardViewEvent event) {<br/>
        if (boardListeners == null) {<br/>
            return;<br/>
        }<br/>
        for(Enumeration e = boardListeners.elements(); e.hasMoreElements();) {<br/>
            BoardViewListener l = (BoardViewListener)e.nextElement();<br/>
            switch(event.getType()) {<br/>
            case BoardViewEvent.BOARD_HEX_CLICKED :<br/>
            case BoardViewEvent.BOARD_HEX_DOUBLECLICKED :<br/>
            case BoardViewEvent.BOARD_HEX_DRAGGED :<br/>
                l.hexMoused(event);<br/>
                break;<br/>
            case BoardViewEvent.BOARD_HEX_CURSOR :<br/>
                l.hexCursor(event);<br/>
                break;<br/>
            case BoardViewEvent.BOARD_HEX_HIGHLIGHTED :<br/>
                l.boardHexHighlighted(event);<br/>
                break;<br/>
            case BoardViewEvent.BOARD_HEX_SELECTED :<br/>
                l.hexSelected(event);<br/>
                break;<br/>
            case BoardViewEvent.BOARD_FIRST_LOS_HEX :<br/>
                l.firstLOSHex(event);<br/>
                break;<br/>
            case BoardViewEvent.BOARD_SECOND_LOS_HEX :<br/>
                l.secondLOSHex(event, getFirstLOS());<br/>
                break;<br/>
            case BoardViewEvent.FINISHED_MOVING_UNITS :<br/>
                l.finishedMovingUnits(event);<br/>
                break;<br/>
            case BoardViewEvent.SELECT_UNIT :<br/>
                l.unitSelected(event);<br/>
                break;<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    public void addMovingUnit(Entity entity, java.util.Vector movePath) {<br/>
        if ( !movePath.isEmpty() ) {<br/>
            Object[] o = new Object[2];<br/>
            o[0] = entity;<br/>
            o[1] = movePath;<br/>
            movingUnits.addElement(o);<br/>
<br/>
            GhostEntitySprite ghostSprite = new GhostEntitySprite(entity);<br/>
            ghostEntitySprites.addElement(ghostSprite);<br/>
<br/>
            // Center on the starting hex of the moving unit.<br/>
            UnitLocation loc = ( (UnitLocation) movePath.elementAt(0) );<br/>
            centerOnHex( loc.getCoords() );<br/>
        }<br/>
    }<br/>
<br/>
    public void addDisplayable(Displayable disp) {<br/>
        displayables.addElement(disp);<br/>
    }<br/>
<br/>
    public void removeDisplayable(Displayable disp) {<br/>
        displayables.removeElement(disp);<br/>
    }<br/>
<br/>
    /**<br/>
     * Specify the scrollbars that control this view's positioning.<br/>
     *<br/>
     * @param   vertical - the vertical &lt;code&gt;Scrollbar&lt;/code&gt;<br/>
     * @param   horizontal - the horizontal &lt;code&gt;Scrollbar&lt;/code&gt;<br/>
     */<br/>
    public void setScrollbars (Scrollbar vertical, Scrollbar horizontal) {<br/>
        this.vScrollbar = vertical;<br/>
        this.hScrollbar = horizontal;<br/>
<br/>
        // When the scroll bars are adjusted, update our offset.<br/>
        this.vScrollbar.addAdjustmentListener (this);<br/>
        this.hScrollbar.addAdjustmentListener (this);<br/>
    }<br/>
<br/>
    /**<br/>
     * Update ourself when a scroll bar is adjusted.<br/>
     *<br/>
     * @param   event - the &lt;code&gt;AdjustmentEvent&lt;/code&gt; that caused this call.<br/>
     */<br/>
    public void adjustmentValueChanged (AdjustmentEvent event) {<br/>
        Point oldPt = this.scroll;<br/>
        Point newPt = new Point (oldPt.x, oldPt.y);<br/>
        if (event.getAdjustable().getOrientation() == Adjustable.VERTICAL) {<br/>
            newPt.y = event.getValue();<br/>
        } else {<br/>
            newPt.x = event.getValue();<br/>
        }<br/>
        this.scroll.setLocation (newPt);<br/>
        this.repaint();<br/>
    }<br/>
<br/>
    public void paint(Graphics g) {<br/>
        update(g);<br/>
    }<br/>
<br/>
    /**<br/>
     * Draw the screen!<br/>
     */<br/>
    public void update(Graphics g) {<br/>
        // Limit our size to the viewport of the scroll pane.<br/>
        final Dimension size = getSize();<br/>
        //         final long startTime = System.currentTimeMillis(); // commentme<br/>
<br/>
        // Make sure our scrollbars have the right sizes.<br/>
        // N.B. A buggy Sun implementation makes me to do this here instead <br/>
        // of updateBoardSize() (which is where *I* think it belongs).<br/>
        if (null != this.vScrollbar) {<br/>
            this.vScrollbar.setVisibleAmount (size.height);<br/>
            this.vScrollbar.setBlockIncrement (size.height);<br/>
            this.vScrollbar.setUnitIncrement ((int) (scale * HEX_H / 2.0));<br/>
            this.vScrollbar.setMaximum (boardSize.height);<br/>
        }<br/>
        if (null != this.hScrollbar) {<br/>
            this.hScrollbar.setVisibleAmount (size.width);<br/>
            this.hScrollbar.setBlockIncrement (size.width);<br/>
            this.hScrollbar.setUnitIncrement ((int) (scale * HEX_W / 2.0));<br/>
            this.hScrollbar.setMaximum (boardSize.width);<br/>
        }<br/>
<br/>
        // update view, offset<br/>
        view.setLocation(scroll);<br/>
        view.setSize(getOptimalView(size));<br/>
        offset.setLocation(getOptimalOffset(size));<br/>
<br/>
        if (!this.isTileImagesLoaded()) {<br/>
            g.drawString(Messages.getString("BoardView1.loadingImages"), 20, 50); //$NON-NLS-1$<br/>
            if (!tileManager.isStarted()) {<br/>
                System.out.println("boardview1: loading images for board"); //$NON-NLS-1$<br/>
                tileManager.loadNeededImages(game);<br/>
            }<br/>
            return;<br/>
        }<br/>
<br/>
        // make sure back buffer is valid<br/>
        if (backGraph == null || !view.getSize().equals(backSize)) {<br/>
            // make new back buffer<br/>
            backSize = view.getSize();<br/>
            backImage = createImage(backSize.width, backSize.height);<br/>
            backGraph = backImage.getGraphics();<br/>
        }<br/>
        <br/>
        // make sure board rectangle contains our current view rectangle<br/>
        if (boardImage == null || !boardRect.union(view).equals(boardRect)) {<br/>
            updateBoardImage();<br/>
        }<br/>
<br/>
        // draw onto the back buffer:<br/>
<br/>
        // draw the board<br/>
        backGraph.drawImage(boardImage, 0, 0, this);<br/>
<br/>
        // draw wrecks<br/>
        if (GUIPreferences.getInstance().getShowWrecks()) {<br/>
            drawSprites(wreckSprites);<br/>
        }<br/>
<br/>
        // Minefield signs all over the place!<br/>
        drawMinefields();<br/>
        <br/>
        // Artillery targets<br/>
        drawArtilleryHexes();<br/>
<br/>
        // draw highlight border<br/>
        drawSprite(highlightSprite);<br/>
<br/>
        // draw cursors<br/>
        drawSprite(cursorSprite);<br/>
        drawSprite(selectedSprite);<br/>
        drawSprite(firstLOSSprite);<br/>
        drawSprite(secondLOSSprite);<br/>
<br/>
        // draw deployment indicators<br/>
        if (m_plDeployer != null) {<br/>
            drawDeployment();<br/>
        }<br/>
<br/>
        // draw C3 links<br/>
        drawSprites(C3Sprites);<br/>
<br/>
        // draw onscreen entities<br/>
        drawSprites(entitySprites);<br/>
<br/>
        // draw moving onscreen entities<br/>
        drawSprites(movingEntitySprites);<br/>
<br/>
        // draw ghost onscreen entities<br/>
        drawSprites(ghostEntitySprites);<br/>
<br/>
        // draw onscreen attacks<br/>
        drawSprites(attackSprites);<br/>
<br/>
        // draw movement, if valid<br/>
        drawSprites(pathSprites);<br/>
<br/>
        // added by kenn<br/>
        // draw the ruler line<br/>
        if (rulerStart != null) {<br/>
            Point start =  getCentreHexLocation(rulerStart);<br/>
            if (rulerEnd != null) {<br/>
                Point end = getCentreHexLocation(rulerEnd);<br/>
                backGraph.setColor(Color.yellow);<br/>
                backGraph.drawLine(start.x - boardRect.x, start.y - boardRect.y, end.x - boardRect.x, end.y - boardRect.y);<br/>
<br/>
                backGraph.setColor(rulerEndColor);<br/>
                backGraph.fillRect(end.x - boardRect.x - 1, end.y - boardRect.y - 1, 2, 2);<br/>
            }<br/>
<br/>
            backGraph.setColor(rulerStartColor);<br/>
            backGraph.fillRect(start.x - boardRect.x - 1, start.y - boardRect.y - 1, 2, 2);<br/>
        }<br/>
        // end kenn<br/>
<br/>
        // draw all the "displayables"<br/>
        for (int i = 0; i &lt; displayables.size(); i++) {<br/>
            Displayable disp = (Displayable) displayables.elementAt(i);<br/>
            disp.draw(backGraph, backSize);<br/>
        }<br/>
<br/>
        // draw the back buffer onto the screen<br/>
        // first clear the entire view if the map has been zoomed<br/>
        if ( hasZoomed == true ){<br/>
            Image tmpImage = createImage( size.width, size.height );<br/>
            Graphics tmpGraphics = tmpImage.getGraphics();<br/>
            tmpGraphics.drawImage(backImage, offset.x, offset.y, this);<br/>
            g.drawImage(tmpImage, 0, 0, this);<br/>
            hasZoomed=false;<br/>
        } else {<br/>
            g.drawImage(backImage, offset.x, offset.y, this);<br/>
        }<br/>
        //g.drawString(""+scale, 10, 10);<br/>
<br/>
        //         final long finishTime = System.currentTimeMillis();//commentme<br/>
        //         System.out.println("BoardView1: updated screen in " + (finishTime - startTime) + " ms."); //commentme<br/>
    }<br/>
<br/>
    /**<br/>
     * Updates the boardSize variable with the proper values for this board.<br/>
     */<br/>
    private void updateBoardSize() {<br/>
        int width = game.getBoard().getWidth() * (int)(HEX_WC*scale) + (int)(HEX_W/4*scale);<br/>
        int height = game.getBoard().getHeight() * (int)(HEX_H*scale) + (int)(HEX_H/2*scale);<br/>
        boardSize = new Dimension(width, height);<br/>
    }<br/>
<br/>
    /**<br/>
     * Think up the size of the view rectangle based on the size of the component<br/>
     * and the size of board<br/>
     */<br/>
    private Dimension getOptimalView(Dimension size) {<br/>
        return new Dimension(<br/>
                Math.min(size.width, boardSize.width),<br/>
                Math.min(size.height, boardSize.height));<br/>
    }<br/>
<br/>
    /**<br/>
     * Where should the offset be for this screen size?<br/>
     */<br/>
    private Point getOptimalOffset(Dimension size) {<br/>
        int ox = 0;<br/>
        int oy = 0;<br/>
        if (size.width &gt; boardSize.width) {<br/>
            ox = (size.width - boardSize.width) / 2;<br/>
        }<br/>
        if (size.height &gt; boardSize.height) {<br/>
            oy = (size.height - boardSize.height) / 2;<br/>
        }<br/>
        return new Point(ox, oy);<br/>
    }<br/>
<br/>
    /**<br/>
     * Repaint the bounds of a sprite, offset by view<br/>
     */<br/>
    private void repaintBounds(Rectangle bounds) {<br/>
        if (view != null) {<br/>
            repaint(bounds.x - view.x + offset.x, bounds.y - view.y + offset.y, bounds.width, bounds.height);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Looks through a vector of buffered images and draws them if they're<br/>
     * onscreen.<br/>
     */<br/>
    private synchronized void drawSprites(Vector spriteVector) {<br/>
        for (int i = 0; i &lt; spriteVector.size(); i++) {<br/>
            final Sprite sprite = (Sprite)spriteVector.get(i);<br/>
            drawSprite(sprite);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Draws a sprite, if it is in the current view<br/>
     */<br/>
    private final void drawSprite(Sprite sprite) {<br/>
        if (view.intersects(sprite.getBounds())) {<br/>
            final int drawX = sprite.getBounds().x - view.x;<br/>
            final int drawY = sprite.getBounds().y - view.y;<br/>
            if (!sprite.isReady()) {<br/>
                sprite.prepare();<br/>
            }<br/>
            sprite.drawOnto(backGraph, drawX, drawY, this);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Manages a cache of scaled images.<br/>
     */<br/>
    private Image getScaledImage(Image base) {<br/>
        if (base == null) {<br/>
            return null;<br/>
        }<br/>
        if ( zoomIndex == BASE_ZOOM_INDEX ) {<br/>
            return base;<br/>
        }<br/>
        <br/>
        <br/>
        Image scaled = (Image) scaledImageCaches[zoomIndex].get(base);<br/>
        if (scaled == null) {<br/>
            Dimension d = getImageBounds(base).getSize();<br/>
            d.width *= scale;<br/>
            d.height *= scale;<br/>
            <br/>
            scaled = scale(base, d.width, d.height);<br/>
<br/>
            MediaTracker tracker = new MediaTracker(this);<br/>
            tracker.addImage( scaled, 1 );<br/>
            // Wait for image to load<br/>
            try{<br/>
                tracker.waitForID( 1 );<br/>
            } catch ( InterruptedException e ){ e.printStackTrace(); }<br/>
              <br/>
            scaledImageCaches[zoomIndex].put(base, scaled);<br/>
        }<br/>
        return scaled;<br/>
    }<br/>
   <br/>
    /**<br/>
     * The actual scaling code.<br/>
     */<br/>
    private Image scale(Image img, int width, int height) {<br/>
        ImageFilter filter;<br/>
<br/>
        filter = new ImprovedAveragingScaleFilter(img.getWidth(null),<br/>
                                                  img.getHeight(null),<br/>
                                                  width, height);<br/>
        <br/>
        ImageProducer prod;<br/>
        prod = new FilteredImageSource(img.getSource(), filter);<br/>
        return Toolkit.getDefaultToolkit().createImage(prod);<br/>
    }<br/>
    <br/>
    private static Rectangle getImageBounds(Image im) {<br/>
        return new Rectangle(-im.getWidth(null) / 2, -im.getHeight(null) / 2, im.getWidth(null), im.getHeight(null));<br/>
    }<br/>
<br/>
    /**<br/>
     * The key assigned to each scaled and cached image. Enables easy<br/>
     * retrieval from the hash table.<br/>
     */<br/>
    private static class ScaledCacheKey {<br/>
        private Image base;<br/>
        private Dimension bounds;<br/>
<br/>
        public ScaledCacheKey(Image base, Dimension bounds) {<br/>
          this.bounds = bounds;<br/>
          this.base = base;<br/>
        }<br/>
<br/>
        public boolean equals(Object o) {<br/>
          if (this == o) return true;<br/>
          if (!(o instanceof ScaledCacheKey)) return false;<br/>
<br/>
          final ScaledCacheKey scaledCacheKey = (ScaledCacheKey) o;<br/>
<br/>
          if (!base.equals(scaledCacheKey.base)) return false;<br/>
          if (!bounds.equals(scaledCacheKey.bounds)) return false;<br/>
<br/>
          return true;<br/>
        }<br/>
<br/>
        public int hashCode() {<br/>
          int result;<br/>
          result = base.hashCode();<br/>
          result = 29 * result + bounds.hashCode();<br/>
          return result;<br/>
        }<br/>
      }<br/>
    <br/>
    /**<br/>
     * Draw an outline around legal deployment hexes<br/>
     */<br/>
    private void drawDeployment() {<br/>
        // only update visible hexes<br/>
        int drawX = view.x / (int)(HEX_WC*scale) - 1;<br/>
        int drawY = view.y / (int)(HEX_H*scale) - 1;<br/>
<br/>
        int drawWidth = view.width / (int)(HEX_WC*scale) + 3;<br/>
        int drawHeight = view.height / (int)(HEX_H*scale) + 3;<br/>
        IBoard board = game.getBoard();<br/>
        // loop through the hexes<br/>
        for (int i = 0; i &lt; drawHeight; i++) {<br/>
            for (int j = 0; j &lt; drawWidth; j++) {<br/>
                Coords c = new Coords(j + drawX, i + drawY);<br/>
                Point p = getHexLocation(c);<br/>
                p.translate(-(view.x), -(view.y));<br/>
                if (board.isLegalDeployment(c, m_plDeployer)) {<br/>
                    backGraph.setColor(Color.yellow);<br/>
                    int[] xcoords = { p.x + (int)(21*scale), p.x + (int)(62*scale), p.x + (int)(83*scale), p.x + (int)(83*scale),<br/>
                            p.x + (int)(62*scale), p.x + (int)(21*scale), p.x, p.x };<br/>
                    int[] ycoords = { p.y, p.y, p.y + (int)(35*scale), p.y + (int)(36*scale), p.y + (int)(71*scale),<br/>
                            p.y + (int)(71*scale), p.y + (int)(36*scale), p.y + (int)(35*scale) };<br/>
                    backGraph.drawPolygon(xcoords, ycoords, 8);<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * returns the weapon selected in the mech display,<br/>
     * or null if none selected or it is not artillery<br/>
     **/<br/>
    private Mounted getSelectedArtilleryWeapon() {<br/>
        Entity e = clientgui.mechD.getCurrentEntity();<br/>
        Mounted weapon = null;<br/>
        <br/>
        if(e != null) {<br/>
            weapon = e.getEquipment(clientgui.mechD.wPan.getSelectedWeaponNum());<br/>
        }<br/>
        if (weapon != null) {<br/>
            if(!(weapon.getType() instanceof WeaponType &amp;&amp; weapon.getType().hasFlag(WeaponType.F_ARTILLERY))) {<br/>
                weapon = null;<br/>
            }<br/>
            //otherwise, a weapon is selected, and it is artillery<br/>
        }<br/>
        return weapon;<br/>
    }<br/>
    <br/>
    /** Display artillery modifier in pretargeted hexes<br/>
     */<br/>
    private void drawArtilleryHexes() {<br/>
        if (clientgui != null) {<br/>
            Entity e = clientgui.mechD.getCurrentEntity();<br/>
            Mounted weapon = getSelectedArtilleryWeapon();<br/>
            <br/>
            if(game.getArtillerySize()==0 &amp;&amp; weapon==null) {<br/>
                return; //nothing to do<br/>
            }<br/>
            <br/>
            if (!e.getOwner().equals(clientgui.getClient().getLocalPlayer())) {<br/>
                return; // Not my business to see this<br/>
            }<br/>
            <br/>
            int drawX = view.x / (int)(HEX_WC*scale) - 1;<br/>
            int drawY = view.y / (int)(HEX_H*scale) - 1;<br/>
    <br/>
            int drawWidth = view.width / (int)(HEX_WC*scale) + 3;<br/>
            int drawHeight = view.height / (int)(HEX_H*scale) + 3;<br/>
    <br/>
            IBoard board = game.getBoard();<br/>
            Image scaledImage;<br/>
    <br/>
            // loop through the hexes<br/>
            for (int i = 0; i &lt; drawHeight; i++) {<br/>
                for (int j = 0; j &lt; drawWidth; j++) {<br/>
                    Coords c = new Coords(j + drawX, i + drawY);<br/>
                    Point p = getHexLocation(c);<br/>
                    p.translate(-(view.x), -(view.y));<br/>
    <br/>
                    if (!board.contains(c)){ continue; }<br/>
    <br/>
                    if(weapon != null) {<br/>
                        //process targetted hexes<br/>
                        int amod = 0;<br/>
                        //Check the predesignated hexes<br/>
                        if(e.getOwner().getArtyAutoHitHexes().contains(c)) {<br/>
                            amod = TargetRoll.AUTOMATIC_SUCCESS;<br/>
                        }<br/>
                        else {<br/>
                            amod = e.aTracker.getModifier(weapon, c);<br/>
                        }<br/>
    <br/>
                        if(amod!=0) {<br/>
    <br/>
                            //draw the crosshairs<br/>
                            if(amod==TargetRoll.AUTOMATIC_SUCCESS) {<br/>
                                //predesignated or already hit<br/>
                                scaledImage = getScaledImage(tileManager.getArtilleryTarget(TilesetManager.ARTILLERY_AUTOHIT));<br/>
                            } else {<br/>
                                scaledImage = getScaledImage(tileManager.getArtilleryTarget(TilesetManager.ARTILLERY_ADJUSTED));<br/>
                            }<br/>
    <br/>
                            backGraph.drawImage(scaledImage, p.x, p.y, this);<br/>
                        }<br/>
                    }<br/>
                    //process incoming attacks - requires server to update client's view of game<br/>
                    <br/>
                    for(Enumeration attacks=game.getArtilleryAttacks();attacks.hasMoreElements();) {<br/>
                        ArtilleryAttackAction a = (ArtilleryAttackAction)attacks.nextElement();<br/>
    <br/>
                        if(a.getWR().waa.getTarget(game).getPosition().equals(c)) {<br/>
                            scaledImage = getScaledImage(tileManager.getArtilleryTarget(TilesetManager.ARTILLERY_INCOMING));<br/>
                            backGraph.drawImage(scaledImage, p.x, p.y, this);<br/>
                            break; //do not draw multiple times, tooltop will show all attacks<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    private Vector getArtilleryAttacksAtLocation(Coords c) {<br/>
        Vector v = new Vector();<br/>
        for(Enumeration attacks=game.getArtilleryAttacks();attacks.hasMoreElements();) {<br/>
            ArtilleryAttackAction a = (ArtilleryAttackAction)attacks.nextElement();<br/>
<br/>
            if(a.getWR().waa.getTarget(game).getPosition().equals(c)) {<br/>
                v.addElement(a);<br/>
            }<br/>
        }<br/>
        return v;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Writes "MINEFIELD" in minefield hexes...<br/>
     */<br/>
    private void drawMinefields() {<br/>
        // only update visible hexes<br/>
        int drawX = view.x / (int)(HEX_WC*scale) - 1;<br/>
        int drawY = view.y / (int)(HEX_H*scale) - 1;<br/>
<br/>
        int drawWidth = view.width / (int)(HEX_WC*scale) + 3;<br/>
        int drawHeight = view.height / (int)(HEX_H*scale) + 3;<br/>
<br/>
        IBoard board = game.getBoard();<br/>
        // loop through the hexes<br/>
        for (int i = 0; i &lt; drawHeight; i++) {<br/>
            for (int j = 0; j &lt; drawWidth; j++) {<br/>
                Coords c = new Coords(j + drawX, i + drawY);<br/>
                Point p = getHexLocation(c);<br/>
                p.translate(-(view.x), -(view.y));<br/>
                <br/>
                if (!board.contains(c)){ continue; }<br/>
                if (!game.containsMinefield(c)){ continue; }<br/>
                <br/>
                Minefield mf = (Minefield) game.getMinefields(c).elementAt(0);<br/>
                <br/>
                Image tmpImage = getScaledImage( tileManager.getMinefieldSign());<br/>
                backGraph.drawImage(<br/>
                        tmpImage,<br/>
                        p.x + (int)(13*scale), <br/>
                        p.y + (int)(13*scale), <br/>
                        this);<br/>
                <br/>
                backGraph.setColor(Color.black);<br/>
                int nbrMfs = game.getNbrMinefields(c);<br/>
                if (nbrMfs &gt; 1) {<br/>
                    drawCenteredString(Messages.getString("BoardView1.Multiple"),  //$NON-NLS-1$<br/>
                                p.x,<br/>
                                p.y + (int)(51*scale),<br/>
                                font_minefield,<br/>
                                backGraph);<br/>
                } else if (nbrMfs == 1) {<br/>
                    switch (mf.getType()) {<br/>
                        case (Minefield.TYPE_CONVENTIONAL) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Conventional"), //$NON-NLS-1$<br/>
                                    p.x,<br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                            break;<br/>
                        case (Minefield.TYPE_THUNDER) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Thunder") + mf.getDamage() + ")",  //$NON-NLS-1$ //$NON-NLS-2$<br/>
                                    p.x, <br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                        break;<br/>
                        case (Minefield.TYPE_THUNDER_INFERNO) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Thunder-Inf") + mf.getDamage() + ")",  //$NON-NLS-1$ //$NON-NLS-2$<br/>
                                    p.x,<br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                        break;<br/>
                        case (Minefield.TYPE_THUNDER_ACTIVE) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Thunder-Actv") + mf.getDamage() + ")",  //$NON-NLS-1$ //$NON-NLS-2$<br/>
                                    p.x,<br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                        break;<br/>
                        case (Minefield.TYPE_COMMAND_DETONATED) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Command-"),  //$NON-NLS-1$<br/>
                                    p.x,<br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.detonated"),  //$NON-NLS-1$<br/>
                                    p.x,<br/>
                                    p.y + (int)(60*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                        break;<br/>
                        case (Minefield.TYPE_VIBRABOMB) :<br/>
                            drawCenteredString(<br/>
                                    Messages.getString("BoardView1.Vibrabomb"),  //$NON-NLS-1$<br/>
                                    p.x,<br/>
                                    p.y + (int)(51*scale),<br/>
                                    font_minefield,<br/>
                                    backGraph);<br/>
                  if (mf.getPlayerId() == localPlayer.getId()) {<br/>
                      drawCenteredString(<br/>
                                    "(" + mf.getSetting() + ")",  //$NON-NLS-1$ //$NON-NLS-2$<br/>
                                        p.x,<br/>
                                        p.y + (int)(60*scale),<br/>
                                        font_minefield,<br/>
                                        backGraph);<br/>
                  }<br/>
                        break;<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    private void drawCenteredString( String string, int x, int y, Font font, Graphics graph ){<br/>
        FontMetrics currentMetrics = getFontMetrics(font);<br/>
        int stringWidth = currentMetrics.stringWidth(string);<br/>
        <br/>
        x += (int)((hex_size.width - stringWidth)/2);<br/>
        <br/>
        graph.setFont(font);<br/>
        graph.drawString( string, x, y );<br/>
    }<br/>
    <br/>
    /**<br/>
     * Updates the board buffer to contain all the hexes needed by the view.<br/>
     */<br/>
    private void updateBoardImage() {<br/>
        // check to make sure image is big enough<br/>
        if (boardGraph == null || view.width &gt; boardRect.width<br/>
            || view.height &gt; boardRect.height) {<br/>
            /* Ok, some history here.  Before the zoom patch, the<br/>
               boardImage was created with the same size as the view.<br/>
               After the zoom patch, the boardImage was created with<br/>
               the same size as the entire board (all maps).  This<br/>
               change ate up a hideous amount of memory (eg: in a 3x3<br/>
               map set test with one mech, memory usage went from<br/>
               about 15MB to 60MB).  I have now changed it back to the<br/>
               old way, and the zoom feature *seems* to still work.<br/>
               Why the zoom author made the change, I cannot say. */<br/>
            boardImage = createImage(view.width, view.height);<br/>
            //boardImage = createImage(boardSize.width, boardSize.height);<br/>
            /* ----- */<br/>
<br/>
            boardGraph = boardImage.getGraphics();<br/>
<br/>
            // Handle resizes correctly.<br/>
            checkScrollBounds();<br/>
            boardRect = new Rectangle(view);<br/>
            System.out.println("boardview1: made a new board buffer " + boardRect); //$NON-NLS-1$<br/>
            drawHexes(view);<br/>
            <br/>
        }<br/>
        if (!boardRect.union(view).equals(boardRect)) {<br/>
            moveBoardImage();<br/>
        }<br/>
    }<br/>
<br/>
    /** <br/>
     * This method creates an image the size of the entire board (all<br/>
     * mapsheets), draws the hexes onto it, and returns that image.<br/>
     */<br/>
    public Image getEntireBoardImage() {<br/>
        Image entireBoard = createImage(boardSize.width, boardSize.height);<br/>
        Graphics temp = boardImage.getGraphics();<br/>
        boardGraph = entireBoard.getGraphics();<br/>
        drawHexes(new Rectangle(boardSize));<br/>
        boardGraph = temp;<br/>
        return entireBoard;<br/>
    }<br/>
<br/>
    /**<br/>
     * Moves the board view to another area.<br/>
     */<br/>
    private void moveBoardImage() {<br/>
        // salvage the old<br/>
<br/>
        boardGraph.setClip(0, 0, boardRect.width, boardRect.height);<br/>
        boardGraph.copyArea(0, 0, boardRect.width, boardRect.height,<br/>
                            boardRect.x - view.x, boardRect.y - view.y);<br/>
<br/>
        // what's left to paint?<br/>
        int midX = Math.max(view.x, boardRect.x);<br/>
        int midWidth = view.width - Math.abs(view.x - boardRect.x);<br/>
        Rectangle unLeft = new Rectangle(view.x, view.y, boardRect.x - view.x, view.height);<br/>
        Rectangle unRight = new Rectangle(boardRect.x + boardRect.width, view.y, view.x -boardRect.x, view.height);<br/>
        Rectangle unTop = new Rectangle(midX, view.y, midWidth, boardRect.y - view.y);<br/>
        Rectangle unBottom = new Rectangle(midX, boardRect.y + boardRect.height, midWidth, view.y - boardRect.y);<br/>
<br/>
        // update boardRect<br/>
        boardRect = new Rectangle(view);<br/>
<br/>
        // paint needed areas<br/>
        if (unLeft.width &gt; 0) {<br/>
            drawHexes(unLeft);<br/>
        } else if (unRight.width &gt; 0) {<br/>
            drawHexes(unRight);<br/>
        }<br/>
        if (unTop.height &gt; 0) {<br/>
            drawHexes(unTop);<br/>
        } else if (unBottom.height &gt; 0) {<br/>
            drawHexes(unBottom);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Redraws all hexes in the specified rectangle<br/>
     */<br/>
    private void drawHexes(Rectangle rect) {<br/>
        <br/>
        // rect is the view<br/>
        int drawX = (int)(rect.x / (HEX_WC*scale))-1;<br/>
        int drawY = (int)(rect.y / (HEX_H*scale))-1;<br/>
<br/>
        int drawWidth = (int)(rect.width / (HEX_WC*scale))+3;<br/>
        int drawHeight = (int)(rect.height / (HEX_H*scale))+3;<br/>
<br/>
        // only draw what we came to draw<br/>
        boardGraph.setClip(rect.x - boardRect.x, rect.y - boardRect.y,<br/>
                           rect.width, rect.height);<br/>
<br/>
        // clear, if we need to<br/>
        if (rect.x &lt; (21*scale)) {<br/>
            boardGraph.clearRect(<br/>
                    rect.x - boardRect.x, rect.y - boardRect.y,<br/>
                    (int)(21*scale) - rect.x, rect.height);<br/>
        }<br/>
        if (rect.y &lt; (36*scale)) {<br/>
            boardGraph.clearRect(<br/>
                    rect.x - boardRect.x, rect.y - boardRect.y,<br/>
                    rect.width, (int)(36*scale) - rect.y);<br/>
        }<br/>
        if (rect.x &gt; boardSize.width - view.width - (21*scale)) {<br/>
            boardGraph.clearRect(<br/>
                    boardRect.width - (int)(21*scale), rect.y - boardRect.y,<br/>
                    (int)(21*scale), rect.height);<br/>
        }<br/>
        if (rect.y &gt; boardSize.height - view.height - (int)(36*scale)) {<br/>
            boardGraph.clearRect(<br/>
                    rect.x - boardRect.x, boardRect.height - (int)(36*scale),<br/>
                    rect.width, (int)(36*scale));<br/>
        }<br/>
<br/>
        // draw some hexes<br/>
        for (int i = 0; i &lt; drawHeight; i++) {<br/>
            for (int j = 0; j &lt; drawWidth; j++) {<br/>
                drawHex(new Coords(j + drawX, i + drawY));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Redraws a hex and all the hexes immediately around it.  Used when the<br/>
     * hex is on the screen, as opposed to when it is scrolling onto the screen,<br/>
     * so it resets the clipping rectangle before drawing.<br/>
     */<br/>
    private void redrawAround(Coords c) {<br/>
        boardGraph.setClip(0, 0, boardRect.width, boardRect.height);<br/>
        drawHex(c);<br/>
        drawHex(c.translated(0));<br/>
        drawHex(c.translated(1));<br/>
        drawHex(c.translated(2));<br/>
        drawHex(c.translated(3));<br/>
        drawHex(c.translated(4));<br/>
        drawHex(c.translated(5));<br/>
    }<br/>
<br/>
    /**<br/>
     * Draws a hex onto the board buffer.  This assumes that boardRect is<br/>
     * current, and does not check if the hex is visible.<br/>
     */<br/>
    private void drawHex(Coords c) {<br/>
        if (!game.getBoard().contains(c)) {<br/>
            return;<br/>
        }<br/>
<br/>
        final IHex hex = game.getBoard().getHex(c);<br/>
        final Point hexLoc = getHexLocation(c);<br/>
<br/>
        int level = hex.getElevation();<br/>
        int depth = hex.depth();<br/>
<br/>
        // offset drawing point<br/>
        <br/>
        int drawX = hexLoc.x - boardRect.x;<br/>
        int drawY = hexLoc.y - boardRect.y;<br/>
<br/>
        // draw picture<br/>
        Image baseImage = tileManager.baseFor(hex);<br/>
        Image scaledImage = getScaledImage(baseImage);<br/>
        <br/>
        boardGraph.drawImage(scaledImage, drawX, drawY, this);<br/>
        <br/>
        if (tileManager.supersFor(hex) != null) {<br/>
            for (Iterator i = tileManager.supersFor(hex).iterator(); i.hasNext();){<br/>
                scaledImage = getScaledImage((Image)i.next());<br/>
                boardGraph.drawImage(scaledImage, drawX, drawY, this);<br/>
            }<br/>
        }<br/>
        <br/>
        if(GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_DARKEN_MAP_AT_NIGHT) &amp;&amp; <br/>
            game.getOptions().booleanOption("night_battle") &amp;&amp;<br/>
            !game.isPositionIlluminated(c)) {<br/>
            scaledImage = getScaledImage(tileManager.getNightFog());<br/>
            boardGraph.drawImage(scaledImage, drawX, drawY, this);<br/>
        }<br/>
        boardGraph.setColor(GUIPreferences.getInstance().getMapTextColor());<br/>
        <br/>
        // draw hex number<br/>
        if (scale &gt;= 0.5){<br/>
            drawCenteredString(<br/>
                    c.getBoardNum(),<br/>
                    drawX,<br/>
                    drawY + (int)(12*scale),<br/>
                    font_hexnum,<br/>
                    boardGraph);<br/>
        }<br/>
        // level | depth<br/>
        if (level != 0 &amp;&amp; depth == 0 &amp;&amp; zoomIndex &gt; 3) {<br/>
            drawCenteredString(<br/>
                    Messages.getString("BoardView1.LEVEL") + level, //$NON-NLS-1$<br/>
                    drawX,<br/>
                    drawY + (int)(70*scale),<br/>
                    font_elev,<br/>
                    boardGraph);<br/>
        } else if (depth != 0 &amp;&amp; level == 0  &amp;&amp; zoomIndex &gt; 3 ) {<br/>
            drawCenteredString(<br/>
                    Messages.getString("BoardView1.DEPTH") + depth, //$NON-NLS-1$<br/>
                    drawX,<br/>
                    drawY + (int)(70*scale),<br/>
                    font_elev,<br/>
                    boardGraph);<br/>
        } else if (level != 0 &amp;&amp; depth != 0  &amp;&amp; zoomIndex &gt; 3) {<br/>
            drawCenteredString(<br/>
                        Messages.getString("BoardView1.LEVEL") + level, //$NON-NLS-1$<br/>
                    drawX,<br/>
                    drawY + (int)(60*scale),<br/>
                    font_elev,<br/>
                    boardGraph);<br/>
                drawCenteredString(<br/>
                        Messages.getString("BoardView1.DEPTH") + depth, //$NON-NLS-1$<br/>
                    drawX,<br/>
                    drawY + (int)(70*scale),<br/>
                    font_elev,<br/>
                    boardGraph);<br/>
        }<br/>
        <br/>
        // draw elevation borders<br/>
        boardGraph.setColor(Color.black);<br/>
        if (drawElevationLine(c, 0)) {<br/>
            boardGraph.drawLine(drawX + (int)(21*scale), drawY, drawX + (int)(62*scale), drawY);<br/>
        }<br/>
        if (drawElevationLine(c, 1)) {<br/>
            boardGraph.drawLine(drawX + (int)(62*scale), drawY, drawX + (int)(83*scale), drawY + (int)(35*scale));<br/>
        }<br/>
        if (drawElevationLine(c, 2)) {<br/>
            boardGraph.drawLine(drawX + (int)(83*scale), drawY + (int)(36*scale), drawX + (int)(62*scale), drawY + (int)(71*scale));<br/>
        }<br/>
        if (drawElevationLine(c, 3)) {<br/>
            boardGraph.drawLine(drawX + (int)(62*scale), drawY + (int)(71*scale), drawX + (int)(21*scale), drawY + (int)(71*scale));<br/>
        }<br/>
        if (drawElevationLine(c, 4)) {<br/>
            boardGraph.drawLine(drawX + (int)(21*scale), drawY + (int)(71*scale), drawX, drawY + (int)(36*scale));<br/>
        }<br/>
        if (drawElevationLine(c, 5)) {<br/>
            boardGraph.drawLine(drawX, drawY + (int)(35*scale), drawX + (int)(21*scale), drawY);<br/>
        }<br/>
<br/>
        // draw mapsheet borders<br/>
        if(GUIPreferences.getInstance().getShowMapsheets()) {<br/>
            boardGraph.setColor(GUIPreferences.getInstance().getColor(GUIPreferences.ADVANCED_MAPSHEET_COLOR));<br/>
            if(c.x % 16 == 0) {<br/>
                //left edge of sheet (edge 4 &amp; 5)<br/>
                boardGraph.drawLine(drawX + (int)(21*scale), drawY + (int)(71*scale), drawX, drawY + (int)(36*scale));<br/>
                boardGraph.drawLine(drawX, drawY + (int)(35*scale), drawX + (int)(21*scale), drawY);<br/>
            }<br/>
            else if(c.x % 16 == 15) {<br/>
                //right edge of sheet (edge 1 &amp; 2)<br/>
                boardGraph.drawLine(drawX + (int)(62*scale), drawY, drawX + (int)(83*scale), drawY + (int)(35*scale));<br/>
                boardGraph.drawLine(drawX + (int)(83*scale), drawY + (int)(36*scale), drawX + (int)(62*scale), drawY + (int)(71*scale));<br/>
            }<br/>
            if(c.y % 17 == 0) {<br/>
                //top edge of sheet (edge 0 and possible 1 &amp; 5)<br/>
                boardGraph.drawLine(drawX + (int)(21*scale), drawY, drawX + (int)(62*scale), drawY);<br/>
                if(c.x % 2 == 0) {<br/>
                    boardGraph.drawLine(drawX + (int)(62*scale), drawY, drawX + (int)(83*scale), drawY + (int)(35*scale));<br/>
                    boardGraph.drawLine(drawX, drawY + (int)(35*scale), drawX + (int)(21*scale), drawY);<br/>
                }<br/>
            } else if (c.y % 17 == 16) {<br/>
                //bottom edge of sheet (edge 3 and possible 2 &amp; 4)<br/>
                boardGraph.drawLine(drawX + (int)(62*scale), drawY + (int)(71*scale), drawX + (int)(21*scale), drawY + (int)(71*scale));<br/>
                if(c.x % 2 == 1) {<br/>
                    boardGraph.drawLine(drawX + (int)(83*scale), drawY + (int)(36*scale), drawX + (int)(62*scale), drawY + (int)(71*scale));<br/>
                    boardGraph.drawLine(drawX + (int)(21*scale), drawY + (int)(71*scale), drawX, drawY + (int)(36*scale));<br/>
                }<br/>
            }<br/>
            boardGraph.setColor(Color.black);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if an elevation line should be drawn between the starting<br/>
     * hex and the hex in the direction specified.  Results should be<br/>
     * transitive, that is, if a line is drawn in one direction, it should be<br/>
     * drawn in the opposite direction as well.<br/>
     */<br/>
    private final boolean drawElevationLine(Coords src, int direction) {<br/>
        final IHex srcHex = game.getBoard().getHex(src);<br/>
        final IHex destHex = game.getBoard().getHexInDir(src, direction);<br/>
        return destHex != null &amp;&amp; srcHex.floor() != destHex.floor();<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns the absolute position of the upper-left hand corner<br/>
     * of the hex graphic<br/>
     */<br/>
    private Point getHexLocation(int x, int y) {<br/>
        return new Point(<br/>
                x * (int)(HEX_WC*scale),<br/>
                y * (int)(HEX_H*scale) + ((x &amp; 1) == 1 ? (int)(HEX_H/2*scale) : 0));<br/>
    }<br/>
    private Point getHexLocation(Coords c) {<br/>
        return getHexLocation(c.x, c.y);<br/>
    }<br/>
<br/>
    // added by kenn<br/>
    /**<br/>
     * Returns the absolute position of the centre<br/>
     * of the hex graphic<br/>
     */<br/>
    private Point getCentreHexLocation(int x, int y) {<br/>
        Point p = getHexLocation(x, y);<br/>
        p.x += (HEX_W/2*scale);<br/>
        p.y += (HEX_H/2*scale);<br/>
        return p;<br/>
    }<br/>
    private Point getCentreHexLocation(Coords c) {<br/>
        return getCentreHexLocation(c.x, c.y);<br/>
    }<br/>
    // end kenn<br/>
<br/>
    /**<br/>
     * Returns the coords at the specified point<br/>
     */<br/>
    Coords getCoordsAt(Point p) {<br/>
        final int x = (p.x + scroll.x - offset.x) / (int)(HEX_WC*scale);<br/>
        final int y = ((p.y + scroll.y - offset.y) - ((x &amp; 1) == 1 ? (int)(HEX_H/2*scale) : 0)) / (int)(HEX_H*scale);<br/>
        return new Coords(x, y);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Shows the tooltip thinger<br/>
     */<br/>
    private void showTooltip() {<br/>
        try {<br/>
            final Point tipLoc = new Point(getLocationOnScreen());<br/>
            // retrieve tip text<br/>
            String[] tipText = getTipText(mousePos);<br/>
            if (tipText == null) {<br/>
                return;<br/>
            }<br/>
<br/>
            // update tip text<br/>
            tipWindow.removeAll();<br/>
            tipWindow.add(new TooltipCanvas(tipText));<br/>
            tipWindow.pack();<br/>
<br/>
            tipLoc.translate(mousePos.x, mousePos.y + 20);<br/>
<br/>
            // adjust horizontal location for the tipWindow if it goes off the frame<br/>
            if (frame.getLocation().x + frame.getSize().width &lt; tipLoc.x + tipWindow.getSize().width + 10) {<br/>
                if (frame.getSize().width &gt; tipWindow.getSize().width) {<br/>
                    // bound it by the right edge of the frame<br/>
                    tipLoc.x -= tipLoc.x + tipWindow.getSize().width + 10 - frame.getSize().width - frame.getLocation().x;<br/>
                }<br/>
                else {<br/>
                    // too big to fit, left justify to the frame (roughly).<br/>
                    // how do I extract the first term of HEX_SIZE to use here?--LDE<br/>
                    tipLoc.x = getLocationOnScreen().x + hex_size.width;<br/>
                }<br/>
            }<br/>
<br/>
            // set tip location<br/>
            tipWindow.setLocation(tipLoc);<br/>
<br/>
            tipWindow.show();<br/>
        } catch (Exception e) {<br/>
            tipWindow = new Window(frame);<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * The text to be displayed when the mouse is at a certain point<br/>
     */<br/>
    private String[] getTipText(Point point) {<br/>
<br/>
        int stringsSize = 0;<br/>
        IHex mhex = null;<br/>
<br/>
        // first, we have to determine how much text we are going to have<br/>
        // are we on a hex?<br/>
        final Coords mcoords = getCoordsAt(point);<br/>
        if (GUIPreferences.getInstance().getShowMapHexPopup() &amp;&amp; game.getBoard().contains(mcoords)) {<br/>
            mhex = game.getBoard().getHex(mcoords);<br/>
            stringsSize += 1;<br/>
        }<br/>
<br/>
        // check if it's on any entities<br/>
        for (Iterator i = entitySprites.iterator(); i.hasNext();) {<br/>
            final EntitySprite eSprite = (EntitySprite)i.next();<br/>
            if (eSprite.isInside(point)) {<br/>
                stringsSize += 3;<br/>
            }<br/>
        }<br/>
<br/>
        // check if it's on any attacks<br/>
        for (Iterator i = attackSprites.iterator(); i.hasNext();) {<br/>
            final AttackSprite aSprite = (AttackSprite)i.next();<br/>
            if (aSprite.isInside(point)) {<br/>
                stringsSize += 1 + aSprite.weaponDescs.size();<br/>
            }<br/>
        }<br/>
<br/>
        // If the hex contains a building or rubble, make more space.<br/>
        if ( mhex != null &amp;&amp;<br/>
             (mhex.containsTerrain(Terrains.RUBBLE) ||<br/>
              mhex.containsTerrain(Terrains.BUILDING)) ) {<br/>
            stringsSize += 1;<br/>
        }<br/>
<br/>
        stringsSize += game.getNbrMinefields(mcoords);<br/>
        <br/>
        // Artillery<br/>
        final Vector artilleryAttacks = getArtilleryAttacksAtLocation(mcoords);<br/>
        stringsSize += artilleryAttacks.size();<br/>
<br/>
        // Artillery fire adjustment<br/>
        final Mounted selectedWeapon = getSelectedArtilleryWeapon();<br/>
        if(selectedWeapon != null)<br/>
            stringsSize++;<br/>
<br/>
        // if the size is zip, you must a'quit<br/>
        if (stringsSize == 0) {<br/>
            return null;<br/>
        }<br/>
<br/>
        // now we can allocate an array of strings<br/>
        String[] strings = new String[stringsSize];<br/>
        int stringsIndex = 0;<br/>
<br/>
        // are we on a hex?<br/>
        if (mhex != null) {<br/>
            strings[stringsIndex] = Messages.getString("BoardView1.Hex") + mcoords.getBoardNum() //$NON-NLS-1$<br/>
                + Messages.getString("BoardView1.level") + mhex.getElevation(); //$NON-NLS-1$<br/>
            stringsIndex += 1;<br/>
<br/>
            // Do we have rubble?<br/>
            if ( mhex.containsTerrain(Terrains.RUBBLE) ) {<br/>
                strings[stringsIndex] = Messages.getString("BoardView1.Rubble"); //$NON-NLS-1$<br/>
                stringsIndex += 1;<br/>
            }<br/>
<br/>
            // Do we have a building?<br/>
            else if ( mhex.containsTerrain(Terrains.BUILDING) ) {<br/>
                // Get the building.<br/>
                Building bldg = game.getBoard().getBuildingAt( mcoords );<br/>
                StringBuffer buf = new StringBuffer( Messages.getString("BoardView1.Height") ); //$NON-NLS-1$<br/>
                // Each hex of a building has its own elevation.<br/>
                buf.append( mhex.terrainLevel(Terrains.BLDG_ELEV) );<br/>
                buf.append( " " ); //$NON-NLS-1$<br/>
                buf.append( bldg.toString() );<br/>
                buf.append( Messages.getString("BoardView1.CF") ); //$NON-NLS-1$<br/>
                buf.append( bldg.getCurrentCF() );<br/>
                strings[stringsIndex] = buf.toString();<br/>
                stringsIndex += 1;<br/>
            }<br/>
<br/>
            if (game.containsMinefield(mcoords)) {<br/>
                java.util.Vector minefields = game.getMinefields(mcoords);<br/>
                for (int i = 0; i &lt; minefields.size(); i++){<br/>
                    Minefield mf = (Minefield) minefields.elementAt(i);<br/>
                    String owner =  " (" + game.getPlayer(mf.getPlayerId()).getName() + ")"; //$NON-NLS-1$ //$NON-NLS-2$<br/>
<br/>
                    switch (mf.getType()) {<br/>
                    case (Minefield.TYPE_CONVENTIONAL) :<br/>
                        strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield") +" " + owner; //$NON-NLS-1$ //$NON-NLS-2$<br/>
                        break;<br/>
                    case (Minefield.TYPE_THUNDER) :<br/>
                        strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield")+"(" + mf.getDamage() + ")" + owner; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$<br/>
                        break;<br/>
                    case (Minefield.TYPE_COMMAND_DETONATED) :<br/>
                        strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield") +" " + owner; //$NON-NLS-1$ //$NON-NLS-2$<br/>
                        break;<br/>
                    case (Minefield.TYPE_VIBRABOMB) :<br/>
                        if (mf.getPlayerId() == localPlayer.getId()) {<br/>
                            strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield")+"(" + mf.getSetting() + ") " + owner; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$<br/>
                        } else {<br/>
                            strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield") + " " + owner; //$NON-NLS-1$ //$NON-NLS-2$<br/>
                        }<br/>
                        break;<br/>
                    case (Minefield.TYPE_THUNDER_ACTIVE) :<br/>
                        strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield")+"(" + mf.getDamage() + ")" + owner; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$<br/>
                        break;<br/>
                    case (Minefield.TYPE_THUNDER_INFERNO) :<br/>
                        strings[stringsIndex] = mf.getName()+Messages.getString("BoardView1.minefield")+"(" + mf.getDamage() + ")" + owner; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$<br/>
                        break;<br/>
                    }<br/>
                    stringsIndex++;<br/>
                }<br/>
            }<br/>
        }<br/>
        // check if it's on any entities<br/>
        for (Iterator i = entitySprites.iterator(); i.hasNext();) {<br/>
            final EntitySprite eSprite = (EntitySprite)i.next();<br/>
            if (eSprite.isInside(point)) {<br/>
                final String[] entityStrings = eSprite.getTooltip();<br/>
                java.lang.System.arraycopy(entityStrings, 0, strings, stringsIndex, entityStrings.length);<br/>
                stringsIndex += entityStrings.length;<br/>
            }<br/>
        }<br/>
<br/>
        // check if it's on any attacks<br/>
        for (Iterator i = attackSprites.iterator(); i.hasNext();) {<br/>
            final AttackSprite aSprite = (AttackSprite)i.next();<br/>
            if (aSprite.isInside(point)) {<br/>
                final String[] attackStrings = aSprite.getTooltip();<br/>
                java.lang.System.arraycopy(attackStrings, 0, strings, stringsIndex, attackStrings.length);<br/>
                stringsIndex += 1 + aSprite.weaponDescs.size();<br/>
            }<br/>
        }<br/>
        <br/>
        // check artillery attacks<br/>
        for(Iterator i = artilleryAttacks.iterator(); i.hasNext();) {<br/>
            final ArtilleryAttackAction aaa = (ArtilleryAttackAction)i.next();<br/>
            final WeaponResult wr = aaa.getWR();<br/>
            final Entity ae = game.getEntity(wr.waa.getEntityId());<br/>
            String s = null;<br/>
            if(ae != null) {<br/>
                if(wr.waa.getWeaponId() &gt; -1) {<br/>
                    Mounted weap = ae.getEquipment(wr.waa.getWeaponId());<br/>
                    s = weap.getName();<br/>
                    if(wr.waa.getAmmoId() &gt; -1) {<br/>
                        Mounted ammo = ae.getEquipment(wr.waa.getAmmoId());<br/>
                        s += "(" + ammo.getName() + ")";<br/>
                    }<br/>
                }<br/>
            }<br/>
            if(s == null) {<br/>
                s = Messages.getString("BoardView1.Artillery");<br/>
            }<br/>
            strings[stringsIndex++] = Messages.getString("BoardView1.ArtilleryAttack", <br/>
                    new Object[] { s, new Integer(aaa.turnsTilHit), wr.toHit.getValueAsString() } );<br/>
        }<br/>
        //check artillery fire adjustment<br/>
        final Entity selectedEntity = clientgui.mechD.getCurrentEntity();<br/>
        if(selectedWeapon != null &amp;&amp; selectedEntity != null) {<br/>
            //process targetted hexes<br/>
            int amod = 0;<br/>
            //Check the predesignated hexes<br/>
            if(selectedEntity.getOwner().getArtyAutoHitHexes().contains(mcoords)) {<br/>
                amod = TargetRoll.AUTOMATIC_SUCCESS;<br/>
            }<br/>
            else {<br/>
                amod = selectedEntity.aTracker.getModifier(selectedWeapon, mcoords);<br/>
            }<br/>
<br/>
            if(amod==TargetRoll.AUTOMATIC_SUCCESS) {<br/>
                strings[stringsIndex++] = Messages.getString("BoardView1.ArtilleryAutohit");<br/>
            } else {<br/>
                strings[stringsIndex++] = Messages.getString("BoardView1.ArtilleryAdjustment", new Object[] { new Integer(amod) } );<br/>
            }<br/>
        }<br/>
        return strings;<br/>
    }<br/>
<br/>
    /**<br/>
     * Hides the tooltip thinger<br/>
     */<br/>
    public void hideTooltip() {<br/>
        tipWindow.setVisible(false);<br/>
    }<br/>
<br/>
    /**<br/>
     * Returns true if the tooltip is showing<br/>
     */<br/>
    private boolean isTipShowing() {<br/>
        return tipWindow.isShowing();<br/>
    }<br/>
<br/>
    /**<br/>
     * Checks if the mouse has been idling for a while and if so, shows the<br/>
     * tooltip window<br/>
     */<br/>
    private void checkTooltip() {<br/>
        if (isTipShowing()) {<br/>
            if (!isTipPossible) {<br/>
                hideTooltip();<br/>
            }<br/>
        } else if (isTipPossible &amp;&amp; System.currentTimeMillis() - lastIdle &gt; GUIPreferences.getInstance().getTooltipDelay()) {<br/>
            showTooltip();<br/>
        }<br/>
    }<br/>
<br/>
    public void redrawMovingEntity(Entity entity, Coords position, int facing) {<br/>
        Integer entityId = new Integer( entity.getId() );<br/>
        EntitySprite sprite = (EntitySprite) entitySpriteIds.get( entityId );<br/>
        Vector newSprites;<br/>
        Hashtable newSpriteIds;<br/>
<br/>
        if (sprite != null) {<br/>
            newSprites = new Vector(entitySprites);<br/>
            newSpriteIds = new Hashtable(entitySpriteIds);<br/>
<br/>
            newSprites.removeElement(sprite);<br/>
<br/>
            entitySprites = newSprites;<br/>
            entitySpriteIds = newSpriteIds;<br/>
        }<br/>
<br/>
        MovingEntitySprite mSprite =<br/>
            (MovingEntitySprite) movingEntitySpriteIds.get( entityId );<br/>
        newSprites = new Vector(movingEntitySprites);<br/>
        newSpriteIds = new Hashtable(movingEntitySpriteIds);<br/>
<br/>
<br/>
        if (mSprite != null) {<br/>
            newSprites.removeElement(mSprite);<br/>
        }<br/>
<br/>
        if (entity.getPosition() != null) {<br/>
            mSprite = new MovingEntitySprite(entity, position, facing);<br/>
            newSprites.addElement(mSprite);<br/>
            newSpriteIds.put( entityId, mSprite );<br/>
        }<br/>
<br/>
        movingEntitySprites = newSprites;<br/>
        movingEntitySpriteIds = newSpriteIds;<br/>
    }<br/>
<br/>
    public boolean isMovingUnits() {<br/>
        return movingUnits.size() &gt; 0;<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears the sprite for an entity and prepares it to be re-drawn.<br/>
     *  Replaces the old sprite with the new!<br/>
     *<br/>
     *  Try to prevent annoying ConcurrentModificationExceptions<br/>
     */<br/>
    public void redrawEntity(Entity entity) {<br/>
        Integer entityId = new Integer( entity.getId() );<br/>
        EntitySprite sprite = (EntitySprite)entitySpriteIds.get( entityId );<br/>
        Vector newSprites = new Vector(entitySprites);<br/>
        Hashtable newSpriteIds = new Hashtable(entitySpriteIds);<br/>
<br/>
<br/>
        if (sprite != null) {<br/>
            newSprites.removeElement(sprite);<br/>
        }<br/>
        Coords position = entity.getPosition();<br/>
        if (position != null) {<br/>
            /*drawHex(position);<br/>
            IHex foo = game.getBoard().getHex(position);<br/>
            foo.markChanged(); */// TODO: Is this really necessary?<br/>
            <br/>
            sprite = new EntitySprite(entity);<br/>
            newSprites.addElement(sprite);<br/>
            newSpriteIds.put( entityId, sprite );<br/>
        }<br/>
<br/>
        entitySprites = newSprites;<br/>
        entitySpriteIds = newSpriteIds;<br/>
<br/>
        for (java.util.Enumeration i = C3Sprites.elements(); i.hasMoreElements();) {<br/>
            final C3Sprite c3sprite = (C3Sprite)i.nextElement();<br/>
            if (c3sprite.entityId == entity.getId())<br/>
                C3Sprites.removeElement(c3sprite);<br/>
            else if(c3sprite.masterId == entity.getId()) {<br/>
                // Only redraw client-to-master; otherwise<br/>
                // we leave stray lines when we move.<br/>
                if(entity.hasC3()) {<br/>
                    C3Sprites.addElement(new C3Sprite(game.getEntity(c3sprite.entityId), game.getEntity(c3sprite.masterId)));<br/>
                }<br/>
                C3Sprites.removeElement(c3sprite);<br/>
<br/>
            }<br/>
        }<br/>
<br/>
        if(entity.hasC3() || entity.hasC3i()) addC3Link(entity);<br/>
<br/>
        repaint(100);<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears all old entity sprites out of memory and sets up new ones.<br/>
     */<br/>
    private void redrawAllEntities() {<br/>
        Vector newSprites = new Vector(game.getNoOfEntities());<br/>
        Hashtable newSpriteIds = new Hashtable(game.getNoOfEntities());<br/>
        Vector newWrecks = new Vector();<br/>
<br/>
        Enumeration e = game.getWreckedEntities();<br/>
        while (e.hasMoreElements()) {<br/>
            Entity entity = (Entity) e.nextElement();<br/>
            if (!(entity instanceof Infantry) &amp;&amp; (entity.getPosition() != null)) {<br/>
                WreckSprite ws = new WreckSprite(entity);<br/>
                newWrecks.addElement(ws);<br/>
            }<br/>
        }<br/>
<br/>
        clearC3Networks();<br/>
        for (java.util.Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
            final Entity entity = (Entity)i.nextElement();<br/>
            if (entity.getPosition() == null) continue;<br/>
<br/>
            EntitySprite sprite = new EntitySprite(entity);<br/>
            newSprites.add(sprite);<br/>
            newSpriteIds.put(new Integer(entity.getId()), sprite);<br/>
<br/>
            if(entity.hasC3() || entity.hasC3i()) addC3Link(entity);<br/>
        }<br/>
<br/>
        entitySprites = newSprites;<br/>
        entitySpriteIds = newSpriteIds;<br/>
        wreckSprites = newWrecks;<br/>
<br/>
        repaint(100);<br/>
    }<br/>
<br/>
    /**<br/>
     * Moves the cursor to the new position, or hides it, if newPos is null<br/>
     */<br/>
    private void moveCursor(CursorSprite cursor, Coords newPos) {<br/>
        final Rectangle oldBounds = new Rectangle(cursor.getBounds());<br/>
        if (newPos != null) {<br/>
            //cursor.setLocation(getHexLocation(newPos));<br/>
            cursor.setHexLocation(newPos);<br/>
        } else {<br/>
            cursor.setOffScreen();<br/>
        }<br/>
        // repaint affected area<br/>
        repaintBounds(oldBounds);<br/>
        repaintBounds(cursor.getBounds());<br/>
    }<br/>
<br/>
<br/>
    public void centerOnHex(Coords c) {<br/>
        if ( null == c ) return;<br/>
        scroll.setLocation(getHexLocation(c));<br/>
        scroll.translate((int)(42*scale) - (view.width / 2), (int)(36*scale) - (view.height / 2));<br/>
<br/>
        isScrolling = false;<br/>
        checkScrollBounds();<br/>
        repaint();<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears the old movement data and draws the new.  Since it's less<br/>
     * expensive to check for and reuse old step sprites than to make a whole<br/>
     * new one, we do that.<br/>
     */<br/>
    public void drawMovementData(Entity entity, MovePath md) {<br/>
        Vector temp = pathSprites;<br/>
<br/>
        clearMovementData();<br/>
<br/>
        for (java.util.Enumeration i = md.getSteps(); i.hasMoreElements();) {<br/>
            final MoveStep step = (MoveStep)i.nextElement();<br/>
            // check old movement path for reusable step sprites<br/>
            boolean found = false;<br/>
            for (Iterator j = temp.iterator(); j.hasNext();) {<br/>
                final StepSprite sprite = (StepSprite)j.next();<br/>
                if (sprite.getStep().canReuseSprite(step)) {<br/>
                    pathSprites.addElement(sprite);<br/>
                    found = true;<br/>
                }<br/>
            }<br/>
            if (!found) {<br/>
                pathSprites.addElement(new StepSprite(step));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears current movement data from the screen<br/>
     */<br/>
    public void clearMovementData() {<br/>
        Vector temp = pathSprites;<br/>
        pathSprites = new Vector();<br/>
        for (Iterator i = temp.iterator(); i.hasNext();) {<br/>
            final Sprite sprite = (Sprite)i.next();<br/>
            repaintBounds(sprite.getBounds());<br/>
        }<br/>
    }<br/>
<br/>
    public void setLocalPlayer(Player p) {<br/>
        localPlayer = p;<br/>
    }<br/>
<br/>
    public Player getLocalPlayer() {<br/>
        return localPlayer;<br/>
    }<br/>
<br/>
    /**<br/>
     * Specifies that this should mark the deployment hexes for a player.  If<br/>
     * the player is set to null, no hexes will be marked.<br/>
     */<br/>
    public void markDeploymentHexesFor(Player p)<br/>
    {<br/>
        m_plDeployer = p;<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds a c3 line to the sprite list.<br/>
     */<br/>
    public void addC3Link(Entity e) {<br/>
        if (e.getPosition() == null) return;<br/>
<br/>
        if(e.hasC3i()) {<br/>
            for (java.util.Enumeration i = game.getEntities(); i.hasMoreElements();) {<br/>
                final Entity fe = (Entity)i.nextElement();<br/>
                if (fe.getPosition() == null) return;<br/>
                if ( e.onSameC3NetworkAs(fe)) {<br/>
                    C3Sprites.addElement(new C3Sprite(e, fe));<br/>
                }<br/>
            }<br/>
        }<br/>
        else if(e.getC3Master() != null) {<br/>
            Entity eMaster = e.getC3Master();<br/>
            if (eMaster.getPosition() == null) return;<br/>
<br/>
            // ECM cuts off the network<br/>
            if (!Compute.isAffectedByECM(e, e.getPosition(), eMaster.getPosition())) {<br/>
                C3Sprites.addElement(new C3Sprite(e, e.getC3Master()));<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Adds an attack to the sprite list.<br/>
     */<br/>
    public void addAttack(AttackAction aa) {<br/>
        // do not make a sprite unless we're aware of both entities<br/>
        // this is not a great solution but better than a crash<br/>
        Entity ae = game.getEntity(aa.getEntityId());<br/>
        Targetable t = game.getTarget(aa.getTargetType(), aa.getTargetId());<br/>
        if (ae == null || t == null || t.getTargetType() == Targetable.TYPE_INARC_POD) {<br/>
            return;<br/>
        }<br/>
<br/>
        for (final Iterator i = attackSprites.iterator(); i.hasNext();) {<br/>
            final AttackSprite sprite = (AttackSprite)i.next();<br/>
<br/>
            // can we just add this attack to an existing one?<br/>
            if (sprite.getEntityId() == aa.getEntityId()<br/>
                &amp;&amp; sprite.getTargetId() == aa.getTargetId()) {<br/>
                // use existing attack, but add this weapon<br/>
                if (aa instanceof WeaponAttackAction) {<br/>
                    WeaponAttackAction waa = (WeaponAttackAction)aa;<br/>
                    if ( aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY <br/>
                        &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_FASCAM<br/>
                        &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_INFERNO_IV<br/>
                        &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_VIBRABOMB_IV) {<br/>
                        sprite.addWeapon(waa);<br/>
                    } else if ( waa.getEntity(game).getOwner().getId() == localPlayer.getId()) {<br/>
                        sprite.addWeapon(waa);<br/>
                    }<br/>
                }<br/>
                if (aa instanceof KickAttackAction) {<br/>
                    sprite.addWeapon((KickAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof PunchAttackAction) {<br/>
                    sprite.addWeapon((PunchAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof PushAttackAction) {<br/>
                    sprite.addWeapon((PushAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof ClubAttackAction) {<br/>
                    sprite.addWeapon((ClubAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof ChargeAttackAction) {<br/>
                    sprite.addWeapon((ChargeAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof DfaAttackAction) {<br/>
                    sprite.addWeapon((DfaAttackAction)aa);<br/>
                }<br/>
                if (aa instanceof ProtomechPhysicalAttackAction) {<br/>
                    sprite.addWeapon((ProtomechPhysicalAttackAction)aa);<br/>
                }<br/>
                return;<br/>
            }<br/>
        }<br/>
        // no re-use possible, add a new one<br/>
        // don't add a sprite for an artillery attack made by the other player<br/>
        if (aa instanceof WeaponAttackAction) {<br/>
            WeaponAttackAction waa = (WeaponAttackAction)aa;<br/>
            if ( aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY <br/>
                &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_FASCAM<br/>
                &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_INFERNO_IV<br/>
                &amp;&amp; aa.getTargetType() != Targetable.TYPE_HEX_VIBRABOMB_IV) {<br/>
                attackSprites.addElement(new AttackSprite(aa));<br/>
            } else if ( waa.getEntity(game).getOwner().getId() == localPlayer.getId()) {<br/>
                attackSprites.addElement(new AttackSprite(aa));<br/>
            }<br/>
        } else {<br/>
            attackSprites.addElement(new AttackSprite(aa));<br/>
        }<br/>
    }<br/>
<br/>
    /** Removes all attack sprites from a certain entity */<br/>
    public void removeAttacksFor(int entityId) {<br/>
        // or rather, only keep sprites NOT for that entity<br/>
        Vector toKeep = new Vector(attackSprites.size());<br/>
        for (Iterator i = attackSprites.iterator(); i.hasNext();) {<br/>
            AttackSprite sprite = (AttackSprite)i.next();<br/>
            if (sprite.getEntityId() != entityId) {<br/>
                toKeep.addElement(sprite);<br/>
            }<br/>
        }<br/>
        this.attackSprites = toKeep;<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears out all attacks and re-adds the ones in the current game.<br/>
     */<br/>
    public void refreshAttacks() {<br/>
        clearAllAttacks();<br/>
        for (Enumeration i = game.getActions(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
            if (ea instanceof AttackAction) {<br/>
                addAttack((AttackAction)ea);<br/>
            }<br/>
        }<br/>
        for (Enumeration i = game.getCharges(); i.hasMoreElements();) {<br/>
            EntityAction ea = (EntityAction)i.nextElement();<br/>
            if (ea instanceof AttackAction) {<br/>
                addAttack((AttackAction)ea);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    public void clearC3Networks() {<br/>
        C3Sprites.removeAllElements();<br/>
    }<br/>
<br/>
    /**<br/>
     * Clears out all attacks that were being drawn<br/>
     */<br/>
    public void clearAllAttacks() {<br/>
        attackSprites.removeAllElements();<br/>
    }<br/>
<br/>
    public Image baseFor(IHex hex) {<br/>
        return tileManager.baseFor(hex);<br/>
    }<br/>
<br/>
    public com.sun.java.util.collections.List supersFor(IHex hex) {<br/>
        return tileManager.supersFor(hex);<br/>
    }<br/>
<br/>
    protected void firstLOSHex(Coords c) {<br/>
        if (useLOSTool) {<br/>
            moveCursor(secondLOSSprite, null);<br/>
            moveCursor(firstLOSSprite, c);<br/>
        }<br/>
    }<br/>
<br/>
    protected void secondLOSHex(Coords c2, Coords c1) {<br/>
        if (useLOSTool) {<br/>
            moveCursor(firstLOSSprite, c1);<br/>
            moveCursor(secondLOSSprite, c2);<br/>
            <br/>
            boolean mechInFirst = GUIPreferences.getInstance().getMechInFirst();<br/>
            boolean mechInSecond = GUIPreferences.getInstance().getMechInSecond();<br/>
            <br/>
            LosEffects.AttackInfo ai = new LosEffects.AttackInfo();<br/>
            ai.attackPos = c1;<br/>
            ai.targetPos = c2;<br/>
            ai.attackHeight = mechInFirst?1:0;<br/>
            ai.targetHeight = mechInSecond?1:0;<br/>
            ai.attackAbsHeight = game.getBoard().getHex(c1).floor() + ai.attackHeight;<br/>
            ai.targetAbsHeight = game.getBoard().getHex(c2).floor() + ai.targetHeight;<br/>
<br/>
            LosEffects le = LosEffects.calculateLos(game, ai);<br/>
            StringBuffer message = new StringBuffer();<br/>
            message.append(Messages.getString("BoardView1.Attacker", new Object[]{ //$NON-NLS-1$<br/>
                    mechInFirst ? Messages.getString("BoardView1.Mech") : Messages.getString("BoardView1.NonMech"), //$NON-NLS-1$ //$NON-NLS-2$<br/>
                    c1.getBoardNum()}));<br/>
            message.append(Messages.getString("BoardView1.Target", new Object[]{ //$NON-NLS-1$<br/>
                    mechInSecond ? Messages.getString("BoardView1.Mech") : Messages.getString("BoardView1.NonMech"), //$NON-NLS-1$ //$NON-NLS-2$<br/>
                    c1.getBoardNum()}));<br/>
            if (!le.canSee()) {<br/>
                message.append(Messages.getString("BoardView1.LOSBlocked", new Object[]{ //$NON-NLS-1$<br/>
                    new Integer(c1.distance(c2))}));<br/>
            } else {<br/>
                message.append(Messages.getString("BoardView1.LOSNotBlocked", new Object[]{ //$NON-NLS-1$<br/>
                        new Integer(c1.distance(c2))}));<br/>
                if (le.getHeavyWoods() &gt; 0) {<br/>
                    message.append(Messages.getString("BoardView1.HeavyWoods", new Object[]{ //$NON-NLS-1$<br/>
                            new Integer(le.getHeavyWoods())}));<br/>
                }<br/>
                if (le.getLightWoods() &gt; 0) {<br/>
                    message.append(Messages.getString("BoardView1.LightWoods", new Object[]{ //$NON-NLS-1$<br/>
                            new Integer(le.getLightWoods())}));<br/>
                }<br/>
                if (le.getLightSmoke() &gt; 0) {<br/>
                    message.append(Messages.getString("BoardView1.LightSmoke", new Object[]{ //$NON-NLS-1$<br/>
                            new Integer(le.getLightSmoke())}));<br/>
                }<br/>
                if (le.getHeavySmoke() &gt; 0) {<br/>
                    if (game.getOptions().booleanOption("maxtech_fire")) { //$NON-NLS-1$<br/>
                        message.append(Messages.getString("BoardView1.HeavySmoke", new Object[]{ //$NON-NLS-1$<br/>
                                new Integer(le.getHeavySmoke())}));<br/>
                    }<br/>
                    else {<br/>
                        message.append(Messages.getString("BoardView1.Smoke", new Object[]{ //$NON-NLS-1$<br/>
                                new Integer(le.getHeavySmoke())}));<br/>
                    }<br/>
                }<br/>
                if (le.isTargetCover()) {<br/>
                    message.append(Messages.getString("BoardView1.TargetPartialCover")); //$NON-NLS-1$<br/>
                }<br/>
                if (le.isAttackerCover()) {<br/>
                    message.append(Messages.getString("BoardView1.AttackerPartialCover")); //$NON-NLS-1$<br/>
                }<br/>
            }<br/>
            AlertDialog alert = new AlertDialog(frame,<br/>
                                                Messages.getString("BoardView1.LOSTitle"), //$NON-NLS-1$<br/>
                                                message.toString(), false);<br/>
            alert.show();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * If the mouse is at the edges of the screen, this<br/>
     * scrolls the board image on the canvas.<br/>
     * NOTE: CTL scroll is handled in mouseMoved()<br/>
     */<br/>
    public boolean doScroll() {<br/>
        final Point oldScroll = new Point(scroll);<br/>
        boolean s = false;<br/>
        <br/>
        if ( isScrolling &amp;&amp; GUIPreferences.getInstance().getRightDragScroll()) {<br/>
            if (! (oldMousePosition == null || mousePos.equals(oldMousePosition)) ) {<br/>
                scroll.x -= GUIPreferences.getInstance().getScrollSensitivity() * (mousePos.x - oldMousePosition.x);<br/>
                scroll.y -= GUIPreferences.getInstance().getScrollSensitivity() * (mousePos.y - oldMousePosition.y);<br/>
                checkScrollBounds();<br/>
                oldMousePosition.setLocation(mousePos);<br/>
                s = !oldScroll.equals(scroll);<br/>
                scrolled = scrolled || s;<br/>
            }<br/>
        }<br/>
<br/>
        if (isScrolling &amp;&amp; (GUIPreferences.getInstance().getClickEdgeScroll() ||GUIPreferences.getInstance().getAutoEdgeScroll()) ) {<br/>
            final int sf = GUIPreferences.getInstance().getScrollSensitivity(); // scroll factor<br/>
            // adjust x scroll<br/>
            // scroll when the mouse is at the edges<br/>
            if (mousePos.x &lt; 100) {<br/>
                scroll.x -= (100 - mousePos.x) / sf;<br/>
            } else if (mousePos.x &gt; (backSize.width - 100)) {<br/>
                scroll.x -= ((backSize.width - 100) - mousePos.x) / sf;<br/>
            }<br/>
            // scroll when the mouse is at the edges<br/>
            if (mousePos.y &lt; 100) {<br/>
                scroll.y -= (100 - mousePos.y) / sf;<br/>
            } else if (mousePos.y &gt; (backSize.height - 100)) {<br/>
                scroll.y -= ((backSize.height - 100) - mousePos.y) / sf;<br/>
            }<br/>
            checkScrollBounds();<br/>
            if (!oldScroll.equals(scroll)) {<br/>
                //            repaint();<br/>
                s = true;<br/>
                scrolled = s;<br/>
            }<br/>
        }<br/>
<br/>
        return s;<br/>
    }<br/>
<br/>
    /**<br/>
     * Makes sure that the scroll dimensions stay in bounds<br/>
     */<br/>
    public void checkScrollBounds() {<br/>
        if (scroll.x &lt; 0) {<br/>
            scroll.x = 0;<br/>
        } else if (scroll.x &gt; (boardSize.width - view.width)) {<br/>
            scroll.x = (boardSize.width - view.width);<br/>
        }<br/>
<br/>
        if (scroll.y &lt; 0) {<br/>
            scroll.y = 0;<br/>
        } else if (scroll.y &gt; (boardSize.height - view.height)) {<br/>
            scroll.y = (boardSize.height - view.height);<br/>
        }<br/>
<br/>
        // Update our scroll bars.<br/>
        if (null != this.vScrollbar) {<br/>
            this.vScrollbar.setValue (scroll.y);<br/>
        }<br/>
        if (null != this.hScrollbar) {<br/>
            this.hScrollbar.setValue (scroll.x);<br/>
        }<br/>
    }<br/>
<br/>
    protected void stopScrolling() {<br/>
        isScrolling = false;<br/>
    }<br/>
<br/>
    /**<br/>
     * Initializes the various overlay polygons with their<br/>
     * vertices.<br/>
     */<br/>
    public void initPolys() {<br/>
        // hex polygon<br/>
        hexPoly = new Polygon();<br/>
        hexPoly.addPoint(21, 0);<br/>
        hexPoly.addPoint(62, 0);<br/>
        hexPoly.addPoint(83, 35);<br/>
        hexPoly.addPoint(83, 36);<br/>
        hexPoly.addPoint(62, 71);<br/>
        hexPoly.addPoint(21, 71);<br/>
        hexPoly.addPoint(0, 36);<br/>
        hexPoly.addPoint(0, 35);<br/>
<br/>
        // facing polygons<br/>
        facingPolys = new Polygon[6];<br/>
        facingPolys[0] = new Polygon();<br/>
        facingPolys[0].addPoint(41, 3);<br/>
        facingPolys[0].addPoint(38, 6);<br/>
        facingPolys[0].addPoint(45, 6);<br/>
        facingPolys[0].addPoint(42, 3);<br/>
        facingPolys[1] = new Polygon();<br/>
        facingPolys[1].addPoint(69, 17);<br/>
        facingPolys[1].addPoint(64, 17);<br/>
        facingPolys[1].addPoint(68, 23);<br/>
        facingPolys[1].addPoint(70, 19);<br/>
        facingPolys[2] = new Polygon();<br/>
        facingPolys[2].addPoint(69, 53);<br/>
        facingPolys[2].addPoint(68, 49);<br/>
        facingPolys[2].addPoint(64, 55);<br/>
        facingPolys[2].addPoint(68, 54);<br/>
        facingPolys[3] = new Polygon();<br/>
        facingPolys[3].addPoint(41, 68);<br/>
        facingPolys[3].addPoint(38, 65);<br/>
        facingPolys[3].addPoint(45, 65);<br/>
        facingPolys[3].addPoint(42, 68);<br/>
        facingPolys[4] = new Polygon();<br/>
        facingPolys[4].addPoint(15, 53);<br/>
        facingPolys[4].addPoint(18, 54);<br/>
        facingPolys[4].addPoint(15, 48);<br/>
        facingPolys[4].addPoint(14, 52);<br/>
        facingPolys[5] = new Polygon();<br/>
        facingPolys[5].addPoint(13, 19);<br/>
        facingPolys[5].addPoint(15, 23);<br/>
        facingPolys[5].addPoint(19, 17);<br/>
        facingPolys[5].addPoint(17, 17);<br/>
<br/>
        // movement polygons<br/>
        movementPolys = new Polygon[8];<br/>
        movementPolys[0] = new Polygon();<br/>
        movementPolys[0].addPoint(41, 65);<br/>
        movementPolys[0].addPoint(38, 68);<br/>
        movementPolys[0].addPoint(45, 68);<br/>
        movementPolys[0].addPoint(42, 65);<br/>
        movementPolys[1] = new Polygon();<br/>
        movementPolys[1].addPoint(17, 48);<br/>
        movementPolys[1].addPoint(12, 48);<br/>
        movementPolys[1].addPoint(16, 54);<br/>
        movementPolys[1].addPoint(17, 49);<br/>
        movementPolys[2] = new Polygon();<br/>
        movementPolys[2].addPoint(18, 19);<br/>
        movementPolys[2].addPoint(17, 15);<br/>
        movementPolys[2].addPoint(13, 21);<br/>
        movementPolys[2].addPoint(17, 20);<br/>
        movementPolys[3] = new Polygon();<br/>
        movementPolys[3].addPoint(41, 6);<br/>
        movementPolys[3].addPoint(38, 3);<br/>
        movementPolys[3].addPoint(45, 3);<br/>
        movementPolys[3].addPoint(42, 6);<br/>
        movementPolys[4] = new Polygon();<br/>
        movementPolys[4].addPoint(67, 15);<br/>
        movementPolys[4].addPoint(66, 19);<br/>
        movementPolys[4].addPoint(67, 20);<br/>
        movementPolys[4].addPoint(71, 20);<br/>
        movementPolys[5] = new Polygon();<br/>
        movementPolys[5].addPoint(69, 55);<br/>
        movementPolys[5].addPoint(66, 50);<br/>
        movementPolys[5].addPoint(67, 49);<br/>
        movementPolys[5].addPoint(72, 48);<br/>
<br/>
        movementPolys[6] = new Polygon(); // up arrow with tail<br/>
        movementPolys[6].addPoint(35, 44);<br/>
        movementPolys[6].addPoint(30, 49);<br/>
        movementPolys[6].addPoint(33, 49);<br/>
        movementPolys[6].addPoint(33, 53);<br/>
        movementPolys[6].addPoint(38, 53);<br/>
        movementPolys[6].addPoint(38, 49);<br/>
        movementPolys[6].addPoint(41, 49);<br/>
        movementPolys[6].addPoint(36, 44);<br/>
        movementPolys[7] = new Polygon(); // down arrow with tail<br/>
        movementPolys[7].addPoint(34, 53);<br/>
        movementPolys[7].addPoint(29, 48);<br/>
        movementPolys[7].addPoint(32, 48);<br/>
        movementPolys[7].addPoint(32, 44);<br/>
        movementPolys[7].addPoint(37, 44);<br/>
        movementPolys[7].addPoint(37, 48);<br/>
        movementPolys[7].addPoint(40, 48);<br/>
        movementPolys[7].addPoint(35, 53);<br/>
    }<br/>
<br/>
    private synchronized boolean doMoveUnits(long idleTime) {<br/>
        boolean movingSomething = false;<br/>
<br/>
        if (movingUnits.size() &gt; 0) {<br/>
<br/>
            moveWait += idleTime;<br/>
<br/>
            if (moveWait &gt; GUIPreferences.getInstance().getInt("AdvancedMoveStepDelay")) {<br/>
<br/>
                java.util.Vector spent = new java.util.Vector();<br/>
<br/>
                for (int i = 0; i &lt; movingUnits.size(); i++) {<br/>
                    Object[] move = (Object[]) movingUnits.elementAt(i);<br/>
                    Entity e = (Entity) move[0];<br/>
                    java.util.Vector movePath = (java.util.Vector) move[1];<br/>
                    movingSomething = true;<br/>
                    Entity ge = game.getEntity(e.getId()); <br/>
                    if (movePath.size() &gt; 0) {<br/>
                        UnitLocation loc =<br/>
                            ( (UnitLocation) movePath.elementAt(0) );<br/>
                        if (ge != null) {<br/>
                            redrawMovingEntity( e,<br/>
                                                loc.getCoords(),<br/>
                                                loc.getFacing() );<br/>
                        }<br/>
                        movePath.removeElementAt(0);<br/>
                    } else {<br/>
                        if (ge != null) {<br/>
                            redrawEntity(ge);<br/>
                        }<br/>
                        spent.addElement(move);<br/>
                    }<br/>
<br/>
                }<br/>
<br/>
                for (int i = 0; i &lt; spent.size(); i++) {<br/>
                    Object[] move = (Object[]) spent.elementAt(i);<br/>
                    movingUnits.removeElement(move);<br/>
                }<br/>
                moveWait = 0;<br/>
<br/>
                if (movingUnits.size() == 0) {<br/>
                    movingEntitySpriteIds.clear();<br/>
                    movingEntitySprites.removeAllElements();<br/>
                    ghostEntitySprites.removeAllElements();<br/>
                    processBoardViewEvent(new BoardViewEvent(this, BoardViewEvent.FINISHED_MOVING_UNITS));<br/>
                }<br/>
            }<br/>
        }<br/>
        return movingSomething;<br/>
    }<br/>
<br/>
    //<br/>
    // KeyListener<br/>
    //<br/>
    public void keyPressed(KeyEvent ke) {<br/>
        switch(ke.getKeyCode()) {<br/>
        case KeyEvent.VK_NUMPAD7 :<br/>
            scroll.y -= 36;<br/>
            scroll.x -= 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD8 :<br/>
            scroll.y -= 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD9 :<br/>
            scroll.y -= 36;<br/>
            scroll.x += 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD1 :<br/>
            scroll.y += 36;<br/>
            scroll.x -= 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD2 :<br/>
            scroll.y += 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD3 :<br/>
            scroll.y += 36;<br/>
            scroll.x += 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD4 :<br/>
            scroll.x -= 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD6 :<br/>
            scroll.x += 36;<br/>
            break;<br/>
        case KeyEvent.VK_NUMPAD5 :<br/>
            // center on the selected entity<br/>
            java.util.Vector v = game.getPlayerEntities(localPlayer);<br/>
            Entity se = clientgui == null?null:game.getEntity(clientgui.getSelectedEntityNum());<br/>
            for (int i = 0; i &lt; v.size(); i++) {<br/>
                Entity e = (Entity) v.elementAt(i);<br/>
                if (e==se) {<br/>
                    centerOnHex(e.getPosition());<br/>
                }<br/>
            }<br/>
            break;<br/>
        case KeyEvent.VK_CONTROL :<br/>
            ctlKeyHeld = true;<br/>
            initCtlScroll = true;<br/>
            break;<br/>
        }<br/>
<br/>
        if (isTipShowing()) {<br/>
            hideTooltip();<br/>
        }<br/>
        lastIdle = System.currentTimeMillis();<br/>
        checkScrollBounds();<br/>
        repaint();<br/>
    }<br/>
<br/>
    public void keyReleased(KeyEvent ke) {<br/>
        if (ke.getKeyCode() == KeyEvent.VK_CONTROL) {<br/>
            ctlKeyHeld = false;<br/>
        }<br/>
    }<br/>
    public void keyTyped(KeyEvent ke) {<br/>
    }<br/>
<br/>
    //<br/>
    // MouseListener<br/>
    //<br/>
    public void mousePressed(MouseEvent me) {<br/>
        scrolled = false; // not scrolled yet<br/>
<br/>
        Point point = me.getPoint();<br/>
        if ( null == point ) {<br/>
            return;<br/>
        }<br/>
        oldMousePosition = point;<br/>
<br/>
        isTipPossible = false;<br/>
        for (int i = 0; i &lt; displayables.size(); i++) {<br/>
            Displayable disp = (Displayable) displayables.elementAt(i);<br/>
            if (disp.isHit(point, backSize)) {<br/>
                return;<br/>
            }<br/>
        }<br/>
<br/>
        // Disable scrolling when ctrl or alt is held down, since this<br/>
        //  means the user wants to use the LOS/ruler tools.<br/>
        int mask = InputEvent.CTRL_MASK | InputEvent.ALT_MASK;<br/>
        if ( !GUIPreferences.getInstance().getRightDragScroll() &amp;&amp;<br/>
            !GUIPreferences.getInstance().getAlwaysRightClickScroll() &amp;&amp;    <br/>
            game.getPhase() == IGame.PHASE_FIRING ) {<br/>
            // In the firing phase, also disable scrolling if<br/>
            // the right or middle buttons are clicked, since<br/>
            // this means the user wants to activate the<br/>
            // popup menu or ruler tool.<br/>
            mask |= InputEvent.BUTTON2_MASK | InputEvent.BUTTON3_MASK;<br/>
        }<br/>
<br/>
        // disable auto--edge-scrolling if no option set<br/>
        if ( !GUIPreferences.getInstance().getAutoEdgeScroll() ) {<br/>
            mask |= InputEvent.BUTTON1_MASK;<br/>
        }<br/>
        // disable edge-scrolling if no option set<br/>
        if ( !GUIPreferences.getInstance().getClickEdgeScroll() ) {<br/>
            mask |= InputEvent.BUTTON3_MASK;<br/>
        }<br/>
        <br/>
        if ( GUIPreferences.getInstance().getRightDragScroll() ) {<br/>
            mask |= InputEvent.BUTTON2_MASK;<br/>
        }<br/>
<br/>
        if ( (me.getModifiers() &amp; mask ) == 0 ) {<br/>
            isScrolling = true; //activate scrolling<br/>
        } else {<br/>
            isScrolling = false; //activate scrolling<br/>
        }<br/>
<br/>
        if (isTipShowing()) {<br/>
            hideTooltip();<br/>
        }<br/>
<br/>
        mouseAction(getCoordsAt(point), BOARD_HEX_DRAG, me.getModifiers());<br/>
    }<br/>
<br/>
    public void mouseReleased(MouseEvent me) {<br/>
        isTipPossible = true;<br/>
        oldMousePosition = mousePos;<br/>
<br/>
        for (int i = 0; i &lt; displayables.size(); i++) {<br/>
            Displayable disp = (Displayable) displayables.elementAt(i);<br/>
            if (disp.isReleased()) {<br/>
                return;<br/>
            }<br/>
        }<br/>
        isScrolling = false;<br/>
<br/>
        // no click action triggered if click was for scrolling the map. Real clicks are without scrolling.<br/>
        if (scrolled)<br/>
            return;<br/>
        if (me.getClickCount() == 1) {<br/>
            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_CLICK, me.getModifiers());<br/>
        } else {<br/>
            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_DOUBLECLICK, me.getModifiers());<br/>
        }<br/>
    }<br/>
<br/>
    public void mouseEntered(MouseEvent me) {<br/>
    }<br/>
<br/>
    public void mouseExited(MouseEvent me) {<br/>
        isTipPossible = false;<br/>
    }<br/>
    public void mouseClicked(MouseEvent me) {<br/>
    }<br/>
<br/>
    //<br/>
    // MouseMotionListener<br/>
    //<br/>
    public void mouseDragged(MouseEvent me) {<br/>
        isTipPossible = false;<br/>
<br/>
        Point point = me.getPoint();<br/>
        if ( null == point ) {<br/>
            return;<br/>
        }<br/>
<br/>
        for (int i = 0; i &lt; displayables.size(); i++) {<br/>
            Displayable disp = (Displayable) displayables.elementAt(i);<br/>
            if (disp.isDragged(point, backSize)) {<br/>
                repaint();<br/>
                return;<br/>
            }<br/>
        }<br/>
        mousePos = point;<br/>
<br/>
        // Disable scrolling when ctrl or alt is held down, since this<br/>
        //  means the user wants to use the LOS/ruler tools.<br/>
        int mask = InputEvent.CTRL_MASK | InputEvent.ALT_MASK;<br/>
<br/>
        if ( !GUIPreferences.getInstance().getRightDragScroll() &amp;&amp;<br/>
            !GUIPreferences.getInstance().getAlwaysRightClickScroll() &amp;&amp;<br/>
            game.getPhase() == IGame.PHASE_FIRING) {<br/>
            // In the firing phase, also disable scrolling if<br/>
            //  the right or middle buttons are clicked, since<br/>
            //  this means the user wants to activate the<br/>
            //  popup menu or ruler tool.<br/>
            mask |= InputEvent.BUTTON2_MASK | InputEvent.BUTTON3_MASK;<br/>
        }<br/>
<br/>
        if ( GUIPreferences.getInstance().getRightDragScroll() ) {<br/>
            mask |= InputEvent.BUTTON1_MASK | InputEvent.BUTTON2_MASK;<br/>
        }<br/>
<br/>
        // disable auto--edge-scrolling if no option set<br/>
        if ( !GUIPreferences.getInstance().getAutoEdgeScroll() ) {<br/>
            mask |= InputEvent.BUTTON1_MASK;<br/>
        }<br/>
<br/>
        // disable edge-scrolling if no option set<br/>
        if ( !GUIPreferences.getInstance().getClickEdgeScroll() &amp;&amp; !GUIPreferences.getInstance().getRightDragScroll() ) {<br/>
            mask |= InputEvent.BUTTON3_MASK;<br/>
        }<br/>
        <br/>
        if ( (me.getModifiers() &amp; mask ) == 0 ) {<br/>
            isScrolling = true; //activate scrolling<br/>
        } else {<br/>
            isScrolling = false; //activate scrolling<br/>
        }<br/>
<br/>
        mouseAction(getCoordsAt(point), BOARD_HEX_DRAG, me.getModifiers());<br/>
    }<br/>
<br/>
    public void mouseMoved(MouseEvent me) {<br/>
        Point point = me.getPoint();<br/>
        if ( null == point ) {<br/>
            return;<br/>
        }<br/>
<br/>
        for (int i = 0; i &lt; displayables.size(); i++) {<br/>
            Displayable disp = (Displayable) displayables.elementAt(i);<br/>
            if (disp.isBeingDragged()) {<br/>
                isTipPossible = false;<br/>
                return;<br/>
            }<br/>
            if (backSize != null) {<br/>
                disp.isMouseOver(point, backSize);<br/>
            }<br/>
        }<br/>
        mousePos = point;<br/>
        if (isTipShowing()) {<br/>
            hideTooltip();<br/>
        }<br/>
        if (ctlKeyHeld &amp;&amp; GUIPreferences.getInstance().getCtlScroll()) {<br/>
            if (initCtlScroll) {<br/>
                previousMouseX = me.getX();<br/>
                previousMouseY = me.getY();<br/>
                initCtlScroll = false;<br/>
            }<br/>
            scroll.x += GUIPreferences.getInstance().getScrollSensitivity() * (me.getX() - previousMouseX);<br/>
            scroll.y += GUIPreferences.getInstance().getScrollSensitivity() * (me.getY() - previousMouseY);<br/>
            previousMouseX = me.getX();<br/>
            previousMouseY = me.getY();<br/>
            checkScrollBounds();<br/>
            repaint();<br/>
        }<br/>
        lastIdle = System.currentTimeMillis();<br/>
        isTipPossible = true;<br/>
    }<br/>
<br/>
    /**<br/>
     * Increases zoomIndex and refreshes the map.<br/>
     * <br/>
     */<br/>
    public void zoomIn(){<br/>
        int tmpZoomIndex = zoomIndex + 1;<br/>
        if ( isJ2RE == true ){<br/>
            zoomIndex++;<br/>
            zoom();<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Decreases zoomIndex and refreshes the map.<br/>
     *<br/>
     */<br/>
    public void zoomOut(){<br/>
        if ( isJ2RE == true ){<br/>
            zoomIndex--;<br/>
            zoom();<br/>
        }<br/>
        }<br/>
<br/>
    /**<br/>
     * zoomIndex is a reference to a static array of scale factors.<br/>
     * The index ranges from 0 to 9 and by default is set to 7 which corresponds<br/>
     * to a scale of 1.0 (draws megamek images at normal size).  To zoom out the<br/>
     * index needs to be set to a lower value.  To zoom in make it larger.<br/>
     * If only zooming a step at a time use the zoomIn and zoomOut methods instead.<br/>
     * <br/>
     * @param zoomIndex<br/>
     */<br/>
    public void setZoomIndex( int zoomIndex ){<br/>
        if ( isJ2RE == true ){<br/>
            this.zoomIndex = zoomIndex;<br/>
            zoom();<br/>
        }<br/>
    }<br/>
<br/>
    public int getZoomIndex(){<br/>
        return zoomIndex;<br/>
    }<br/>
    <br/>
    private void checkZoomIndex(){<br/>
        if ( zoomIndex &gt; ZOOM_FACTORS.length-1 ) {<br/>
            zoomIndex = ZOOM_FACTORS.length-1;<br/>
        }<br/>
        if ( zoomIndex &lt; 0 ) zoomIndex = 0;<br/>
    }<br/>
    <br/>
    //<br/>
    // Changes hex dimensions and refreshes the map with the new scale<br/>
    //<br/>
    private void zoom(){<br/>
        checkZoomIndex();<br/>
        scale = ZOOM_FACTORS[zoomIndex];<br/>
        GUIPreferences.getInstance().setMapZoomIndex(zoomIndex);<br/>
<br/>
        hex_size = new Dimension((int)(HEX_W*scale), (int)(HEX_H*scale));<br/>
<br/>
        final Dimension size = getSize();<br/>
        //Coords c = getCoordsAt(new Point((int)(size.width/2), (int)(size.height/2)));<br/>
<br/>
        boardGraph=null;<br/>
        backGraph=null;<br/>
        hasZoomed=true;<br/>
<br/>
        updateBoardSize();<br/>
<br/>
        view.setLocation(scroll);<br/>
        view.setSize(getOptimalView(size));<br/>
        offset.setLocation(getOptimalOffset(size));<br/>
<br/>
        updateFontSizes();<br/>
        updateBoardImage();<br/>
        <br/>
        update(this.getGraphics());<br/>
    }<br/>
    <br/>
    private void updateFontSizes(){<br/>
        if ( zoomIndex &lt;= 4 ) {<br/>
                font_elev = FONT_7;<br/>
                font_hexnum = FONT_7;<br/>
                font_minefield = FONT_7;<br/>
        }<br/>
        if ( zoomIndex &lt;= 5 &amp; zoomIndex &gt; 4 ){<br/>
                font_elev = FONT_8;<br/>
                font_hexnum = FONT_8;<br/>
                font_minefield = FONT_8;<br/>
        }<br/>
        if ( zoomIndex &gt; 5 ){<br/>
            font_elev = FONT_9;<br/>
            font_hexnum = FONT_9;<br/>
            font_minefield = FONT_9;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Displays a bit of text in a box.<br/>
     *<br/>
     * TODO: make multi-line<br/>
     */<br/>
    private class TooltipCanvas extends Canvas<br/>
    {<br/>
        private String[] tipStrings;<br/>
        private Dimension size;<br/>
<br/>
        public TooltipCanvas(String[] tipStrings) {<br/>
            this.tipStrings = tipStrings;<br/>
<br/>
            // setup<br/>
            setFont(new Font("SansSerif", Font.PLAIN, 12)); //$NON-NLS-1$<br/>
            setBackground(SystemColor.info);<br/>
            setForeground(SystemColor.infoText);<br/>
<br/>
            // determine size<br/>
            final FontMetrics fm = getFontMetrics(getFont());<br/>
            int width = 0;<br/>
            for (int i = 0; i &lt; tipStrings.length; i++) {<br/>
                if (fm.stringWidth(tipStrings[i]) &gt; width) {<br/>
                    width = fm.stringWidth(tipStrings[i]);<br/>
                }<br/>
            }<br/>
            size = new Dimension(width + 5, fm.getAscent() * tipStrings.length + 4);<br/>
            setSize(size);<br/>
        }<br/>
<br/>
        public void paint(Graphics g) {<br/>
            final FontMetrics fm = getFontMetrics(getFont());<br/>
            g.setColor(getBackground());<br/>
            g.fillRect(0, 0, size.width, size.height);<br/>
            g.setColor(getForeground());<br/>
            g.drawRect(0, 0, size.width - 1, size.height - 1);<br/>
            for (int i = 0; i &lt; tipStrings.length; i++) {<br/>
                g.drawString(tipStrings[i], 2, (i + 1) * fm.getAscent());<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Everything in the main map view is either the board or it's a sprite<br/>
     * displayed on top of the board.  Most sprites store a transparent image<br/>
     * which they draw onto the screen when told to.  Sprites keep a bounds<br/>
     * rectangle, so it's easy to tell when they'return onscreen.<br/>
     */<br/>
    private abstract class Sprite implements ImageObserver<br/>
    {<br/>
        protected Rectangle bounds;<br/>
        protected Image image;<br/>
<br/>
        /**<br/>
         * Do any necessary preparation.  This is called after creation,<br/>
         * but before drawing, when a device context is ready to draw with.<br/>
         */<br/>
        public abstract void prepare();<br/>
<br/>
        /**<br/>
         * When we draw our buffered images, it's necessary to implement<br/>
         * the ImageObserver interface.  This provides the necesasry<br/>
         * functionality.<br/>
         */<br/>
        public boolean imageUpdate(Image image, int infoflags, int x, int y,<br/>
                                   int width, int height) {<br/>
            if (infoflags == ImageObserver.ALLBITS) {<br/>
                prepare();<br/>
                repaint();<br/>
                return false;<br/>
            } else {<br/>
                return true;<br/>
            }<br/>
        }<br/>
<br/>
        /**<br/>
         * Returns our bounding rectangle.  The coordinates here are stored<br/>
         * with the top left corner of the _board_ being 0, 0, so these do<br/>
         * not always correspond to screen coordinates.<br/>
         */<br/>
        public Rectangle getBounds() {<br/>
            return bounds;<br/>
        }<br/>
<br/>
        /**<br/>
         * Are we ready to draw?  By default, checks to see that our buffered<br/>
         * image has been created.<br/>
         */<br/>
        public boolean isReady() {<br/>
            return image != null;<br/>
        }<br/>
<br/>
        /**<br/>
         * Draws this sprite onto the specified graphics context.<br/>
         */<br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer) {<br/>
            drawOnto(g, x, y, observer, false);<br/>
        }<br/>
<br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer, boolean makeTranslucent) {<br/>
            if (isReady()) {<br/>
                Image tmpImage;<br/>
                if (zoomIndex == BASE_ZOOM_INDEX ){<br/>
                    tmpImage = image;<br/>
                } else {<br/>
                    tmpImage = getScaledImage(image);<br/>
                }<br/>
                if (makeTranslucent &amp;&amp; isJ2RE) {<br/>
                    Graphics2D g2 = (Graphics2D) g;<br/>
                    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));<br/>
                    g2.drawImage(tmpImage, x, y, observer);<br/>
                    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));<br/>
                } else {<br/>
                    g.drawImage(tmpImage, x, y, observer);<br/>
                }<br/>
            } else {<br/>
                // grrr... we'll be ready next time!<br/>
                prepare();<br/>
            }<br/>
        }<br/>
<br/>
        /**<br/>
         * Returns true if the point is inside this sprite.  Uses board<br/>
         * coordinates, not screen coordinates.   By default, just checks our<br/>
         * bounding rectangle, though some sprites override this for a smaller<br/>
         * sensitive area.<br/>
         */<br/>
        public boolean isInside(Point point) {<br/>
            return bounds.contains(point);<br/>
        }<br/>
<br/>
        /**<br/>
         * Since most sprites being drawn correspond to something in the game,<br/>
         * this returns a little info for a tooltip.<br/>
         */<br/>
        private String[] getTooltip() {<br/>
            return null;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sprite for a cursor.  Just a hexagon outline in a specified color.<br/>
     */<br/>
    private class CursorSprite extends Sprite<br/>
    {<br/>
        private Color color;<br/>
        private Coords hexLoc;<br/>
        <br/>
        public CursorSprite(Color color) {<br/>
            this.color = color;<br/>
            this.bounds = new Rectangle(hexPoly.getBounds().width + 1,<br/>
                    hexPoly.getBounds().height + 1);<br/>
            this.image = null;<br/>
<br/>
            // start offscreen<br/>
            setOffScreen();<br/>
        }<br/>
<br/>
        public void prepare() {<br/>
            // create image for buffer<br/>
            Image tempImage = createImage(bounds.width, bounds.height);<br/>
            Graphics graph = tempImage.getGraphics();<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
            // draw attack poly<br/>
            graph.setColor(color);<br/>
            graph.drawPolygon(hexPoly);<br/>
<br/>
            // create final image<br/>
            this.image = createImage(new FilteredImageSource(tempImage.getSource(),<br/>
                                                             new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
<br/>
        public void setOffScreen(){<br/>
            bounds.setLocation(-100, -100);<br/>
            hexLoc = new Coords(-2, -2);<br/>
        }<br/>
        <br/>
        public void setHexLocation( Coords hexLoc ){<br/>
            this.hexLoc = hexLoc;<br/>
            bounds.setLocation(getHexLocation(hexLoc));<br/>
        }<br/>
        <br/>
        public Rectangle getBounds(){<br/>
            this.bounds = new Rectangle(hexPoly.getBounds().width + 1,<br/>
                    hexPoly.getBounds().height + 1);<br/>
            bounds.setLocation(getHexLocation( hexLoc ));<br/>
            <br/>
            return bounds;<br/>
        }<br/>
    }<br/>
<br/>
    <br/>
    private class GhostEntitySprite extends Sprite {<br/>
        private Entity entity;<br/>
        private Rectangle entityRect;<br/>
        private Rectangle modelRect;<br/>
<br/>
        public GhostEntitySprite(Entity entity) {<br/>
            this.entity = entity;<br/>
<br/>
            String shortName = entity.getShortName();<br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            modelRect = new Rectangle(47, 55,<br/>
                            getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                            getFontMetrics(font).getAscent());<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
<br/>
            this.bounds = tempBounds;<br/>
            this.entityRect = new Rectangle(<br/>
                    bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale), <br/>
                    (int)(44*scale), <br/>
                    (int)(44*scale));<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        /**<br/>
         * Creates the sprite for this entity.  It is an extra pain to<br/>
         * create transparent images in AWT.<br/>
         */<br/>
        public void prepare() {<br/>
            // create image for buffer<br/>
            Image tempImage;<br/>
            Graphics graph;<br/>
            try {<br/>
                tempImage = createImage(bounds.width, bounds.height);<br/>
                graph = tempImage.getGraphics();<br/>
            } catch (NullPointerException ex) {<br/>
                // argh!  but I want it!<br/>
                return;<br/>
            }<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
<br/>
            // draw entity image<br/>
            graph.drawImage(tileManager.imageFor(entity), 0, 0, this);<br/>
<br/>
            // create final image<br/>
            this.image = createImage(new FilteredImageSource(tempImage.getSource(),<br/>
                                                             new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
<br/>
        public Rectangle getBounds(){<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
            this.bounds = tempBounds;<br/>
        <br/>
            this.entityRect = new Rectangle(bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale),<br/>
                    (int)(44*scale),<br/>
                    (int)(44*scale));<br/>
            <br/>
            return bounds;<br/>
        }<br/>
        <br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer) {<br/>
            drawOnto(g, x, y, observer, true);<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    private class MovingEntitySprite extends Sprite {<br/>
        private int facing;<br/>
        private Entity entity;<br/>
        private Rectangle entityRect;<br/>
        private Rectangle modelRect;<br/>
<br/>
        public MovingEntitySprite(Entity entity, Coords position, int facing) {<br/>
            this.entity = entity;<br/>
            this.facing = facing;<br/>
<br/>
            String shortName = entity.getShortName();<br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            modelRect = new Rectangle(47, 55,<br/>
                            getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                            getFontMetrics(font).getAscent());<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(position));<br/>
<br/>
            this.bounds = tempBounds;<br/>
            this.entityRect = new Rectangle(bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale),<br/>
                    (int)(44*scale),<br/>
                    (int)(44*scale));<br/>
            this.image = null;<br/>
        }<br/>
        <br/>
        /**<br/>
         * Creates the sprite for this entity.  It is an extra pain to<br/>
         * create transparent images in AWT.<br/>
         */<br/>
        public void prepare() {<br/>
            // create image for buffer<br/>
            Image tempImage;<br/>
            Graphics graph;<br/>
            try {<br/>
                tempImage = createImage(bounds.width, bounds.height);<br/>
                graph = tempImage.getGraphics();<br/>
            } catch (NullPointerException ex) {<br/>
                // argh!  but I want it!<br/>
                return;<br/>
            }<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
<br/>
            // draw entity image<br/>
            graph.drawImage(tileManager.imageFor(entity, facing), 0, 0, this);<br/>
<br/>
            // create final image<br/>
            this.image = createImage(new FilteredImageSource(tempImage.getSource(),<br/>
                                                             new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
    }<br/>
<br/>
<br/>
    /**<br/>
     * Sprite for an wreck.  Consists<br/>
     * of an image, drawn from the Tile Manager and an identification label.<br/>
     */<br/>
    private class WreckSprite extends Sprite<br/>
    {<br/>
        private Entity entity;<br/>
        private Rectangle entityRect;<br/>
        private Rectangle modelRect;<br/>
<br/>
        public WreckSprite(Entity entity) {<br/>
            this.entity = entity;<br/>
<br/>
            String shortName = entity.getShortName();<br/>
            <br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            modelRect = new Rectangle(47, 55,<br/>
                                    getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                                    getFontMetrics(font).getAscent());<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
<br/>
            this.bounds = tempBounds;<br/>
            this.entityRect = new Rectangle(<br/>
                    bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale),<br/>
                    (int)(44*scale),<br/>
                    (int)(44*scale));<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        public Rectangle getBounds(){<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
            this.bounds = tempBounds;<br/>
        <br/>
            this.entityRect = new Rectangle(<br/>
                    bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale),<br/>
                    (int)(44*scale),<br/>
                    (int)(44*scale));<br/>
            <br/>
            return bounds;<br/>
        }<br/>
        <br/>
        /**<br/>
         * Creates the sprite for this entity.  It is an extra pain to<br/>
         * create transparent images in AWT.<br/>
         */<br/>
        public void prepare() {<br/>
            // figure out size<br/>
            String shortName = entity.getShortName();<br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            Rectangle tempRect =<br/>
                new Rectangle(47, 55,<br/>
                              getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                              getFontMetrics(font).getAscent());<br/>
<br/>
            // create image for buffer<br/>
            Image tempImage;<br/>
            Graphics graph;<br/>
            try {<br/>
                tempImage = createImage(bounds.width, bounds.height);<br/>
                graph = tempImage.getGraphics();<br/>
            } catch (NullPointerException ex) {<br/>
                // argh!  but I want it!<br/>
                return;<br/>
            }<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
<br/>
            // Draw wreck image,if we've got one.<br/>
            Image wreck = tileManager.wreckMarkerFor(entity);<br/>
            if ( null != wreck ) {<br/>
                graph.drawImage( wreck, 0, 0, this );<br/>
            }<br/>
<br/>
            // draw box with shortName<br/>
            Color text = Color.lightGray;<br/>
            Color bkgd = Color.darkGray;<br/>
            Color bord = Color.black;<br/>
<br/>
            graph.setFont(font);<br/>
            graph.setColor(bord);<br/>
            graph.fillRect(tempRect.x, tempRect.y,<br/>
                           tempRect.width, tempRect.height);<br/>
            tempRect.translate(-1, -1);<br/>
            graph.setColor(bkgd);<br/>
            graph.fillRect(tempRect.x, tempRect.y,<br/>
                           tempRect.width, tempRect.height);<br/>
            graph.setColor(text);<br/>
            graph.drawString(shortName, tempRect.x + 1,<br/>
                             tempRect.y + tempRect.height - 1);<br/>
<br/>
            // create final image<br/>
            this.image = createImage<br/>
                (new FilteredImageSource(tempImage.getSource(),<br/>
                                         new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
<br/>
        /**<br/>
         * Overrides to provide for a smaller sensitive area.<br/>
         */<br/>
        public boolean isInside(Point point) {<br/>
            return false;<br/>
        }<br/>
<br/>
    }<br/>
    /**<br/>
     * Sprite for an entity.  Changes whenever the entity changes.  Consists<br/>
     * of an image, drawn from the Tile Manager; facing and possibly secondary<br/>
     * facing arrows; armor and internal bars; and an identification label.<br/>
     */<br/>
    private class EntitySprite extends Sprite<br/>
    {<br/>
        private Entity entity;<br/>
        private Rectangle entityRect;<br/>
        private Rectangle modelRect;<br/>
<br/>
        public EntitySprite(Entity entity) {<br/>
            this.entity = entity;<br/>
<br/>
            String shortName = entity.getShortName();<br/>
            <br/>
            if (entity.getMovementMode() == IEntityMovementMode.VTOL) {<br/>
                shortName = shortName.concat(" (FL: ").concat(Integer.toString(entity.getElevation())).concat(")");<br/>
            }<br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            modelRect = new Rectangle(47, 55,<br/>
                                        getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                                        getFontMetrics(font).getAscent());<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
<br/>
            this.bounds = tempBounds;<br/>
            this.entityRect = new Rectangle(bounds.x + (int)(20*scale),<br/>
                                            bounds.y + (int)(14*scale),<br/>
                                            (int)(44*scale),<br/>
                                            (int)(44*scale));<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        public Rectangle getBounds(){<br/>
            Rectangle tempBounds = new Rectangle(hex_size).union(modelRect);<br/>
            tempBounds.setLocation(getHexLocation(entity.getPosition()));<br/>
            this.bounds = tempBounds;<br/>
        <br/>
            this.entityRect = new Rectangle(<br/>
                    bounds.x + (int)(20*scale),<br/>
                    bounds.y + (int)(14*scale),<br/>
                    (int)(44*scale),<br/>
                    (int)(44*scale));<br/>
            <br/>
            return bounds;<br/>
        }<br/>
        <br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer) {<br/>
            if (trackThisEntitiesVisibilityInfo(this.entity)<br/>
                &amp;&amp; !this.entity.isVisibleToEnemy()) {<br/>
                // create final image with translucency<br/>
                drawOnto(g, x, y, observer, true);<br/>
            } else {<br/>
                drawOnto(g, x, y, observer, false);<br/>
            }<br/>
        }<br/>
<br/>
        /**<br/>
         * Creates the sprite for this entity.  It is an extra pain to<br/>
         * create transparent images in AWT.<br/>
         */<br/>
        public void prepare() {<br/>
            // figure out size<br/>
            String shortName = entity.getShortName();<br/>
            if (entity.getMovementMode() == IEntityMovementMode.VTOL) {<br/>
                shortName = shortName.concat(" (FL: ").concat(Integer.toString(entity.getElevation())).concat(")");<br/>
            }<br/>
            if (PreferenceManager.getClientPreferences().getShowUnitId()) {<br/>
                shortName+=(Messages.getString("BoardView1.ID")+entity.getId()); //$NON-NLS-1$<br/>
            }<br/>
            Font font = new Font("SansSerif", Font.PLAIN, 10); //$NON-NLS-1$<br/>
            Rectangle tempRect =<br/>
                new Rectangle(47, 55,<br/>
                              getFontMetrics(font).stringWidth(shortName) + 1,<br/>
                              getFontMetrics(font).getAscent());<br/>
<br/>
            // create image for buffer<br/>
            Image tempImage;<br/>
            Graphics graph;<br/>
            try {<br/>
                tempImage = createImage(bounds.width, bounds.height);<br/>
                graph = tempImage.getGraphics();<br/>
            } catch (NullPointerException ex) {<br/>
                // argh!  but I want it!<br/>
                return;<br/>
            }<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
<br/>
            // draw entity image<br/>
            graph.drawImage(tileManager.imageFor(entity), 0, 0, this);<br/>
<br/>
            // draw box with shortName<br/>
            Color text, bkgd, bord;<br/>
            if (entity.isDone()) {<br/>
                text = Color.lightGray;<br/>
                bkgd = Color.darkGray;<br/>
                bord = Color.black;<br/>
            } else if (entity.isImmobile()) {<br/>
                text = Color.darkGray;<br/>
                bkgd = Color.black;<br/>
                bord = Color.lightGray;<br/>
            } else {<br/>
                text = Color.black;<br/>
                bkgd = Color.lightGray;<br/>
                bord = Color.darkGray;<br/>
            }<br/>
            graph.setFont(font);<br/>
            graph.setColor(bord);<br/>
            graph.fillRect(tempRect.x, tempRect.y,<br/>
                           tempRect.width, tempRect.height);<br/>
            tempRect.translate(-1, -1);<br/>
            graph.setColor(bkgd);<br/>
            graph.fillRect(tempRect.x, tempRect.y,<br/>
                           tempRect.width, tempRect.height);<br/>
            graph.setColor(text);<br/>
            graph.drawString(shortName, tempRect.x + 1,<br/>
                             tempRect.y + tempRect.height - 1);<br/>
<br/>
            // draw facing<br/>
            graph.setColor(Color.white);<br/>
            if (entity.getFacing() != -1) {<br/>
                graph.drawPolygon(facingPolys[entity.getFacing()]);<br/>
            }<br/>
<br/>
            // determine secondary facing for non-mechs &amp; flipped arms<br/>
            int secFacing = entity.getFacing();<br/>
            if (!(entity instanceof Mech || entity instanceof Protomech)) {<br/>
                secFacing = entity.getSecondaryFacing();<br/>
            } else if (entity.getArmsFlipped()) {<br/>
                secFacing = (entity.getFacing() + 3) % 6;<br/>
            }<br/>
            // draw red secondary facing arrow if necessary<br/>
            if (secFacing != -1 &amp;&amp; secFacing != entity.getFacing()) {<br/>
                graph.setColor(Color.red);<br/>
                graph.drawPolygon(facingPolys[secFacing]);<br/>
            }<br/>
<br/>
            // Determine if the entity is a tank with a locked turret.<br/>
            boolean turretLocked = false;<br/>
            if ( entity instanceof Tank &amp;&amp;<br/>
                 !( (Tank) entity ).hasNoTurret() &amp;&amp;<br/>
                 !entity.canChangeSecondaryFacing() ) {<br/>
                turretLocked = true;<br/>
            }<br/>
<br/>
            // draw condition strings<br/>
            if ( entity.isImmobile() &amp;&amp; !entity.isProne() &amp;&amp; !turretLocked ) {<br/>
                // draw "IMMOBILE"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 18, 39); //$NON-NLS-1$<br/>
                graph.setColor(Color.red);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 17, 38); //$NON-NLS-1$<br/>
            } else if (!entity.isImmobile() &amp;&amp; entity.isProne()) {<br/>
                // draw "PRONE"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.PRONE"), 26, 39); //$NON-NLS-1$<br/>
                graph.setColor(Color.yellow);<br/>
                graph.drawString(Messages.getString("BoardView1.PRONE"), 25, 38); //$NON-NLS-1$<br/>
            } else if ( !entity.isImmobile() &amp;&amp; turretLocked ) {<br/>
                // draw "LOCKED"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.LOCKED"), 22, 39); //$NON-NLS-1$<br/>
                graph.setColor(Color.yellow);<br/>
                graph.drawString(Messages.getString("BoardView1.LOCKED"), 21, 38); //$NON-NLS-1$<br/>
            } else if (entity.isImmobile() &amp;&amp; entity.isProne()) {<br/>
                // draw "IMMOBILE" and "PRONE"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 18, 35); //$NON-NLS-1$<br/>
                graph.drawString(Messages.getString("BoardView1.PRONE"), 26, 48); //$NON-NLS-1$<br/>
                graph.setColor(Color.red);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 17, 34); //$NON-NLS-1$<br/>
                graph.setColor(Color.yellow);<br/>
                graph.drawString(Messages.getString("BoardView1.PRONE"), 25, 47); //$NON-NLS-1$<br/>
            } else if ( entity.isImmobile() &amp;&amp; turretLocked ) {<br/>
                // draw "IMMOBILE" and "LOCKED"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 18, 35); //$NON-NLS-1$<br/>
                graph.drawString(Messages.getString("BoardView1.LOCKED"), 22, 48); //$NON-NLS-1$<br/>
                graph.setColor(Color.red);<br/>
                graph.drawString(Messages.getString("BoardView1.IMMOBILE"), 17, 34); //$NON-NLS-1$<br/>
                graph.setColor(Color.yellow);<br/>
                graph.drawString(Messages.getString("BoardView1.LOCKED"), 21, 47); //$NON-NLS-1$<br/>
            }<br/>
<br/>
            // If this unit is being swarmed or is swarming another, say so.<br/>
            if ( Entity.NONE != entity.getSwarmAttackerId() ) {<br/>
                // draw "SWARMED"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.SWARMED"), 17, 22); //$NON-NLS-1$<br/>
                graph.setColor(Color.red);<br/>
                graph.drawString(Messages.getString("BoardView1.SWARMED"), 16, 21); //$NON-NLS-1$<br/>
            }<br/>
<br/>
            // If this unit is transporting another, say so.<br/>
            if ((entity.getLoadedUnits()).size() &gt; 0) {<br/>
                // draw "T"<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString("T", 20, 71); //$NON-NLS-1$<br/>
                graph.setColor(Color.black);<br/>
                graph.drawString("T", 19, 70); //$NON-NLS-1$<br/>
            }<br/>
            <br/>
            // If this unit is stuck, say so.<br/>
            if ((entity.isStuck())) {<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(Messages.getString("BoardView1.STUCK"), 26, 61); //$NON-NLS-1$<br/>
                graph.setColor(Color.orange);<br/>
                graph.drawString(Messages.getString("BoardView1.STUCK"), 25, 60); //$NON-NLS-1$<br/>
                <br/>
            }<br/>
<br/>
            // If this unit is currently unknown to the enemy, say so.<br/>
            if (trackThisEntitiesVisibilityInfo(entity)) {<br/>
                if (!entity.isSeenByEnemy()) {<br/>
                    // draw "U"<br/>
                    graph.setColor(Color.darkGray);<br/>
                    graph.drawString("U", 30, 71); //$NON-NLS-1$<br/>
                    graph.setColor(Color.black);<br/>
                    graph.drawString("U", 29, 70); //$NON-NLS-1$<br/>
                } else if (!entity.isVisibleToEnemy() &amp;&amp; !isJ2RE) {<br/>
                    // If this unit is currently hidden from the enemy, say so.<br/>
                    // draw "H"<br/>
                    graph.setColor(Color.darkGray);<br/>
                    graph.drawString("H", 30, 71); //$NON-NLS-1$<br/>
                    graph.setColor(Color.black);<br/>
                    graph.drawString("H", 29, 70); //$NON-NLS-1$<br/>
                }<br/>
            }<br/>
<br/>
            //Lets draw our armor and internal status bars<br/>
            int baseBarLength = 23;<br/>
            int barLength = 0;<br/>
            double percentRemaining = 0.00;<br/>
<br/>
            percentRemaining = entity.getArmorRemainingPercent();<br/>
            barLength = (int)(baseBarLength * percentRemaining);<br/>
<br/>
            graph.setColor(Color.darkGray);<br/>
            graph.fillRect(56, 7, 23, 3);<br/>
            graph.setColor(Color.lightGray);<br/>
            graph.fillRect(55, 6, 23, 3);<br/>
            graph.setColor(getStatusBarColor(percentRemaining));<br/>
            graph.fillRect(55, 6, barLength, 3);<br/>
<br/>
            percentRemaining = entity.getInternalRemainingPercent();<br/>
            barLength = (int)(baseBarLength * percentRemaining);<br/>
<br/>
            graph.setColor(Color.darkGray);<br/>
            graph.fillRect(56, 11, 23, 3);<br/>
            graph.setColor(Color.lightGray);<br/>
            graph.fillRect(55, 10, 23, 3);<br/>
            graph.setColor(getStatusBarColor(percentRemaining));<br/>
            graph.fillRect(55, 10, barLength, 3);<br/>
<br/>
            // create final image<br/>
            this.image = createImage(new FilteredImageSource(tempImage.getSource(),<br/>
                                                             new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
<br/>
        /*<br/>
         * We only want to show double-blind visibility indicators on<br/>
         * our own mechs and teammates mechs (assuming team vision option).<br/>
         */<br/>
        private boolean trackThisEntitiesVisibilityInfo(Entity e) {<br/>
            if (getLocalPlayer() == null) {<br/>
                return false;<br/>
            }<br/>
<br/>
            if (game.getOptions().booleanOption("double_blind") //$NON-NLS-1$<br/>
                &amp;&amp; (e.getOwner().getId() == getLocalPlayer().getId()<br/>
                    || (game.getOptions().booleanOption("team_vision") //$NON-NLS-1$<br/>
                        &amp;&amp; e.getOwner().getTeam() == getLocalPlayer().getTeam()))) {<br/>
                return true;<br/>
            } else {<br/>
                return false;<br/>
            }<br/>
        }<br/>
<br/>
        private Color getStatusBarColor(double percentRemaining) {<br/>
            if ( percentRemaining &lt;= .25 )<br/>
                return Color.red;<br/>
            else if ( percentRemaining &lt;= .75 )<br/>
                return Color.yellow;<br/>
            else<br/>
                return new Color(16, 196, 16);<br/>
        }<br/>
<br/>
        /**<br/>
         * Overrides to provide for a smaller sensitive area.<br/>
         */<br/>
        public boolean isInside(Point point) {<br/>
            return entityRect.contains(     point.x + view.x - offset.x,<br/>
                                        point.y + view.y - offset.y);<br/>
        }<br/>
<br/>
        private String[] getTooltip() {<br/>
            String[] tipStrings = new String[3];<br/>
            StringBuffer buffer;<br/>
<br/>
            buffer = new StringBuffer();<br/>
            buffer.append( entity.getChassis() )<br/>
                .append( " (" ) //$NON-NLS-1$<br/>
                .append( entity.getOwner().getName() )<br/>
                .append( "); " ) //$NON-NLS-1$<br/>
                .append( entity.getCrew().getGunnery() )<br/>
                .append( "/" ) //$NON-NLS-1$<br/>
                .append( entity.getCrew().getPiloting() )<br/>
                .append( Messages.getString("BoardView1.pilot") ); //$NON-NLS-1$<br/>
            int numAdv = entity.getCrew().countAdvantages();<br/>
            if (numAdv &gt; 0) {<br/>
                buffer.append( " &lt;" ) //$NON-NLS-1$<br/>
                    .append( numAdv )<br/>
                    .append( Messages.getString("BoardView1.advs") ); //$NON-NLS-1$<br/>
            }<br/>
            tipStrings[0] = buffer.toString();<br/>
<br/>
            buffer = new StringBuffer();<br/>
            buffer.append( Messages.getString("BoardView1.move") ) //$NON-NLS-1$<br/>
                .append( entity.getMovementAbbr(entity.moved) )<br/>
                .append( ":" ) //$NON-NLS-1$<br/>
                .append( entity.delta_distance )<br/>
                .append( " (+" ) //$NON-NLS-1$<br/>
                .append( Compute.getTargetMovementModifier<br/>
                         (game, entity.getId()).getValue() )<br/>
                .append( ");" ) //$NON-NLS-1$<br/>
                .append( Messages.getString("BoardView1.Heat") ) //$NON-NLS-1$<br/>
                .append( entity.heat );<br/>
            if (entity.isDone())<br/>
                buffer.append(" (").append(Messages.getString("BoardView1.done")).append(")");<br/>
            tipStrings[1] = buffer.toString();<br/>
<br/>
            buffer = new StringBuffer();<br/>
            buffer.append( Messages.getString("BoardView1.Armor") ) //$NON-NLS-1$<br/>
                .append( entity.getTotalArmor() )<br/>
                .append( Messages.getString("BoardView1.internal") ) //$NON-NLS-1$<br/>
                .append( entity.getTotalInternal() );<br/>
            tipStrings[2] = buffer.toString();<br/>
<br/>
            return tipStrings;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Sprite for a step in a movement path.  Only one sprite should exist for<br/>
     * any hex in a path.  Contains a colored number, and arrows indicating<br/>
     * entering, exiting or turning.<br/>
     */<br/>
    private class StepSprite extends Sprite<br/>
    {<br/>
        private MoveStep step;<br/>
<br/>
        public StepSprite(MoveStep step) {<br/>
            this.step = step;<br/>
<br/>
            // step is the size of the hex that this step is in<br/>
            bounds = new Rectangle(getHexLocation(step.getPosition()), hex_size);<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        public void prepare() {<br/>
            // create image for buffer<br/>
            Image tempImage = createImage(bounds.width, bounds.height);<br/>
            Graphics graph = tempImage.getGraphics();<br/>
<br/>
            // fill with key color<br/>
            graph.setColor(new Color(TRANSPARENT));<br/>
            graph.fillRect(0, 0, bounds.width, bounds.height);<br/>
<br/>
            // setup some variables<br/>
            final Point stepPos = getHexLocation(step.getPosition());<br/>
            stepPos.translate(-bounds.x, -bounds.y);<br/>
            final Polygon facingPoly = facingPolys[step.getFacing()];<br/>
            final Polygon movePoly = movementPolys[step.getFacing()];<br/>
            Point offsetCostPos;<br/>
            Polygon myPoly;<br/>
            Color col;<br/>
            // set color<br/>
            switch (step.getMovementType()) {<br/>
                case IEntityMovementType.MOVE_RUN:<br/>
                case IEntityMovementType.MOVE_VTOL_RUN:<br/>
                    if (step.isUsingMASC()) {<br/>
                        col = GUIPreferences.getInstance().getColor("AdvancedMoveMASCColor");<br/>
                    } else {<br/>
                        col = GUIPreferences.getInstance().getColor("AdvancedMoveRunColor");<br/>
                    }<br/>
                    break;<br/>
                case IEntityMovementType.MOVE_JUMP :<br/>
                    col = GUIPreferences.getInstance().getColor("AdvancedMoveJumpColor");<br/>
                    break;<br/>
                case IEntityMovementType.MOVE_ILLEGAL :<br/>
                    col = GUIPreferences.getInstance().getColor("AdvancedMoveIllegalColor");<br/>
                    break;<br/>
                default :<br/>
                    if (step.getType()==MovePath.STEP_BACKWARDS) {<br/>
                        col = GUIPreferences.getInstance().getColor("AdvancedMoveBackColor");<br/>
                    } else {<br/>
                        col = GUIPreferences.getInstance().getColor("AdvancedMoveDefaultColor");<br/>
                    }<br/>
                    break;<br/>
            }<br/>
<br/>
            // draw arrows and cost for the step<br/>
            switch (step.getType()) {<br/>
            case MovePath.STEP_FORWARDS :<br/>
            case MovePath.STEP_BACKWARDS :<br/>
            case MovePath.STEP_CHARGE :<br/>
            case MovePath.STEP_DFA :<br/>
            case MovePath.STEP_LATERAL_LEFT :<br/>
            case MovePath.STEP_LATERAL_RIGHT :<br/>
            case MovePath.STEP_LATERAL_LEFT_BACKWARDS :<br/>
            case MovePath.STEP_LATERAL_RIGHT_BACKWARDS :<br/>
                // draw arrows showing them entering the next<br/>
                myPoly = new Polygon(movePoly.xpoints, movePoly.ypoints,<br/>
                                     movePoly.npoints);<br/>
                graph.setColor(Color.darkGray);<br/>
                myPoly.translate(stepPos.x + 1, stepPos.y + 1);<br/>
                graph.drawPolygon(myPoly);<br/>
                graph.setColor(col);<br/>
                myPoly.translate(-1, -1);<br/>
                graph.drawPolygon(myPoly);<br/>
                // draw movement cost<br/>
                drawMovementCost(step, stepPos, graph, col, true);<br/>
                break;<br/>
            case MovePath.STEP_GO_PRONE:<br/>
                // draw arrow indicating dropping prone<br/>
                Polygon downPoly = movementPolys[7];<br/>
                myPoly = new Polygon(downPoly.xpoints, downPoly.ypoints, downPoly.npoints);<br/>
                graph.setColor(Color.darkGray);<br/>
                myPoly.translate(stepPos.x, stepPos.y);<br/>
                graph.drawPolygon(myPoly);<br/>
                graph.setColor(col);<br/>
                myPoly.translate(-1, -1);<br/>
                graph.drawPolygon(myPoly);<br/>
                offsetCostPos = new Point(stepPos.x + 1, stepPos.y + 15);<br/>
                drawMovementCost(step, offsetCostPos, graph, col, false);<br/>
                break;<br/>
            case MovePath.STEP_GET_UP:<br/>
                // draw arrow indicating standing up<br/>
                Polygon upPoly = movementPolys[6];<br/>
                myPoly = new Polygon(upPoly.xpoints, upPoly.ypoints, upPoly.npoints);<br/>
                graph.setColor(Color.darkGray);<br/>
                myPoly.translate(stepPos.x, stepPos.y);<br/>
                graph.drawPolygon(myPoly);<br/>
                graph.setColor(col);<br/>
                myPoly.translate(-1, -1);<br/>
                graph.drawPolygon(myPoly);<br/>
                offsetCostPos = new Point(stepPos.x, stepPos.y + 15);<br/>
                drawMovementCost(step, offsetCostPos, graph, col, false);<br/>
                break;<br/>
            case MovePath.STEP_TURN_LEFT:<br/>
            case MovePath.STEP_TURN_RIGHT:<br/>
                // draw arrows showing the facing<br/>
                myPoly = new Polygon(facingPoly.xpoints, facingPoly.ypoints,<br/>
                                     facingPoly.npoints);<br/>
                graph.setColor(Color.darkGray);<br/>
                myPoly.translate(stepPos.x + 1, stepPos.y + 1);<br/>
                graph.drawPolygon(myPoly);<br/>
                graph.setColor(col);<br/>
                myPoly.translate(-1, -1);<br/>
                graph.drawPolygon(myPoly);<br/>
                break;<br/>
            case MovePath.STEP_LOAD:<br/>
                // Announce load.<br/>
                String load = Messages.getString("BoardView1.Load"); //$NON-NLS-1$<br/>
                if (step.isPastDanger()) {<br/>
                    load = "(" + load + ")"; //$NON-NLS-1$ //$NON-NLS-2$<br/>
                }<br/>
                graph.setFont(new Font("SansSerif", Font.PLAIN, 12)); //$NON-NLS-1$<br/>
                int loadX = stepPos.x + 42 - (graph.getFontMetrics(graph.getFont()).stringWidth(load) / 2);<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(load, loadX, stepPos.y + 39);<br/>
                graph.setColor(col);<br/>
                graph.drawString(load, loadX - 1, stepPos.y + 38);<br/>
                break;<br/>
            case MovePath.STEP_UNLOAD:<br/>
                // Announce unload.<br/>
                String unload = Messages.getString("BoardView1.Unload"); //$NON-NLS-1$<br/>
                if (step.isPastDanger()) {<br/>
                    unload = "(" + unload + ")"; //$NON-NLS-1$ //$NON-NLS-2$<br/>
                }<br/>
                graph.setFont(new Font("SansSerif", Font.PLAIN, 12)); //$NON-NLS-1$<br/>
                int unloadX = stepPos.x + 42 - (graph.getFontMetrics(graph.getFont()).stringWidth(unload) / 2);<br/>
                int unloadY = stepPos.y + 38 + graph.getFontMetrics(graph.getFont()).getHeight();<br/>
                graph.setColor(Color.darkGray);<br/>
                graph.drawString(unload, unloadX, unloadY + 1);<br/>
                graph.setColor(col);<br/>
                graph.drawString(unload, unloadX - 1, unloadY);<br/>
                break;<br/>
<br/>
            default :<br/>
                break;<br/>
            }<br/>
<br/>
            // create final image<br/>
            this.image = createImage(new FilteredImageSource(tempImage.getSource(),<br/>
                                                             new KeyAlphaFilter(TRANSPARENT)));<br/>
        }<br/>
<br/>
        public Rectangle getBounds(){<br/>
            bounds = new Rectangle(getHexLocation(step.getPosition()), hex_size);<br/>
            return bounds;<br/>
        }<br/>
        <br/>
        public MoveStep getStep() {<br/>
            return step;<br/>
        }<br/>
<br/>
        private void drawMovementCost(MoveStep step, Point stepPos, Graphics graph, Color col, boolean shiftFlag) {<br/>
            String costString = null;<br/>
            StringBuffer costStringBuf = new StringBuffer();<br/>
            costStringBuf.append( step.getMpUsed() );<br/>
<br/>
            // If the step is using a road bonus, mark it.<br/>
            if ( step.isPavementStep() &amp;&amp; step.getParent().getEntity() instanceof Tank ) {<br/>
                costStringBuf.append( "+" ); //$NON-NLS-1$<br/>
            }<br/>
<br/>
            // If the step is dangerous, mark it.<br/>
            if ( step.isDanger() ) {<br/>
                costStringBuf.append( "*" ); //$NON-NLS-1$<br/>
            }<br/>
<br/>
            // If the step is past danger, mark that.<br/>
            if (step.isPastDanger()) {<br/>
                costStringBuf.insert( 0, "(" ); //$NON-NLS-1$<br/>
                costStringBuf.append( ")" ); //$NON-NLS-1$<br/>
            }<br/>
<br/>
            if (step.isUsingMASC()) {<br/>
                costStringBuf.append("["); //$NON-NLS-1$<br/>
                costStringBuf.append(step.getTargetNumberMASC());<br/>
                costStringBuf.append("+]"); //$NON-NLS-1$<br/>
            }<br/>
            <br/>
            if (step.getMovementType() == <span class="upd">IEntityMovementType.<span class="upd">MOVE_VTOL_WALK</span></span> ||<br/>
                <span class="mv">step.getMovementType() == IEntityMovementType.MOVE_VTOL_RUN</span>) {<br/>
                costStringBuf.append("{").append(step.getElevation()).append("}");<br/>
            }<br/>
<br/>
            // Convert the buffer to a String and draw it.<br/>
            costString = costStringBuf.toString();<br/>
            graph.setFont(new Font("SansSerif", Font.PLAIN, 12)); //$NON-NLS-1$<br/>
            int costX = stepPos.x + 42;<br/>
            if (shiftFlag) {<br/>
                costX -= (graph.getFontMetrics(graph.getFont()).stringWidth(costString) / 2);<br/>
            }<br/>
            graph.setColor(Color.darkGray);<br/>
            graph.drawString(costString, costX, stepPos.y + 39);<br/>
            graph.setColor(col);<br/>
            graph.drawString(costString, costX - 1, stepPos.y + 38);<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Sprite and info for a C3 network.  Does not actually use the image buffer<br/>
     * as this can be horribly inefficient for long diagonal lines.<br/>
     */<br/>
    private class C3Sprite extends Sprite<br/>
    {<br/>
        private Polygon C3Poly;<br/>
<br/>
        protected int entityId;<br/>
        protected int masterId;<br/>
        protected Entity entityE;<br/>
        protected Entity entityM;<br/>
        <br/>
        Color spriteColor;<br/>
<br/>
        public C3Sprite(Entity e, Entity m) {<br/>
            this.entityE = e;<br/>
            this.entityM = m;<br/>
            this.entityId = e.getId();<br/>
            this.masterId = m.getId();<br/>
            this.spriteColor = PlayerColors.getColor(e.getOwner().getColorIndex());<br/>
<br/>
            if(e.getPosition() == null || m.getPosition() == null) {<br/>
                C3Poly = new Polygon();<br/>
                C3Poly.addPoint(0, 0);<br/>
                C3Poly.addPoint(1,0);<br/>
                C3Poly.addPoint(0,1);<br/>
                this.bounds = new Rectangle(C3Poly.getBounds());<br/>
                bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
                this.image = null;<br/>
                return;<br/>
            }<br/>
<br/>
            makePoly();<br/>
<br/>
            // set bounds<br/>
            this.bounds = new Rectangle(C3Poly.getBounds());<br/>
            bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
<br/>
            // move poly to upper right of image<br/>
            C3Poly.translate(-bounds.getLocation().x, -bounds.getLocation().y);<br/>
<br/>
            // set names &amp; stuff<br/>
<br/>
            // nullify image<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        public void prepare() {<br/>
        }<br/>
<br/>
        private void makePoly( ){<br/>
            // make a polygon<br/>
            final Point a = getHexLocation(entityE.getPosition());<br/>
            final Point t = getHexLocation(entityM.getPosition());<br/>
<br/>
            final double an = (entityE.getPosition().radian(entityM.getPosition()) + (Math.PI * 1.5)) % (Math.PI * 2); // angle<br/>
            final double lw = scale*C3_LINE_WIDTH; // line width<br/>
            <br/>
            C3Poly = new Polygon();<br/>
            C3Poly.addPoint(<br/>
                    a.x + (int)(scale*(HEX_W/2) - (int)Math.round(Math.sin(an) * lw)),<br/>
                    a.y + (int)(scale*(HEX_H/2) + (int)Math.round(Math.cos(an) * lw)));<br/>
            C3Poly.addPoint(<br/>
                    a.x + (int)(scale*(HEX_W/2) + (int)Math.round(Math.sin(an) * lw)), <br/>
                    a.y + (int)(scale*(HEX_H/2) - (int)Math.round(Math.cos(an) * lw)));<br/>
            C3Poly.addPoint(<br/>
                    t.x + (int)(scale*(HEX_W/2) + (int)Math.round(Math.sin(an) * lw)), <br/>
                    t.y + (int)(scale*(HEX_H/2) - (int)Math.round(Math.cos(an) * lw)));<br/>
            C3Poly.addPoint(<br/>
                    t.x + (int)(scale*(HEX_W/2) - (int)Math.round(Math.sin(an) * lw)), <br/>
                    t.y + (int)(scale*(HEX_H/2) + (int)Math.round(Math.cos(an) * lw)));<br/>
        }<br/>
<br/>
        public Rectangle getBounds(){<br/>
            makePoly();<br/>
            // set bounds<br/>
            this.bounds = new Rectangle(C3Poly.getBounds());<br/>
            bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
<br/>
            // move poly to upper right of image<br/>
            C3Poly.translate(-bounds.getLocation().x, -bounds.getLocation().y);<br/>
            this.image = null;<br/>
            <br/>
            return bounds;<br/>
        }<br/>
        <br/>
        public boolean isReady() {<br/>
            return true;<br/>
        }<br/>
<br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer) {<br/>
            //makePoly();<br/>
            <br/>
            Polygon drawPoly = new Polygon(C3Poly.xpoints, C3Poly.ypoints, C3Poly.npoints);<br/>
            drawPoly.translate(x, y);<br/>
<br/>
            g.setColor(spriteColor);<br/>
            g.fillPolygon(drawPoly);<br/>
            g.setColor(Color.black);<br/>
            g.drawPolygon(drawPoly);<br/>
        }<br/>
<br/>
        /**<br/>
         * Return true if the point is inside our polygon<br/>
         */<br/>
        public boolean isInside(Point point) {<br/>
            return C3Poly.contains(point.x + view.x - bounds.x - offset.x,<br/>
                                   point.y + view.y - bounds.y - offset.y);<br/>
        }<br/>
<br/>
    }<br/>
<br/>
    /**<br/>
     * Sprite and info for an attack.  Does not actually use the image buffer<br/>
     * as this can be horribly inefficient for long diagonal lines.<br/>
     *<br/>
     * Appears as an arrow. Arrow becoming cut in half when two Meks attacking<br/>
     * each other.<br/>
     */<br/>
    private class AttackSprite extends Sprite<br/>
    {<br/>
        private java.util.Vector attacks = new java.util.Vector();<br/>
        private Point a;<br/>
        private Point t;<br/>
        private double an;<br/>
        private StraightArrowPolygon attackPoly;<br/>
        private Color attackColor;<br/>
        private int entityId;<br/>
        private int targetType;<br/>
        private int targetId;<br/>
        private String attackerDesc;<br/>
        private String targetDesc;<br/>
        private Vector weaponDescs = new Vector();<br/>
        private final Entity ae;<br/>
        private final Targetable target;<br/>
<br/>
        public AttackSprite(AttackAction attack) {<br/>
            this.attacks.addElement(attack);<br/>
            this.entityId = attack.getEntityId();<br/>
            this.targetType = attack.getTargetType();<br/>
            this.targetId = attack.getTargetId();<br/>
            this.ae = game.getEntity(attack.getEntityId());<br/>
            this.target = game.getTarget(targetType, targetId);<br/>
<br/>
            // color?<br/>
            attackColor = PlayerColors.getColor(ae.getOwner().getColorIndex());<br/>
            //angle of line connecting two hexes<br/>
            this.an = (ae.getPosition().radian(target.getPosition()) + (Math.PI * 1.5)) % (Math.PI * 2); // angle<br/>
            makePoly();<br/>
<br/>
            // set bounds<br/>
            this.bounds = new Rectangle(attackPoly.getBounds());<br/>
            bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
            // move poly to upper right of image<br/>
            attackPoly.translate(-bounds.getLocation().x, -bounds.getLocation().y);<br/>
<br/>
            // set names &amp; stuff<br/>
            attackerDesc = ae.getDisplayName();<br/>
            targetDesc = target.getDisplayName();<br/>
            if (attack instanceof WeaponAttackAction) {<br/>
                addWeapon((WeaponAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof KickAttackAction) {<br/>
                addWeapon((KickAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof PunchAttackAction) {<br/>
                addWeapon((PunchAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof PushAttackAction) {<br/>
                addWeapon((PushAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof ClubAttackAction) {<br/>
                addWeapon((ClubAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof ChargeAttackAction) {<br/>
                addWeapon((ChargeAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof DfaAttackAction) {<br/>
                addWeapon((DfaAttackAction)attack);<br/>
            }<br/>
            if (attack instanceof ProtomechPhysicalAttackAction) {<br/>
                addWeapon((ProtomechPhysicalAttackAction)attack);<br/>
            }<br/>
<br/>
            // nullify image<br/>
            this.image = null;<br/>
        }<br/>
<br/>
        private void makePoly(){<br/>
            // make a polygon<br/>
            this.a = getHexLocation(ae.getPosition());<br/>
            this.t = getHexLocation(target.getPosition());<br/>
            // OK, that is actually not good. I do not like hard coded figures.<br/>
            // HEX_W/2 - x distance in pixels from origin of hex bounding box to the center of hex.<br/>
            // HEX_H/2 - y distance in pixels from origin of hex bounding box to the center of hex.<br/>
            // 18 - is actually 36/2 - we do not want arrows to start and end directly<br/>
            // in the centes of hex and hiding mek under.<br/>
<br/>
            a.x = a.x + (int)(HEX_W/2*scale) + (int)Math.round(Math.cos(an) * (int)(18*scale));<br/>
            t.x = t.x + (int)(HEX_W/2*scale) - (int)Math.round(Math.cos(an) * (int)(18*scale));<br/>
            a.y = a.y + (int)(HEX_H/2*scale) + (int)Math.round(Math.sin(an) * (int)(18*scale));<br/>
            t.y = t.y + (int)(HEX_H/2*scale) - (int)Math.round(Math.sin(an) * (int)(18*scale));<br/>
<br/>
            // Checking if given attack is mutual. In this case we building halved arrow<br/>
            if (isMutualAttack()){<br/>
                attackPoly = new StraightArrowPolygon(a, t, (int)(8*scale), (int)(12*scale), true);<br/>
            } else {<br/>
                attackPoly = new StraightArrowPolygon(a, t, (int)(4*scale), (int)(8*scale), false);<br/>
            }<br/>
        }<br/>
        <br/>
        public Rectangle getBounds(){<br/>
            makePoly();<br/>
            // set bounds<br/>
            this.bounds = new Rectangle(attackPoly.getBounds());<br/>
            bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
            // move poly to upper right of image<br/>
            attackPoly.translate(-bounds.getLocation().x, -bounds.getLocation().y);<br/>
            <br/>
            return bounds;<br/>
        }<br/>
<br/>
        /** If we have build full arrow already with single attack and have got<br/>
         * counter attack from our target lately - lets change arrow to halved.<br/>
         */<br/>
        public void rebuildToHalvedPolygon(){<br/>
            attackPoly = new StraightArrowPolygon(a, t, (int)(8*scale), (int)(12*scale), true);<br/>
            // set bounds<br/>
            this.bounds = new Rectangle(attackPoly.getBounds());<br/>
            bounds.setSize(bounds.getSize().width + 1, bounds.getSize().height + 1);<br/>
            // move poly to upper right of image<br/>
            attackPoly.translate(-bounds.getLocation().x, -bounds.getLocation().y);<br/>
        }<br/>
        /** Cheking if attack is mutual and changing target arrow to half-arrow<br/>
         */<br/>
        private boolean isMutualAttack(){<br/>
            for (final Iterator i = attackSprites.iterator(); i.hasNext();) {<br/>
                final AttackSprite sprite = (AttackSprite)i.next();<br/>
                if (sprite.getEntityId() == this.targetId &amp;&amp; sprite.getTargetId() == this.entityId) {<br/>
                    sprite.rebuildToHalvedPolygon();<br/>
                    return true;<br/>
                }<br/>
            }<br/>
            return false;<br/>
        }<br/>
<br/>
        public void prepare() {<br/>
        }<br/>
<br/>
        public boolean isReady() {<br/>
            return true;<br/>
        }<br/>
<br/>
        public void drawOnto(Graphics g, int x, int y, ImageObserver observer) {<br/>
            Polygon drawPoly = new Polygon(attackPoly.xpoints, attackPoly.ypoints, attackPoly.npoints);<br/>
            drawPoly.translate(x, y);<br/>
<br/>
            g.setColor(attackColor);<br/>
            g.fillPolygon(drawPoly);<br/>
            g.setColor(Color.gray.darker());<br/>
            g.drawPolygon(drawPoly);<br/>
        }<br/>
<br/>
        /**<br/>
         * Return true if the point is inside our polygon<br/>
         */<br/>
        public boolean isInside(Point point) {<br/>
            return attackPoly.contains(point.x + view.x - bounds.x - offset.x,<br/>
                                       point.y + view.y - bounds.y - offset.y);<br/>
        }<br/>
<br/>
        public int getEntityId() {<br/>
            return entityId;<br/>
        }<br/>
<br/>
        public int getTargetId() {<br/>
            return targetId;<br/>
        }<br/>
<br/>
        /**<br/>
         * Adds a weapon to this attack<br/>
         */<br/>
        public void addWeapon(WeaponAttackAction attack) {<br/>
            final Entity entity = game.getEntity(attack.getEntityId());<br/>
            final WeaponType wtype = (WeaponType)entity.getEquipment(attack.getWeaponId()).getType();<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            weaponDescs.addElement( wtype.getName() + Messages.getString("BoardView1.needs") + roll ); //$NON-NLS-1$<br/>
        }<br/>
<br/>
        public void addWeapon(KickAttackAction attack) {<br/>
            String bufer = ""; //$NON-NLS-1$<br/>
            String rollLeft = ""; //$NON-NLS-1$<br/>
            String rollRight = ""; //$NON-NLS-1$<br/>
            final int leg = attack.getLeg();<br/>
            switch (leg){<br/>
            case KickAttackAction.BOTH:<br/>
                rollLeft = KickAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), KickAttackAction.LEFT).getValueAsString();<br/>
                rollRight = KickAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), KickAttackAction.RIGHT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.kickBoth", new Object[]{rollLeft,rollRight}); //$NON-NLS-1$<br/>
                break;<br/>
            case KickAttackAction.LEFT:<br/>
                rollLeft = KickAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), KickAttackAction.LEFT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.kickLeft", new Object[]{rollLeft}); //$NON-NLS-1$<br/>
                break;<br/>
            case KickAttackAction.RIGHT:<br/>
                rollRight = KickAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), KickAttackAction.RIGHT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.kickRight", new Object[]{rollRight}); //$NON-NLS-1$<br/>
                break;<br/>
            }<br/>
            weaponDescs.addElement(bufer);<br/>
        }<br/>
<br/>
        public void addWeapon(PunchAttackAction attack) {<br/>
            String bufer = ""; //$NON-NLS-1$<br/>
            String rollLeft = ""; //$NON-NLS-1$<br/>
            String rollRight = ""; //$NON-NLS-1$<br/>
            final int arm = attack.getArm();<br/>
            switch (arm){<br/>
            case PunchAttackAction.BOTH:<br/>
                rollLeft = PunchAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), PunchAttackAction.LEFT).getValueAsString();<br/>
                rollRight = PunchAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), PunchAttackAction.RIGHT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.punchBoth", new Object[]{rollLeft,rollRight}); //$NON-NLS-1$<br/>
                break;<br/>
            case PunchAttackAction.LEFT:<br/>
                rollLeft = PunchAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), PunchAttackAction.LEFT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.punchLeft", new Object[]{rollLeft}); //$NON-NLS-1$<br/>
                break;<br/>
            case PunchAttackAction.RIGHT:<br/>
                rollRight = PunchAttackAction.toHit( game, attack.getEntityId(), game.getTarget(attack.getTargetType(), attack.getTargetId()), PunchAttackAction.RIGHT).getValueAsString();<br/>
                bufer = Messages.getString("BoardView1.punchRight", new Object[]{rollRight}); //$NON-NLS-1$<br/>
                break;<br/>
            }<br/>
            weaponDescs.addElement(bufer);<br/>
        }<br/>
<br/>
        public void addWeapon(PushAttackAction attack) {<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            weaponDescs.addElement(Messages.getString("BoardView1.push", new Object[]{roll})); //$NON-NLS-1$<br/>
        }<br/>
<br/>
        public void addWeapon(ClubAttackAction attack) {<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            final String club = attack.getClub().getName();<br/>
            weaponDescs.addElement(Messages.getString("BoardView1.hit", new Object[]{club,roll})); //$NON-NLS-1$<br/>
        }<br/>
<br/>
        public void addWeapon(ChargeAttackAction attack) {<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            weaponDescs.addElement(Messages.getString("BoardView1.charge", new Object[]{roll})); //$NON-NLS-1$<br/>
        }<br/>
        public void addWeapon(DfaAttackAction attack) {<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            weaponDescs.addElement(Messages.getString("BoardView1.DFA", new Object[]{roll})); //$NON-NLS-1$<br/>
        }<br/>
        public void addWeapon(ProtomechPhysicalAttackAction attack) {<br/>
            final String roll = attack.toHit(game).getValueAsString();<br/>
            weaponDescs.addElement(Messages.getString("BoardView1.proto", new Object[]{roll})); //$NON-NLS-1$<br/>
        }<br/>
<br/>
        private String[] getTooltip() {<br/>
            String[] tipStrings = new String[1 + weaponDescs.size()];<br/>
            int tip = 1;<br/>
            tipStrings[0] = attackerDesc + " "+Messages.getString("BoardView1.on")+" " + targetDesc; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$<br/>
            for (Iterator i = weaponDescs.iterator(); i.hasNext();) {<br/>
                tipStrings[tip++] = (String)i.next();<br/>
            }<br/>
            return tipStrings;<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Determine if the tile manager's images have been loaded.<br/>
     *<br/>
     * @return  &lt;code&gt;true&lt;/code&gt; if all images have been loaded.<br/>
     *          &lt;code&gt;false&lt;/code&gt; if more need to be loaded.<br/>
     */<br/>
    public boolean isTileImagesLoaded() {<br/>
        return this.tileManager.isLoaded();<br/>
    }<br/>
<br/>
    public void setUseLOSTool(boolean use) {<br/>
        useLOSTool = use;<br/>
    }<br/>
<br/>
    public TilesetManager getTilesetManager() {<br/>
        return tileManager;<br/>
    }<br/>
<br/>
    // added by kenn<br/>
    public void drawRuler(Coords s, Coords e, Color sc, Color ec) {<br/>
        rulerStart = s;<br/>
        rulerEnd = e;<br/>
        rulerStartColor = sc;<br/>
        rulerEndColor = ec;<br/>
<br/>
        repaint();<br/>
    }<br/>
    // end kenn<br/>
<br/>
    /**<br/>
     * @param lastCursor The lastCursor to set.<br/>
     */<br/>
    public void setLastCursor(Coords lastCursor) {<br/>
        this.lastCursor = lastCursor;<br/>
    }<br/>
<br/>
    /**<br/>
     * @return Returns the lastCursor.<br/>
     */<br/>
    public Coords getLastCursor() {<br/>
        return lastCursor;<br/>
    }<br/>
<br/>
    /**<br/>
     * @param highlighted The highlighted to set.<br/>
     */<br/>
    public void setHighlighted(Coords highlighted) {<br/>
        this.highlighted = highlighted;<br/>
    }<br/>
<br/>
    /**<br/>
     * @return Returns the highlighted.<br/>
     */<br/>
    public Coords getHighlighted() {<br/>
        return highlighted;<br/>
    }<br/>
<br/>
    /**<br/>
     * @param selected The selected to set.<br/>
     */<br/>
    public void setSelected(Coords selected) {<br/>
        this.selected = selected;<br/>
    }<br/>
<br/>
    /**<br/>
     * @return Returns the selected.<br/>
     */<br/>
    public Coords getSelected() {<br/>
        return selected;<br/>
    }<br/>
<br/>
    /**<br/>
     * @param firstLOS The firstLOS to set.<br/>
     */<br/>
    public void setFirstLOS(Coords firstLOS) {<br/>
        this.firstLOS = firstLOS;<br/>
    }<br/>
<br/>
    /**<br/>
     * @return Returns the firstLOS.<br/>
     */<br/>
    public Coords getFirstLOS() {<br/>
        return firstLOS;<br/>
    }<br/>
    <br/>
    /**<br/>
     * Determines if this Board contains the Coords,<br/>
     * and if so, "selects" that Coords.<br/>
     *<br/>
     * @param coords the Coords.<br/>
     */<br/>
    public void select(Coords coords) {<br/>
        if(coords == null || game.getBoard().contains(coords)) {<br/>
            setSelected(coords);<br/>
            moveCursor(selectedSprite, coords);<br/>
            moveCursor(firstLOSSprite, null);<br/>
            moveCursor(secondLOSSprite, null);<br/>
            processBoardViewEvent(new BoardViewEvent(this, coords, null, BoardViewEvent.BOARD_HEX_SELECTED,0));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * "Selects" the specified Coords.<br/>
     *<br/>
     * @param x the x coordinate.<br/>
     * @param y the y coordinate.<br/>
     */<br/>
    public void select(int x, int y) {<br/>
        select(new Coords(x, y));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Determines if this Board contains the Coords,<br/>
     * and if so, highlights that Coords.<br/>
     *<br/>
     * @param coords the Coords.<br/>
     */<br/>
    public void highlight(Coords coords) {<br/>
        if(coords == null || game.getBoard().contains(coords)) {<br/>
            setHighlighted(coords);<br/>
            moveCursor(highlightSprite, coords);<br/>
            moveCursor(firstLOSSprite, null);<br/>
            moveCursor(secondLOSSprite, null);<br/>
            processBoardViewEvent(new BoardViewEvent(this, coords, null, BoardViewEvent.BOARD_HEX_HIGHLIGHTED, 0));<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Highlights the specified Coords.<br/>
     *<br/>
     * @param x the x coordinate.<br/>
     * @param y the y coordinate.<br/>
     */<br/>
    public void highlight(int x, int y) {<br/>
        highlight(new Coords(x, y));<br/>
    }<br/>
    <br/>
    /**<br/>
     * Determines if this Board contains the Coords,<br/>
     * and if so, "cursors" that Coords.<br/>
     *<br/>
     * @param coords the Coords.<br/>
     */<br/>
    public void cursor(Coords coords) {<br/>
        if(coords == null || game.getBoard().contains(coords)) {<br/>
            if(getLastCursor() == null || coords == null || !coords.equals(getLastCursor())) {<br/>
                setLastCursor(coords);<br/>
                moveCursor(cursorSprite, coords);<br/>
                moveCursor(firstLOSSprite, null);<br/>
                moveCursor(secondLOSSprite, null);<br/>
                processBoardViewEvent(new BoardViewEvent(this, coords, null, BoardViewEvent.BOARD_HEX_CURSOR, 0));<br/>
            } else {<br/>
                setLastCursor(coords);<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * "Cursors" the specified Coords.<br/>
     *<br/>
     * @param x the x coordinate.<br/>
     * @param y the y coordinate.<br/>
     */<br/>
    public void cursor(int x, int y) {<br/>
        cursor(new Coords(x, y));<br/>
    }<br/>
<br/>
    public void checkLOS(Coords c) {<br/>
        if(c == null || game.getBoard().contains(c)) {<br/>
            if (getFirstLOS() == null) {<br/>
                setFirstLOS(c);<br/>
                firstLOSHex(c);<br/>
                processBoardViewEvent(new BoardViewEvent(this, c, null, BoardViewEvent.BOARD_FIRST_LOS_HEX, 0));<br/>
            } else {<br/>
                secondLOSHex(c,getFirstLOS());<br/>
                processBoardViewEvent(new BoardViewEvent(this, c, null, BoardViewEvent.BOARD_SECOND_LOS_HEX, 0));<br/>
                setFirstLOS(null);<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    /**<br/>
     * Determines if this Board contains the (x, y) Coords,<br/>
     * and if so, notifies listeners about the specified mouse<br/>
     * action.<br/>
     */<br/>
    public void mouseAction(int x, int y, int mtype, int modifiers) {<br/>
        if(game.getBoard().contains(x, y)) {<br/>
            Coords c = new Coords(x, y);<br/>
            switch(mtype) {<br/>
            case BOARD_HEX_CLICK :<br/>
                if ((modifiers &amp; java.awt.event.InputEvent.CTRL_MASK) != 0) {<br/>
                    checkLOS(c);<br/>
                } else {<br/>
                    processBoardViewEvent(new BoardViewEvent(this, c, null, BoardViewEvent.BOARD_HEX_CLICKED, modifiers));<br/>
                }<br/>
                break;<br/>
            case BOARD_HEX_DOUBLECLICK :<br/>
                processBoardViewEvent(new BoardViewEvent(this, c, null, BoardViewEvent.BOARD_HEX_DOUBLECLICKED, modifiers));<br/>
                break;<br/>
            case BOARD_HEX_DRAG :<br/>
                processBoardViewEvent(new BoardViewEvent(this, c, null, BoardViewEvent.BOARD_HEX_DRAGGED, modifiers));<br/>
                break;<br/>
            }<br/>
        }<br/>
    }<br/>
    <br/>
    /**<br/>
     * Notifies listeners about the specified mouse action.<br/>
     *<br/>
     * @param coords the Coords.<br/>
     */<br/>
    public void mouseAction(Coords coords, int mtype, int modifiers) {<br/>
        mouseAction(coords.x, coords.y, mtype, modifiers);<br/>
    }<br/>
    <br/>
    /**<br/>
     * Return, whether a popup may be drawn, this currently means, whether no scrolling took place.<br/>
     */<br/>
    public boolean mayDrawPopup() {<br/>
        return !scrolled;<br/>
    }<br/>
<br/>
    /* (non-Javadoc)<br/>
     * @see megamek.common.BoardListener#boardNewBoard(megamek.common.BoardEvent)<br/>
     */<br/>
    public void boardNewBoard(BoardEvent b) {        <br/>
        updateBoard();<br/>
    }<br/>
<br/>
    /* (non-Javadoc)<br/>
     * @see megamek.common.BoardListener#boardChangedHex(megamek.common.BoardEvent)<br/>
     */<br/>
    public void boardChangedHex(BoardEvent b) {<br/>
        IHex hex = game.getBoard().getHex(b.getCoords());<br/>
        tileManager.clearHex(hex);<br/>
        tileManager.waitForHex(hex);<br/>
        if (boardGraph != null) {<br/>
            redrawAround(b.getCoords());<br/>
        }<br/>
    }<br/>
<br/>
    //TODO Is there a better solution?<br/>
    //This is required because the BoardView creates the redraw thread <br/>
    //that must be stopped explicitly     <br/>
    public void die() {<br/>
        redrawWorker.stop();<br/>
    }<br/>
<br/>
    private GameListener gameListener = new GameListenerAdapter(){<br/>
        <br/>
        public void gameEntityNew(GameEntityNewEvent e) {<br/>
            redrawAllEntities();            <br/>
        }<br/>
<br/>
        public void gameEntityRemove(GameEntityRemoveEvent e) {<br/>
            redrawAllEntities();            <br/>
        }<br/>
<br/>
        public void gameEntityChange(GameEntityChangeEvent e) {<br/>
            java.util.Vector mp = e.getMovePath();<br/>
            if (mp != null &amp;&amp; mp.size() &gt; 0 &amp;&amp; GUIPreferences.getInstance().getShowMoveStep()) {<br/>
                addMovingUnit(e.getEntity(), mp);<br/>
            }else {<br/>
                redrawEntity(e.getEntity());<br/>
            }<br/>
        }<br/>
<br/>
        public void gameNewAction(GameNewActionEvent e) {<br/>
            EntityAction ea = e.getAction();<br/>
            if (ea instanceof AttackAction) {            <br/>
                addAttack((AttackAction)ea);<br/>
            }<br/>
        }<br/>
<br/>
        public void gameBoardNew(GameBoardNewEvent e) {<br/>
            IBoard b = e.getOldBoard();<br/>
            if (b != null) {<br/>
                b.removeBoardListener(BoardView1.this);<br/>
            }<br/>
            b = e.getNewBoard();<br/>
            if (b != null) {<br/>
                b.addBoardListener(BoardView1.this);<br/>
            }<br/>
            updateBoard();<br/>
        }        <br/>
<br/>
        public void gameBoardChanged(GameBoardChangeEvent e) {<br/>
            boardImage = null;<br/>
            boardGraph = null;<br/>
            redrawAllEntities();<br/>
        }<br/>
    };<br/>
<br/>
    protected void updateBoard() {<br/>
        updateBoardSize();<br/>
        backGraph = null;<br/>
        backImage = null;<br/>
        backSize = null;<br/>
        boardImage = null;<br/>
        boardGraph = null;<br/>
        tileManager.reset();<br/>
        redrawAllEntities();<br/>
    }<br/>
    <br/>
    /*<br/>
     * It's not quite polished solution, but on other hand it's better then nothing.<br/>
     */<br/>
    protected class RedrawWorker implements Runnable {<br/>
<br/>
        private boolean finished = false;<br/>
<br/>
        public void start() {<br/>
            Thread thread = new Thread(this, "BoardView RedrawWorker Thread"); //$NON-NLS-1$<br/>
            thread.start();<br/>
            <br/>
        }<br/>
        <br/>
        public void stop() {<br/>
            finished = true;<br/>
        }<br/>
<br/>
        public void run() {<br/>
            long lastTime = System.currentTimeMillis();<br/>
            long currentTime = System.currentTimeMillis();<br/>
            while (!finished) {<br/>
                try {<br/>
                    Thread.sleep(20);<br/>
                } catch(InterruptedException ex) {<br/>
                    // duh?<br/>
                }<br/>
                if (finished) {<br/>
                    break;<br/>
                }<br/>
                if (!isShowing()) {<br/>
                    currentTime = System.currentTimeMillis();<br/>
                    lastTime = currentTime;<br/>
                    continue;<br/>
                }<br/>
                currentTime = System.currentTimeMillis();<br/>
                boolean redraw = false;<br/>
                for (int i = 0; i &lt; displayables.size(); i++) {<br/>
                    Displayable disp = (Displayable) displayables.elementAt(i);<br/>
                    if (!disp.isSliding()) {<br/>
                        disp.setIdleTime(currentTime - lastTime, true);<br/>
                    } else {<br/>
                        redraw = redraw || disp.slide();<br/>
                    }<br/>
                }<br/>
                if (backSize != null) {<br/>
                    redraw = redraw || doMoveUnits(currentTime - lastTime);<br/>
                    redraw = redraw || doScroll();<br/>
                    checkTooltip();<br/>
                } else {<br/>
                    repaint(100);<br/>
                }<br/>
                if (redraw) {<br/>
                    repaint();<br/>
                }<br/>
                lastTime = currentTime;<br/>
            }<br/>
        }<br/>
    }<br/>
}<br/>
</div>
</div>
</div>
<div class="clear"></div>
</div>
</body>
</html>